@&#MAIN-TITLE@&#A temporal agent based approach for testing open distributed systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present some technical issues for testing distributed frameworks with timing constraints.


                        
                        
                           
                           We model an architecture taking into account the delay of messages exchanged between the components of the testing distributed applications.


                        
                        
                           
                           We propose a Multi-Agent based system to capture the complex monitoring tasks of distributed tester behaviors


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Distributed testing

Timing constraints

Multi-agent systems

@&#ABSTRACT@&#


               
               
                  The development of distributed testing frameworks is more complex, where the implementation process must consider the mechanisms and functions required to support interaction as long as the communication and the coordination between distributed testing components. The typical reactions of such systems are the generation of errors‘set: time outs, locks, observability, controllability and synchronization problems. In other side, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred. In this paper, we show how to cope with these problems by using a distributed testing method including timing constraints. Afterwards, a multi-agent architecture is proposed in the design process to describe the behavior of testing a distributed chat group application on high level of abstraction.
               
            

@&#INTRODUCTION@&#

Several reference models, architectures and frameworks such as ODP (Open Distributed Processing), CORBA (Common Object Request Broker Architecture), and TINA (Telecommunications Information Networking Architecture) have already been designed and proposed for developing distributed systems [1]. However, even though models provide a good basis for developing working open distributed applications, conformance testing approaches are required for gaining confidence in final products and guaranteeing their integration and interoperability within open distributed environment [2].

The conformance testing may be seen as mean to execute an IUT (Implementation under Test) by carrying out test cases, in order to observe whether the behavior of the implementation is conforming to its specification. Hence, the IUT (Implementation under Test) may be viewed in the context of open distributed systems as a system providing standardized interfaces for interacting with other systems. Based on testing of OSI communicating systems, conformance of an open distributed system can be assessed by attaching a related tester at each provided interface [4]. However, many problems influencing faults detection arise during the conformance testing process if there is no coordination between distributed testers.

In fact, the use of multiple testers introduces the possibility of coordination problems amongst remote testers. These potential problems are known as controllability and observability fault detections which are fundamental features of conformance testing [2–7]. To avoid these problems, many works [1–4] propose to introduce coordination messages which lead each tester to determine when to apply a particular input to the implementation under test (IUT) and whether a correct output from the IUT is generated in response to a specific input, respectively. Nevertheless, even if the introduction of such messages can resolve such mentioned issues, it leads to another kind of problems commonly known as synchronization problems. In this perspective, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred especially if the system has to respect some timing constraints. Thus, two different time constraints are defined: transfer time i.e. the time required for a coordination message to travel from a tester to another, and reaction time, i.e. the time elapsed between the reception of an input by the IUT and the sending of the corresponding output by the IUT. We emphasize that even if some authors [4–6] have made a simplifying assumption that the time required for a transfer time, is greater than the reaction time of the IUT. Many academic researches [8,9] showed that controllability and observability problems are indeed resolved if and only if the test system observes those timing constraints.

In this paper, we focus on the temporal properties that specify the time required to exchange messages between the various components of the distributed test application. Thereby taking into consideration the temporal properties in the specification of the behavior of conformance testing it will provide a higher degree of expressiveness and flexibility. The proposed approach consists firstly on introducing a new architecture taking into account the delay of messages exchanged between testers and the IUT, and between testers. The main based idea of the proposed work is to develop an algorithm for generating Timing Local Test Sequences for each tester guarantying to avoid problems of coordination, observation and synchronization. Secondly, on high level of abstraction, we show how multi-agent based system used in distributed testing prototype realization contribute to capture the complex monitoring tasks of distributed tester behaviors.

The paper is structured as follows: Section 2 describes the architecture and some modeling concepts of distributed testing application and presents the synchronization problems arisen in distributed testing execution. Section 3 is dedicated to introduce the architecture and modeling concepts of testing distributed applications with timing constraints. Section 4, presents the algorithm allowing the generation of timing local test sequences. Sections 5 and 6 describe the behavior of testing a distributed chat group application and design the test process of such application on high level of abstraction using a multi-agent architecture. Finally Section 7 gives some conclusions and identifies future works.

Alongside the academic research activities, efforts have been made in the industry and standards bodies (ISO and ITU) to develop approaches to conformance testing of OSI protocols. A standardized methodology, tools, experiences and theories exist today with a certain degree of maturity [10]. This section is devoted to the extension of the results of testing protocols for dealing with the test of open distributed systems.

The principle is to apply input events to the IUT and compare the observed outputs with expected results. A set of input events and planned outputs is commonly called a test case and it is generated from the specification of the IUT.

The basic idea of distributed testing architecture is to coordinate parallel testers called PTCs (Parallel Test Components) using a communication service in conjunction with the IUT. Each tester interacts with the IUT through a port PCO (Point of Control and Observation), and communicates with other testers through a multicast channel.


                        Fig. 1
                         gives an abstract view of what have could be an ODP distributed testing architecture. An IUT is the implementation of the distributed application to test. It can be considered as a “black-box”; its behavior is known only by interactions through its interfaces with the environment or other systems. Each tester sends some stimulus to the IUT via their attached interfaces called PCOs (Points of Control and Observations) and from which it observes the output IUT reactions. The external behavior of the IUT is observable via another interface type called IAP (Implementation Access Points). The difference between the PCO and the IAP is that PCOs are the logical points where communications are made, but the IAPs are the physical access points of the IUT. In order to control the test execution, PTCs exchange messages that encapsulate the information avoiding controllability and observability problems.

To approach the testing process in a formal way, the specification and the IUT must be modeled using the same concepts. The specification of the behavior of a distributed system is described by an automaton with n-port [11] (FSM: Finite State Machine) defining inputs and the results expected for each PCO. We denote Σk the input alphabet of the port “k” (PCO number k) and Γk the output alphabet of the port k. Fig. 2
                         gives an example of a 3p-FSM with: Q={q0, q1, q2}, q0 the initial state, Σ1
                        ={a1, a2}, Σ2
                        ={b1}, Σ3
                        ={c1}, and Γ1={x1, x2 }, Γ2
                        ={ y1,y2}, Γ3
                        ={z1}.

A test sequence of an np-FSM is a sequence in the form:!X1? Y1!X2 ? Y2…! Xt ?Yt where for i=1,..,t, Xi belongs to Σ=Σ1U … U Σn with Σi ∩ Σj
                        =∅ for i≠j and Yi is a subset of 
                           
                              
                                 ∪
                                 n
                              
                              
                                 k
                                 =
                                 1
                              
                           
                           
                              Γ
                              k
                           
                         such that, for each port k, |Yi ∩Γk|≤1, i.e. Yi contains at most one symbol from the output alphabet of each port of 
                           A
                        .
                           
                              •
                              !Xi: Denotes sending the message Xi to IUT.

?Yi: Denotes the reception of messages belonging to the Yi from the IUT.

An example of a global test sequence (GTS) deduced from the 3p-FSM given in Fig. 2 is:
                           
                              (1)
                              
                                 !
                                 
                                    a
                                    1
                                 
                                 ?
                                 
                                    
                                       
                                          x
                                          1
                                       
                                       .
                                       
                                          y
                                          1
                                       
                                    
                                 
                                 !
                                 
                                    b
                                    1
                                 
                                 ?
                                 
                                    
                                       
                                          x
                                          2
                                       
                                       .
                                       
                                          y
                                          2
                                       
                                    
                                 
                                 !
                                 
                                    c
                                    1
                                 
                                 ?
                                 
                                    
                                       z
                                       1
                                    
                                 
                              
                           
                        
                     

Generally, test sequences are generated from the specification of the IUT and characterized by fault coverage. Several methods exist for generating test sequence from FSM specification. They are mainly used for detecting two basic types of faults output faults and transfer faults [12].

The work [4] allows generating local test sequences for each tester, and thus the behavior of the test application in each PCO is well defined. In fact, each tester executes its local test sequence (LTS), built from the global test sequence of the IUT. The generated LTS encapsulate the information that allows controlling the test execution. Indeed, many problems influencing fault detection during the conformance testing process arises if there is no coordination between distributed testers. These potential problems are known as controllability and observability fault detections which are fundamental features of conformance distributed testing. The controllability may be defined as the capability of the test system to realize input events at corresponding PCO in a given order, and observability may be defined as the capability of the test system to determine the output events and the order in which they take place at corresponding PCO [4]. To solve such problems, authors in [4] propose an algorithm to generate Local Test Sequences (LTS) from Global Test Sequence (GTS). The following LTS are the results given by applying the proposed algorithm to test sequence (1):
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                W
                                                1
                                             
                                             =
                                             !
                                             
                                                a
                                                1
                                             
                                             ?
                                             
                                                x
                                                1
                                             
                                             ?
                                             
                                                x
                                                2
                                             
                                             ?
                                             
                                                O
                                                3
                                             
                                          
                                       
                                       
                                          
                                             
                                                W
                                                2
                                             
                                             =
                                             ?
                                             
                                                y
                                                1
                                             
                                             !
                                             
                                                b
                                                1
                                             
                                             ?
                                             
                                                y
                                                2
                                             
                                             !
                                             
                                                C
                                                3
                                             
                                          
                                       
                                       
                                          
                                             
                                                W
                                                3
                                             
                                             =
                                             ?
                                             
                                                C
                                                2
                                             
                                             !
                                             
                                                O
                                                1
                                             
                                             !
                                             
                                                c
                                                1
                                             
                                             ?
                                             
                                                z
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where:
                           
                              •
                              !x denote sending of message x to IUT

?y denote receiving of message y from the IUT

!Ck denote sending coordination message to tester k and ?Ck receiving coordination message from tester k.

!Ok denote sending observation message to tester k and ?Ok receiving observation message from tester k.

Thus, each tester executes its LTS as follows: for each message “xi” sent to the IUT or a coordination message, the tester supports the process of sending this message. If “xi” is an expected message from the IUT or a coordination message, the tester waits for this message. If no message is received, or if the received message is not expected, the tester returns a verdict Fail (fail). If the tester reaches the end of its local test sequence, then it gives a verdict Accept (accepted). Thus, if all testers return a verdict Accept, then the test system ends the test with a global verdict Accept.

In the distributed test, each tester (PTC) executes its local test sequence produced from the global test sequence of the IUT. Let the execution of the first fragment of each local test sequence W
                           f1
                        , W
                           f2
                         and W
                           f3
                         select from W1, W2 and W3 as follows:
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                W
                                                
                                                   f
                                                   1
                                                
                                             
                                             =
                                             !
                                             
                                                a
                                                1
                                             
                                             ?
                                             
                                                x
                                                1
                                             
                                             ?
                                             
                                                x
                                                2
                                             
                                          
                                       
                                       
                                          
                                             
                                                W
                                                
                                                   f
                                                   2
                                                
                                             
                                             =
                                             ?
                                             
                                                y
                                                1
                                             
                                             !
                                             
                                                b
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                W
                                                
                                                   f
                                                   3
                                                
                                             
                                             =
                                             ?
                                             
                                                C
                                                2
                                             
                                             !
                                             
                                                O
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The execution of local test sequences W
                           f1
                        , W
                           f2
                         and W
                           f3
                         must give the result shown in Fig. 3(a) but the execution of our prototype provides an incorrect result given in Fig. 3(b).

Indeed, in the diagram Fig. 3(b) the second tester sends the message “b2” to the IUT before the first tester receives the message “x1” from the IUT. So, the execution of local testing does not conform with the specification given in (1), where the message “b2“ must be sent only if all messages due to the sending of “a1” by the tester-1 are received by the IUT.

In this perspective, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred especially if the system has to respect some timing constraints.

For example, in the execution of the first fragment of the GTS given in (1): !a1?{x1.y1}!b1?{x2.y2}, the tester-1 begins by sending a message “!a1” to the IUT. However, the tester-2 can't send the message “!b1“ and must wait until receiving the message “?y1“ from the IUT and the message “?x1“ to be received by the tester-1.

Now, the principal question that can be studied and discussed is how much time the tester-2 and tester-1 can wait for receiving “?y1” and “?x1” respectively, so that the tester-2 can send “!b2” to the IUT?

@&#RELATED WORKS@&#

Recently, the rapid growth of distributed systems has led to made specific reflections about its coordination. Many frameworks suggest several key issues that will contribute to the success of open distributed systems [13,14–16] and many works has been made to avoid the coordination problems of testing such frameworks previously explained.

In this context, the author in [8] shows that controllability and observability are indeed resolved if and only if the test system respects some timing constraints and he proposes a centralized architecture for distributed testing. Another work [17] shows that the use of coordination messages can introduce delays and this can cause problems especially if there are timing constraints.

The work [18] proposes a new method to generate a test sequence using multiple unique input/output (UIO) sequences. The method is essentially guided by the way of minimizing the use of external coordination messages and input/output operations.

In [19], the authors suggest to build a test or checking sequence from the specification of the system under test such that it is free from these problems without requiring the use of external coordination messages. In this context, they propose some algorithms for generating subsequences that eliminate the need for external coordination messages.

The basic idea in [7,20,21] is to build a test sequence that causes no coordination problems during its application in a distributed test architecture. For some specifications, such test sequence exists where the coordination is achieved via their interactions with the IUT. However, it is not always true as detailed in [22].

The emphasis of recent works is to minimize the use of external message exchanges among testers [21] or to identify conditions on a given FSM under which the problems in distributed testing can be overcome without using external coordination messages [23,24].

In [30], we propose to integrate the mobile agent technology for checking the well receipt of expected messages on different (PCO). However, the management of the mobile agent movements makes the testing process more complex to implement. We think that the deployment of mobile agent technology in distributed testing must make some mechanisms where the mobility is more restricted. Another work presented in [25] proposes fault detection architecture through web services based on passive testing. They propose an observer (mobile agent) that can be invoked by interested parties when developed and published as a web service.

Finally, we suggest in some previous works [26-29,31] to use some concepts issued from Artificial Intelligence to overcome distributed testing problems. So, we express in [26–28] the rules to be respected by the testers to guarantee their coordination. The objective of introducing rules is to ensure coordination between testers using the artificial intelligence features. The basic idea behind introducing the concept of rules in the distributed test context is that the exchange of messages to perform the test is sequential. In fact, for each transition in the test process, the next messages to be sent to the IUT depend mainly on the previous messages received even from the IUT or from other testers. For this purpose, we suggest a rule based systems that provide an interesting approach for representing and interpreting such kind of messages exchange. These systems permit the implementation of highly flexible systems capable of adapting themselves to different situations by seeking to express an automatism in a similar way to as would make it a human being: “IF antecedents THEN consequents”. Additionally, such systems are able to take decisions concerning possible malfunctions and decided if the process of test returns a failed verdict or an accepted one which increases significantly the flexibility of the test system implemented.

Our approach in this paper consists on introducing a new architecture allowing to avoid the synchronization problems by considering the delay of messages exchanged between: (i) testers and the IUT and (ii) between testers.

Indeed, the management of increasingly complex open distributed systems with timing constraints poses very significant challenges. This is particularly true when reaction to events must be done in a timely and predictable manner while guaranteeing timing constraints imposed by users, the environment, or applications.

In these scenarios, our system should be able to maintain the conformity of distributed testing by allowing individual nodes (testers) to autonomously adapt under different constraints of resource availability and input quality.

Finally, our proposed approach must be general enough to be used in a wide range of scenarios characterized by a high degree of openness and dynamism where coordination tasks need to be time dependent. For all this reasons, our system could benefit from a multi-agent system in which agents communicate, coordinate and negotiate to meet their goals, within specified timing and quality constraints.

In our context of testing open distributed testing, agent-based systems are distributed in the ODP term sense, i.e. they comply in a technical and organizational heterogeneous context. They consist of interacting entities which can be agents and/or objects. Therefore the set of concepts and structuring rules defined in the Reference Model of Open Distributed Processing can be applied when developing such systems and they can help to rigorously define these systems.

This section is dedicated to extend results from testing distributed system to deal with testing an implementation under test with some timing constraints.

The new proposed architecture will operate in an environment with some timing constraints. In this context, it is not sufficient to check if the IUT produces the correct outputs “?yi” but it should also check if the timings of outputs are corrects. Moreover, the timing of these outputs “?yi” depends on the timing of the inputs ”!xi”. Indeed, any message sent by a tester to the IUT must be blocked as long as all output events, caused by the last sending message, have been received by all related testers. In other words, the date of the sending inputs “!xi+1” to IUT depends on the dates of the receiving the outputs “?yi” by related testers.

In order to analyze all these timing constraints, we consider that each tester has a clock that computes the delay of messages exchanged between a tester and the IUT (“!xi” and “?yi”) and between testers(“!/? C/O”). We add then, a set of clocks to model the temporal behavior of the test process and by the way, each port of the distributed system has a corresponding local tester with a local clock. However, the clock synchronization among different testers is one of the difficulties to overcome especially when the temporal constraints must be considered in the testing process.

In the aim to check timing constraints in distributed testing correctly, all testers' clocks should be synchronized. In other words, all testers must have the same time reference. For this purpose, we suggest to deal with the clock synchronization similarly to IEEE 1588 Precision Time Protocol (PTP). It is a new synchronization standard with very high accuracy and particularly proposed for embedded industrial communication systems. PTP provides a mean for networked computer systems to agree on a master clock reference time and a mean for slave clocks to estimate their offset from master clock time [33].

In this section, we propose a formal model to specify the temporal behavior of the distributed testing system. We extend the definition of a timed automaton with n-port to define timing constraint for inputs and the expected result at each PCO in distributed testing model. Timed Automata with n ports is generalized from Timed Automata [34]. A set of clocks and Canonical Enabling Conditions are used to model the temporal behavior of the system. We introduce below some definitions related to Timed Automata with n ports.
                           Definition 1
                           
                              Timed Automaton with n ports named as np-TA is defined by A
                              =(Q, q0, Act, X, Tr) with:
                                 
                                    •
                                    Q is a finite set of locations;

q0 ϵ Q is the initial location;

Act=Σ U Γ
                                          
                                             (i)
                                             Σ={ Σ 1, Σ 2,..,Σ n} where Σi is a finite set of inputs of port i, Σi ∩ Σj
                                                =∅ for i≠j and i,j=1,2,…,n and Σ=Σ1U … U Σn
                                             

Γ
                                                =
                                                {Γ1, Γ2,.., Γn} where Γ
                                                   i
                                                 is a finite set of outputs of port i, Γ
                                                   i ∩ Γ
                                                   j
                                                
                                                =∅ for i≠j and i,j=1,2,…,n and Γ=Γ 1U … U Γn
                                             


                                       
                                          X
                                          =
                                       {x1,x2,….,xn} is a finite set of clocks

Tr is a finite set of transitions.

The transition is a tuple (q1,γ, σ, r, q2), where:
                                 
                                    •
                                    q1,q2 ϵ Q are the source and destination locations;

γ ϵ G is the guard, a conjunction of constraints of the form x~c, where G={Λ x~c | x ϵ 
                                          X
                                        and c ϵ N and~ϵ [<,≤,=,>,≥] } ;

r ϵ 2x is a set of clocks to reset to zero, called Rest of Tr;

σ is the reception of an input x (figured as ?xi) or sending of an output y (figured as !yj).
                                          
                                             
                                                T
                                                r
                                                
                                                ⊂
                                                
                                                Q
                                                ×
                                                G
                                                ×
                                                Act
                                                ×
                                                
                                                   2
                                                   X
                                                
                                                ×
                                                Q
                                             
                                          
                                       
                                    

We note that the clocks in X are viewed as a continuous time clock. Continuous time is a real variable that evolves indefinitely and its derivative with respect to time is equal to 1 [32,35]. Each clock's value can be reset at any instant. A transition Tr can be executed if and only if the guard is verified (True) and the clocks in “r” are reset after the execution of Tr.

The use of the concept of an np-TA as defined above will make the temporal behavior of the system to be modeled. The np-TA allows also to model constraints on delays between events of a given system. To this end, we introduce a clock “c” to specify that a delay between two transitions Tr1 and Tr2 will be in the range of T=[Tmin, Tmax]. We define then the reset of Tr1 as {c} and the guard of Tr2 as c~T with c ~1Tmin Λ c ~2Tmax and ~1 Є [=,>, ≥] and ~2 Є [<, ≤, =]. As shown in Fig. 5
                        
                        , the new automaton modeling by 3p-TA (b) extends the 3p-FSM (a) by adding new states and integrating temporal constraints.

Literally, this new specification requires that for the transition !a1?{x1.y1} of (Fig. 5.a) if we send “a1” on port 1 then “x1” must be received on port 1 between T1min and T1max and “y2” on port 2 between T2min and T2max (Fig. 5.b) otherwise the behavior is not specified (in our context, this case cannot be considered). We remind that ci
                        ~Ti means ci ~1Timin Λ ci ~2Timax with ~1 Є [=,>, ≥] and ~2 Є [<, ≤, =].

This subsection presents some characteristics of the proposed architecture as well as the time consumed when messages are exchanged between the components of our distributed test system. In the new architecture (Fig. 4), temporal constraints should be satisfied. As mentioned before, the correctness of testing distributed systems depends not only on the logical result of a computation, but also on the time when the result was delivered.

For this purpose, we define two types of temporal constraints to be checked in distributed test approach: timing constraints on inter-port and intra-port level respectively. The intra-port timing constraints occur when communication is established between a tester and the IUT, it could be the reaction time required for a tester receiving a message belonging to “yi” in response to the reception of the input “xi” by the IUT. And thus, the inter-port timing constraints may be the transfer time required when testers communicate on different ports.

In this subsection we consider only different Intra-port timing constraints when communication is established between tester and IUT. Fig. 6
                            shown how the first part of the GTS (1) fgts
                           
                           =!a1?{x1.y1} can be executed and how the time required to execute each message in fgts
                            can be treated. c1 and c2 clocks are used to compute the reaction time of “x1” and “y1”.

Where the different computing times used in Fig. 6 are defined as follow:
                              
                                 1.
                                 
                                    TTBIT
                                    : Transfer time between the IUT and the Tester is the time separating: (i) the instant when a Message M is sent by the IUT (resp. the tester) and (ii) the instant when M is received by the Tester (resp. IUT).


                                    Tiut
                                    : the reaction time of the IUT is an upper bound of the time separating: (i) any instant when an event 
                                       e
                                     is received by the IUT and (ii) the instant when the IUT has terminated to send all the outputs (if any) in response to the reception of 
                                       e
                                    . We emphasize the word “all” because the definition includes possible unexpected outputs (in the case of a non-conformant IUT) [8,9].


                                    
                                       Time Out
                                     is the waiting time that a tester can wait for receiving a message. In case where this time is elapsed the test system should return Failed.


                                    Master Clock provides the reference time for all clocks in the testing system. Therefore, as shown in Fig. 6, Intra-port timing constraints can be presented as follows:
                                       
                                          •
                                          If the message is a sending message “!xi”, then there is no time constraint to verify, the message will be sent and we initialize all clocks of testers that should receive messages due to this sent ?(yi).

If the message is a reception ?a (a Є yi): The guard (denoted ζ1) must check that the reception time c measured by the clockport(a) is:
                                                
                                                   (4)
                                                   
                                                      
                                                         T
                                                         
                                                            TBIT
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                      +
                                                      Tiut
                                                      +
                                                      
                                                         T
                                                         
                                                            TBIT
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                      <
                                                      =
                                                      c
                                                      <
                                                      =
                                                      Time
                                                      
                                                      Out
                                                   
                                                
                                             
                                             
                                                
                                                   (a)
                                                   TTBIT (1) denotes the transfer time between the tester sending “!Xi” and the IUT.

Tiut denotes the reaction time of the IUT.

TTBIT (2) denotes the transfer time between IUT and the tester receiving “?a” that can be considered as the same time TTBIT (1)
                                                   

Formally c verify ζ1
                            (denoted c |=
                           ζ1
                           ) when:

c |=
                           ζ1
                            =>c~Tc =>c ~1Tcmin Λ c ~2Tcmax with ~1 Є [=,>,≥] and ~2 Є [<,≤=] and:
                              
                                 (5)
                                 
                                    Tcmin
                                    =
                                    2
                                    *
                                    
                                       T
                                       TBIT
                                    
                                    +
                                    Tiut
                                 
                              
                           
                           
                              
                                 (6)
                                 
                                    Tcmax
                                    =
                                    Time
                                    
                                    Out
                                 
                              
                           
                        

In the IUT, Testers exchange Coordination and Observability messages. In this context, we consider two following cases:
                              
                                 •
                                 If tester-i sends a message “!C
                                       j
                                     “or “ !O
                                       j
                                     “ to tester-j: There is no constraint time to verify, the message is sent and we initialize all clock clocki of the testers that will receive this message.

If tester-j receives the message “?C
                                       i” or “?O
                                       i “ from tester-i:The guard (denoted ζ2
                                    ) must check if the time c quantified by the clocki is as:
                                       
                                          (7)
                                          
                                             
                                                T
                                                TBIT
                                             
                                             <
                                             =
                                             c
                                             =
                                             <
                                             Time
                                             
                                             Out
                                          
                                       
                                    
                                 


                           T
                           TBTT is the transfer time between tester-i and Tester-j. TTBTT is defined by the time separating: (i) the instant when a “O” or “C” (Observation/Coordination message) is sent by the tester and (ii) the instant when “O” or “C” is received by another Tester. Formally c verify ζ2
                            (denoted c |=
                           ζ2
                           ) when:

c |=
                           ζ2
                            =>c~Tc =>c ~1Tcmin Λ c ~2Tcmax with ~1 Є [=,>,≥] and ~2 Є [<,≤=] and:
                              
                                 (8)
                                 
                                    Tcmin
                                    =
                                    
                                       T
                                       TBIT
                                    
                                 
                              
                           
                           
                              
                                 (9)
                                 
                                    Tcmax
                                    =
                                    Time
                                    
                                    Out
                                 
                              
                           
                        

In distributed test method, each tester executes its local test sequence generated from the complete test sequence. Generally test sequences are generated from the IUT specification and characterized by their faults coverage (input faults and output faults). As we have shown above, the testing process can avoid the synchronization problems by considering the delay of messages exchanged between testers and the IUT and between testers. We have extended the concept of automaton testing specification to automaton with temporal constraint. In this section we show how we can define the new form of complete test sequences and how the local test sequences could be generated within timing constraints imposed by the new specification.

A timed global test sequence (TGTS) is a test sequence of an np-TA which corresponds to the sequence of transitions: Tr
                           !x1
                        .Tr
                           ?y1
                        .Tr
                           !x2
                        .Tr
                           ?y2
                        ….. Tr
                           !xt.T
                           ?yt
                         where:
                           
                              •
                              Tr
                                    !xi
                                  is a transition of sending an output “xi” in port-k, we denote: <!x,Reseti>. Clocks which will compute the transfer time for each message received in response to this sent are initialized in 
                                    Reserti
                                    
                                 .

Tr
                                    ?yi
                                  represents the outputs sent in the different ports (1,2,….j), with 1<=j<=n in response to the reception of the input “xi” by the IUT and it has the form: {<?h1,guard1,Reset1>,<?h2,guard2,Reset2> ….,<?hj,guardj,Resetj>}.
                                    
                                       (i)
                                       Each guard
                                          i defines the timing constraint on the reception of “?hi“.


                                          Reset
                                          i contains the clock of the port receiving “hi” to be initialized after this transition. An example of TGTS of 3p-TA (Fig. 5.b) is defined by:
                                             
                                                •
                                                Tr
                                                      !a1
                                                   
                                                   =(!a1
                                                   ,{c1,c2});
                                                

Tr
                                                      ?y1
                                                   
                                                   =
                                                   ?{(x1
                                                   ,c1|=
                                                   ζ1
                                                   ,{c1}).(y1
                                                   , c2|=
                                                   ζ1
                                                   ,{c2})};

Tr
                                                      !b1
                                                   
                                                   =(!b1
                                                   ,{c1,c2});

Tr
                                                      ?y2
                                                   
                                                   =
                                                   ?{(x2
                                                   , c1|=
                                                   ζ1
                                                   ,{c1}).(y2
                                                   , c2|=
                                                   ζ1
                                                   ,{ c2})};

Tr
                                                      !c1
                                                    
                                                   =(!c1
                                                   ,{c3});
                                                

Tr
                                                      ?y3
                                                   
                                                   =?{(z3
                                                   , c1|=
                                                   ζ1
                                                   ,{ c3})};

This TGTS is written as Tr
                           !a1
                        .Tr
                           ?y1
                        .Tr
                           !b1
                        .Tr
                           ?y2
                        .Tr
                           !c1
                        .Tr
                           ?y3
                        :
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                                !
                                                
                                                   a
                                                   1
                                                
                                                ,
                                                
                                                   
                                                      c
                                                      1
                                                   
                                                   
                                                      c
                                                      2
                                                   
                                                
                                             
                                          
                                          .
                                          ?
                                          
                                             
                                                
                                                   
                                                      
                                                         x
                                                         1
                                                      
                                                      ,
                                                      
                                                         c
                                                         1
                                                      
                                                      |
                                                      =
                                                      
                                                         ζ
                                                         1
                                                      
                                                      ,
                                                      
                                                         
                                                            c
                                                            1
                                                         
                                                      
                                                   
                                                
                                                .
                                                
                                                   
                                                      
                                                         y
                                                         1
                                                      
                                                      ,
                                                      
                                                         c
                                                         2
                                                      
                                                      |
                                                      =
                                                      
                                                         ζ
                                                         1
                                                      
                                                      
                                                         
                                                            c
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          .
                                          
                                             
                                                !
                                                
                                                   b
                                                   1
                                                
                                                ,
                                                
                                                   
                                                      c
                                                      1
                                                   
                                                   
                                                      c
                                                      2
                                                   
                                                
                                             
                                          
                                          .
                                          ?
                                          {
                                          
                                             
                                                
                                                   x
                                                   2
                                                
                                                ,
                                                
                                                   c
                                                   1
                                                
                                                |
                                                =
                                                
                                                   ζ
                                                   1
                                                
                                                ,
                                                
                                                   
                                                      c
                                                      1
                                                   
                                                
                                             
                                          
                                          .
                                          (
                                          
                                             y
                                             2
                                          
                                          ,
                                       
                                    
                                    
                                       
                                          
                                             c
                                             2
                                          
                                          |
                                          
                                             ζ
                                             1
                                          
                                          ,
                                          
                                             
                                                c
                                                2
                                             
                                          
                                          )
                                          }
                                          .
                                          ?
                                          
                                             
                                                !
                                                
                                                   c
                                                   1
                                                
                                                ,
                                                
                                                   
                                                      c
                                                      3
                                                   
                                                
                                             
                                          
                                          .
                                          ?
                                          
                                             
                                                
                                                   
                                                      z
                                                      3
                                                   
                                                   ,
                                                   
                                                      c
                                                      1
                                                   
                                                   |
                                                   =
                                                   
                                                      ζ
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         3
                                                      
                                                   
                                                
                                             
                                          
                                          ;
                                       
                                    
                                 
                              
                           
                        
                     

The faults covered by Timed Automata with n-ports are classified in:
                           
                              •
                              faults independent of timing constraints: output faults, transfer faults or combination of both of them

Timing faults [6]: faults are caused by the violation of timing constraints by the IUT. The test system has to respect timing constraints of inputs and checks if timing constraints of outputs are respected.

The introduction of the time concept in the LTS of each tester-k, leads to build Timed Local Test Sequences (TLTS) related to each tester with the form tr1.tr2.tr3….trn where each tri has the form αi
                        k,guardi
                        k,Reseti
                        k and each αi is either:
                           
                              •
                              !xi: Tester-k sends “xi” through port k to IUT

?yi: IUT sends “yi” through port k to tester-k.

!Ok: Observation message sent to tester-k.

?Ok: Observation message received from tester-k.

!Ck: Coordination message C sent to tester-k.

?Ck: Coordination message received by tester-k.
                                    
                                       (i)
                                       For each message “xi” sending to the IUT or a Coordination/Observability message, the tester supports the process of sending this message and resets all testers' clock that will receive a message due to this sending in Reseti.

If “αi” is an expected message from the IUT or a Coordination/Observability message, the tester waits for this message. After its reception, the tester checks whether guardi is true or not and resets the clock in Reseti. If gaurdi is not true, then test return Failed.

The algorithm shown in Fig. 7
                         is dedicated to generate the TLTS from the TGTS. It takes as input a timed global test sequence where we consider each transition as a data structure containing the message to be sent or to be received, the guard to be checked and the list of clocks that will be reset at the end of the transition.

The Loop in (line 23) adds the reception of messages belonging to “yi” to the appropriate sequences. The coordination messages are added to the projections to avoid both Coordination and Observability Problems:
                           
                              •
                              To avoid observation problems, each tester receiving a message h ϵ yi−1 should be able to determinate that h has been sent by IUT after IUT has received “xi−1” and before IUT receives “xi”. In this case, we added “ ?Ok ” (k is port sending O) and “!Ok “(k is port receiving O) to the appropriate local test sequences (lines 4 to 19)
                              

Controllability problem arises when Test cannot guarantee that IUT will receive event of transition (i) before event of transition (i+1). In this case, we added “?Ck” (k is port sending C) and “ !Ck “(k is port receiving C) to the appropriate local test sequences. “?Ck” is added to wt
                                    h
                                  where h is the tester sending “xi+1”. “!Ck “ is added to the sequence of a tester receiving a message belonging to “yi”, if yi
                                 ≠Ø (lines 38 to 47), if not “!C” is added to the sequence of the tester sending “xi” (lines 30 to 37).
                              

For a communication with the IUT, we deduce the time constraints (the guard) from the TGTS (lines 20 to 26). However, for communication between testers, these constraints will be added to local timed sequences as follow:
                           
                              •
                              If tester-i sends a message “!C
                                    j” or “!O
                                    j
                                  “ to tester-j: there is no constraint time to verify, the message is sent and we initialize all clocki of testers that will receive this message (lines 13,18,31,32,40,41,50,51).

If tester-j receives the message “?Ci” or “?Oi“ from tester-i: the time c observed from the clocki must verify the intra-port guard ζ2 (lines 17,35,44,54).
                              

By applying the proposed algorithm to the TGTS giving in (10), we get the following TLTS describing the behavior of tester-1, tester-2 and tester-3.
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             
                                                w
                                                
                                                   t
                                                   1
                                                
                                             
                                             =
                                             
                                                
                                                   !
                                                   
                                                      a
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         1
                                                      
                                                      
                                                         c
                                                         2
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                                
                                                   ?
                                                   
                                                      x
                                                      1
                                                   
                                                   ,
                                                   
                                                      c
                                                      1
                                                   
                                                   |
                                                   =
                                                   
                                                      ζ
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         1
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                                
                                                   ?
                                                   
                                                      x
                                                      2
                                                   
                                                   ,
                                                   
                                                      c
                                                      1
                                                   
                                                   |
                                                   =
                                                   
                                                      ζ
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         1
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                             
                                                
                                                   ?
                                                   
                                                      O
                                                      3
                                                   
                                                   ,
                                                   
                                                   
                                                      c
                                                      2
                                                   
                                                   |
                                                   =
                                                   
                                                   
                                                      ζ
                                                      2
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                w
                                                
                                                   t
                                                   2
                                                
                                             
                                             =
                                             
                                                
                                                   ?
                                                   
                                                      y
                                                      1
                                                   
                                                   ,
                                                   
                                                      c
                                                      2
                                                   
                                                   |
                                                   =
                                                   
                                                      ζ
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         2
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                                
                                                   !
                                                   
                                                      b
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         1
                                                      
                                                      
                                                         c
                                                         2
                                                      
                                                   
                                                
                                             
                                             .
                                             (
                                             ?
                                             
                                                y
                                                2
                                             
                                             ,
                                             
                                                c
                                                2
                                             
                                             |
                                             =
                                             
                                                ζ
                                                2
                                             
                                             ,
                                             
                                                
                                                   c
                                                   2
                                                
                                             
                                             .
                                             
                                                
                                                   !
                                                   
                                                      C
                                                      3
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         3
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                w
                                                
                                                   t
                                                   3
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                   ?
                                                   
                                                      C
                                                      2
                                                   
                                                   ,
                                                   
                                                      c
                                                      3
                                                   
                                                   |
                                                   
                                                      ζ
                                                      2
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         3
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                                
                                                   !
                                                   
                                                      O
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         1
                                                      
                                                   
                                                
                                             
                                             .
                                             
                                             
                                                
                                                   !
                                                   
                                                      c
                                                      1
                                                   
                                                   ,
                                                   
                                                      
                                                         c
                                                         3
                                                      
                                                   
                                                
                                             
                                             
                                             .
                                             
                                                
                                                   ?
                                                   
                                                      z
                                                      1
                                                   
                                                   ,
                                                   
                                                   
                                                      c
                                                      3
                                                   
                                                   |
                                                   =
                                                   
                                                      ζ
                                                      1
                                                   
                                                   ,
                                                   
                                                   
                                                      
                                                         c
                                                         3
                                                      
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Now, after generating the timed local sequences, we will tackle to compute the test verdict. In fact, during the execution of each timed local test sequence, the tester-k will guarantee (resp. check) the timing constraints (the guard) of the inputs (resp. outputs). More precisely, for each message “xi” sending to the IUT or a coordination/observation message, the tester supports the process of sending this message. If “αi” is an expected message from the IUT or a coordination/observation message, the tester waits for this message. If no message is received in a correct time, or if the received message is not expected, the tester returns a verdict Fail (fail). If the tester reaches the end of its local test sequence, then it gives a verdict Accept (accepted). Thus, if all testers return a verdict Accept, then the test system ends the test with a global verdict Accept.

This section describes a testing example of a chat group application. The application and its interfaces are briefly presented. Related temporal local test sequences are constructed from timed global test sequence, and then test results are given and discussed.

The CORBA Architecture (Common Object Request Broker Architecture) is a framework of standards and concepts proposed by the Object Management Group (OMG) for open systems. In the proposed architecture, remote object methods are requested transparently in a distributed and heterogeneous environment through the ORB (Object Request Broker). The CORBA specification defines the ORB (Object Request Broker) interfaces and establishes the role of each ORB component in the environment. CORBA interfaces mask the differences among ORB implementations.

The objectives of CORBA and ODP are quite similar. They aim to describe systems implemented in terms of configurations of distributed objects. To do that, they identify common infrastructure functions that support the operation of such systems and simplify their implementation. However if ODP is a generic model, CORBA is more implementation-oriented. Therefore, several implementations of CORBA are already commercially available. This section is experiments with implementation of the distributed test method through a prototype within the CORBA infrastructure.

In developing a prototype for the distributed test method, three main testing aspects may be distinguished: preparation, execution and conclusion. Preparation consists of designing a test sequences for the IUT from the specification. Execution consists of connecting the testers to the IUT ports and providing them the related local test sequences. The testing can then be executed according to the behavior described in previous sections. Finally, the conclusion consists of collecting the testers' verdicts to determine the global verdict.

This section describes the main objects of the prototype, which are grouped into three categories: information objects, computing objects and communication objects.
                           
                              a-
                              
                                 Information objects. There are two types of information objects: test sequences and verdicts.
                                    
                                       -
                                       A Timed Local Test Sequence object encapsulates the sequence of inputs to be applied to the IUT by a given tester as well as the expected results. It also includes the coordination messages to be (sent to/received from) other testers

A verdict object encapsulates information about the global verdict. If each Tester Object provides a true local verdict then the global verdict is True.


                                 Computing objects are represented as the Tester objects. These objects apply a timed local test sequence to the IUT interfaces and provide local verdicts at a given port.


                                 Communication objects. Two kinds of communication are considered: communication between the testers, and communication between the testers and the IUT.
                                    
                                       -
                                       
                                          Communication between testers and the IUT consists mainly of method invocation. To get a generic test application, adapting itself to the interfaces of the IUT, we introduce an Adapter object which provides a Tester object with methods to send and to receive actions. An Adapter object communicates with the associated IUT interface through the CORBA dynamic invocation mechanism.


                                          Communication between testers is 1 to n: a tester may send a coordination message to some or all other testers. This is realized through the Coordination Channel using the CORBA event service. To send a coordination message to testers h1,….,hr, it invokes the Pull method Pull proxy hi. The coordination message is transferred from Push proxy k to Pull proxy hi using the CORBA event service.

The example to be tested and described below is based on a distributed chat group application. Actually, for sending a message to a chat group, the user has to join this group, and then the text message submitted by the user will be sent to a central server. The server then forwards these messages to other clients which have joined the same group. The role of the central server is to manage all messages sent to all chat groups. It receives the messages from client applications and forwards these messages to other clients appropriately. The application has two interfaces:
                           
                              •
                              User interface allowing subscribers to post and to retrieve messages;

Manager interface allowing one to add and to remove subscribers, to forward messages to the clients appropriately and to provide some statistical information about the total number of messages sent through the system for example.

We will use the Interface Definition Language (IDL) for the specification of these interfaces as shown in Fig. 8
                        .

To illustrate the test execution, we use the following test sequence (Fig. 9
                        ). This sequence describes the sending of a message by a user to other users who have joined the group through the manager.

The local test sequences corresponding to this global test sequence are given in the figure (
                        Fig. 10
                        
                        ). We notice that a coordination message is sent by the user ‘User1’ to the user ‘User2’ to coordinate the sending of a message from ‘User1’ to ‘User2’. Each tester uses two interfaces: IUT, related to the IUT interface associated with the tester, and CC related to the interface with the coordination channel. These sequences come from testing experiments with the prototype on students' realizations of chat group application.

Agent technologies promote a large variety of abstractions, protocols and mechanisms that aim to make them easier to design, develop, and implement complex system. On high level of abstraction, we show in this section how multi-agent based system used in open distributed testing prototype realization contributes to capture the complex monitoring tasks of distributed tester behaviors.

In our multi-agent architecture, the Tester Agent plays the role of moderator in the same tester, and according to its timed local test sequence, it expresses its needs in terms of coordination, observation and of execution to be synchronized with other agents. As shown in Fig. 11
                        , the complex tasks of tester agents are delegated to well define specialized agent:
                           
                              •
                              
                                 EATi
                                 : It is an Execution Agent in Tester-i used for control and observation of events on each PCO. It allows tester to apply input event actions to IUT and to receive output results from the IUT.


                                 TATi
                                 : It is a Timing Agent in Tester-i used for checking timings constraints during execution for TLTSi. It provides the validation of time constraints for sending or receiving messages by referring to the tester's clock:
                                    
                                       ▪
                                       If the tester receives a message: TAT will save the time of reception and checks if the timing constraints of the inputs are respected by the guard.

If the tester sends a message: TAT will save the time of sending.


                                 OATi
                                 : It is an Observation Agent in Tester-i used for sending and receiving observation messages.


                                 CATi
                                 : It is a Coordination Agent in Tester-i used for sending and receiving Coordination messages;

The OATi and CATi components enable the testers to exchange messages of Observation/Coordination (O/C). According to its local test sequence, the OAT/CAT of the concerned tester-i will send messages of O/C to the other concerned testers while communicating with their OATj/CATj for i≠j

In this section, we define the agent tester's behavior of our distributed testing platform with temporal constraints. Actually, each agent tester executes its local test sequence as follows:
                           
                              a)
                              
                                 For a communication with the IUT
                                 
                                    
                                       •
                                       If the message is a reception, the tester waits until it has informed by its EAT that the reception of the message has been observed, and by its TAT that the timing constraints have been respected.

If the message is a sending, the tester sends this message and TAT saves the send.


                                 For a communication with other testers
                                 
                                    
                                       •
                                       If the message is a reception, the tester waits until it has informed by its OAT/CAT of the reception of the waiting message and by its TAT that the timing constraints have been respected.

If the message is a sending, the tester informs its OAT/CAT which will communicate with the OAT/CAT of the tester that will receive this message. Then, the TAT saves the send timing.

In order to illustrate the execution of a given agent tester, we will therefore use the pseudo code of tester-3 as example of the execution of its Timed Local Test Sequence generated in (13):
                           
                              
                                 
                                    w
                                    
                                       t
                                       3
                                    
                                 
                                 
                                 =
                                 
                                 
                                    
                                       
                                       ?
                                       
                                          C
                                          2
                                       
                                       ,
                                       
                                          c
                                          3
                                       
                                       |
                                       
                                          ζ
                                          2
                                       
                                       ,
                                       
                                          
                                             c
                                             3
                                          
                                       
                                    
                                 
                                 .
                                 
                                    
                                       !
                                       
                                          O
                                          1
                                       
                                       ,
                                       
                                          
                                             c
                                             1
                                          
                                       
                                    
                                 
                                 .
                                 
                                 
                                    
                                       !
                                       
                                          c
                                          1
                                       
                                       ,
                                       
                                          
                                             c
                                             3
                                          
                                       
                                    
                                 
                                 
                                 .
                                 
                                    
                                       ?
                                       
                                          z
                                          1
                                       
                                       ,
                                       
                                       
                                          c
                                          3
                                       
                                       |
                                       
                                       =
                                       
                                       
                                          ζ
                                          1
                                       
                                       ,
                                       
                                          
                                             c
                                             3
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     


                        Fig. 12
                         shows how different Agents generated in a tester cooperate to execute all occurrence of each event in the TLTS. Firstly, each tester establishes communication with other testers and after with IUT. Each tester implements its timed local test sequence wti by delegating performed tasks to its specifics agents (EATi, CATi or OATi). After the occurrence of each waiting event in the TLTS, the TATi checks whether the timing constraints are satisfied.

@&#CONCLUSION@&#

In practice, the development of the distributed testing system framework is a complex process where the testing systems must not only check if the output events have been observed, but also the dates when these events have been occurred. In this context, the work presented in this paper is dedicated to extend results from testing distributed system to deal with testing an implementation under test with some timing constraints. There are some contributions in our paper that address those that look at presenting some issues to avoid the coordination, observation and synchronization problems in distributed testing.

We firstly propose a new architecture for testing distributed system, after that a distributed test model and a method are analyzed in terms of controllability, observability and synchronization that play an important role in fault detections. In other side, we introduce another way to overcome the issues arisen in this context by presenting an algorithm to generate the timed local test sequences that define the behavior of each tester. The main idea beside the proposed work is to consider each transition as a data structure containing the message to be sent or to be received, the guard to be verified and the list of clocks that will be reset at the end of the transition.

Finally, we exploit the concept of agents which make architectures able to support the dynamic adaptation between the various components of the distributed test architecture.

Our work is now oriented to develop more consequent testing environments for testing distributed significant application including web services applications, and real-time systems.

@&#REFERENCES@&#

