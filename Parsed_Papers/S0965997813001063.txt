@&#MAIN-TITLE@&#A method for the acquisition of ontology-based user profiles

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The algorithm introduces simulated annealing to hierarchical clustering in the construction of user ontologies.


                        
                        
                           
                           The k-nearest-neighbor query method is combined with branch-and-bound search algorithm in the maintenance of user ontology.


                        
                        
                           
                           The method has less human intervention in creating user profiles and can make user profiles more strong expressive.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Information retrieval

User profile

Semantic Web

Ontology

User ontology

Optimization

@&#ABSTRACT@&#


               
               
                  User profiles play an important role in information retrieval system. In this paper, we propose a novel method for the acquisition of ontology-based user profiles. In the method, the ontology-based user profiles can maintain the representations of personal interest. In addition, user ontologies can be automatically constructed. The method can make user profiles strong expressive and less manually interfered.
               
            

@&#INTRODUCTION@&#

The ability of facilitating users to achieve useful information is more and more important for information retrieval systems. User profiles can represent personal interests. These representations can be utilized for information retrieval. User profiles can be leveraged to recommend the truly valuable information to the users.

Generally, there are two major methods of collecting user profiles [1]. Firstly, preprocessing is a method done with a questionnaire. This method is time consuming for users. Secondly, automatic collection is based on the interaction between the user and the system. When a user frequently uses a system, the cost of automatic collection is not more expensive than that of preprocessing [1]. However, when a user rarely uses a system, it is difficult for the system to represent the user’s personal interests. To solve this problem, the user has to repeat a similar procedure for each system and therefore this increases user burden [1].

With emergence of Semantic Web, user ontology has more opportunities to improve user profiles. User ontology can share information between systems. Even if a user rarely uses a system, the system may share relevant information in other systems and represent the user’s personal interests. However, manual ontology construction is a time-consuming and expensive task. Thus, we propose a method called OUPA (Ontology-based User Profiles Acquisition) to acquire user-profiles through the construction of user ontologies. In the OUPA method, the ontology-based user profiles can maintain the representations of personal interest. In addition, user ontologies can be automatically constructed to avoid the problem of time consuming and expensive manual construction task using manual ontology building.

@&#RELATED WORK@&#

Navigli et al. [2,3] present a system, called OntoLearn. The OntoLearn system employs a combination of inductive machine learning and natural language processing for the extraction of domain ontologies from a corpus of domain text. In the OntoLearn system, semantic interpretation is used to identify the concepts and the semantic relations among the concepts, and a method called SSI is used for sense classification. More recently, Wei et al. [4] employ probabilistic topic models to learn relationships between a set of concepts. Particularly, they employ the LDA model to learn concept hierarchies.

Sánchez et al. [5] propose a method of automatically acquiring non-taxonomic relationships for constructing domain ontologies. This method discovers and selects domain-related verb phrases as non-taxonomic labels, and labels the non-taxonomic relationship according to the retrieved verbs relating a pair of concepts. More recently, Villaverde et al. [6] exploit the syntactic structures and dependencies among concepts existing to acquire non-taxonomic relationships and extract verbs that are frequently applied for linking the related concepts. They employ a popular association rule mining algorithm to discover concepts and verbs that frequently co-occur from a domain-specific text corpus.

Wu and Weld [7] present an autonomous system called KOG (Kylin Ontology Generator) for refining the wikipedia infobox ontology. In KOG, support-vector machines (SVMs) and Markov Logic Networks (MLNs) is used to build a rich ontology that is combined Wikipedia infoboxes with WordNet. More recently, Lau et al. [8] propose a method of automatically extracting lightweight fuzzy domain ontology, in order to extract and visualize the concept maps for representing learners’ knowledge structures. This method uses the notion of fuzzy ontology to create a formal fuzzy domain ontology model.

Han et al. [9] present an approach to acquiring ontology information from Web documents. The method employs association rules and inference mechanism to acquire association instances of ontology classes and employs clustering to construct ontology. Han [10] present a method of the creation of ontology-based adaptive user profiles. The method employs a combination of collaborative filtering, association rules, simulated annealing and fuzzy genetic algorithms to create user profiles and employs a combination of complete-link clustering algorithms and inference mechanism to create user ontologies. Han et al. [11] employ a combination of complete-link clustering and inference for the creation of semantic annotations and employ the k-nearest-neighbor query for the maintenance of semantic annotations. Han et al. [12] employ an augmented Lagrangian function to build fuzzy clustering model and employ the fuzzy c-means combined with simulated annealing and PHR to build ontology-based user profiles. Han and Chen [13] employ ontology-based collaborative filtering to discover semantic relationships that are acquired from the constructed ontologies and employ RBF neural networks to find the most relevant web documents and their corresponding terms from these similar users’ queries. Han et al. [14] employ a combination of genetic algorithm, self-organizing map, association rules and inference mechanism for the creation of semantic annotations and employ a combination of k-nearest-neighbor query and simulated annealing for the maintenance of semantic annotations. Han and Yan [15] employ compromise programming combined with pattern search to construct biclusters and to identify user communities.

In contrast to the above related work, our OUPA method considers two components of constructing the user profiles based on ontologies. Firstly, we propose the algorithm which introduces simulated annealing to hierarchical clustering in the construction of user ontologies. Secondly, we propose the k-nearest-neighbor query method combined with branch-and-bound search algorithm in the maintenance of user ontology. The method has less human intervention in creating user profiles and can make user profiles more strong expressive.

The OUPA method is used to acquire hierarchically structured ontology-based user profiles. The OUPA method consists of the CUO (The Construction of User Ontologies) method and the MUO (The Maintenance of User Ontology) method. The CUO method is used to construct user ontologies, and the MUO method is used to maintain user ontology. The CUO method is described in Section 3.1, and the MUO method is described in Section 3.2.

In the OUPA method, the user profiles can be constructed from the Web resources which are some personal web pages related to their name, title, research interests, publications, research projects etc. In OUPA, a user profile corresponds to several user ontologies, the same ontology can be share by several user profiles, and an ontology-based user profile is used to represent personal interests in order that a user may own several interests. For example, there are two user ontologies faculty and student. In ontology faculty, faculty is an entity superclass, and professor, associate professor and assistant professor are entity subclasses. Name, positions, and students in faculty are attributes. Ontology faculty is constructed. In the other ontology student, student is an entity superclass, and undergraduate student and graduate student are entity subclasses. At the next lower level, graduate student is an entity superclass, and Master student and Ph.D. student are entity subclasses. Name, advisor and research interests in graduate student are attributes. Ontology student is constructed. Once these entity classes are instanced, user profiles can be expressed. There exists the relationship between faculty and student, therefore Xun Zhang’s user profile is described as follows: {Xun Zhang, professor, {(Lingxin Yun, information retrieval), (Guangan Fei, database), (Yun Wu, semantic Web)}}, where { denotes layer. Xun Zhang’s user profile is explained below: Xun Zhang is a professor. His research interests are information retrieval, database and semantic Web. Ph.D. student Lingxin Yun, Guangan Fei and Yun Wu are supervised under the same advisor Xun Zhang. Ph.D. student Lingxin Yun’s research interest is information retrieval. Ph.D. student Guangan Fei’s research interest is database. Ph.D. student Yun Wu’s research interest is semantic Web. In addition, there exists the relationship between faculty and course, therefore course may be inserted into the user ontology. Course name and credit in course are attributes. Once course are instanced, Xun Zhang’s user profile is described as follows: {Xun Zhang, professor, {(information retrieval, Lingxin Yun), (database, Guangan Fei), (semantic Web, Yun Wu)}, {(information retrieval, 2)}}. Xun Zhang’s user profile is explained below: Xun Zhang is a professor. He teaches information retrieval that carries 2 credits. His research interests are information retrieval, database and semantic Web. Ph.D. student Lingxin Yun, Guangan Fei and Yun Wu are supervised under the same advisor Xun Zhang. Ph.D. student Lingxin Yun’s research interest is information retrieval. Ph.D. student Guangan Fei’s research interest is database. Ph.D. student Yun Wu’s research interest is semantic Web.

The CUO method consists of the ISAC (Introduce Simulated Annealing to Clustering) algorithm and the ACUO (Automatically Constructing User Ontologies) algorithm, where we assume that the entities in Web pages have been extracted. The ISAC algorithm is used to compute optimal solution. Based on the ISAC algorithm, the ACUO algorithm is used to the construction of user ontologies. The ISAC algorithm is described in Section 3.1.1, and the ACUO algorithm is described in Section 3.1.2.

The ISAC algorithm is used for splitting clusters in the data set. The ISAC algorithm introduces simulated annealing [16–20] to cluster partition. The simulated annealing algorithm can be viewed as globally optimizing an objective function. The convergence of the simulated annealing algorithm has been widely studied. Thus, The ISAC algorithm can ensure to break away current local optimal solution and to reduce the computing workload. The time complexity of the ISAC algorithm is O(sum
                           ×
                           len
                           ×
                           p), where sum is the number of iterative steps, len is the maximum length of Markov chain, and p is the number of entities.

The ISAC algorithm is based on the following solution form:
                              
                                 
                                    
                                    
                                       
                                          1. Solution space is {entity}, where an entity consists of some attributes.
                                       
                                       
                                          2. Objective function is 
                                                
                                                   f
                                                   =
                                                   min
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         r
                                                         =
                                                         1
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   =
                                                   min
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         r
                                                         =
                                                         1
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      
                                                         
                                                            
                                                               n
                                                            
                                                            
                                                               r
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               ri
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     r
                                                                  
                                                               
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         ri
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               r
                                                            
                                                         
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   )
                                                
                                             , where Sr
                                              is the squared error, nr
                                              is the number of entity in cluster r, xri
                                              is entity i in cluster r, and 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                
                                              is the centroid of cluster r.
                                       
                                       
                                          3. New solution is produced by randomly choosing another entity from neighboring region N(x).
                                       
                                       
                                          4. Objective function difference is △f
                                             =
                                             f(new entity)−
                                             f(local optimal solution).
                                       
                                       
                                          5. Accept criterion is P
                                             =1 for △f
                                             >0 or P
                                             =exp(−△f/t) for △f
                                             ⩽0.
                                       
                                       
                                          The ISAC algorithm is described as follows:
                                       
                                       
                                          
                                             Input: a set of entities, initial solution x
                                             0, function f, initial temperature t
                                             0, initial step q
                                             0, monotone increment function I(x)
                                       
                                       
                                          
                                             Output: optimal solution
                                       
                                       
                                          {
                                             x*
                                             
                                             =
                                             x
                                             0; // initialize optimal solution x*
                                             
                                          
                                       
                                       
                                          
                                             
                                             f*
                                             
                                             =
                                             f
                                             0 ; // initialize optimal objective function value f∗
                                             
                                          
                                       
                                       
                                          
                                             
                                             q
                                             =
                                             q
                                             0; // initialize step q
                                          
                                       
                                       
                                          
                                             
                                             t
                                             =
                                             t
                                             0; // initialize temperature t=80
                                       
                                       
                                          
                                             
                                             i
                                             =1; // initializtion
                                       
                                       
                                          
                                             
                                             at
                                             =1; // initializtion
                                       
                                       
                                          
                                             
                                             while |Ri
                                             
                                             –
                                             C|>
                                             ε //ε is a given enough small positive number, where ε
                                             =9×10−2. Threshold C is 0.82
                                       
                                       
                                          
                                             {Ri−
                                             
                                             1
                                             =
                                             at/as; // at is the acceptable times of new solution, as is iterative steps number, Ri−
                                             
                                             1 is acceptable rate
                                       
                                       
                                          
                                             
                                             
                                             at
                                             =
                                             at
                                             +1;
                                       
                                       
                                          
                                             
                                             
                                             as
                                             =0; // initializtion
                                       
                                       
                                          
                                             
                                             
                                             while 
                                             J<>U // U is the upper limit of step length
                                       
                                       
                                          
                                             
                                             { as
                                             =
                                             as
                                             +1;
                                       
                                       
                                          
                                             
                                             
                                             
                                             while 
                                             x
                                             ∉
                                             N(x) // N(x) is neighboring region
                                       
                                       
                                          
                                             
                                             
                                             { step length is q and the BFGS optimizer in the quasi-Newton method is used to compute local optimal solution;
                                       
                                       
                                          
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             xi
                                              is produced by randomly choosing another entity from neighboring region N(x) and objective function difference Δf
                                             =
                                             f(xi
                                             )−
                                             f(x) is computed;
                                       
                                       
                                          
                                             
                                             
                                             
                                             if Δf
                                             ⩽0 or exp(−Δf/t)>random(0,1)
                                       
                                       
                                          
                                             
                                             
                                             
                                             then { x
                                             =
                                             xi
                                             ;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             if 
                                             f
                                             <
                                             f*
                                             
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then { x
                                             =
                                             x
                                             *;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             f
                                             =
                                             f
                                             *;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             if 
                                             at is equal to the given acceptable times
                                       
                                       
                                          
                                             
                                             
                                             
                                             then break;
                                       
                                       
                                          
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             q
                                             =
                                             I(Ri
                                             )×
                                             q; // adjustment function I(x) is monofonic increasing function, I(x)=(x
                                             −0.5)2
                                             +1
                                       
                                       
                                          
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             if 
                                             f
                                             <
                                             f
                                             *
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             then {x
                                             =
                                             x
                                             *;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             f
                                             =
                                             f
                                             *;
                                       
                                       
                                          
                                             
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             Ri
                                             
                                             =
                                             at/as;
                                       
                                       
                                          
                                             
                                             
                                             
                                             if 
                                             i
                                             >2
                                       
                                       
                                          
                                             
                                             
                                             
                                             then // compute self-adjusting temperature
                                       
                                       
                                          
                                             
                                             
                                             
                                             { if 
                                             Ri−
                                             
                                             1
                                             <
                                             C and Ri
                                             
                                             <
                                             C
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then 
                                             t
                                             =
                                             t
                                             +
                                             TC; // TC is a given constant
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             if 
                                             Ri−
                                             
                                             1
                                             ⩾
                                             C and Ri
                                             
                                             ⩾
                                             C
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then 
                                             t
                                             =
                                             t
                                             −
                                             TC;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             if 
                                             Ri−
                                             
                                             1
                                             ⩽
                                             C and Ri
                                             
                                             ⩾
                                             C
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then 
                                             t
                                             =
                                             t
                                             −
                                             TC/2;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             if 
                                             Ri−
                                             
                                             1
                                             >
                                             C and Ri
                                             
                                             <
                                             C
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then 
                                             t
                                             =
                                             t
                                             +
                                             TC/2;
                                       
                                       
                                          
                                             
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             i
                                             =
                                             i
                                             +1;
                                       
                                       
                                          
                                             
                                             }
                                       
                                       
                                          
                                             }
                                       
                                    
                                 
                              
                           
                        

Based on the ISAC algorithm, the ACUO algorithm is used to automatically construct user ontologies. The ACUO algorithm is a divisive clustering algorithm for hierarchical clustering [21–23]. In a divisive clustering algorithm, all entities are first considered to be in one cluster. The farthest two entities in the same cluster are used as seed points for two clusters. All entities that have the closest seed in the old cluster are placed into the new cluster. This procedure continues and smaller subsets are produced until a threshold distance is reached. As described in the ISAC algorithm, the ACUO algorithm introduces simulated annealing to analyze the semantic relationships between entities, and construct the hierarchically structured user ontologies. Accordingly, the construction of user ontologies is converted into the global optimization problem for clustering. The time complexity of the ACUO algorithm is O((2
                              l
                           
                           −1)×(the time complexity of the ISAC algorithm)), where l is the number of layers in user ontology.

The ACUO algorithm is described as follows:
                              
                                 
                                    
                                    
                                       
                                          
                                             Input: the entire entities set
                                       
                                       
                                          
                                             Output: user ontologies
                                       
                                       
                                          
                                             {all entities in the entire dataset are regarded as one cluster;
                                       
                                       
                                          
                                             
                                             
                                             while one cluster does not consist of only a single entity
                                       
                                       
                                          
                                             
                                             { the ISAC algorithm is used to compute optimal solution, so that one cluster is broken down into two subsets;
                                       
                                       
                                          
                                             
                                             
                                             every subset is regarded as one cluster;
                                       
                                       
                                          
                                             
                                             }
                                       
                                       
                                          
                                             }
                                       
                                    
                                 
                              
                           
                        

In contrast to other divisive clustering algorithms such as Principal Direction Divisive Partitioning (PDDP) algorithm for hierarchical clustering [22] and the non-greedy version of the PDDP (NGPDDP) algorithm [23], the ACUO algorithm introduces simulated annealing to clustering for the construction of user ontologies. A simulated annealing algorithm ISAC can break down the data into sub-clusters more reasonably.

The maintenance of user ontology aims to update some parts of the ontology, in order to perform incremental clustering for supporting insertions and deletions after initial clusters are formed. The MUO method consists of the BBU (Introduce Branch and Bound for Updating) algorithm and the AMUO (Automating the Maintenance of User Ontology) algorithm. The BBU algorithm is used to evaluate the nodes close enough to the entity which will be inserted or deleted. Based on the BBU algorithm, the AMUO algorithm is used to maintain user ontology. The BBU algorithm is described in Section 3.2.1, and the AMUO algorithm is described in Section 3.2.2.

We propose an efficient branch-and-bound search algorithm called BBU to evaluate the nodes close enough to the entity which will be inserted into a user ontology or deleted from a user ontology. The BBU algorithm introduces a branch and bound method [24,25] to evaluate the entity classes of user ontology close enough to the specified entity which is inserted or deleted. Specifically, the BBU algorithm examines the connectivity of entity classes in user ontology, traverses the semantic relationships between entity classes before a given threshold is reached, and finds the closest entity classes according to their semantic distance.

In the following description, k stands for the iteration index, Listk
                            denotes the list in which the candidate class nodes are listed, Uk
                            denotes the upper bound at the end of k iterations, and x*
                            denotes optimal solution. The bounding function F(x)=max(cos(d
                           1,
                           d
                           2)), where d
                           1 and d
                           2 are two classes vectors. cos(d
                           1,
                           d
                           2)=(d
                           1·d
                           2)/(||d
                           1||×||d
                           2||), where· indicates vector dot product, ||d
                           1|| is the length of vector d
                           1, and ||d
                           2|| is the length of vector d
                           2. The time complexity of the BBU algorithm is O(n
                           ×log2
                           n), where n is the number of entity classes.

The BBU algorithm is described as follows:
                              
                                 
                                    
                                    
                                       
                                          
                                             Input: user ontology, a specified entity which will be inserted or deleted
                                       
                                       
                                          
                                             Output: optimal solution x
                                             *
                                          
                                       
                                       
                                          { x
                                             *
                                             =Ø; // x
                                             * is an optimal solution
                                       
                                       
                                          
                                             
                                             k
                                             =0;
                                       
                                       
                                          
                                             
                                             List
                                             0
                                             ={root node};
                                       
                                       
                                          
                                             
                                             U
                                             0
                                             =+∞;
                                       
                                       
                                          
                                             do {maximizing choose the class node x with the largest value of the bounding function F(x), where x
                                             ∊
                                             Listk
                                             ;
                                       
                                       
                                          
                                             
                                             
                                             Listk+
                                             
                                             1
                                             =
                                             Listk
                                             
                                             −{x};
                                       
                                       
                                          
                                             
                                             
                                             if 
                                             f(x)⩾
                                             Uk
                                             
                                          
                                       
                                       
                                          
                                             
                                             
                                             then prune the node;
                                       
                                       
                                          
                                             
                                             
                                             else {x
                                             *
                                             =
                                             x;
                                       
                                       
                                          
                                             
                                             
                                             
                                             Uk
                                             
                                             =
                                             f(x);
                                       
                                       
                                          
                                             
                                             
                                             split x into x
                                             1 and x
                                             2;
                                          
                                       
                                       
                                          
                                             
                                             
                                             
                                             Listk+
                                             
                                             1
                                             =
                                             Listk
                                             ∪{x
                                             1,
                                             x
                                             2};
                                       
                                       
                                          
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             k
                                             =
                                             k
                                             +1;
                                       
                                       
                                          
                                             
                                             }
                                       
                                       
                                          
                                             
                                             while 
                                             Listk
                                             
                                             ≠Ø and Uk
                                             
                                             −
                                             f(x)>
                                             ε
                                          
                                       
                                       
                                          
                                             }
                                       
                                    
                                 
                              
                           
                        

We propose the AMUO algorithm which introduces a k-nearest-neighbor query method [26] to maintain the hierarchically structured user ontology. The AMUO algorithm is used to insert a specified entity into a user ontology or delete a specified entity from a user ontology. The time complexity of the AMUO algorithm is O(l
                           ×
                           n
                           ×log2
                           n), where l is the number of layers in user ontology and n is the number of entity classes.

The AMUO algorithm is described as follows:
                              
                                 
                                    
                                    
                                       
                                          
                                             Input: user ontology, a specified entity
                                       
                                       
                                          
                                             Output: insert or delete this entity into or from the user ontology
                                       
                                       
                                          { the children of the root node is added to a queue;
                                       
                                       
                                          
                                             
                                             while the queue is not empty
                                       
                                       
                                          
                                             
                                             {a node is taken off the queue;
                                       
                                       
                                          
                                             
                                             the BBU algorithm is used to evaluate whether the node and any of its descendants are close enough to the entity;
                                       
                                       
                                          
                                             
                                             
                                             if the specified entity is inserted into a user ontology // insert the specified entity into a user ontology
                                       
                                       
                                          
                                             
                                             
                                             then if the node and any of its descendants are not close enough to the entity
                                       
                                       
                                          
                                             
                                             
                                             
                                             then the subtree represented is discarded by this node;
                                       
                                       
                                          
                                             
                                             
                                             
                                             else if the node is not a leaf node
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then the children of this node is added to a queue;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             else { the entity is inserted into the leaf node;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             if there are “too many” entity classes in the leaf node
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             then {the leaf nodes are split;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             some entity classes in the leaf nodes are reassigned to the other centroids that may increase the least squared error;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             if the entity is farthest from any cluster centroid
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             then a new cluster centroid is introduced;
                                       
                                       
                                          
                                             
                                             
                                             
                                             }
                                       
                                       
                                          
                                             
                                             
                                             
                                             if the specified entity is deleted from a user ontology // delete the specified entity from a user ontology
                                       
                                       
                                          
                                             
                                             
                                             
                                             then if the node and any of its descendants are not close enough to the entity
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             then the subtree represented is discarded by this node;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             else if the node is not a leaf node
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             then the children of this node is added to a queue;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             else { the entity is deleted from the leaf node;
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             
                                             if there are “too few” entity classes in the leaf node
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             
                                             then the neighboring leaf nodes are merged;
                                       
                                       
                                          
                                             
                                             }
                                       
                                       
                                          
                                             }
                                       
                                       
                                          }
                                       
                                    
                                 
                              
                           
                        

The AMUO algorithm is different from Roussopoulos et al. [26] in that the AMUO algorithm is used to maintain a hierarchically structured user ontology, while Roussopoulos et al. [26] is used to process exactly the k nearest neighbors of a given query point in space for the R-trees. In contrast to Boley [22] and Cutting et al. [27] and Li et al. [28], the AMUO algorithm is a hybrid algorithm of both k-nearest-neighbor query method and branch-and-bound search algorithm for maintaining user ontology, where a branch-and-bound search algorithm BBU is used to improve search efficiency.

In this section, a case study has been given and some experiments have been done to evaluate the performance of the proposed method. In the case study, six user ontologies are described below: user ontology 1 is position, user ontology 2 is organization, user ontology 3 is teaching, user ontology 4 is project, user ontology 5 is publication and user ontology 6 is educational background. There are nine entities in user ontology 1. Nine entities in user ontology 1 include Research Fellow, Senior Research Associate, Senior Research Assistant, Professor, Associate Professor, Assistant Professor, Lecturer, Senior Lecturer and Reader. The construction process of user ontology 1 is shown in Fig. 1
                     . Number 1–9 in Fig. 1 respectively denote Research Fellow, Senior Research Associate, Senior Research Assistant, Professor, Associate Professor, Assistant Professor, Lecturer, Senior Lecturer and Reader. There are seven entities in user ontology 2. Seven entities in user ontology 2 include Name of Organization, Nature of Organization, Address of Organization, Post Code of Organization, Web Site of Organization, Fax of Organization and Name of Employer. The construction process of user ontology 2 is shown in Fig. 2
                     . Number 1–7 in Fig. 2 respectively denote Name of Organization, Nature of Organization, Address of Organization, Post Code of Organization, Web Site of Organization, Fax of Organization and Name of Employer. There are seven entities in user ontology 3. Seven entities in user ontology 3 include Name of Book, Teacher, Number of Student, Class of Student, Period of Course, Code of Course and Name of Course. The construction process of user ontology 3 is shown in Fig. 3
                     . Number 1–7 in Fig. 3 respectively denote Name of Book, Teacher, Number of Student, Class of Student, Period of Course, Code of Course and Name of Course. There are five entities in user ontology 4. Five entities in user ontology 4 include Category of Project, Number of Project, Name of Project, Period of Project and Sum of Project. The construction process of user ontology 4 is shown in Fig. 4
                     . Number 1–5 in Fig. 4 respectively denote Category of Project, Number of Project, Name of Project, Period of Project and Sum of Project. There are seven entities in user ontology 5. Seven entities in user ontology 5 include Title, Author, Source of Index, Name of Publication, Data of Publication, Volume of Publication and Issue of Publication. The construction process of user ontology 5 is shown in Fig. 5
                     . Number 1–7 in Fig. 5 respectively denote Title, Author, Source of Index, Name of Publication, Data of Publication, Volume of Publication and Issue of Publication. There are six entities in user ontology 6. Six entities in topic 6 include Student Level, Primary Students, Students of High School, Undergraduates, Master’s Degree Students and Doctoral Degree Students. The construction process of user ontology 6 is shown in Fig. 6
                     . Number 1–6 in Fig. 6 respectively denote Student Level, Primary Students, Students of High School, Undergraduates, Master’s Degree Students and Doctoral Degree Students.

Experiments are conducted to evaluate the precision of the proposed method. The concept of precision is used to evaluate the experimental results of the method. The precision is the proportion of entities that is exactly constructed in the hierarchically structured user ontologies. Six user ontologies are constructed to show that the proposed method has a high precision. Six user ontologies are described below: user ontology 1 is position, user ontology 2 is organization, user ontology 3 is teaching, user ontology 4 is project, user ontology 5 is publication and user ontology 6 is educational background. The precisions of these user ontologies are shown respectively in Table 1
                     . The experiment result in Table 1 shows that the proposed method can perform better in user ontology 2, user ontology 3, user ontology 4, user ontology 5 and user ontology 6.

@&#CONCLUSION@&#

User profiles have an important role in information retrieval system. With emergence of Semantic Web, user ontology provides opportunities for improving user profiles. User ontology can maintain the representations of personal interest. In this paper, a method called OUPA is proposed for the acquisition of ontology-based user profiles. One key feature of OUPA is that we introduce simulated annealing to cluster partition for automatically constructing user ontologies. Another key feature of OUPA is that a hybrid algorithm of both k-nearest-neighbor query method and branch-and-bound search algorithm is proposed for maintaining user ontology.

@&#ACKNOWLEDGEMENTS@&#

The authors thank Professor Linping Sun for technical help. The authors thank the anonymous reviewers for their constructive comments. This work is supported by the National Natural Science Foundation of China (Project 60571048, Project 60873264, Project 60971088, Project 61272402, and Project 61070214), and the Qing Lan Project.

@&#REFERENCES@&#

