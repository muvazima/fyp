@&#MAIN-TITLE@&#A branch and bound based heuristic for makespan minimization of washing operations in hospital sterilization services

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Parallel batch scheduling approach for hospital sterilization services.


                        
                        
                           
                           A branch and bound based heuristic method is developed.


                        
                        
                           
                           Our algorithm, 
                                 
                                    
                                       
                                          BB
                                       
                                       
                                          H
                                       
                                    
                                 
                              , can solve real-world size instances with short computation time.


                        
                        
                           
                           
                              
                                 
                                    
                                       
                                          BB
                                       
                                       
                                          H
                                       
                                    
                                 
                               outperforms the current state of the art solution methods for most of the problem instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

OR in health services

Parallel batch scheduling

Makespan

Branch and bound heuristic

@&#ABSTRACT@&#


               
               
                  In this paper, we address the problem of parallel batching of jobs on identical machines to minimize makespan. The problem is motivated from the washing step of hospital sterilization services where jobs have different sizes, different release dates and equal processing times. Machines can process more than one job at the same time as long as the total size of jobs in a batch does not exceed the machine capacity. We present a branch and bound based heuristic method and compare it to a linear model and two other heuristics from the literature. Computational experiments show that our method can find high quality solutions within short computation time.
               
            

@&#INTRODUCTION@&#

Sterilization services are hospital departments where medical devices (MDs) are sterilized. There are two types of MDs: single use MDs and reusable MDs. Reusable MDs (RMDs) are used in surgeries, sterilized, and then reused in other surgeries. We consider the sterilization process of RMDs in this study.

All RMDs used in a surgery constitute the RMD set of the surgery. After a surgery, all RMDs used are sent to the sterilization service. Due to surgery characteristics and surgeons needs, RMD sets may contain different numbers and types of instruments. Hence, they may have different sizes (or volumes). Moreover, they are sent to the sterilization service at different times within a day since each surgery may have a different starting and ending time.

A typical sterilization service is composed of the following steps (Di Mascolo & Gouin, 2013): pre-disinfection, washing, packing and sterilization. Pre-disinfection is a manual step during which RMDs are submerged in a chemical substance. Then, they are washed in an automatic washer. Afterwards, they are packed and sterilized with steam in autoclaves.

We are interested in the washing step which is a bottleneck for sterilization services. More than one RMD set can be washed in an automatic washer at the same as long as the machine capacity is not exceeded. All RMD sets washed at the same time constitute a single batch. Depending on the organization between operating theatres and the sterilization service, RMD arrivals can be known in advance. For instance, RMD arrivals can be known accurately for operating theatres where ambulatory surgeries take place. Another example is sterilization services that accept RMD arrivals only at specific times within a day. However, although RMD arrival times and sizes are known in advance, the decision of how to load the machines, i.e., how to batch RMD sets and launch washing cycles is not trivial. We model this problem using a parallel batch scheduling approach. Jobs may have different sizes (or volumes), different release dates and equal processing times. All jobs processed at the same time constitute a single batch which is processed on a single machine. The processing time of batches are the same and equal to the processing time of jobs. Hence, our problem becomes a parallel batching problem where RMD sets are treated as jobs having different sizes, different release dates and equal processing times.

The remainder of this paper is organized as follows. In Section 2, we provide a literature review about batch scheduling problems and summarize the contributions of this paper. In Section 3, we give a formal description of our problem. Section 4 is dedicated to the solution methodology. Section 5 presents computational tests. Finally, we conclude the study and propose some further research directions.

@&#LITERATURE REVIEW@&#

We review only batch scheduling literature regarding jobs with different sizes. For more information about batch scheduling, we refer the reader to Potts and Kovalyov (2000) and Mathirajan and Sivakumar (2006). There are two types of batch scheduling: serial and parallel. In serial batch scheduling, jobs in the same batch are processed sequentially on one or more machines. The processing of a batch is completed when the last job of the batch is processed. A typical example is confection workshops where many types of clothes are sewed. For instance, sewing of t-shirts constitutes a batch while shirts, trousers, etc. may constitute a second batch. In parallel batching however, all jobs are processed simultaneously in the same machine. In this paper, we study a parallel batch scheduling problem.

To the best of our knowledge, exact methods for parallel batching with jobs having different processing times are only applied to the case when all jobs are available at the same time. Uzsoy (1994) proposes a branch and bound algorithm to minimize the sum of job completion times on a single machine in which jobs have different processing times and sizes. For the same problem but with the objective of minimizing makespan, Dupont and Dhaenens-Flipo (2002) develop a branch and bound algorithm. Later on, Parsa, Karimi, and Kashan (2010) propose a branch and price method for the same problem. They report that their method is more efficient in terms of solution time than the one proposed by Dupont and Dhaenens-Flipo (2002). Malapert, Gueret, and Rousseau (2012) study the minimization of maximum lateness on a single machine for which they propose a constraint programming approach. Other than these studies, there are many other studies where the case of unit size jobs is tackled. For instance, Yuan, Liu, Ng, and Cheng (2004) study the case where jobs have unit sizes but different processing times and release dates in the presence of job families. They provide dynamic programming algorithms when the number of jobs, number of job families and number of release dates are bounded. For the general case, they propose a 2-approximation algorithm. Cheng, Yuan, and Yang (2005) propose polynomial time dynamic programming algorithms for a set of regular objective functions when jobs have unit sizes, unit processing times, release dates and precedence constraints in the presence of a single machine.

Regardless of processing times, all problems considering different job sizes are in the class of NP-hard. The additional difficulty in our problem is due to different release dates.

Most studies on batch scheduling with different job sizes focus on heuristic, meta-heuristic methods and approximation algorithms. Zhang, Cai, Lee, and Wong (2001) consider the case where jobs are available at the same time while having different sizes and processing times. They develop an approximation algorithm with a worst case performance ratio equal to 7/4 for makespan minimization on a single machine. Cheng, Yang, Hu, and Chen (2012) propose an approximation algorithm with a worst case ratio of 2 and (8/3−2/3*m) for makespan and total completion time criteria, respectively, in the presence of m identical machines. Li, Li, Wang, and Liu (2005) extend the problem studied in Zhang et al. (2001) by considering job release dates. They present a 2+
                              
                                 ∊
                              
                            approximation algorithm which is derived from a polynomial time approximation scheme that they propose for the case where jobs have unit sizes. Lu, Feng, and Li (2010) use a similar approach and provide a 2+
                              
                                 ∊
                              
                            approximation algorithm for bi-objective minimization of makespan and penalization of unscheduled jobs. Liu, Ng, and Cheng (2014) present heuristics and approximation algorithms for makespan minimization in the presence of unit size jobs with release dates and different processing times. Their work is later generalized to the case of different job sizes by Li (2012). Chou (2007) studies the same problem as in Li et al. (2005) and proposes a genetic algorithm using a dynamic programming procedure to find the makespan of a given chromosome.

Because in our problem we have release dates, different job sizes and parallel machines, the articles cited in this paragraph are more related to our problem. Li (2012) presents the only approximation algorithm with a worst case performance ratio equal to 2+
                              
                                 ∊
                              
                            when jobs have different sizes, different processing times, release dates. There are, however, mostly heuristic/meta-heuristic methods in the literature for the batch scheduling problem studied by Li (2012). For the same problem, Chung, Tai, and Pearn (2009) propose a mixed integer linear programming model (MILP) and heuristics. Many other authors use the heuristics of Chung et al. (2009) for benchmarking. Wang and Chou (2010), Damodaran and Velez Gallego (2010) and Damodaran, Velez-Gallego, and Maya (2011) consider the same problem for which they develop a genetic algorithm, a greedy randomized adaptive search procedure (GRASP) meta-heuristic and a constructive heuristic, respectively. All report that their approaches outperform the heuristics proposed in Chung et al. (2009). In another work, Damodaran and Velez-Gallego (2012) propose a simulated annealing algorithm which is able compete with the GRASP approach. Ozturk, Espinouse, Di Mascolo, and Gouin (2012) develop a MILP model that runs faster than that proposed by Chung et al. (2009) for the case with equal job processing times. They also treat some special cases and provide optimal greedy algorithms. Recently, Pearn, Hong, and Tai (2013) enlarge the broad of the problem considering job families, due dates and set-up times between the processing of batches from different families.

The method we propose exploits the structural properties of the problem under study. It is based on constructing a search tree where each node represents a job release date or the starting time of batch processing thanks to equal job processing time property. Numerical tests show that our branch bound based heuristic method (
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                        ) can solve problem instances containing up to 40 jobs in short computational time and can solve larger instances in reasonable time. MILP model of Ozturk et al. (2012) can find the optimal solution for small and medium size instances but it requires too much computational time. Regarding other methods from the literature, benchmarking results show that our method’s solution quality is higher than two other heuristics from the literature. Our method is applicable in sterilization services since it can quickly solve real size instances.

We begin with definitions and notation:
                        
                           •
                           There are m identical parallel machines with a limited capacity B.

There are n jobs to be processed. A job is a task that is characterized by a release date, 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          j
                                       
                                    
                                 
                              , a size, 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                    
                                 
                              , and a processing time, p.

The size of a job cannot be greater than the machine capacity.

Since washing times are the same for all RMD sets, job processing times are the same for all jobs.

A batch is composed of jobs processed at the same time on the same machine. Several jobs can be batched together, complying with the machine capacity constraint.

Once the processing of a batch is started, it cannot be interrupted (i.e. pre-emption is not allowed). Jobs cannot be split into multiple batches.

The objective is to minimize makespan.

Using the Graham’s notation (Graham, Lawler, Lenstra, & Rinnooy Kan, 1979), we have a 
                        
                           P
                           ∣
                           p
                           -
                           batch
                           ,
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                           ,
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           =
                           p
                           ,
                           
                              
                                 w
                              
                              
                                 j
                              
                           
                           ,
                           B
                           ∣
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                      scheduling problem. In this notation, P stands for identical machines. 
                        
                           p
                           -
                           batch
                        
                      indicates that we have a parallel batching problem where all jobs in the same batch are processed at the same time. 
                        
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                        
                      and 
                        
                           
                              
                                 w
                              
                              
                                 j
                              
                           
                        
                      stands for job release dates and sizes, respectively. 
                        
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           =
                           p
                        
                      indicates that all job processing times are equal to p. B is the machine capacity. Finally, 
                        
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                      is the objective function.

It is straightforward to show that this problem is NP-hard. Consider the special case where all jobs are simultaneously available at instant 0 (
                        
                           1
                           ∣
                           p
                           -
                           batch
                           ,
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                           =
                           0
                           ,
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           =
                           p
                           ,
                           
                              
                                 w
                              
                              
                                 j
                              
                           
                           ,
                           B
                           ∣
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                     ). Then, minimizing makespan is equivalent to minimizing the number of batches, which is a bin-packing problem. Since bin-packing is strongly NP-hard, our problem is also strongly NP-hard.

In this section, we present first a lower bound algorithm and then a branch and bound based heuristic for the problem of makespan minimization. The lower bound algorithm will be used for pruning in the branch and bound method. Throughout this section, without loss of generality, we suppose that jobs are sorted in non-decreasing order of release dates.

The idea of the lower bound algorithm consists in splitting jobs in size and creating batches with consecutive jobs. When a job, say job j, is split in size, two new jobs 
                           
                              
                                 
                                    j
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    j
                                 
                                 
                                    2
                                 
                              
                           
                         are obtained such that sum of their sizes is equal to the size of job j. Moreover, release dates of jobs 
                           
                              
                                 
                                    j
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    j
                                 
                                 
                                    2
                                 
                              
                           
                         are equal to the release date of job j. Obviously, a lower bound on the number of batches is also obtained when jobs are allowed to be split in size. If after assigning a job to a batch, the number of batches to be created with the remaining jobs decreases, then this batch can be processed immediately. Because there is at least a batch whose processing starting time is equal to the release date, 
                           
                              
                                 
                                    r
                                 
                                 
                                    j
                                 
                              
                           
                        , of the last job, j, it contains, and a minimum number of batches is created after job j with the remaining jobs, therefore a lower bound on 
                           
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                           
                         is obtained.

The lower bound algorithm takes the following steps:
                           
                              1.
                              Calculate a lower bound on the number of batches by allowing jobs to be split. Select the first unbatched job (i.e., the unbatched job having the smallest release date), put it in a batch, then recalculate the minimum number of batches with the remaining unbatched jobs.

If the number of batches to create decreases, close the batch.

In case that job does not completely enter the open batch, split the job, put its first part to the batch in order to have a 
                                    
                                       100
                                       %
                                    
                                  full batch and close the batch. Treat the second part of the job as a new job having the same release date.

Execute the same steps with the remaining jobs.

Here closing a batch means that the batch is ready for processing and no other job is put in that batch. The notation used and the lower bound algorithm can be found in the appendix.

The LB algorithm finds the minimum number of batches by finding the sum of all unbatched job sizes and dividing this sum by the machine capacity. Then, this value (if fractional) is rounded up to the smallest integer. To illustrate with a numerical example, Fig. 1
                         shows the release dates and sizes of 4 jobs. Let p be 60 and consider two machines whose capacities are equal to 12.

The minimum number of batches is equal to 
                           
                              
                                 
                                    
                                       (
                                       4
                                       +
                                       7
                                       +
                                       9
                                       +
                                       4
                                       )
                                       /
                                       12
                                    
                                 
                              
                              =
                              2
                           
                        . When the minimum number of batches is recalculated after placing the first job in a batch, we obtain 
                           
                              
                                 
                                    
                                       (
                                       7
                                       +
                                       9
                                       +
                                       4
                                       )
                                       /
                                       12
                                    
                                 
                              
                              =
                              2
                           
                        . Thus, the first batch is not closed yet. The second job is also put to batch 1. The minimum number of batches with the remaining jobs is equal to 
                           
                              
                                 
                                    
                                       (
                                       9
                                       +
                                       4
                                       )
                                       /
                                       12
                                    
                                 
                              
                              =
                              2
                           
                        . Batch 1 stays open. The third job is put in batch 1 but because of the capacity limitation, it cannot completely be placed in batch 1. Thus, job 3 is split such that the size of the first split part is 1 and the second part’s size is 8. The first part of job 3 is put in batch 1. The second part of job 3 is treated as new job having the same release date as job 3. Finally, the same procedure is applied to remaining jobs. Once all jobs are assigned to a batch, batch ready times are set equal to the greatest job release date they contain. Then, they are assigned consecutively on machines. The solution is shown on a Gantt diagram in Fig. 2
                        .

Because jobs have equal processing times, assignment of batches to machines is an easy task in the presence of identical machines. When a batch is to be processed, it is assigned to the machine having the smallest idle time. Here, smallest idle time (or smallest machine idle time) indicates the smallest instant when a machine becomes available to process new jobs. For instance consider the solution given in Fig. 2. There are two machines such that machine 
                           
                              
                                 
                                    M
                                 
                                 
                                    1
                                 
                              
                           
                         terminates the processing of some jobs at instant 90 and machine 
                           
                              
                                 
                                    M
                                 
                                 
                                    2
                                 
                              
                           
                         terminates at instant 100. Then the smallest machine time for this example is instant 90 after which machine 
                           
                              
                                 
                                    M
                                 
                                 
                                    1
                                 
                              
                           
                         is available to process new jobs. Because jobs have equal processing times, we have a limited number of starting times for the processing of batches due to equal processing times (Baptiste, 2000). Let 
                           
                              π
                           
                         be the set of all possible starting times for batches. Then, 
                           
                              π
                              =
                              {
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                              
                              +
                              k
                              ∗
                              p
                              ∣
                              i
                              ∈
                              {
                              1
                              ,
                              …
                              ,
                              n
                              }
                           
                         and 
                           
                              k
                              ∈
                              {
                              0
                              ,
                              …
                              ,
                              n
                              }
                              }
                              ,
                              ∣
                              π
                              ∣
                           
                         = 
                           
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . In our branch and bound tree, each node is characterized by an instant, say t, which is an element of set 
                           
                              π
                           
                        , and by two sets of jobs representing present but unprocessed jobs at t and jobs which have not been released by t, respectively.

The algorithm explores all possible instants by creating a binary tree. The left branch of the tree represents delaying the processing of jobs until the release of next job. The right branch represents the processing of a batch (we talk about the batch creation procedure in the next section).

Consider an instant t at which some jobs are available. A node, say v, in the search tree represents instant t as well as available (or released) but unprocessed and unavailable (or unreleased) jobs at t. Let us denote released but unprocessed jobs by 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               and unreleased jobs by 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                 
                              . Left branch leads to a child node, say 
                                 
                                    
                                       
                                          v
                                       
                                       
                                          l
                                       
                                    
                                 
                              , by delaying the processing of jobs in 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               until the release of first job in 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                 
                              . Job 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          first
                                       
                                    
                                 
                               denoting the first job in 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          l
                                       
                                    
                                 
                               is characterized by an instant 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          l
                                       
                                    
                                 
                               such that 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          l
                                       
                                    
                                    ←
                                    
                                       
                                          r
                                       
                                       
                                          first
                                       
                                    
                                 
                               where 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          first
                                       
                                    
                                 
                               is the release date of job 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          first
                                       
                                    
                                 
                              , and sets 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                UA
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                A
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                 
                               such that 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                A
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    ←
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    ∪
                                 
                               job(s) j and 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                UA
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    ←
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                 
                               – job(s) j for 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          r
                                       
                                       
                                          first
                                       
                                    
                                 
                              . For instance, let 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          j
                                       
                                       
                                          1
                                       
                                    
                                    }
                                 
                               available at 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          1
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          j
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          j
                                       
                                       
                                          3
                                       
                                    
                                    }
                                 
                               available at 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          2
                                       
                                    
                                 
                               such that 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          1
                                       
                                    
                                    <
                                    
                                       
                                          t
                                       
                                       
                                          2
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          2
                                       
                                    
                                    =
                                    
                                       
                                          r
                                       
                                       
                                          3
                                       
                                    
                                    =
                                    
                                       
                                          t
                                       
                                       
                                          2
                                       
                                    
                                 
                              . Then, 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          l
                                       
                                    
                                    =
                                    
                                       
                                          t
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                A
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          j
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          j
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          j
                                       
                                       
                                          3
                                       
                                    
                                    }
                                 
                               and 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          
                                             
                                                UA
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    }
                                 
                              .

Regarding the right branch, a batch is created with jobs present in set 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                              . Let 
                                 
                                    
                                       
                                          jobs
                                       
                                       
                                          batch
                                       
                                    
                                 
                               represent the jobs put in the batch (we explain the batch creation procedure in Section 4.2.4). After right branching, i.e., after processing jobs 
                                 
                                    
                                       
                                          jobs
                                       
                                       
                                          batch
                                       
                                    
                                    ,
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               is updated as follows: 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    ←
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    -
                                    
                                       
                                          jobs
                                       
                                       
                                          batch
                                       
                                    
                                 
                              . For the processing starting time of the batch, batch ready time and the smallest machine idle time are taken into account. Instant 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          batch
                                       
                                    
                                 
                               representing the ready time of the batch and 
                                 
                                    
                                       
                                          disp
                                       
                                       
                                          min
                                       
                                    
                                 
                               the minimum machine idle time, the processing starting time of batch is 
                                 
                                    max
                                    (
                                    
                                       
                                          r
                                       
                                       
                                          batch
                                       
                                    
                                    ,
                                    
                                       
                                          disp
                                       
                                       
                                          min
                                       
                                    
                                    )
                                 
                              .

The idea of exploring new instants after right branching is based on finding the smallest instant 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          s
                                       
                                    
                                 
                               which will allow processing jobs. After right branching, if there are still unprocessed jobs in 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                              , then the next interesting instant is the smallest machine idle time, i.e., 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          s
                                       
                                    
                                    =
                                    
                                       
                                          disp
                                       
                                       
                                          min
                                       
                                    
                                 
                              . If, however, 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               becomes empty after right branching, then the next interesting instant is the maximum between the smallest machine idle time and the first job release date 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          first
                                       
                                    
                                 
                               in 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                 
                              , i.e., 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          s
                                       
                                    
                                    =
                                    max
                                    (
                                    
                                       
                                          disp
                                       
                                       
                                          min
                                       
                                    
                                    ,
                                    
                                       
                                          r
                                       
                                       
                                          first
                                       
                                    
                                    )
                                 
                              . Once 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          s
                                       
                                    
                                 
                               is determined, left and right branchings reoccur to explore new instants.

Let 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          r
                                       
                                    
                                 
                               be the next instant to be explored after right branching at t. 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               is updated by erasing jobs processed at t. Since new jobs may be released at instant 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          r
                                       
                                    
                                    ,
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                 
                               must contain these jobs. 
                                 
                                    
                                       
                                          jobs
                                       
                                       
                                          
                                             
                                                t
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                 
                               denoting the job(s) released earlier or at 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          r
                                       
                                    
                                 
                               but not processed by 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          r
                                       
                                    
                                 
                              , job lists are updated as follows: 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    ←
                                    
                                       
                                          Jobs
                                       
                                       
                                          A
                                       
                                    
                                    ∪
                                    
                                       
                                          jobs
                                       
                                       
                                          
                                             
                                                t
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                    ←
                                    
                                       
                                          Jobs
                                       
                                       
                                          UA
                                       
                                    
                                    -
                                    
                                       
                                          jobs
                                       
                                       
                                          
                                             
                                                t
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                 
                              .

A natural branching scheme would be depth first search by selecting always left branches first. However, this type of search may increase the solution time and space since the first right branching is done when all jobs are available, i.e., at the final node discovered by left branching. Instead, we develop a preprocessing method that calculates the lower bound value for each child node. More precisely, before any child node is visited, we calculate the value of lower bound for each child node reached by left and right branches. Then, child node having the smaller lower bound value is prioritized. In case lower bound values are equal, tie is broken by choosing the left branch.

We add cuts to improve the solution time of the algorithm. The first cut is done using the lower bound algorithm.
                              Proposition 1
                              
                                 If at any node, the lower bound value is greater than the best makespan value obtained so far, that node is pruned.
                              


                                 If a node represents an instant greater than 
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  
                                 (release date of the last job), then left branching is no longer necessary.
                              

Since 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  is the last job release date, there is no other job released after 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                 . Then, unprocessed jobs by 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  (or at an instant greater than 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                 ) can be processed without being delayed, i.e., without left branching. 
                                 
                                    
                                       □
                                    
                                 
                              


                                 Let t be an instant associated with node v at which some jobs are available for processing. If t is smaller than 
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  
                                 and if the next job release date is greater or equal to 
                                 
                                    
                                       t
                                       +
                                       p
                                    
                                 
                                 , then there is no left branching at v.
                              

Since the processing time of a batch is p, delaying the jobs available at t, until 
                                    
                                       t
                                       +
                                       p
                                    
                                  results in unnecessary waiting and hence, solely right branching at node v is sufficient. A batch is thus created with jobs available at v. 
                                 
                                    
                                       □
                                    
                                 
                              

We use a suboptimal procedure to create batches. The idea is to maximize the used batch capacity which reduces the batch creation step to a knapsack problem. Note that a similar approach is presented as an approximation algorithm in the bin-packing literature. While there are jobs to be put in a bin, the algorithm solves a knapsack problem until there is no job left. Gupta and Ho (1999) test this method on randomly generated instances and report that it performs much better than other heuristic methods in the bin packing literature. They also show that the algorithm guarantees the optimal solution if the sum of item sizes is at most equal to twice of bin capacity. Caprara and Pferschy (2004) show that the worst case performance ratio of the method is bounded by 4/3 +ln4/3 
                              
                                 ≈
                              
                            1.6210. A detailed performance analysis of this approach and other bin-packing algorithms can be found in Vanderbeck (1999).

Although there is a tight relation between our problem and bin packing problem, we should point out that minimizing number of batches does not guarantee the optimality of makespan for our problem. Consider the following example for which job sizes and release dates are given in Table 1
                           . Consider two machines with capacity B. Let p be the processing time and 
                              
                                 
                                    
                                       ∊
                                    
                                    
                                       j
                                    
                                 
                              
                            a number smaller than 
                              
                                 B
                                 /
                                 2
                              
                            
                           
                              
                                 ∀
                                 j
                              
                           .

If the objective is minimizing the number of batches, 3 full batches can be created and the processing of batches starts at 
                              
                                 4
                                 p
                              
                           . Makespan value is thus 
                              
                                 6
                                 p
                              
                           . However, it is easy to see that the optimal makespan is 
                              
                                 5
                                 p
                              
                            which can be achieved by creating 5 batches. Fig. 3
                            shows both solutions. Hence, the structure of our problem allows to have optimal makespan without minimizing the number of batches. However, maximizing the used batch capacity is a natural approach when a batch is created. We strengthen this approach by applying a dominance criterion proposed by Martello and Toth (1990).


                           Dominance criterion: (Martello & Toth, 1990) Let 
                              
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                              
                            be two feasible partitions of jobs such that 
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       
                                          
                                             f
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       
                                          
                                             f
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 ⩽
                                 Cap
                              
                           . 
                              
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                              
                            dominates 
                              
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                              
                            if the cardinality of 
                              
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                              
                            is smaller than the cardinality of 
                              
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                              
                           .

The dominance criterion above prioritizes big size jobs for batch creation. This way, if there are other big size jobs released later and if these jobs cannot be batched with earlier big size jobs, the idea of the dominance criterion is to leave smaller size jobs to later instants. For that purpose, a binary search procedure is used to create a single batch. If there are many batch configurations, binary search procedure chooses the one containing the least number of jobs. This procedure, named (
                              
                                 createBatch
                                 (
                                 .
                                 )
                              
                           ), is presented in the appendix.

We use a heuristic to find an upper value on makespan at the root node. This heuristic creates batches with consecutive jobs. If a job cannot be placed in a batch because of capacity limitations, batch is closed and assigned to the machine having the smallest idle time.

Consider the example given previously in Fig. 1. Fig. 4
                            shows the search tree for the example. Numbers in nodes represent the order of visiting nodes in the search tree. Lower bound values associated with each child node is represented next to branches. We explain below the solution procedure step by step.

The heuristic finds an upper bound value equal to 140. The initial lower bound is 100.


                              Node 1 (root node): Left branch represents delaying the processing of job 1 until the release of second job which provides a lower bound value smaller than processing job 1 immediately upon its release. Thus, left branching is prioritized.


                              Nodes 2, 3 and 4: Delaying the processing of jobs 1, 2 and 3 until the release of job 4 gives a lower bound value smaller than right branching at nodes 2 and 3. Thus, left child nodes are visited first. At node 4, all jobs are available. Right branching at node 4 represents the processing of jobs 1 and 2 in the same batch at instant 40. But the lower bound value of the child node is 160. This branch is thus pruned.


                              Backtracking at node 3: Left branch at node 3 processes jobs 1 and 2 in the same batch at instant 30. But with the remaining jobs, at least two other batches are created and thus the lower bound associated with that branch becomes 150. It is thus pruned.


                              Backtracking at node 2: Left branch at node 2 processes jobs 1 and 2 in the same batch at instant 20. Since the lower bound associated with the right child node is equal to 140, i.e. current best makespan value, right branch is pruned.


                              Backtracking at node 1 and right branching: Job 1 is processed on machine 1 at instant 10.


                              Node 5: Left branch has a lower bound value equal to that of right branch at node 5. Job 2, which is available at node 5, is thus delayed.


                              Node 6: Left and right branches has equal lower bound value. Tie is broken by choosing left branch.


                              Node 7: All unprocessed jobs are available at node 7. Job 1 has already been processed. Machine 1 is idle at 70 and machine two is idle at 0. Jobs 2 and 4 are put is the same batch and processed at instant 40 on machine 2.


                              Node 8: Finally, job 3 is processed on machine 1 which gives a makespan value equal to 130 (130 becomes the new best 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          max
                                       
                                    
                                 
                               value).


                              Backtracking at nodes 6 and 5: The lower bound values associated with the right branches of nodes 6 and 5 are greater or equal to 130. These branches are thus pruned.


                              Fig. 5
                               shows the Gantt Diagram corresponding to the optimal solution.

Pseudo-code of the algorithm is given in appendix.


                           Ikura and Gimple (1986) studied a special case of our problem where jobs have unit sizes and presented a polynomial time algorithm. It is straightforward to see that 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            guarantees the optimal solution if all jobs have the same size in a problem instance since batch creation becomes easy. We now present another special case that 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            can guarantee optimal solution. Suppose for any time interval of length of 
                              
                                 p
                                 /
                                 m
                              
                           , sum of job sizes is smaller or equal to machine capacity for jobs whose release dates are in that time interval. We first show that in this special case makespan value is equal to 
                              
                                 
                                    
                                       r
                                    
                                    
                                       n
                                    
                                 
                                 +
                                 p
                              
                            and then argue that 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            finds optimal solution.
                              Property 1
                              
                                 Suppose for any a time interval 
                                 
                                    
                                       [
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                       
                                       +
                                       p
                                       /
                                       m
                                       ]
                                    
                                  
                                 the sum of job sizes is smaller or equal to the machine capacity, i.e. 
                                 
                                    
                                       ∑
                                       
                                          
                                             w
                                          
                                          
                                             k
                                          
                                       
                                       ⩽
                                       B
                                    
                                  
                                 
                                    
                                       ∀
                                       k
                                    
                                  
                                 such that 
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             k
                                          
                                       
                                       ∈
                                       [
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                       
                                       +
                                       p
                                       /
                                       m
                                       ]
                                    
                                  
                                 
                                    
                                       ∀
                                       j
                                    
                                 
                                 . Then, the optimum makespan value is equal to 
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       +
                                       p
                                    
                                  
                                 where 
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  
                                 is the last job release date.
                              

Let K be an integer such that 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ∈
                                       [
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       K
                                       ∗
                                       p
                                       /
                                       m
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       1
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                       ]
                                    
                                 . Then, we have K intervals of length 
                                    
                                       p
                                       /
                                       m
                                    
                                  which allows us to create K batches. Considering the first batch is processed at instant 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       1
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                    
                                 , a second batch can be created and processed at 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       2
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                    
                                  on machine 2. Then, the second batch on machine 1 is created with jobs whose release dates are in 
                                    
                                       [
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       m
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       (
                                       m
                                       +
                                       1
                                       )
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                       ]
                                    
                                  and processed at most at instant 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       (
                                       m
                                       +
                                       1
                                       )
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                    
                                 . Observe that 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       (
                                       m
                                       +
                                       1
                                       )
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                    
                                  is equal to the processing ending time of the first batch on machine 1, i.e. 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       (
                                       K
                                       -
                                       1
                                       )
                                       ∗
                                       p
                                       /
                                       m
                                       +
                                       p
                                    
                                 . Similarly, jobs having release dates in the interval 
                                    
                                       [
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       -
                                       p
                                       /
                                       m
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       ]
                                    
                                  are processed at 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                    
                                  which concludes the proof. 
                                 
                                    
                                       □
                                    
                                 
                              

In this special case, since 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            explores instants at which only a single batch can be created, batch creation is no longer a difficult task and thus 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            gives the optimal makespan thanks to exploring every possible instant in the problem.

In this section, we test two types of problem instances which are inspired from the hospital sterilization context. Algorithms are coded in Java and implemented on an Intel Core i5 2.50GHz machine. Solution time limit is set to one hour. We use the genetic algorithm of Wang and Chou (2010) noted 
                        
                           
                              
                                 GA
                              
                              
                                 Lit
                              
                           
                        
                     , approximation algorithm of Li (2012) noted 
                        
                           
                              
                                 AA
                              
                              
                                 Lit
                              
                           
                        
                      and the MILP model of Ozturk et al. (2012) noted 
                        
                           
                              
                                 MILP
                              
                              
                                 Lit
                              
                           
                        
                      for benchmarking.


                     
                        
                           
                              
                                 MILP
                              
                              
                                 Lit
                              
                           
                        
                      can guarantee the optimal solution once a problem instance is completely solved. 
                        
                           
                              
                                 GA
                              
                              
                                 Lit
                              
                           
                        
                      is a powerful meta-heuristic which provides slightly better results in terms of solution quality and solution time compared to other meta-heuristics from the literature. Briefly, 
                        
                           
                              
                                 GA
                              
                              
                                 Lit
                              
                           
                        
                      generates chromosomes at each iteration by randomization and immigration, and then performs a two point crossover between chromosomes chosen with the roulette wheel technique. 
                        
                           
                              
                                 AA
                              
                              
                                 Lit
                              
                           
                        
                      solves the problem initially by allowing jobs to be split. Split jobs are scheduled by being assigned individually to a batch following the last batch in the lower bound solution. To the best of our knowledge, the performance of approximation algorithms in the batch scheduling literature, including the one proposed by Li (2012), have not been tested on numerical instances. It would be thus interesting to observe how 
                        
                           
                              
                                 AA
                              
                              
                                 Lit
                              
                           
                        
                      performs on our instances. For all these reasons, we choose these three methods for benchmarking.

Before proceeding with the testing of instances inspired from the sterilization context, we tested 
                        
                           B
                           &
                           
                              
                                 B
                              
                              
                                 H
                              
                           
                        
                      on many small instances which can be solved quickly by 
                        
                           
                              
                                 MILP
                              
                              
                                 Lit
                              
                           
                        
                     . This way, we compared makespan values found by 
                        
                           B
                           &
                           
                              
                                 B
                              
                              
                                 H
                              
                           
                        
                      to optimal solutions given by 
                        
                           
                              
                                 MILP
                              
                              
                                 Lit
                              
                           
                        
                     . For that purpose, we generated 20,000 test instances containing 6 to 10 jobs in the presence of 1 to 4 machines (1000 problem instances are generated for each combination of number of jobs and number of machines). Job sizes are generated from a discrete uniform distribution: U[1, 120]. 
                        
                           p
                           =
                           60
                        
                      minutes being the job processing time, 
                        
                           
                              
                                 r
                              
                              
                                 1
                              
                           
                           =
                           0
                        
                      being the first job release date in any instance, job release dates are generated using the following formula: 
                        
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                           =
                           
                              
                                 r
                              
                              
                                 j
                                 -
                                 1
                              
                           
                           +
                           U
                           [
                           0
                           ,
                           30
                           ]
                        
                      
                     
                        
                           ∀
                           j
                           =
                           2
                           ,
                           …
                           ,
                           n
                        
                     . Among 20,000 instances, only 34 of them could not be solved optimally by 
                        
                           B
                           &
                           
                              
                                 B
                              
                              
                                 H
                              
                           
                        
                     . This observation encouraged us about the solution quality of 
                        
                           B
                           &
                           
                              
                                 B
                              
                              
                                 H
                              
                           
                        
                     . Thus we proceeded with a detailed analysis of 
                        
                           B
                           &
                           
                              
                                 B
                              
                              
                                 H
                              
                           
                        
                      by testing real life instances.

In some hospitals, RMD sets are sent to the sterilization service just after the end of a surgery. Thus, RMD arrivals can happen at any time within a day. An example of this kind of organization can be found at the sterilization service of the ambulatory surgery department of University Hospital Gasthuisberg in Leuven, Belgium.

Supposing there are surgeries at operating blocks during 8 to 10hour per day, job release dates are created according to the uniform distribution U[0, 600] (unit in minutes). The size of automatic washers can be between 6 and 12din. (Din is a measurement unit for the volume of automatic washers which is about 0.003m3.) Fixing the machine capacity to 12din, we create job sizes according to a continuous uniform distribution such that 
                           
                              
                                 
                                    w
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    U
                                 
                                 
                                    c
                                 
                              
                              [
                              0
                              ,
                              12
                              ]
                           
                         since any RMD set size smaller than machine capacity is possible. A washing cycle is 60minutes. The number of machines is varied from 1 to 4. For each combination of number of jobs and number of machines, 20 problem instances are generated and solved through this section.

Medium size instances contain 10 to 40 jobs. For all instances tested in Table 2
                           , 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            is able to give the best solution each time except for one. Let us detail our analysis by providing more insights about the quality of solution provided by 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            and other methods. In Table 2, column 
                              
                                 #
                                 NB
                              
                            (not best) indicates the number of times a method does not provide the best solution. Avg. gap shows the average of gap for instances whose makespan value is not equal to the best one. The formula used for Avg. gap is the following: (
                              
                                 
                                    
                                       Solution
                                    
                                    
                                       method
                                    
                                 
                                 -
                                 best
                              
                            
                           solution)/best solution.

For instances containing more than 10 jobs, MILP cannot find the optimal solution within one hour. Nevertheless, it can provide the best solution for all instances containing 10, 20 and 30 jobs (The optimality gap reported by CPLEX is around 
                              
                                 10
                                 %
                              
                            for instances with 30 jobs at the end of one hour). Starting from 40 job instances, performance of 
                              
                                 
                                    
                                       MILP
                                    
                                    
                                       Lit
                                    
                                 
                              
                            decreases. Regarding 
                              
                                 
                                    
                                       GA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       AA
                                    
                                    
                                       Lit
                                    
                                 
                              
                           , their performances increase with the increasing number of machines since it becomes easier to find an idle machine for the processing of a batch. In the presence of one and two machines, solution quality of these heuristics are not satisfactory. However, their solution times are faster. 
                              
                                 
                                    
                                       AA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            can find a solution within some milliseconds. The maximum solution time with 
                              
                                 
                                    
                                       GA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            is 10 s. A detailed presentation of average solution times for all irregular type instances is given in Table 5.


                           
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            can quickly find a solution for instances containing up to 40 jobs in the presence of a single machine. The branching scheme and quality of upper and lower bound algorithms play an important role for the solution time. Table 3
                            shows the quality of the lower bound algorithm and the initialization heuristic as well as the number of nodes created by 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            and the average solution times in seconds. Columns 4 and 5 show the average and maximum gaps between lower bound and 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            which is calculated as 
                              
                                 (
                                 
                                    
                                       Solution
                                    
                                    
                                       B
                                       &
                                       
                                          
                                             B
                                          
                                          
                                             H
                                          
                                       
                                    
                                 
                                 -
                                 
                                    
                                       Solution
                                    
                                    
                                       LB
                                    
                                 
                                 /
                                 
                                    
                                       Solution
                                    
                                    
                                       LB
                                    
                                 
                                 )
                              
                           . Gap between initialization heuristic and 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            is reported in the same way in columns 6 and 7.

Solution time with 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            increases when the number of machines increases. In the presence of 3 or 4 machines and 40 jobs, no instance is completely solved within one hour. This is mainly because same instants are visited more than once in the branch and bound tree in the presence of parallel machines. For instance, if two batches can be created with jobs available at an instant and if there are two machines idle at the same time, algorithm processes the first batch on machine one and the second batch on machine two. If, moreover, new jobs are released after batch processing, left branching occurs more than once for the same job(s). Hence the number of nodes in the search tree increases.

We see that the lower bound algorithm performs quite well. The average lower bound value is around 
                              
                                 5
                                 %
                              
                            which is close to the optimal/best 
                              
                                 
                                    
                                       C
                                    
                                    
                                       max
                                    
                                 
                              
                            value. Regarding the quality of the initialization heuristic, we observe that the difference between the final value given by 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            and the upper bound value is around 
                              
                                 15
                                 %
                              
                            which leaves room for improvement. For that purpose, we used the optimal/best makespan value as the initialization value and tested some of the same problem instances. We observed that there is almost no improvement in the solution time. Then, for the same instances, we forced the initial makespan value to be equal to a very big number. We observed that the average solution time increased by an average of 
                              
                                 1
                                 %
                              
                           . We can thus conclude that the performance of the initialization heuristic is good for decreasing the solution time.

We enlarge the test instances and go beyond 40 jobs to test the behavior of 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            on larger instances. Table 4
                            shows test results for 50, 75 and 100 jobs. Solution methods are stopped at the end of one hour since neither 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            nor 
                              
                                 
                                    
                                       MILP
                                    
                                    
                                       Lit
                                    
                                 
                              
                            can terminate within the time limit as also shown in Table 5
                           .


                           
                              
                                 Δ
                                 LB
                              
                            shows the average difference between the best solution and the lower bound solution. There is a slight decrease in the performance of the lower bound algorithm. This is due to the increase in the number of jobs while release dates are within the same interval. There is a slight decrease in the performances of 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       GA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            in the presence of a single machine. When the number of machines increases, especially for the case 4 machines, 
                              
                                 
                                    
                                       GA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            performs better than 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            both for solution time and quality of makespan since the size of the branch and bound tree increases exponentially and more computational time is required to improve the solution quality. Performance of 
                              
                                 
                                    
                                       AA
                                    
                                    
                                       Lit
                                    
                                 
                              
                            also decreases in these big instances due to the increasing difference between the lower bound and optimal makespan values.

These test instances are inspired from the sterilization service of Grenoble University Hospital. RMD sets are sent to the sterilization service twice a day: early in the morning and in the afternoon. RMD sets arriving in the morning are those used the day before. Ones sent in the afternoon are those used in surgeries in the morning. We impose two different release dates for job arrivals: 0 and 
                           
                              
                                 
                                    r
                                 
                                 
                                    max
                                 
                              
                              /
                              2
                           
                         where 
                           
                              
                                 
                                    r
                                 
                                 
                                    max
                                 
                              
                           
                         stands for the closing time of the service. Considering the sterilization service is open 10h per day, 
                           
                              
                                 
                                    r
                                 
                                 
                                    max
                                 
                              
                              =
                              600
                           
                        . We assume that half of the jobs are released at instant 0 and half of them at 
                           
                              
                                 
                                    r
                                 
                                 
                                    max
                                 
                              
                              /
                              2
                           
                        .


                        Tables 6 and 7
                        
                         summarize the test results for quality of makespan and solution time, respectively. There is a considerable decrease in the solution time of 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                         due to having only two different release dates. Left branching is done a few times and thus number of nodes also decreases. Regarding the quality of the lower bound algorithm, we observe that it gives similar results compared to those in irregular arrivals in the presence of medium size jobs. This observation is consistent since lower bound algorithm takes into account only job sizes.

Although 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                         and 
                           
                              
                                 
                                    GA
                                 
                                 
                                    Lit
                                 
                              
                           
                         are able to find the best solution most of the time, there is an increase in the average gap for all methods. This is because of arrival of jobs in big quantities. When many jobs are simultaneously released, our problem becomes more like a bin-packing problem and hence even a small increase in the number of batches yields a bigger gap for 
                           
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                           
                        . We observed that our method has at most two more batches compared to the number of batches in the solution giving the best makespan value unless provided by 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                        . This observation is in line with the bin packing results given in Vanderbeck (1999). Regarding 
                           
                              
                                 
                                    MILP
                                 
                                 
                                    Lit
                                 
                              
                           
                        , it gives the best solution for instances containing less or equal to 30 jobs. However, it requires too much computation. While 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                         finds a solution within some seconds, the optimality gap is more than 
                           
                              50
                              %
                           
                         with 
                           
                              
                                 
                                    MILP
                                 
                                 
                                    Lit
                                 
                              
                           
                         at the end of 300seconds for the case of a single machine.

As in the case of irregular arrivals, the performance of the lower bound algorithm decreases when the number of jobs increases. However, this situation has almost no impact on the solution time with 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                         since the size of the search tree is small due to having two different job release dates. While 
                           
                              
                                 
                                    MILP
                                 
                                 
                                    Lit
                                 
                              
                           
                         is not able to provide a better makespan value for instances containing more than 40 or 50 jobs depending on the number of machines, our method is able to compete with 
                           
                              
                                 
                                    GA
                                 
                                 
                                    Lit
                                 
                              
                           
                         in the presence of a few machines. When the number of machines increases, 
                           
                              B
                              &
                              
                                 
                                    B
                                 
                                 
                                    H
                                 
                              
                           
                         performs better than other methods. Regarding solution times of other methods, 
                           
                              
                                 
                                    AA
                                 
                                 
                                    Lit
                                 
                              
                           
                         is very fast and it can find a solution within some miliseconds. 
                           
                              
                                 
                                    GA
                                 
                                 
                                    Lit
                                 
                              
                           
                         on the other hand has an increase in its solution time. It can provide a solution in less than one minute for big size instances.

@&#CONCLUSIONS@&#

In this paper, we studied a parallel batch scheduling problem whose origin is hospital sterilization services. Jobs have different sizes, different release dates and equal processing times. Our objective is to minimize the makespan on parallel identical machines. MILP models in the literature require long computation time for real size instances. Heuristic methods are faster but do not guarantee the optimality for makespan. We presented a branch and bound based heuristic method which can solve instances containing up to 40 jobs within very short time. We tested this method on real life instances and compared the solution quality to other methods from the literature. Numerical results show that our method can provide high quality makespan values in reasonable computational time.

Many extensions of our problem can be considered for future work. Considering there is imperfect knowledge about job arrivals at the sterilization service, uncertain job release dates may be considered. Some dynamic stochastic approaches (e.g., rolling horizon method) can be applied to this new case instead of deterministic methods. Moreover, some other objective functions (e.g., 
                        
                           ∑
                           
                              
                                 C
                              
                              
                                 j
                              
                           
                        
                     ) can be studied.


                     Table A.8
                     
                     
                        Algorithm 1
                        Lower Bound algorithm: LB 
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                     Tables B.9 and B.10
                     
                     
                     
                        Algorithm 2
                        Branch and Bound Heuristic: 
                              
                                 B
                                 &
                                 
                                    
                                       B
                                    
                                    
                                       H
                                    
                                 
                              
                            
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 
                                    
                                       preprocessing
                                    
                                    
                                       leftBranch
                                    
                                 
                                 (
                                 )
                              
                            
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             Input:
                                             
                                                
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         UA
                                                      
                                                   
                                                   ,
                                                   dispM
                                                   ,
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         
                                                            
                                                               A
                                                            
                                                            
                                                               L
                                                            
                                                         
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         
                                                            
                                                               UA
                                                            
                                                            
                                                               L
                                                            
                                                         
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         dispM
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                
                                             ;
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ←
                                                
                                             release date of first job in 
                                                
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         UA
                                                      
                                                   
                                                
                                             ;
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         
                                                            
                                                               A
                                                            
                                                            
                                                               L
                                                            
                                                         
                                                      
                                                   
                                                   ←
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                   ∪
                                                
                                              job(s) j in 
                                                
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         UA
                                                      
                                                   
                                                
                                              such that 
                                                
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ⩽
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                
                                             ;
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         
                                                            
                                                               UA
                                                            
                                                            
                                                               L
                                                            
                                                         
                                                      
                                                   
                                                   ←
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         UA
                                                      
                                                   
                                                   -
                                                
                                             job(s) j in 
                                                
                                                   
                                                      
                                                         jobList
                                                      
                                                      
                                                         UA
                                                      
                                                   
                                                
                                              such that 
                                                
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ⩽
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                
                                             ;
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         dispM
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ←
                                                   dispM
                                                
                                             ;
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 
                                    
                                       preprocessing
                                    
                                    
                                       rightBranch
                                    
                                 
                                 (
                                 )
                              
                            
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 createBatch
                                 (
                                 )
                              
                            
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

@&#REFERENCES@&#

