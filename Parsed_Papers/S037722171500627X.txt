@&#MAIN-TITLE@&#The multi-vehicle traveling purchaser problem with pairwise incompatibility constraints and unitary demands: A branch-and-price approach

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We study the unitary demand case of the multi-vehicle TPP with incompatibilities among products.


                        
                        
                           
                           We propose a new set-covering formulation and a branch-and-price approach.


                        
                        
                           
                           We present a hybrid procedure combining two exact methods for solving the pricing problem.


                        
                        
                           
                           Our method outperforms an existing branch-and-cut both in solution quality and CPU time.


                        
                        
                           
                           Our method shows good performance even when the number of vehicles and PICs grows.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Traveling purchaser problem

Multi-vehicle

Pairwise incompatibility constraints

Column generation

Branch-and-price

@&#ABSTRACT@&#


               
               
                  In this work, we study a supplier selection and routing problem where a fleet of homogeneous vehicles with a predefined capacity is available for procuring different products from different suppliers with the aim to satisfy demand at the minimum traveling and purchasing cost. Decisions are further complicated by the presence of pairwise incompatibility constraints among products, implying the impossibility of loading two incompatible products on the same vehicle. The problem is known as the Multi-Vehicle Traveling Purchaser Problem with Pairwise Incompatibility Constraints. We study the special case in which the demand for each product is unitary and propose a column generation approach based on a Dantzig–Wolfe reformulation of the problem, where each column represents a feasible vehicle route associated with a compatible purchasing plan. To solve the pricing problem we propose a hybrid strategy exploiting the advantages of two alternative exact methods, a labeling algorithm solving a Resource-Constrained Elementary Shortest Path Problem on an expanded graph, and a tailored branch-and-cut algorithm. Due to the integrality request on variables, we embed the column generation in a branch-and-bound framework and propose different branching rules. Extensive tests, carried out on a large set of instances, show that our branch-and-price method performs well, improving on average, both in quality and in computational time, solutions obtained by a state-of-art branch-and-cut approach applied to a three-index connectivity constraints based formulation.
               
            

@&#INTRODUCTION@&#

The Traveling Purchaser Problem (TPP) is a single-vehicle routing problem that has been widely studied in the last decades. Consider a depot 0, a set M of suppliers (dispersed over a geographical area around the depot), and a set K of products to purchase. A discrete demand dk
                     , associated with each product k ∈ K, is specified. Product k is available for a quantity qik
                      at supplier i, i ∈ Mk
                      ⊆ M, and can be bought at a non-negative price pik
                     , potentially different for each supplier i ∈ Mk
                     . Quantity globally offered for product k is such that 
                        
                           
                              ∑
                              
                                 i
                                 ∈
                                 
                                    M
                                    k
                                 
                              
                           
                           
                              q
                              
                                 i
                                 k
                              
                           
                           ≥
                           
                              d
                              k
                           
                        
                     . Let G ≔ (V, A) be a complete directed graph where V ≔ {0} ∪  M is the node set and A ≔ {(i, j): i ∈ V, j ∈ V, i ≠ j} is the arc set. A traveling cost cij
                      is associated with each arc (i, j) ∈ A. The TPP looks for a cycle in G starting and ending to the depot, and visiting a subset of suppliers so to exactly satisfy products demand, while minimizing both traveling and purchasing costs. When demand and quantities offered are positive integer such that qik
                      ≤ dk, k ∈ K and i ∈ Mk
                      with some strict inequalities, the problem is known as restricted TPP. The unrestricted TPP is instead an interesting special case where supplies are unlimited, qik
                      ≥ dk, k ∈ K, i ∈ Mk
                     , that is equivalent to consider 
                        
                           
                              d
                              k
                           
                           =
                           1
                           ,
                        
                      
                     k ∈ K, and 
                        
                           
                              q
                              
                                 i
                                 k
                              
                           
                           =
                           1
                           ,
                        
                      
                     k ∈ K, i ∈ Mk
                     . The combined optimization of routing decisions, suppliers selection and purchasing plan construction, makes the TPP a very challenging problem, that fits well in several real-life procurement settings and in other contexts like job scheduling. Hence, a lot of exact and heuristic approaches have been developed by researchers for the TPP and its several deterministic and stochastic variants (see, e.g., Laporte, Riera-Ledesma, & Salazar-González, 2003; Mansini & Tocchella, 2009; Voss, 1996, and more recently Angelelli, Mansini, & Vindigni, in press; Beraldi, Bruni, Manerba, & Mansini, in press).

Recently, a multi-vehicle variant of the Travelling Purchaser Problem (MVTPP) has been introduced by Choi and Lee (2011) as a formulation for maximizing the reliability of components in a purchasing system with budget constraints. In the MVTPP, optimization has to be done over a fleet F of homogeneous vehicles, ensuring that the quantity collected by each vehicle does not exceed a predefined capacity Q. Only few contributes can be found in the literature for this problem. Riera-Ledesma and Salazar-González (2012) study the MVTPP as a location routing problem in the context of school bus service, where suppliers correspond to bus stops and products to students to pick up. They present a branch-and-cut approach based on a single-commodity flow formulation enhanced by valid inequalities. The same authors propose a column generation approach for the problem (Riera-Ledesma & Salazar-González, 2013) taking into account different resource constraints for each route such as upper bounds on the distances traveled by the students, upper bounds on the number of visited bus stop and lower bounds on the number of students to pick up. Finally, Bianchessi, Mansini, and Speranza (2014) study the distance-constrained MVTPP ensuring that the distance traveled by each vehicle does not exceed a predefined upper bound.
                  

Very recently, Manerba and Mansini (2015) introduce a generalization of the MVTPP further complicated by the presence of pairwise incompatibilities among products imposing the impossibility of loading two incompatible products on the same vehicle. The problem, called Multi-Vehicle Traveling Purchaser Problem with Pairwise Incompatibility Constraints (MVTPP-PIC), aims at determining a tour for each vehicle f ∈ F visiting a subset of suppliers so that the total product demands are satisfied at minimum purchasing and traveling cost, while guaranteeing all existing incompatibility restrictions among products and without exceeding vehicle capacity Q. The authors propose a branch-and-cut method based on the separation of several families of valid inequalities and a matheuristic providing a good initial solution for the exact approach.

Vehicle routing problems explicitly taking into account incompatibility constraints have been seldom studied in the literature, whereas similar restrictions, sometimes called exclusionary side constraints, have been introduced in several combinatorial optimization problems (see Sun, 2002 and Goossens & Spieksma, 2009 for the application of such constraints to the Transportation Problem, and Gendreau, Laporte, & Semet, 2004 for the Bin Packing Problem).

In vehicle routing specialized literature, the incompatibility issue is frequently tackled through the use of heterogeneous dedicated vehicles or through the introduction of separation devices on the vehicles. The latter situation, known as Multi-Compartment Vehicle Routing Problem, is surveyed in Iori and Martello (2010). To the best of our knowledge, the present paper and Manerba and Mansini (2015) are the only existing contributions directly applying incompatibility constraints to a vehicle routing problem.

In particular, we study the unitary-demand MVTPP-PIC assuming 
                        
                           
                              d
                              k
                           
                           =
                           1
                           ,
                        
                      
                     k ∈ K. Since the problem does not allow to purchase more than the required products demand, the availability of a product is also assumed to be unitary in each supplier that sells it, i.e. 
                        
                           
                              q
                              
                                 i
                                 k
                              
                           
                           =
                           1
                           ,
                        
                      
                     k ∈ K, i ∈ Mk
                     . In this case, the vehicle capacity Q can be seen as a cardinality constraint limiting the total number of compatible products (good types) that can be loaded on a vehicle. The incompatibility issues are modeled by defining the set B ≔ {(k, g): k, g ∈ K} of product pairs that cannot be transported simultaneously on the same vehicle. A product is said to be incompatible if it appears in at least one pair of the set B. On the contrary, a product is said to be free when it is compatible with all the other products and can be loaded freely on any vehicle. Finally, a product is said to be totally incompatible if it is in conflict with the entire set of incompatible products. Each totally incompatible product can be transported only with free products.

As for the general case, the unitary-demand MVTPP-PIC allows multiple visit to the same supplier by different vehicles. This feature identifies the so-called Split-Delivery vehicle routing problems (SDVRP). However, while in SDVRP the split of deliveries is motivated by traveling costs saving, in the MVTPP-PIC multiple visit to a supplier may be forced by the incompatibilities among products and thus may cause a traveling cost increase. Example 1 shows the optimal solution of the MVTPP-PIC in two instances differing only for the set of incompatibilities. In the first case a multiple visit results to be convenient, as for classical split-delivery problems, whereas in the second case, as induced by the incompatibility constraints, causes a traveling cost increase. For sake of simplicity, we exclude purchasing costs by assuming that each product is offered by only one supplier so that all suppliers have to be visited.

                        Example 1
                        Let us consider a fleet of homogeneous vehicles with capacity 
                              
                                 Q
                                 =
                                 3
                                 ,
                              
                            6 products {a, b, c, d, e, f} with unitary demand, and 4 suppliers {1, 2, 3, 4} each offering a subset of the products as shown in the square brackets of Fig. 1(a). The same figure also shows the graph’s topology and the traveling costs associated with each pair of nodes. In Fig. 1(b) and (c) are plotted the visiting tours of the vehicles in the MVTPP-PIC optimal solution when the set B of incompatibilities is {(a, c), (b, c), (c, d)} and {(a, c), (b, c), (c, d), (c, f)}, respectively.

In the first case, the multiple visit of supplier 2 is convenient. In fact, if multiple visit were not allowed, one more vehicle would be necessary to satisfy the demand and the total cost would rise to 13. In the second case, visiting supplier 4 at least twice becomes compulsory because of the incompatibility between products c and f (no feasible solution would exists if multiple visit were not allowed), thus impacting negatively on the cost.

As far as the procurement/distribution logistics context is concerned, incompatibility restrictions can be found in several real-life problems involving the loading of several vehicles. For example, in general markets procurement, foods and chemical products should be transported separately, and again in industry distribution, hazardous materials/liquids might dangerously react if loaded together on the same vehicle (see, e.g., Christofides, Mingozzi, & Toth, 1979). However, the MVTPP-PIC, especially in its unitary demand version, finds application in several real contexts different from the procurement one we use to define it.

A first application is represented by the natural extension of the school-bus location and routing problem presented in Riera-Ledesma and Salazar-González (2012; 2013), where the decision maker may include additional restrictions on the type of persons who can be transported on the same vehicle. For instance, students from primary school or kindergarten should not be transported on the same bus with high school students. Again, in a more general bus routing context, it may be desirable that students, frequently too noisy, do not share the same bus with common citizens especially older people, and so on.

Another important application raises in the health-care domain, and in particular in the daily scheduling of operating rooms. In this problem a set K of surgeries have to be done taking into account that a set M of medical teams are available to accomplish them. A given surgery k ∈ K can be accomplished by different medical teams i, i ∈ Mk
                         ⊆ M, requiring a possibly different operating time pik
                         depending on the experience and on the composition of the team. A set F of identical operating rooms is available, and no more than Q surgeries can be operated per day in each operating room. If in the same operating room two different teams i, j ∈ M are going to operate in sequence a set-up time cij
                         for specific tools and equipment preparation is required. Cleaning a room after a surgery usually requires a constant time and is considered irrelevant in terms of optimization. There are however some types of surgery where the risk of reciprocal contamination is extremely high and the time for cleaning the room between them is prohibitive, so that they are considered incompatible in the same room (e.g., a throat surgery cannot be done in the same operating room of a stomach surgery). The objective is to minimize the total time to accomplish the required surgeries.

Finally, reconsidering the original interpretation of the TPP in the job scheduling context (see Burstall, 1966), the MVTPP-PIC can be seen as the problem to minimize set-up and completion times in a multiprocessor system with incompatible jobs (two incompatible jobs cannot be processed by the same machine).

We have already highlighted that both the multi-vehicle optimization and the incompatibility constraints applied to the TPP are very recent streams of research. Moreover, while in general the use of more than one vehicle highly increases the complexity of a routing problem, in this case the problem complexity strongly depends also on the number of products taken into account and on the number of incompatibilities existing among them. Hence, the novelty and the challenging aspects of the MVTPP-PIC make the problem worthy of being further analyzed.

The aim of the present work is to develop and test a branch-and-price approach for the unitary-demand MVTPP-PIC. This approach embeds a non-trivial adaptation of state-of-art column generation techniques (stabilization, exact and approximated solution of the subproblem, and so on) as well as branching strategies and restricted master heuristics. The algorithm relies on a new set-covering formulation that exploits the separability of the problem over the vehicles thus overcoming the presence of symmetry in the solutions (which is one of the main computational drawback encountered when solving multi-vehicle problems). This is especially important in the MVTPP-PIC, where the introduction of incompatibilities among products highly impacts on the number of vehicles required, which is usually quite large. In particular, we propose a master problem where each column represents a feasible vehicle route associated with a compatible purchasing plan, whereas the pricing problem comes out to be a TPP variant where no specific demand is considered and the presence of possibly negative purchasing costs forces the buying of products.

The most recent branch-and-price approaches for vehicle routing problems use a Resource-Constrained Elementary Shortest Path Problem as column generation subproblem, solved by a label setting algorithm. Unfortunately, the adaptation of this method is not straightforward when products to buy are variables instead of predefined quantities and labels have to manage both routing and purchasing decisions, as in our case. To solve the pricing problem we propose an innovative hybrid strategy combining two different exact methods, i.e. a labeling algorithm over an auxiliary graph (connecting, through properly weighted arcs, all possible pairs of products and suppliers), and a tailored branch-and-cut directly applied to the mathematical formulation of the pricing problem. This hybrid approach represents an important contribution of the present work. In particular, we show that there is no clear dominance of one method over the other, but that the two approaches present different and complementing features, which are effectively combinable. The strategy is general and can be easily used also in other contexts.

Computational results on a large set of instances demonstrate how the new branch-and-price approach can efficiently optimize instances over a very large fleet of vehicles and with a high density of incompatibility among products. To provide a comparison to our approach, we customized the branch-and-cut algorithm proposed in Manerba and Mansini (2015) to the MVTPP-PIC with unitary demand. Since the method makes uses of a three-index mathematical formulation that naturally incorporates symmetry issues, we also implement symmetry breaking constraints. Our new approach outperforms the existing branch-and-cut algorithm both in terms of quality of the solutions determined within a time limit, and number of optimal solutions found.

The rest of the paper is structured as follows. In Section 2, we first present a mixed integer linear programming formulation of the problem based on connectivity constraints to exclude subtours, then we propose and analyze a set covering based reformulation obtained through a Dantzig–Wolfe decomposition technique. Section 3 is devoted to the description of the proposed branch-and-price approach. We present a simple initial heuristic, the column generation procedure along with the two exact algorithms used for solving the pricing problem (i.e., a labeling algorithm on an expanded graph and a tailored branch-and-cut approach), and the branching rules to ensure integrality of the final solutions. The computational results are discussed in Section 4, along with the presentation of the instances used. Finally, some conclusions are sketched in Section 5.

In this section, we first propose a three-index connectivity constraints based formulation for the problem, then a set covering formulation based on a Dantzig–Wolfe decomposition.

Let 
                           
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 f
                              
                              ,
                           
                         for each arc (i, j) ∈ A and for each vehicle f ∈ F, be a binary variable taking value 1 if arc (i, j) is crossed by vehicle f, and 0 otherwise. Let 
                           
                              
                                 y
                                 i
                                 f
                              
                              ,
                           
                         for each supplier i ∈ M and for each vehicle f ∈ F, be a binary variable taking value 1 if the corresponding node i is visited by vehicle f, and 0 otherwise. Let 
                           
                              
                                 w
                                 k
                                 f
                              
                              ,
                           
                         for each product k ∈ K and for each vehicle f ∈ F, be a binary variable taking value 1 if product k is loaded on vehicle f, and 0 otherwise. Finally, let 
                           
                              z
                              
                                 i
                                 k
                              
                              f
                           
                         be a binary variable equal to 1 if product k, k ∈ K, is purchased by supplier i, i ∈ Mk
                        , and loaded on vehicle f, f ∈ F, and 0 otherwise. Moreover, given a set S ⊂ V, let 
                           
                              
                                 δ
                                 +
                              
                              
                                 (
                                 S
                                 )
                              
                           
                         denote the set of arcs (i, j) with i ∈ S and j ∈ V∖S, and 
                           
                              
                                 δ
                                 −
                              
                              
                                 (
                                 S
                                 )
                              
                           
                         denote the set of arcs (i, j) with j ∈ S and i ∈ V∖S. The unitary-demand MVTPP-PIC can be formulated as follows:

                           
                              (1)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          f
                                          ∈
                                          F
                                       
                                    
                                    
                                       ∑
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ∈
                                          A
                                       
                                    
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       f
                                    
                                    +
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          f
                                          ∈
                                          F
                                       
                                    
                                    
                                       p
                                       
                                          i
                                          k
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                 
                              
                           
                        subject to

                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          f
                                          ∈
                                          F
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                    =
                                    1
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             
                                                {
                                                h
                                                }
                                             
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       f
                                    
                                    =
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             −
                                          
                                          
                                             (
                                             
                                                {
                                                h
                                                }
                                             
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       f
                                    
                                    =
                                    
                                       y
                                       h
                                       f
                                    
                                    
                                    h
                                    ∈
                                    M
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       f
                                    
                                    ≥
                                    
                                       y
                                       h
                                       f
                                    
                                    
                                    S
                                    ⊆
                                    M
                                    ,
                                    h
                                    ∈
                                    S
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                    ≤
                                    Q
                                    
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                    ≤
                                    
                                       y
                                       i
                                       f
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    
                                       M
                                       k
                                    
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       w
                                       
                                          k
                                       
                                       f
                                    
                                    +
                                    
                                       w
                                       
                                          g
                                       
                                       f
                                    
                                    ≤
                                    1
                                    
                                    
                                       (
                                       k
                                       ,
                                       g
                                       )
                                    
                                    ∈
                                    B
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                    =
                                    
                                       w
                                       
                                          k
                                       
                                       f
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       f
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    ∈
                                    A
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       y
                                       i
                                       f
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    i
                                    ∈
                                    M
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       w
                                       k
                                       f
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    f
                                    ∈
                                    F
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                       f
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    
                                       M
                                       k
                                    
                                    ,
                                    f
                                    ∈
                                    F
                                    .
                                 
                              
                           
                        
                     

Objective function (1) establishes the minimization of traveling and purchasing costs. Constraints (2) ensure that each product demand must be satisfied. In constraints (3) we impose that if vehicle f visits a supplier h (i.e. 
                           
                              
                                 y
                                 h
                                 f
                              
                              
                                 =
                                 1
                                 )
                                 ,
                              
                           
                         it also has to leave it, while connectivity inequalities (4) allow to eliminate subtours. Inequalities (5) impose a cardinality constraint on the number of products that can be loaded on each vehicle. Constraints (6) avoid a vehicle f to load a product k from a supplier i not included in its visiting tour. Constraints (7) and (8) model the pairwise incompatibility among products. The first group of constraints states that for each pair of incompatible products (k, g) ∈ B a vehicle f can load at most one of the two. The second set of constraints ensures that if 
                           
                              
                                 w
                                 
                                    k
                                 
                                 f
                              
                              =
                              0
                              ,
                           
                         vehicle f cannot load product k from any suppliers of its tour, whereas if 
                           
                              
                                 w
                                 
                                    k
                                 
                                 f
                              
                              =
                              1
                           
                         the vehicle must purchase exactly one unit of the product from a supplier that sells it. Finally, (9)–(12) are binary conditions on the variables. Note that w-variables can be easily eliminated from the model using equalities (8), but we keep them to clearly state the assignment of a product to a vehicle.

We now describe a reformulation of the model (1)–(12) obtained through the use of the Dantzig–Wolfe decomposition technique for linear programs (see Dantzig & Wolfe, 1960). Let 
                           
                              D
                              =
                              {
                              (
                              x
                              ,
                              y
                              ,
                              w
                              ,
                              z
                              )
                              :
                              (
                              x
                              ,
                              y
                              ,
                              w
                              ,
                              z
                              )
                           
                         satisfies (3)–(12)} be the feasible domain of the subproblem identified by constraints (3)–(12). This domain is decomposable over the vehicles in identical feasible domains 
                           
                              
                                 D
                                 f
                              
                              
                                 =
                                 {
                              
                              
                                 (
                                 
                                    x
                                    f
                                 
                                 ,
                                 
                                    y
                                    f
                                 
                                 ,
                                 
                                    w
                                    f
                                 
                                 ,
                                 
                                    z
                                    f
                                 
                                 )
                              
                              :
                              
                                 (
                                 
                                    x
                                    f
                                 
                                 ,
                                 
                                    y
                                    f
                                 
                                 ,
                                 
                                    w
                                    f
                                 
                                 ,
                                 
                                    z
                                    f
                                 
                                 )
                              
                           
                         satisfies (3)–(12) for f ∈ F}. A solution (xf, yf, wf, zf
                        ) ∈ Df
                         corresponds to a feasible route when it is associated with a feasible purchasing plan satisfying vehicle capacity and incompatibility restrictions. Given this subproblem domain, the Dantzig–Wolfe decomposition leads to the master program described in the following (a similar decomposition approach has been proposed in Jin, Liu, and Eksioglu (2008) for solving the SDVRP, and in Desaulniers (2010) for the SDVRP with Time Windows).

Let us define R as the set of all feasible routes. A feasible route is basically a set of arcs representing a tour in G starting and ending to the depot 0, and visiting a subset of suppliers that guarantees the accomplishment of a feasible purchasing plan. A feasible purchasing plan associated with a route represents the set of decisions about which product to purchase from which supplier belonging to the route, ensuring that: a) a product is purchased from a supplier only if it is available there; b) incompatible products cannot be part of the same purchasing plan; c) the total number of products purchased does not exceed the vehicle capacity (cardinality constraint). That said, a feasible solution for the MVTPP-PIC can be viewed as a collection of O(|F|) routes in R such that the demand for each product is satisfied. For each feasible route r ∈ R, we also define:

                           
                              •
                              
                                 θr
                                 : an integer variable equal to the number of times route r is assigned to a vehicle;


                                 
                                    
                                       δ
                                       
                                          i
                                          k
                                       
                                       r
                                    
                                 : a coefficient equal to 1 if product k is purchased from supplier i in the route r;


                                 
                                    
                                       a
                                       
                                          i
                                       
                                       r
                                    
                                 : a coefficient equal to 1 if node i is visited in the route r, and 0 otherwise;


                                 
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                       r
                                    
                                 : a coefficient equal to 1 if the arc (i, j) is traversed in the route r, and 0 otherwise;


                                 
                                    
                                       
                                          c
                                          r
                                       
                                       =
                                       
                                          ∑
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                             ∈
                                             r
                                          
                                       
                                       
                                          c
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 : the total traveling cost associated with the route r;


                                 
                                    
                                       
                                          p
                                          r
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             ∈
                                             K
                                          
                                       
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             
                                                M
                                                k
                                             
                                          
                                       
                                       
                                          p
                                          
                                             i
                                             k
                                          
                                       
                                       
                                          δ
                                          
                                             i
                                             k
                                          
                                          r
                                       
                                    
                                 : the total purchasing cost associated with the route r.

Finally, let Xij
                         be an integer variable representing the number of times arc (i, j) ∈ A is traversed, and let Yi
                         be an integer variable representing the number of times node i ∈ V is visited. With this notation, the MVTPP-PIC can be reformulated as follows:

                           
                              (13)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       (
                                       
                                          c
                                          r
                                       
                                       +
                                       
                                          p
                                          r
                                       
                                       )
                                    
                                    
                                       θ
                                       r
                                    
                                 
                              
                           
                        subject to

                           
                              (14)
                              
                                 
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       θ
                                       r
                                    
                                    ≤
                                    
                                       |
                                       F
                                       |
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       δ
                                       
                                          i
                                          k
                                       
                                       r
                                    
                                    
                                       θ
                                       r
                                    
                                    ≥
                                    1
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       θ
                                       r
                                    
                                    ∈
                                    N
                                    
                                    r
                                    ∈
                                    R
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       a
                                       
                                          i
                                       
                                       r
                                    
                                    
                                       θ
                                       r
                                    
                                    =
                                    
                                       Y
                                       i
                                    
                                    
                                    i
                                    ∈
                                    V
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                       r
                                    
                                    
                                       θ
                                       r
                                    
                                    =
                                    
                                       X
                                       
                                          i
                                          j
                                       
                                    
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       Y
                                       i
                                    
                                    ∈
                                    N
                                    
                                    i
                                    ∈
                                    V
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       X
                                       
                                          i
                                          j
                                       
                                    
                                    ∈
                                    N
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    ∈
                                    A
                                 
                              
                           
                        Objective function (13) minimizes the total cost of the selected routes. Inequality (14) limits the number of selected routes to the fleet size, while constraints (15) ensure that, for each product, its unitary demand is satisfied. Eqs. (17) and (18) express Yi
                         and Xij
                         variables in terms of the θr
                         ones. Finally, in (16), (19) and (20) the integrality of variables is defined. Constraints (17)–(20) are not strictly necessary for the model. Anyway, these relations are stated here since they are useful to understand the branching rules proposed in Section 3.3. From now on, we denote the linear relaxation of (13)–(16) as master problem (MP).

Since the set R contains a huge number of feasible routes, it is impossible to solve explicitly the model by generating all its variables. Hence, we resort to a branch-and-price solution approach where, at each node of the tree, the MP is solved by using a column generation procedure. Note that, differently from formulation (1)–(12), here it is not explicitly required to purchase exactly a unit for each product. However, this relaxation is valid since buying more than one unit for any product is never optimal. The rationale behind the choice of a set-covering formulation instead of a set-partitioning one is that an equality in constraints (15) would lead to free dual variables, which typically slow down the convergence of a column generation algorithm. Finally, variables θ are not defined to be binary to avoid |R| constraints of the type θr
                         ≤ 1 in the MP, even if it is clear that any solution containing a route r with θr
                         > 1 could not be optimal.

This section is devoted to describe all the components of the branch-and-price solution algorithm based on the set-covering formulation (13)–(20). Branch-and-price represents a standard approach for solving huge integer programs (see Barnhart, Johnson, Nemhauser, Savelsbergh, & Vance, 1998) and it has been applied effectively to many vehicle routing and scheduling problems (see, e.g., Gendreau, Dejax, Feillet, & Gueguen, 2006 and Desaulniers, Desrosiers, & Solomon, 2002). This method combines a branch-and-bound framework with the use of a column generation technique for solving the linear relaxations at each node of the tree. In our implementation, the overall procedure is initialized by a simple heuristic, to find a feasible solution quickly.

In every enumerative methods based on bounding, it is useful to start the procedure with a feasible solution (an upper bound in this case) that permits to prune a higher number of nodes in the branch-and-bound tree. In order to better understand the behavior of our branch-and-price, we decide to implement just a basic initial heuristic consisting in a simplified version of the four-step heuristic proposed in Manerba and Mansini (2015). That heuristic relies on a decision tree, searched through a Beam Search procedure, where each node corresponds to a different subset of suppliers. In this work, that decision tree is essentially reduced to a unique node corresponding to the set of all the suppliers.

First, we find a feasible purchasing plan by optimally solving the following problem:

                           
                              (21)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       p
                                       
                                          i
                                          k
                                       
                                    
                                    
                                       λ
                                       
                                          i
                                          k
                                       
                                    
                                 
                              
                           
                        subject to

                           
                              (22)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       λ
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    1
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    
                                       λ
                                       
                                          i
                                          k
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    
                                       M
                                       k
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 λ
                                 
                                    i
                                    k
                                 
                              
                              :
                              =
                              
                                 ∑
                                 
                                    f
                                    ∈
                                    F
                                 
                              
                              
                                 z
                                 
                                    i
                                    k
                                 
                                 f
                              
                           
                         are binary variables taking value 1 if product k is purchased in supplier i, and 0 otherwise. Actually, the problem is an easy-to-solve Assignment Problem, since constraints (23) can be relaxed to simple non-negativity conditions on the variables. Once obtained the optimal solution of (21)–(23), we then eliminate all non-visited suppliers.

Since problem (21)–(23) ignores the vehicles, a greedy heuristic is then used to find a feasible assignment of products to vehicles and, consequently, of vehicles to suppliers. The method chooses randomly an incompatible product, and assign it to a vehicle. If a product cannot be assigned to a vehicle (because it would exceed its capacity or because it is incompatible with some already loaded products) another vehicle is chosen, and so on. This procedure is repeated for each incompatible product. Then, for each supplier, the remaining free products fill up first the vehicles that have been already associated with that supplier. Note that the previous procedure may occasionally lead to infeasibility, since the number of vehicles is bounded. In this case, as detailed explained in Manerba and Mansini (2015), a recovery method consisting in the exact solution of a MIP problem that minimizes the number of vehicles used and ensures the satisfaction of all restrictions on vehicles (capacity and PICs) is used.

Finally, once decided which suppliers have to be visited by each vehicle, we find a feasible route by solving a Traveling Salesman Problem (TSP). This is done heuristically through the Lin–Kernighan–Helsgaun algorithm, which is a recent variant of one of the most successful methods for generating near-optimal solutions for the TSP (Helsgaun, 2000).

Column generation is a state-of-the-art method for solving linear programs containing a huge number of variables. In this method, columns (variables) are iteratively found by a so-called pricing problem (or subproblem), and added to the master problem. The pricing problem aims at computing columns with negative reduced cost with respect to a dual solution of the restricted master problem (RMP), i.e. the linear relaxation of the master problem limited to the current subset of variables. When no new columns with negative reduced cost can be found, the optimal solution of the RMP is also optimal for the MP.

In our case, given π the non-positive dual variable associated with constraint (14), and μk
                         the non-negative dual variable associated with the constraint (15) for product k, the pricing problem is as follows:

                           
                              (24)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ∈
                                          A
                                       
                                    
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          M
                                       
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       (
                                       
                                          p
                                          
                                             i
                                             k
                                          
                                       
                                       −
                                       
                                          μ
                                          k
                                       
                                       )
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                    
                                    −
                                    π
                                 
                              
                           
                        subject to

                           
                              (25)
                              
                                 
                                    
                                    
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             
                                                {
                                                h
                                                }
                                             
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             −
                                          
                                          
                                             (
                                             
                                                {
                                                h
                                                }
                                             
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       y
                                       h
                                    
                                    
                                    h
                                    ∈
                                    M
                                 
                              
                           
                        
                        
                           
                              (26)
                              
                                 
                                    
                                       ∑
                                       
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≥
                                    
                                       y
                                       h
                                    
                                    
                                    S
                                    ⊆
                                    M
                                    ,
                                    h
                                    ∈
                                    S
                                 
                              
                           
                        
                        
                           
                              (27)
                              
                                 
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                    
                                    ≤
                                    
                                       y
                                       i
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    
                                       M
                                       k
                                    
                                 
                              
                           
                        
                        
                           
                              (28)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                    
                                    ≤
                                    Q
                                 
                              
                           
                        
                        
                           
                              (29)
                              
                                 
                                    
                                       w
                                       k
                                    
                                    +
                                    
                                       w
                                       g
                                    
                                    ≤
                                    1
                                    
                                    
                                       (
                                       k
                                       ,
                                       g
                                       )
                                    
                                    ∈
                                    B
                                 
                              
                           
                        
                        
                           
                              (30)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    
                                       w
                                       k
                                    
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (31)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (32)
                              
                                 
                                    
                                       y
                                       i
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    i
                                    ∈
                                    M
                                 
                              
                           
                        
                        
                           
                              (33)
                              
                                 
                                    
                                       w
                                       k
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (34)
                              
                                 
                                    
                                       z
                                       
                                          i
                                          k
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    
                                       M
                                       k
                                    
                                 
                              
                           
                        Variables x, y, w and z have the same meaning as variables in formulation (1)–(12), but for a given vehicle f ∈ F. The problem (24)–(34) is a Traveling Purchaser Problem with Pairwise Incompatibility Constraints but without the demand constraints. In this problem, the purchasing of each product is not forced by a specific demand requirement (as in common TPP), but by the minimization of a purchasing cost where product (reduced) prizes 
                           
                              
                                 p
                                 
                                    i
                                    k
                                 
                                 ′
                              
                              :
                              =
                              
                                 p
                                 
                                    i
                                    k
                                 
                              
                              −
                              
                                 μ
                                 k
                              
                           
                         can be negative.

To solve the pricing problem, we propose a hybrid strategy composed by two exact methods, i.e. the labeling algorithm and the branch-and-cut approach described in Sections 3.2.1 and 3.2.2, respectively. It is worth noticing that, at each iteration of the column generation procedure, a lower bound on the optimal value of the MP can be computed as:

                           
                              (35)
                              
                                 
                                    
                                       
                                          z
                                          ̲
                                       
                                       
                                          M
                                          P
                                       
                                    
                                    =
                                    
                                       z
                                       
                                          R
                                          M
                                          P
                                       
                                       *
                                    
                                    +
                                    
                                       
                                          c
                                          ˜
                                       
                                       *
                                    
                                    
                                       |
                                       F
                                       |
                                    
                                 
                              
                           
                        where 
                           
                              z
                              
                                 R
                                 M
                                 P
                              
                              *
                           
                         corresponds to the optimal value of the current RMP and 
                           
                              
                                 c
                                 ˜
                              
                              *
                           
                         is the reduced cost value of the optimal column found by the relative pricing problem.

The pricing problem can be reformulated as an Elementary Shortest Path Problem with Resource Constraints (ESPPRC) on an expanded graph 
                              
                                 
                                    G
                                    ′
                                 
                                 =
                                 
                                    (
                                    
                                       A
                                       ′
                                    
                                    ,
                                    
                                       V
                                       ′
                                    
                                    )
                                 
                              
                            defined as follows. The node set V′ includes the depot 0 and the nodes representing all the possible pairs (k, i) where k ∈ K and i ∈ Mk
                           . The arc set A′ corresponds to the Cartesian product V′ × V′. For each arc (v
                           1, v
                           2) ∈ A′ we define a cost 
                              
                                 
                                    c
                                    ˜
                                 
                                 
                                    
                                       v
                                       1
                                    
                                    ,
                                    
                                       v
                                       2
                                    
                                 
                              
                            equal to:

                              
                                 (36)
                                 
                                    
                                       
                                          
                                             c
                                             ˜
                                          
                                          
                                             
                                                v
                                                1
                                             
                                             ,
                                             
                                                v
                                                2
                                             
                                          
                                       
                                       :
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      
                                                         c
                                                         
                                                            0
                                                            j
                                                         
                                                      
                                                      +
                                                      
                                                         p
                                                         
                                                            j
                                                            k
                                                         
                                                      
                                                      −
                                                      
                                                         μ
                                                         k
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         v
                                                         1
                                                      
                                                      =
                                                      0
                                                      
                                                      and
                                                      
                                                      
                                                         v
                                                         2
                                                      
                                                      =
                                                      
                                                         (
                                                         k
                                                         ,
                                                         j
                                                         )
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         c
                                                         
                                                            i
                                                            j
                                                         
                                                      
                                                      +
                                                      
                                                         p
                                                         
                                                            j
                                                            g
                                                         
                                                      
                                                      −
                                                      
                                                         μ
                                                         g
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         v
                                                         1
                                                      
                                                      =
                                                      
                                                         (
                                                         k
                                                         ,
                                                         i
                                                         )
                                                      
                                                      
                                                      and
                                                      
                                                      
                                                         v
                                                         2
                                                      
                                                      =
                                                      
                                                         (
                                                         g
                                                         ,
                                                         j
                                                         )
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         p
                                                         
                                                            i
                                                            g
                                                         
                                                      
                                                      −
                                                      
                                                         μ
                                                         g
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         v
                                                         1
                                                      
                                                      =
                                                      
                                                         (
                                                         k
                                                         ,
                                                         i
                                                         )
                                                      
                                                      
                                                      and
                                                      
                                                      
                                                         v
                                                         2
                                                      
                                                      =
                                                      
                                                         (
                                                         g
                                                         ,
                                                         i
                                                         )
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      c
                                                      
                                                         i
                                                         0
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         v
                                                         1
                                                      
                                                      =
                                                      
                                                         (
                                                         k
                                                         ,
                                                         i
                                                         )
                                                      
                                                      
                                                      and
                                                      
                                                      
                                                         v
                                                         2
                                                      
                                                      =
                                                      0
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   ∞
                                                
                                                
                                                   otherwise.
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Even if solving an ESPPRC on G′ is an 
                              NP
                           -hard problem, the aim of this formulation is to take advantage from the effective labeling algorithms proposed in the literature (see e.g. Irnich & Desaulniers, 2005). In such labeling algorithms, any feasible partial path starting from the depot is represented by a label associated with the arriving node. Generally, labels include useful information about the partial path, such as its current (reduced) cost, the visited nodes, and the current value of its resources. Starting from an initial void label associated with the depot, labels are extended in all possible directions through arcs in the graph (and their components are updated accordingly), until they return to the depot. It is possible to extend a label only if the extension satisfies all the resource constraints. Finally, dominance procedures can be used to eliminate labels and speed up the solution. An exact solution of the just explained algorithm returns a set of Pareto-optimal columns with respect to all the considered resources.

In our implementation, each feasible partial path from 0 to a node 
                              
                                 v
                                 =
                                 
                                    (
                                    k
                                    ,
                                    i
                                    )
                                 
                                 ∈
                                 
                                    V
                                    ′
                                 
                              
                            is represented by a label E ≔ (C, L, (tk
                           )
                              k ∈ K
                           , v) where C is the reduced cost of the partial path, L represents the vehicle load, and (tk
                           )
                              k ∈ K
                            is a {0, 1}-vector indicating for each product k if it is loaded on the vehicle. A partial path is feasible if the vehicle load complies with the cardinality constraint, i.e. L ≤ Q, and if the vehicle does not transport incompatible products, i.e if for any k, g ∈ K such that 
                              
                                 
                                    t
                                    k
                                 
                                 =
                                 1
                              
                            and 
                              
                                 
                                    t
                                    g
                                 
                                 =
                                 1
                              
                            it holds that 
                              
                                 (
                                 k
                                 ,
                                 g
                                 )
                                 ∉
                                 B
                              
                           . Thus, a label can be extended only if the new label is associated with a feasible path. Extending a label 
                              
                                 (
                                 
                                    C
                                    
                                       v
                                       1
                                    
                                 
                                 ,
                                 
                                    L
                                    
                                       v
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       (
                                       
                                          t
                                          k
                                          
                                             v
                                             1
                                          
                                       
                                       )
                                    
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 ,
                                 
                                    v
                                    1
                                 
                                 )
                              
                            along an arc (v
                           1, v
                           2) ∈ A′ to a node 
                              
                                 
                                    v
                                    2
                                 
                                 =
                                 
                                    (
                                    g
                                    ,
                                    j
                                    )
                                 
                              
                            produces a new label 
                              
                                 (
                                 
                                    C
                                    
                                       v
                                       2
                                    
                                 
                                 ,
                                 
                                    L
                                    
                                       v
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       (
                                       
                                          t
                                          k
                                          
                                             v
                                             2
                                          
                                       
                                       )
                                    
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 ,
                                 
                                    v
                                    2
                                 
                                 )
                              
                            where 
                              
                                 
                                    C
                                    
                                       v
                                       2
                                    
                                 
                                 =
                                 
                                    C
                                    
                                       v
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       c
                                       ˜
                                    
                                    
                                       
                                          v
                                          1
                                       
                                       ,
                                       
                                          v
                                          2
                                       
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    L
                                    
                                       v
                                       2
                                    
                                 
                                 =
                                 
                                    L
                                    
                                       v
                                       1
                                    
                                 
                                 +
                                 1
                                 ,
                              
                           
                           
                              
                                 
                                    t
                                    g
                                    
                                       v
                                       2
                                    
                                 
                                 =
                                 1
                                 ,
                              
                            and 
                              
                                 
                                    t
                                    k
                                    
                                       v
                                       2
                                    
                                 
                                 =
                                 
                                    t
                                    k
                                    
                                       v
                                       1
                                    
                                 
                              
                            for k ∈ K, k ≠ g. If instead the arriving node is the depot (
                              
                                 
                                    v
                                    2
                                 
                                 =
                                 0
                              
                           ), the extension simply produces a new label 
                              
                                 (
                                 
                                    C
                                    
                                       v
                                       2
                                    
                                 
                                 ,
                                 
                                    L
                                    
                                       v
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       (
                                       
                                          t
                                          k
                                          
                                             v
                                             1
                                          
                                       
                                       )
                                    
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 ,
                                 
                                    v
                                    2
                                 
                                 )
                              
                            where 
                              
                                 
                                    C
                                    
                                       v
                                       2
                                    
                                 
                                 :
                                 =
                                 
                                    C
                                    
                                       v
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       c
                                       ˜
                                    
                                    
                                       
                                          v
                                          1
                                       
                                       ,
                                       
                                          v
                                          2
                                       
                                    
                                 
                              
                           .

Moreover, we decide to allow extensions of labels from a node 
                              
                                 
                                    v
                                    1
                                 
                                 =
                                 
                                    (
                                    k
                                    ,
                                    i
                                    )
                                 
                              
                            to a node 
                              
                                 
                                    v
                                    2
                                 
                                 =
                                 
                                    (
                                    g
                                    ,
                                    i
                                    )
                                 
                              
                            only if g > k. This restriction prevents the possibility of generating equivalent paths that differ only for the order in which products are purchased in a supplier, thus solving the symmetries yielded by using the expanded graph G′. Note also that it is never convenient to extend a label to a node 
                              
                                 
                                    v
                                    2
                                 
                                 =
                                 
                                    (
                                    g
                                    ,
                                    j
                                    )
                                 
                              
                            if 
                              
                                 
                                    t
                                    g
                                    
                                       v
                                       1
                                    
                                 
                                 =
                                 1
                                 ,
                              
                            i.e. if product g has been already loaded on the vehicle.

A dominance rule can be applied in order to eliminate partial paths that cannot be extended to Pareto-optimal ones. Given two labels 
                              
                                 
                                    E
                                    1
                                 
                                 =
                                 
                                    (
                                    
                                       C
                                       1
                                    
                                    ,
                                    
                                       L
                                       1
                                    
                                    ,
                                    
                                       
                                          (
                                          
                                             t
                                             k
                                             1
                                          
                                          )
                                       
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    ,
                                    v
                                    )
                                 
                              
                            and 
                              
                                 
                                    E
                                    2
                                 
                                 =
                                 
                                    (
                                    
                                       C
                                       2
                                    
                                    ,
                                    
                                       L
                                       2
                                    
                                    ,
                                    
                                       
                                          (
                                          
                                             t
                                             k
                                             2
                                          
                                          )
                                       
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    ,
                                    v
                                    )
                                 
                              
                            associated with the same node f, E
                           1 is said to dominate E
                           2 if it collects the same products (independently from the visited suppliers) and it has a better reduced cost, i.e. if 
                              
                                 
                                    t
                                    k
                                    1
                                 
                                 =
                                 
                                    t
                                    k
                                    2
                                 
                                 ,
                                 k
                                 ∈
                                 K
                              
                            and C
                           1 ≤ C
                           2.

Since several polyhedral aspects of (25)–(34) have been studied before, we are able to develop an efficient branch-and-cut algorithm by using some families of valid inequalities, as an alternative solution method to the dynamic programming algorithm proposed above.

A consolidated approach in the literature consists in solving the model (25)–(34) without the connectivity constraints (26), that are exponential in the size of |M|, adding dynamically only those of them that better cutoff the current LP relaxation optimal solution (x
                           *, y
                           *, w
                           *, z
                           *). An exact separation algorithm for connectivity constraints can be executed in polynomial time by solving max-flow/min-cut problems on a capacitated graph 
                              
                                 G
                                 =
                                 (
                                 V
                                 ,
                                 A
                                 )
                              
                            where for each arc (i, j) ∈ A a capacity 
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 *
                              
                            is considered. More precisely, given a supplier h such that 
                              
                                 
                                    y
                                    h
                                    *
                                 
                                 ≠
                                 0
                                 ,
                              
                            the most violated constraint (26) corresponds to the partition (S, V∖S) associated with a minimum-capacity cut in G separating node 0 from h, and such that h ∈ S.

We also consider valid inequalities corresponding to a particular type of connectivity constraints involving z-variables (the so-called zSEC inequalities introduced for the TPP by Laporte et al., 2003):

                              
                                 (37)
                                 
                                    
                                       
                                          ∑
                                          
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                             
                                             ∈
                                             
                                                δ
                                                −
                                             
                                             
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       
                                          ∑
                                          
                                             h
                                             ∈
                                             
                                                M
                                                k
                                             
                                             ∖
                                             S
                                          
                                       
                                       
                                          z
                                          
                                             h
                                             k
                                          
                                       
                                       ≥
                                       1
                                       
                                       k
                                       ∈
                                       K
                                       ,
                                       S
                                       ⊆
                                       
                                          M
                                          k
                                       
                                       .
                                    
                                 
                              
                           Each inequality (37) imposes that at least one arc must enter a subset S ⊆ Mk
                            whenever any product offered in S is not purchased in at least one supplier of Mk
                           ∖S. Similarly to the previous separation procedure, given a product k ∈ K, we can formulate a max-flow/min-cut problem on a capacitated graph Gk
                            ≔ (Vk, Ak
                           ) where Vk
                            ≔ V ∪ {t}, t is a dummy supplier, and 
                              
                                 
                                    A
                                    k
                                 
                                 =
                                 A
                                 ∪
                                 
                                    {
                                    
                                       (
                                       h
                                       ,
                                       t
                                       )
                                    
                                    :
                                    h
                                    ∈
                                    
                                       M
                                       k
                                    
                                    }
                                 
                              
                           . In this graph, the capacity of each arc (i, j) ∈ A is equal to 
                              
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    *
                                 
                                 ,
                              
                            whereas the capacity of each new arc (h, t) is equal to 
                              
                                 z
                                 
                                    h
                                    k
                                 
                                 *
                              
                           . The most violated valid inequalities (37) corresponds to consider the set S ≔ St
                           ∖{t}, where (St, Vk
                           ∖St
                           ) is the node partition associated with a minimum-capacity cut in Gk
                            separating 0 and t, with t ∈ St
                           . The cut is effective only if the minimum-capacity cut value is less than 1.

Moreover, the model (25)–(34) can be enriched with the direct addition of the following classes of simple valid inequalities:

                              
                                 (38)
                                 
                                    
                                       
                                          z
                                          
                                             i
                                             k
                                          
                                       
                                       ≤
                                       
                                          w
                                          k
                                       
                                       
                                       k
                                       ∈
                                       K
                                       ,
                                       i
                                       ∈
                                       
                                          M
                                          k
                                       
                                       ,
                                    
                                 
                              
                           
                           
                              
                                 (39)
                                 
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             
                                                M
                                                k
                                             
                                          
                                       
                                       
                                          y
                                          i
                                       
                                       ≥
                                       
                                          w
                                          k
                                       
                                       
                                       k
                                       ∈
                                       K
                                       ,
                                    
                                 
                              
                           
                           
                              
                                 (40)
                                 
                                    
                                       
                                          y
                                          i
                                       
                                       ≤
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             M
                                          
                                       
                                       
                                          x
                                          
                                             0
                                             j
                                          
                                       
                                       
                                       i
                                       ∈
                                       M
                                       ,
                                    
                                 
                              
                           
                           
                              
                                 (41)
                                 
                                    
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                       
                                       ≤
                                       
                                          y
                                          j
                                       
                                       
                                       i
                                       ∈
                                       V
                                       ,
                                       j
                                       ∈
                                       M
                                       .
                                    
                                 
                              
                           Inequalities (38) state that if a product k is purchased at a supplier i (
                              
                                 
                                    z
                                    
                                       i
                                       k
                                    
                                 
                                 =
                                 1
                              
                           ) then the product k has to be loaded (
                              
                                 
                                    w
                                    k
                                 
                                 =
                                 1
                              
                           ). Inequalities (39) establish that if a product k is loaded, at least one of the suppliers offering such a product has to be visited. Valid inequalities (40) simply state that if a supplier i is visited, then at least an arc must leave the depot, and, through inequalities (25), that one arc has to enter and one has to leave the depot. The three previous cuts are inherited from those proposed in Manerba and Mansini (2015) for the MVTPP-PIC with non unitary demands and restricted availabilities. Finally, inequalities (41) are logical constraints ensuring that if the arc (i, j) is used, then the supplier at the end of the arc has to be visited (Fischetti, Salazar-González, & Toth, 1998). These constraints make the integrality requirement on the y-variables redundant.

Column generation approaches generally suffer from slow convergence of the objective function. This is especially true when primal problem shows heavy degeneracy and multiple dual solutions can be associated with each primal solution. A wrong choice of the dual variables values used in the subproblem could lead indeed to an inappropriate estimation of the marginal costs associated with columns.

In order to overcome this drawback, we implement the interior point stabilization (IPS) method proposed by Rousseau, Gendreau, and Feillet (2007). Briefly, the main idea is to solve, at each iteration of the column generation, a certain number of slightly perturbed master problems, to collect all the optimal dual solutions and finally to return a dual solution corresponding to an interior point calculated as the convex combination of all the collected points (we take the average of the generated extreme points). To correctly obtain different dual optimal solutions, one can simply define a random well-formed objective function and optimize it several times over the optimal dual polyhedron containing all optimal values of the dual variables (μ, π). This polyhedron can be constructed applying complementary slackness conditions on the primal optimal solution. In practice, however, it is more efficient to make simple modifications to the right-hand side of the original problem, to solve it through the simplex method and to collect dual optimal values. We adopt this strategy. In particular, anytime we have to perturb the problem, we randomly generate |K| values in [0, 1] and substitute them to the right-hand-side values in constraints (15).

Lots of different stabilization methods have been proposed in the literature (see e.g. du Merle, Villeneuve, Desrosiers, & Hansen, 1999). However, the IPS method is particularly indicated when the MP needs very few CPU time to be solved, as in our case. On other hand, a better estimation of the marginal costs generally leads to subproblems more complex to solve. Hence, the method results efficient especially when is associated with heuristic or really optimized solution algorithms for the subproblem.

Several techniques, described in the following, have been implemented in order to speed up the entire column generation phase.

We decide to initialize the column generation phase with columns corresponding to the routes originated from the initial heuristic (explained in Section 3.1). Hence, O(|F|) columns are initially added. Moreover, in order to ensure the feasibility of the MP, even with respect to the branching constraints, we add |K| artificial slack variables, one in each inequality (15). These variables are highly penalized in the objective function.

Since labeling algorithms are really time consuming, a common practice is to stop the generation of columns prematurely. This can be done apart from the very last iteration of the column generation, where we need to prove that no more negative reduced cost columns exist. We implement two different stopping rules based on the number of labels returned to the depot. More precisely, the algorithm stops when a number negLabelLIM
                               of negative reduced cost labels has returned to the depot 0 (that corresponds to bound the number of columns added to the master problem for each iteration), or when the total number of labels returned to the depot reaches allLabelLIM
                              . In order to make these stopping rules more efficient, they are checked every time a new label arrives in 0. Moreover, the first extension for each label associated with a node v
                              1 is along the arc (v
                              1, 0).

The branch-and-cut proposed in Section 3.2.2 aims at finding the optimal solution corresponding to a column with the minimum reduced cost. However, we store all the feasible integer solutions found during the branch-and-cut tree and return them as columns to add to the MP.

Actually, the heuristically stopped labeling algorithm and the branch-and-cut method proposed for solving the subproblem have quite complementary features. While the first method returns a lot of columns, most of which of bad quality, the second method returns very few columns but always including the best one. This suggests that the two methods can be used alternatively to solve the subproblems, taking advantage from the good features of each one. The combined use of the two algorithms might take different configurations. After several preliminary tests, we decide to implement the following scheme that represents our hybrid strategy to solve the subproblem. At each node of the branch-and-price tree the subproblem is initially solved through the labeling algorithm, always checking for the stopping rules. If negLabelLIM
                               is reached, the labeling algorithm stops and the MP (enriched by the columns found) is solved again, but the solution method for the subproblem does not change. Instead, it switches to the branch-and-cut as soon as the allLabelLIM
                               is reached, i.e. when the labeling algorithm seems no more effective in finding negative reduced cost columns.

We implement a two-phase procedure, executed at each iteration of the column generation, in order to get feasible solutions quickly without waiting the end of the entire process. This is useful also for reducing the number of visited nodes in the branch-and-price tree. Both the two phases are based on the solution of the RMP. First, during the column generation procedure, it might happen that the RMP yields an integer (non-optimal) solution but that such a solution results infeasible for the MVTPP-PIC showing a purchase greater than 1 for some products. In fact, the relaxation used in the master problem, i.e. the inequalities (15), is equivalent to the MVTPP-PIC only if optimality has been reached. However, given an integer solution, we can easily check if the purchase for each product is unitary, i.e. if 
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             M
                                             k
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                    
                                       δ
                                       
                                          i
                                          k
                                       
                                       r
                                    
                                    
                                       θ
                                       r
                                    
                                    =
                                    1
                                    ,
                                 
                               
                              k ∈ K. In case of positive answer, we can update the best incumbent solution and the overall upper bound. In the negative case, the second phase is applied. This consists in optimally solving, through the use of a MIP solver, the integer model (13)–(16) restricted to the columns currently generated, and where the inequalities (15) are changed in equalities. If the optimal solution has a better value than the incumbent one, the upper bound is updated.

When the optimal solution of the MP results to be fractional, we need to implement a branching scheme to ensure integrality of variables. This rises some difficulties, because the branching rules need to be compatible with the column generation phase.
                     

It is widely accepted that branching on variables θ representing routes in the master problem is inefficient, leading to strong imbalance in the branch-and-bound tree. Hence, we prefer to branch on the more representative variables derived from the connectivity constraints based formulation. Some very efficient branching schemes have been developed for branch-and-price approaches applied to similar vehicle routing problems where each supplier has to be visited at most by one vehicle. Unluckily, in our problem suppliers may be visited more than once, hence those schemes are not enough to ensure integrality. Following Gendreau et al. (2006), we propose a hierarchical branching scheme composed by three different rules. These branching decisions are explained in the order we apply them.

In the first branching rule, if any node is visited a fractional number α of times (i.e., if Yi
                         is fractional), we choose the node i for which the fractional part of the corresponding Yi
                         variable’s value is closest to 0.5, and we impose 
                           
                              
                                 ∑
                                 
                                    r
                                    ∈
                                    R
                                 
                              
                              
                                 a
                                 
                                    i
                                 
                                 r
                              
                              
                                 θ
                                 r
                              
                              ≤
                              
                                 ⌊
                                 α
                                 ⌋
                              
                           
                         and 
                           
                              
                                 ∑
                                 
                                    r
                                    ∈
                                    R
                                 
                              
                              
                                 a
                                 
                                    i
                                 
                                 r
                              
                              
                                 θ
                                 r
                              
                              ≥
                              
                                 ⌈
                                 α
                                 ⌉
                              
                              ,
                           
                         respectively. Note that branching on the depot is equivalent to branching on the number of vehicles used in the solution.

When all Y variables are integer, we check if any arc is traversed a fractional number β of times (i.e., if any Xij
                         is fractional). In this second branching rule, we select the arc (i, j) with a fractional part of the corresponding Xij
                         variable closest to 0.5 and we impose 
                           
                              
                                 ∑
                                 
                                    r
                                    ∈
                                    R
                                 
                              
                              
                                 b
                                 
                                    i
                                    j
                                 
                                 r
                              
                              
                                 θ
                                 r
                              
                              ≤
                              
                                 ⌊
                                 β
                                 ⌋
                              
                           
                         and 
                           
                              
                                 ∑
                                 
                                    r
                                    ∈
                                    R
                                 
                              
                              
                                 b
                                 
                                    i
                                    j
                                 
                                 r
                              
                              
                                 θ
                                 r
                              
                              ≥
                              
                                 ⌈
                                 β
                                 ⌉
                              
                           
                         for the two generated subproblems, respectively.

When all Y and X variables are integer, we adopt a third level of branching applying the so-called Flow-Splitting Method proposed in Feillet, Dejax, and Gendreau (2005). Briefly, the idea is to branch on a subset of θ variables generating a fractional flow for the current solution. In vehicle routing problems this set can be generally identified by clustering variables that begin with the same sequence of visited customers. In our case, the clustering is based on the sequence of visits in an expanded graph where nodes are of the type (k, i), k ∈ K, i ∈ Mk
                        , as in the graph G′ described in Section 3.2.1. Note that this third-level branching rules is not expected to be often used in practice, however it is necessary to ensure the θ-variables integrality.

This section presents the setting and the results of the computational experiments we run. The branch-and-price has been implemented in C++, makes use of Cplex 12.5 solver for the solution of linear programs, and the branch-and-bound tree is searched through a best-first strategy. Cplex 12.5 is also used as a general branch-and-cut framework (for the solution of the subproblems), where cuts are embedded via Concert Technology callbacks. Concerning the IPS method, we generate (at each iteration) 20 random vertices of the optimal master problem’s dual polyhedron and use their convex combination. Preliminary tests confirmed that this number of points is large enough to produce a valuable dual variables stabilization effect, without damaging the total computational time.

No specific benchmark instances exist for the MVTPP-PIC with unitary demands. In Manerba and Mansini (2015) the authors introduced a set of instances for the more general case in which demands are not unitary. It is clear that a simple modification of those instances would lead to very meaningless relations between the demand of products and the capacity of the vehicles. We decide to create new instances adapting the method used in the just mentioned paper, as follows.

The suppliers and the depot integer coordinates are randomly generated in a [0, 1000] × [0, 1000] square according to a uniform distribution, and routing costs are computed by rounding the Euclidean distances through EUC_2D function from TSPLIB. Each product k is randomly associated with |Mk
                        | selected suppliers, where |Mk
                        | is randomly generated in the interval [1, |M|]. For each product k and each supplier i, prices pik
                         are selected in interval [1, 200] according to a discrete uniform distribution. To generate the incompatibility set B, we first fix the percentage of free products with respect to the total number of products, i.e. 
                           
                              
                                 f
                                 r
                                 
                                 percent
                                 =
                                 100
                                 |
                              
                              
                                 K
                                 
                                    f
                                    r
                                    e
                                    e
                                 
                              
                              
                                 |
                                 /
                                 |
                                 K
                                 |
                              
                           
                         where Kfree
                         is the set of all the free products. Then, for each product 
                           
                              k
                              ∉
                              
                                 K
                                 
                                    f
                                    r
                                    e
                                    e
                                 
                              
                              ,
                           
                         we randomly choose the number and the set of products with which there is an incompatibility and we construct the incompatibility pairs. Parameter fr percent allows to better control the structure of the instance.

Finally, for each instance, we need to determine the number |F| of available vehicles in order to guarantee that at least a feasible assignment of products to the vehicles exists. In Manerba and Mansini (2015) the authors propose an 
                           NP
                        -hard procedure (including the exact solution of a Minimum Vertex Coloring Problem) just to calculate the minimum feasible size of the fleet. The rationale is that, in the case of their branch-and-cut solution algorithm, the dimension of the model strongly depends on the number of vehicles.

Since a strict evaluation of the fleet size is often impractical in real settings, we prefer to simply compute an upper bound on the optimal fleet size by using the following formula:

                           
                              (42)
                              
                                 
                                    
                                       |
                                       F
                                       |
                                       :
                                       =
                                       |
                                       K
                                       ∖
                                    
                                    
                                       K
                                       
                                          f
                                          r
                                          e
                                          e
                                       
                                    
                                    
                                       |
                                       +
                                       m
                                       a
                                       x
                                    
                                    
                                       (
                                       0
                                       ,
                                       
                                          ⌈
                                          
                                             
                                                
                                                   |
                                                
                                                
                                                   K
                                                   
                                                      f
                                                      r
                                                      e
                                                      e
                                                   
                                                
                                                
                                                   |
                                                   −
                                                   |
                                                   K
                                                   ∖
                                                
                                                
                                                   K
                                                   
                                                      f
                                                      r
                                                      e
                                                      e
                                                   
                                                
                                                
                                                   |
                                                   *
                                                   
                                                      (
                                                      Q
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                             
                                             Q
                                          
                                          ⌉
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

This method assigns one vehicle to each product with at least one incompatibility, then adds the number of vehicles necessary to load the remaining demand, i.e. the entire demand of all free products minus the quantity that can be loaded on the residual capacity of the former vehicles. Note that, if no incompatibility exists among products, expression (42) reduces to the common upper bound value used for computing the fleet size in vehicle routing problems.
                     

We run a set of preliminary tests considering instances with a number of nodes (the suppliers plus the depot) 
                           
                              |
                              V
                              |
                              =
                              {
                              10
                              ,
                              25
                              ,
                              40
                              }
                              ,
                           
                         and a number of products 
                           
                              |
                              K
                              |
                              =
                              {
                              10
                              ,
                              20
                              ,
                              30
                              }
                           
                        . We also consider three percentage values of free products fr percent, equal to 80 percent, 50 percent and 30 percent. This means that the most constrained instances have 70 percent of cross-incompatibilities between products. Moreover, we use three different values for the vehicle capacity Q, i.e. {6, 10, 15}. Generating an instance for each combination of {|V|, |K|, fr percent, Q} leads to a set of 81 instances.

We compare our branch-and-price (B&P) with the branch-and-cut method (MM-B&C) proposed by Manerba and Mansini (2015) that embeds, beside the separation of several families of valid inequalities, an initial heuristic and symmetry breaking constraints. We set the labeling algorithm’s parameters negLabelLIM
                         and allLabelLIM
                         of our B&P to 50 and 500, respectively.


                        Table 1 shows this comparison on the entire set of 81 instances, considering a threshold time of 7200 seconds (i.e., 2 hours) for both the methods. Each table entry refers to the average result out of 9 instances with the same combination of {|V|, |K|}. For each method, the columns have the following meaning: gap percent is the percentage gap between the best integer solution and the best lower bound found during the search in the branch-and-bound tree; t is the CPU time in seconds; ttb is the CPU time in seconds needed to find the best feasible (integer) solution; root percent is the percentage ratio between the value of the LP solution found at the root node of the branch-and-bound tree and the value of the optimal integer solution; 
                           
                              B
                              &
                              B
                              n
                           
                         is the number of nodes visited in the branch-and-bound tree (value 1 represents the root node). Moreover, 
                           
                              #
                              o
                              p
                              t
                           
                         is the number of instances (out of 9) optimally solved by both the methods whereas column Δ percent shows the percentage deviation of the branch-and-price solutions with respect to the branch-and-cut ones (a negative value means that the branch-and-price has found a better solution).

Looking at Table 1 results, we can notice that the branch-and-cut method is able to prove optimality only for 47 instances out of 81. Moreover, it shows very high percentage gaps especially for instances with a higher number of products, and in general, as expected, for larger fleet sizes. On the contrary, the branch-and-price always finds the optimal solution for all the instances within the threshold time. Apart from the optimality gaps, the branch-and-price strictly improves the branch-and-cut solution in 8 instances, yielding an average percentage deviation (Δ percent) of 
                           
                              −
                              0.48
                           
                        . Concerning computational times, the branch-and-cut results quite efficient for instances with a small fleet size, reaching the time limit of 2 hours in the remaining cases. B&P requires a computational time close to the time limit in one instance, and never exceeds 900 seconds in the remaining ones. Finally, the average CPU time (t) and the average time-to-best (ttb) for the branch-and-price are an order of magnitude lower than the competitor’s ones.

Finally, to deeply understand the behavior of our B&P approach, in Tables 2–4
                        
                         we provide additional statistics showing the detailed results obtained by the method for the instances with 
                           
                              |
                              V
                              |
                              =
                              10
                              ,
                           
                         25 and 40, respectively. In each table, instances are uniquely identified by a combination of the tuple {|V|, |K|, fr percent, Q, |F|}. Apart from the column headers already explained, tUB
                         is the CPU time of the initial heuristic in seconds, 
                           
                              #
                              i
                              t
                              e
                              r
                           
                         is the number of iterations performed by the column generation, tsub
                         is the average CPU time in seconds needed for the solution of a subproblem, and troot
                         is the CPU time needed to calculate the linear relaxation at the root node of the branch-and-bound tree.

It clearly seems that the superiority of the branch-and-price approach (in terms of solution quality and computational times) relies on the strength of the set-covering formulation used. In fact, in the most part of the instances, its linear relaxation already coincides with the optimal integer solution (see all the values equal to 100.00 in the root percent column). In the remaining cases, when branching is needed, the branch-and-price tree never exceeds 40 nodes. On average, branch-and-price trees have 3 nodes, whereas the branch-and-cut trees have about 270,000 nodes.

Being established that our new branch-and-price is the best method to solve the unitary-demand MVTPP-PIC (especially when fleet size is quite large), we define 72 new instances to better evaluate its performance. We consider a number of nodes (suppliers plus the depot) 
                           
                              |
                              V
                              |
                              =
                              {
                              20
                              ,
                              35
                              ,
                              50
                              }
                              ,
                           
                         a number of products 
                           
                              |
                              K
                              |
                              =
                              {
                              10
                              ,
                              30
                              ,
                              50
                              ,
                              70
                              }
                              ,
                           
                         and a percentage value of free products fr percent ≔ {30, 55, 80}. For each combination of {|V|, |K|, fr percent}, two particular values of the capacity Q ≔ {Q
                        1, Q
                        2} are considered. In particular, Q
                        1 ≔ ⌈|K|/max{|Ktot
                        |, 2}⌉ where Ktot
                         represents the set of totally incompatible products, and Q
                        2 ≔ ⌈10Q
                        1/fr percent⌉. The rationale of this choice is as follows. A larger vehicle capacity as Q
                        1 tends to generate instances where the number of vehicles needed to satisfy the demand is strongly (or uniquely) influenced by incompatibilities among products. The value Q
                        2 leads instead to more strict capacity constraints, and the final number of vehicles used may depend on the trade-off between vehicle capacity and incompatibilities. This new set of hard-to-solve problems also provides a test bed for future contributions and can be downloaded from the web page http://www.ing.unibs.it/∼orgroup/instances.html.


                        Tables 5
                        
                        –7
                         present the results for 
                           
                              |
                              V
                              |
                              =
                              20
                              ,
                           
                         35 and 50 instances, respectively. Columns meaning has been already explained, apart from 
                           
                              #
                              f
                           
                         and obj that represent the number of vehicles used and the objective function value of the best solution found, respectively. In column gap percent, values are highlighted in bold font when they correspond to a solution proved to be optimal. In this new experiments, the value of the parameters negLabelLIM
                         and allLabelLIM
                         have been doubled, being set to 100 and 1000, respectively. Finally, in order to avoid a useless explosion of the branch-and-bound tree, we also stop the branch-and-price when the percentage gap is less than 0.2 percent.

The new results confirm the overall goodness of our approach, also pointing out some of its limitations. The method works very well in particular for instances with 
                           
                              |
                              V
                              |
                              =
                              20
                           
                         and 
                           
                              |
                              V
                              |
                              =
                              35
                           
                         (see Tables 5 and 6). For 11 out of 72 instances the method is not able to terminate the column generation procedure at the root node within the threshold time (see entries with value 1 in column 
                           
                              B
                              &
                              B
                              n
                           
                         and gap percent greater than zero). In these cases the integrality gaps are quite high, because the restricted master heuristic seems quite ineffective and the best solutions are compared to very poor lower bounds (computed as the maximum between the value obtained by the formula (35) and the optimal solution value of the LP relaxation of (1)–(12) without constraints (4)). However, the B&P has been able to solve optimally about 78 percent of the instances (in particular, it has found 22, 21 and 13 optimal solutions out of 24 instances with 
                           
                              |
                              V
                              |
                              =
                              20
                              ,
                           
                         35, and 50, respectively). For the whole set of instances with 
                           
                              |
                              V
                              |
                              =
                              20
                              ,
                           
                         the B&P generates an average percentage gap equal to 0.01, and the average CPU time is about 870 seconds.
                     

Some other trends can also be noticed. For example, the complexity of the instances grows not surprisingly with the number of products involved, but also with the percentage of free products. The reason might be that our subproblem solving procedures are much more efficient when products present a lot of incompatibilities. Moreover, instances with a vehicle capacity equal to Q
                        1 (odd lines of each table) appear in general a bit harder to solve than the ones with capacity Q
                        2 (even lines). It seems that a smaller value of Q, instead of enhancing the combined effect of the two types of restrictions (cardinality constraint and incompatibilities), mitigates the combinatorial hardness caused by the PIC.

In order to better understand the benefits of some components of our branch-and-price (B&P), we compare its performance to those obtained by the method excluding stabilization (B&P-NoStab) and the two-phase restricted master heuristic (B&P-NoRMH). Table 8 shows this comparison on a subset of 24 instances of the type {|V|, |K|, fr percent, Q}, where 
                           
                              |
                              V
                              |
                              =
                              {
                              20
                              ,
                              35
                              ,
                              50
                              }
                              ,
                           
                        
                        
                           
                              |
                              K
                              |
                              =
                              {
                              10
                              ,
                              70
                              }
                              ,
                           
                        
                        
                           
                              f
                              r
                              
                              percent
                              =
                              {
                              30
                              ,
                              80
                              }
                              ,
                           
                         and 
                           
                              Q
                              =
                              {
                              
                                 Q
                                 1
                              
                              ,
                              
                                 Q
                                 2
                              
                              }
                           
                        . Each table entry refers to the average result out of 4 instances with the same combination of {|V|, |K|}. We can see that B&P-NoStab achieves 1 optimal solution less and shows an optimality gap about the 5 percent worse than the standard version. This is due to a slower convergence of the column generation procedure. In fact, on average, the overall CPU time and that for solving the linear relaxation at the root node are greater. This is not true for the easiest instances, where the stabilization seems unnecessary. On the contrary, B&P-NoRMH is slightly less time consuming with respect to the standard version (since it does not make use of the restricted master heuristic), but presents a worse optimality gap and a consistent average percentage deviation of the solutions with respect to the best found (around 10 percent). In conclusion, as expected, both the stabilization method and the restricted master heuristic implemented give efficiency and effectiveness to the solution procedure, in particular for the hardest instances.

On the same subset of instances we now evaluate the contribution to the column generation procedure of the two methods composing the hybrid solution approach proposed for the pricing problem, i.e., the labeling algorithm (Lab) and the tailored branch-and-cut (B&C). The average CPU time per iteration (tSUB
                        ) of the two methods is presented in Fig. 2
                        , whereas Fig. 3
                         shows the percentage number of iterations executed and the number of columns added by the two methods out of the total number. Results are grouped by value of |V|. In Fig. 2, we see that tSUB
                         for B&C grows exponentially with the number of nodes, whereas it grows quite linearly for Lab. This depends on the fact that the labeling algorithm, in our branch-and-price implementation, is stopped prematurely as soon as it results to be ineffective, whereas the branch-and-cut always needs to ensure optimality for the pricing problem. Fig. 3 reveals instead how the two methods collaborate in the column generation procedure. Not surprisingly, the labeling algorithm is always executed very few times with respect to the total number of iterations (this value never exceeds, on average, the 5 percent). However, in proportion, it generates a conspicuous part of the total number of columns (20 percent for 
                           
                              |
                              V
                              |
                              =
                              35
                           
                         instances, and almost 35 percent for 
                           
                              |
                              V
                              |
                              =
                              50
                           
                         instances). B&C, instead, returns the most part of the columns but using a number of iterations about 20 times larger. This means that the intrinsic drawbacks of the two pricing problem solution procedures are very well compensated by the use of the switching method (exposed in Section 3.2.4) that rules the hybrid approach.

@&#CONCLUSIONS@&#

In this paper, we deal with the Multi-Vehicle Traveling Purchaser Problem with Pairwise Incompatibility Constraints and unitary demand for the products. We develop a branch-and-price solution approach embedding a column generation procedure within a branch-and-bound framework. The column generation relies on a set-covering formulation of the problem where a column corresponds to a feasible route associated with a compatible purchasing plan. To solve the pricing problem, we propose a hybrid strategy combining two exact methods, i.e. a labeling algorithm solving a Resource-Constrained Elementary Shortest Path Problem on an expanded graph and a tailored branch-and-cut approach. We also introduce an initial heuristic, three different branching rules, and several acceleration techniques to speed up the process. Experimental tests have shown that the resulting implementation outperforms a state-of-the-art branch-and-cut method, both in solution quality and in computational time. This is especially evident when the size of the fleet involved is quite large as in real applications. In particular, our branch-and-price has been able to optimally solve in a reasonable amount of time instances with up to 50 suppliers, 70 products, and 70% of cross-incompatibilities among products.

@&#ACKNOWLEDGMENT@&#

This work was partially supported by the Canadian Natural Science and Engineering Research Council (NSERC) through its Discovery Grants Program.

@&#REFERENCES@&#

