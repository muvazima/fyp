@&#MAIN-TITLE@&#Flow shop scheduling with heterogeneous workers

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We extend the flow shop scheduling problem to consider heterogeneous workers.


                        
                        
                           
                           We provide a model and propose a heuristic solution for the problem.


                        
                        
                           
                           Computational results show that this approach finds good solutions in a short time.


                        
                        
                           
                           Solving the extended problem can reduce the makespan and hide incompatibilities.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Scheduling

Metaheuristics

Flow shop

Integer programming

Heterogeneous workers

@&#ABSTRACT@&#


               
               
                  We propose an extension to the flow shop scheduling problem named Heterogeneous Flow Shop Scheduling Problem (Het-FSSP), where two simultaneous issues have to be resolved: finding the best worker assignment to the workstations, and solving the corresponding scheduling problem. This problem is motivated by Sheltered Work centers for Disabled, whose main objective is the labor integration of persons with disabilities, an important aim not only for these centers but for any company desiring to overcome the traditional standardized vision of the workforce. In such a scenario the goal is to maintain high productivity levels by minimizing the maximum completion time, while respecting the diverse capabilities and paces of the heterogeneous workers, which increases the complexity of finding an optimal schedule. We present a mathematical model that extends a flow shop model to admit a heterogeneous worker assignment, and propose a heuristic based on scatter search and path relinking to solve the problem. Computational results show that this approach finds good solutions within a short time, providing the production managers with practical approaches for this combined assignment and scheduling problem.
               
            

@&#INTRODUCTION@&#

According to the International Labour Organization, persons with disabilities represent an estimated ten percent of the worlds population. This amounts to about 700million people worldwide, out of whom almost 500million are in working age and usually suffering much higher unemployment rates than other people. Governments have implemented different policies for the integration of persons with disabilities such as reserving a percentage of jobs in companies, or creating Sheltered Work centers for Disabled (SWDs). SWDs have been adopted successfully in countries such as Spain, facilitating jobs for disabled workers, both as a transition formula towards real integration or as stable workplaces, by overcoming certain prejudices and by considering the workforce as heterogeneous as it actually is. Although SWDs receive some institutional support, they compete in real labor markets. Thus, they need to be efficient and competitive, not only for their survival but also to be able to grow (to promote new jobs), and they must ensure socialemployment integration for their workers, taking into account their limitations and aiming to evolve positively their capabilities and capacities (Miralles, Marin-Garcia, Ferrus, & Costa, 2010).

Most Operations Research/Management Science (OR/MS) approaches and tools standardize the processing time of every operation independently of the worker that performs it. This assumption is not realistic and may cause serious planning and control problems. Moreover, the decision making process of defining the master schedule or the workplace assignments becomes harder when the production manager has to cope with rigid information systems that disregard heterogeneity of skills. In these cases the next best solution is often to compensate in advance the existent deviations in the workforce (sometimes with rules of thumb), or by using a not very efficient “worst case” scenario. These measures lead to implement suboptimal solutions and many output results will be difficult to check, because of aggregated effects from the planning compensations, and because of rush adaptations made by the workers themselves, with clear differences between the defined scenarios and the reality, and without any control in the corresponding indicators. Instead, it would be more reliable to assume the workers heterogeneity, to estimate a priori the deviations, and to feed the planning/scheduling process with real, approximate data including this heterogeneity.

The OR/MS area is progressively proposing approaches that address the human diversity in the procedures for Design, Planning & Control of productive systems, thus contributing to narrow the gap between research and practice. Some authors do this by using a fuzzy or stochastic model of task execution times (e.g. Erel, Sabuncuoglu, & Sekerci, 2005), and others by directly categorizing different kinds of workers (e.g. Corominas, Pastor, & Plans, 2008). The Assembly Line Worker Assignment and Balancing Problem (ALWABP) focuses in the heterogeneity of task times and the presence of incompatibilities, defining a new set of realistic hypotheses originally inspired by assembly lines in SWDs. Thus, from the initial paper of Miralles, Garcia-Sabater, Andrés, and Cardos (2007), many other authors have contributed to give this problem visibility proposing different extensions and methods to solve it (see for example Miralles et al. (2010), Blum & Miralles (2011), Moreira, Ritt, Costa, & Chaves (2012) and Corominas, Ferrer, & Pastor (2012)).

To the best of our knowledge, the problem of worker diversity when scheduling jobs in flow shop systems has not been addressed in the literature. If the workers are heterogeneous, then the processing time of an operation performed on a machine will depend on the assigned worker. The term “machine” is the usual term in the flow shop literature, but it refers to a work center in which the process performed may be automated or manual. Furthermore, in such a scenario, the complete solution of the problem consists of two elements: as usual, a schedule of jobs that optimizes a given objective function, and, additionally, the optimal allocation of workers to work centers (machines) that helps to get the best possible solution. The additional worker assignment increases the number of possible solutions of the normal non-permutation flow shop by a factor of 
                           
                              m
                              !
                           
                        . Therefore, sophisticated resolution methods are necessary in order to obtain the optimal worker allocation and the corresponding optimal schedule in reasonable computation time. In fact computation time is important due to rescheduling caused by workers rotation, turnover and absenteeism, mainly in SWDs where periodical health and psychological support are mandatory (Miralles et al., 2007).

Although the initial scenario that inspired this research was a SWD (as a perfect test bed where more than 70% of workers are disabled with different skills), this paper aims to present new models and approaches to cope with issues that arise in ordinary companies when the natural human diversity of workers needs to be considered, with or without regard to disabilities.

The next section reviews the main references on flow shop scheduling in the literature. Section 3 gives an example of the problem of finding a flow shop schedule for a heterogeneous workforce. In Section 4 we define the problem formally by a mathematical model, and in Section 5 we propose a scatter search with path relinking for solving it. We define a new set of instances which models the situation of heterogeneous workers in Section 6, and present computational experiments with standard solvers and the proposed heuristic. Finally, in Section 7, we analyze and discuss the results and conclude.

In a flow shop scheduling problem (FSSP) we have to schedule a set of jobs 
                        
                           
                              
                                 J
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 J
                              
                              
                                 n
                              
                           
                        
                      on machines 
                        
                           
                              
                                 M
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 M
                              
                              
                                 m
                              
                           
                        
                     . Job 
                        
                           
                              
                                 J
                              
                              
                                 j
                              
                           
                        
                      consists of m operations 
                        
                           
                              
                                 o
                              
                              
                                 1
                                 j
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 o
                              
                              
                                 mj
                              
                           
                        
                     . Operation 
                        
                           
                              
                                 o
                              
                              
                                 ij
                              
                           
                        
                      must be processed on machine 
                        
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                        
                      in time 
                        
                           
                              
                                 p
                              
                              
                                 ij
                              
                           
                        
                      without preemption. The jobs cannot be processed in parallel, and the machines can execute only one operation at any given instant. Each job must be processed on the machines in the given order. If, in addition, each machine has to process all jobs in the same order, we obtain the particular case of a permutation flow shop scheduling problem (PFSSP). The most common objective function in flow shop scheduling is to minimize the makespan 
                        
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                     , i.e. the maximum completion time of any operation, which is also the focus of this paper. The two problems are also denoted by 
                        
                           F
                           ‖
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                      and 
                        
                           F
                           |
                           prmu
                           |
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                     . For up to three machines both have the same optimal makespan. 
                        
                           F
                           ‖
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                      can be solved in time 
                        
                           O
                           (
                           n
                           log
                           n
                           )
                        
                      for two machines, but is strongly NP-hard for three or more machines.


                     Fig. 1
                      shows an example of the FSSP. The table on the left gives the processing times of four jobs on four machines. The optimal schedule shown on the right has makespan 11. Note that this is a non-permutation schedule, since jobs two and three exchange their processing order on machine three. In this paper we permit non-permutation schedules, since our motivating application in SWDs is not restricted to permutation schedules.

The makespan of a schedule is defined by a critical path, which is a sequence of consecutive operations on the same machine or of the same job that leads to the longest overall duration. A critical path can be decomposed in maximal blocks of operations that are executed on the same machine. Critical paths are important in exact and heuristic algorithms, since we must reduce their total time in order to improve a schedule. In the example of the schedule of Fig. 1, the critical path is given by the striped operations.

@&#RELATED WORK@&#

Since most of the extensive literature on flow shop scheduling focuses on the PFSSP, and these results are often also useful in the general case, we give first a brief overview on methods restricted to permutation schedules, and then discuss previous work on non-permutation schedules. For a more detailed account we refer to the excellent surveys of Ruiz and Maroto (2005) and Potts and Strusevich (2009).

Due to the difficulty of the PFSSP, most authors propose heuristics for obtaining approximate solutions. Among the constructive heuristics proposed for the PFSSP, variants of the algorithm NEH of Nawaz, Enscore, and Ham (1983) have been consistently found to perform best (Kalczynski & Kamburowski, 2011; Ruiz & Maroto, 2005).

The currently best performing improvement and recombination heuristics are the ant colony algorithms of Rajendran and Ziegler (2004), the hybrid genetic algorithm of Ruiz, Marato, and Alcaraz (2006), the hybrid particle swarm optimization of Tasgetiren, Liang, Sevkli, and Gencyilmaz (2007), the iterated greedy algorithm of Ruiz and Stützle (2007), and the hybridization of a genetic algorithm with variable neighborhood search of Zobolas, Tarantilis, and Ioannou (2009). On standard instances these heuristics produce in time nm/10seconds schedules whose makespan deviates less than 1% from the best known values.

Algorithms with proven guarantees are much more limited: the best (randomized) polynomial-time approximation algorithm comes only within a factor 
                           
                              O
                              (
                              
                                 
                                    min
                                    {
                                    m
                                    ,
                                    n
                                    }
                                 
                              
                              )
                           
                         of the optimal makespan (Nagarajan & Sviridenko, 2009). State-of-the-art exact algorithms based on branch-and-bound solve most of the standard instances up to 10 machines within a few hours, but are unable to solve instances with more machines (Companys & Mateo, 2007; Ladhari & Haouari, 2005).

Since the worst case gap between non-permutation and permutation schedules is a factor of 
                           
                              Θ
                              (
                              
                                 
                                    m
                                 
                              
                              )
                           
                         (Nagarajan & Sviridenko, 2009), non-permutation schedules may be much shorter. The gain in practical instances, however, seems limited to a few percent (Liao, Liao, & Tseng, 2006; Tandon, Cummings, & Levan, 1991).

Several constructive heuristics that produce non-permutation schedules have been proposed. Gonzalez and Sahni (1978) solve two-machine flow shop problems on subsequent machine pairs optimally and join the obtained schedules, in time 
                           
                              O
                              (
                              mn
                              log
                              n
                              )
                           
                        . Their algorithm is a 
                           
                              ⌈
                              m
                              /
                              2
                              ⌉
                           
                        -approximation. The guarantee has been slightly improved by Chen, Glass, Potts, and Strusevich (1996) to 
                           
                              m
                              /
                              2
                              +
                              1
                              /
                              6
                           
                        . The heuristic of Koulamas (1998) solves all 
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                m
                                             
                                          
                                          
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                         two-machine subproblems optimally and schedules the jobs in non-decreasing order of their summed rank, followed by an improvement procedure that can produce non-permutation schedules. Further constructive heuristics have been proposed by Leisten (1990), Tandon et al. (1991) and Pugazhendhi, Thiagarajan, Rajendran, and Anantharaman (2002).

Only a few authors have applied metaheuristics to minimize the makespan in a non-permutation FSSP. The main approaches are simulated annealing (Tandon et al., 1991), tabu search (Brucker, Heitmann, & Hurink, 2003; Liao et al., 2006), iterated greedy algorithm (Ying, 2008), and ant colony optimization (Rossi & Lanzetta, 2013; Sadjadi, Bouquard, & Ziaee, 2008; Yagmahan & Yenisey, 2010; Ying & Lin, 2007).

The current best results have been found by a hybrid of simulated annealing and tabu search proposed by Lin and Ying (2009). It limits the search space to three permutations for the first two, the last two, and the remaining machines. Simulated annealing operates on a neighborhood that swaps two random jobs in one of the three permutations. It additionally uses a short-term memory, a standard component of tabu search, that prevents a job to return to its previous rank in the permutation during the tabu tenure.


                     Table 1
                      shows a situation where we have four workers, which we want to assign to four machines. Some of them may be unable to operate a subset of the machines (for therapeutic or strategic reasons). In the example, worker 2 is unable to operate machine 4, represented by a processing time of 
                        
                           ∞
                        
                     . Moreover, the workers may have different execution times for the same operations. In this example, we chose processing times randomly in the interval 
                        
                           [
                           p
                           ,
                           2
                           p
                           ]
                        
                     , for a processing time of p in the original flow shop instance given in Fig. 1. The increase of the average processing time (excluding incompatibilities) is 
                        
                           1.46
                        
                     , and thus we can expect to achieve a makespan of about 16.

If we maintain the optimal schedule of the original instance, and evaluate different allocations of workers to machines, we get an average makespan of 
                        
                           18.8
                        
                      over all 18 valid permutations. The best assignment found this way has a makespan of 17, and the worst has a makespan of 22. The best assignment (assigning workers 
                        
                           3
                           ,
                           1
                           ,
                           2
                           ,
                           4
                        
                      to the machines in this order) is shown in the left part of Fig. 2
                     . On the other hand, if we construct the optimal schedule considering the heterogeneity of the workers, we can reduce the makespan to 15. This optimal solution is shown in the right part of Fig. 2.

The example shows, that the optimal schedule considering the heterogeneity of the workers can improve over a more naive strategy. In this case the optimal solution of 15 is about 12% less than the best assignment for the optimal flow shop schedule. In Section 6 we will quantify this behavior in larger instances.

In this section we present a formulation of the flow shop scheduling problem with heterogeneous workers. We use the index i for machines, j for jobs, and w for workers, and the notation 
                        
                           [
                           n
                           ]
                           =
                           {
                           1
                           ,
                           …
                           ,
                           n
                           }
                        
                     . The Het-FSSP can be formulated as
                        
                           (1)
                           
                              min
                              .
                              
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (2)
                           
                              s
                              .
                              t
                              .
                              
                              
                                 
                                    x
                                 
                                 
                                    mj
                                 
                              
                              +
                              
                                 
                                    p
                                 
                                 
                                    mj
                                 
                              
                              ⩽
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                              ,
                              
                              ∀
                              j
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (3)
                           
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                              
                              +
                              
                                 
                                    p
                                 
                                 
                                    ij
                                 
                              
                              ⩽
                              
                                 
                                    x
                                 
                                 
                                    i
                                    +
                                    1
                                    ,
                                    j
                                 
                              
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              -
                              1
                              ]
                              ,
                              
                              j
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (4)
                           
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                              
                              +
                              
                                 
                                    p
                                 
                                 
                                    ij
                                 
                              
                              ⩽
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          ij
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              +
                              M
                              (
                              1
                              -
                              
                                 
                                    y
                                 
                                 
                                    
                                       
                                          ijj
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              )
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                              
                              j
                              
                              ≠
                              
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (5)
                           
                              
                              
                                 
                                    y
                                 
                                 
                                    
                                       
                                          ijj
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              +
                              
                                 
                                    y
                                 
                                 
                                    
                                       
                                          ij
                                       
                                       
                                          ′
                                       
                                    
                                    j
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                              
                              j
                              
                              ≠
                              
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (6)
                           
                              
                              
                                 
                                    p
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       w
                                       ∈
                                       [
                                       m
                                       ]
                                    
                                 
                              
                              
                                 
                                    p
                                 
                                 
                                    ijw
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    iw
                                 
                              
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                              
                              j
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (7)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       w
                                       ∈
                                       [
                                       m
                                       ]
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    iw
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                           
                        
                     
                     
                        
                           (8)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ∈
                                       [
                                       m
                                       ]
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    iw
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              w
                              ∈
                              [
                              m
                              ]
                              ,
                           
                        
                     
                     
                        
                           (9)
                           
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                              
                              ⩾
                              0
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                              
                              j
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (10)
                           
                              
                              
                                 
                                    y
                                 
                                 
                                    
                                       
                                          ijj
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              
                              ∀
                              i
                              ∈
                              [
                              m
                              ]
                              ,
                              
                              j
                              
                              ≠
                              
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              ∈
                              [
                              n
                              ]
                              ,
                           
                        
                     
                     
                        
                           (11)
                           
                              
                              
                                 
                                    z
                                 
                                 
                                    iw
                                 
                              
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              
                              ∀
                              i
                              ,
                              w
                              ∈
                              [
                              m
                              ]
                              .
                           
                        
                     In this formulation, the auxiliary variables 
                        
                           
                              
                                 x
                              
                              
                                 ij
                              
                           
                        
                      and 
                        
                           
                              
                                 p
                              
                              
                                 ij
                              
                           
                        
                      represent the starting time and processing time of the operation of job j that must be executed on machine i. Constraints (2)–(5) solve the flow shop subproblem for a fixed worker allocation: constraint (2) defines 
                        
                           
                              
                                 C
                              
                              
                                 max
                              
                           
                        
                      as the latest completion time, and constraints (3) and (4) set the starting time of all operations according to the precedences. The constant M should be sufficiently large (e.g. 
                        
                           
                              
                                 ∑
                              
                              
                                 i
                                 ∈
                                 [
                                 m
                                 ]
                              
                           
                           
                              
                                 ∑
                              
                              
                                 j
                                 ∈
                                 [
                                 n
                                 ]
                              
                           
                           
                              
                                 max
                              
                              
                                 w
                                 ∈
                                 [
                                 m
                                 ]
                              
                           
                           
                              
                                 p
                              
                              
                                 i
                                 ,
                                 j
                                 ,
                                 w
                              
                           
                        
                     ). For each pair of operations of different jobs 
                        
                           j
                           ,
                           
                              
                                 j
                              
                              
                                 ′
                              
                           
                        
                      that must be processed on the same machine i, and whose precedence is not fixed, we introduce a binary decision variable 
                        
                           
                              
                                 y
                              
                              
                                 
                                    
                                       ijj
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                        
                     , which equals 1 if j precedes 
                        
                           
                              
                                 j
                              
                              
                                 ′
                              
                           
                        
                      on machine i. Thus, constraint (5) enforces precedence relations for operations on the same machine. The processing time of an operation depends on the worker assigned to its machine, and is defined in constraint (6) based on the processing time 
                        
                           
                              
                                 p
                              
                              
                                 ijw
                              
                           
                        
                      of the operation 
                        
                           
                              
                                 o
                              
                              
                                 ij
                              
                           
                        
                      when executed by worker w. We introduce a binary assignment variable 
                        
                           
                              
                                 z
                              
                              
                                 iw
                              
                           
                        
                      which equals 1 if worker w is assigned to machine i. Constraints (7) and (8) define the assignment of workers to machines.

Scatter search is a meta-heuristic that explores the search space by systematically selecting and evolving a set of reference solutions. In each step it forms several subsets of the solutions in the reference set, combines them to produce new solutions, possibly applies an improvement method to them, and then updates the reference set. Scatter search aims to strategically include elements of diversification and intensification. A basic scatter search procedure has five main elements. A diversification generation method is used to produce a large, initial pool of diverse solutions. An improvement method is applied to each solution in the pool and an initial reference set is created by a reference set update method drawing from the solutions in the pool. The reference set update method aims to choose solutions that are of good quality and sufficiently distributed in the solution space. In each iteration, a new pool of solutions is created by a subset generation method followed by a solution combination method that produces one or more new solutions from the solutions in each subset. The new solutions are subjected to the improvement method and enter the new pool. A good overview of scatter search can be found in Laguna and Martí (2003).

Scatter search may use path relinking as a solution combination method. Path relinking is a strategy that explores trajectories between two solutions. One solution is the starting point of the trajectory, and the other the guiding solution. The trajectory between them is explored by repeatedly applying to the current solution the best local modification that makes it more similar to the guiding solution. Formally, if 
                        
                           N
                           (
                           s
                           )
                        
                      is the set of neighbors of the current solution s, and 
                        
                           d
                           (
                           s
                           ,
                           
                              
                                 s
                              
                              
                                 ′
                              
                           
                           )
                        
                      a distance measure between solution s and the guiding solution 
                        
                           
                              
                                 s
                              
                              
                                 ′
                              
                           
                        
                     , path relinking explores the directed neighborhood 
                        
                           D
                           (
                           s
                           )
                           =
                           {
                           
                              
                                 s
                              
                              
                                 ″
                              
                           
                           ∈
                           N
                           (
                           s
                           )
                           |
                           d
                           (
                           
                              
                                 s
                              
                              
                                 ″
                              
                           
                           ,
                           
                              
                                 s
                              
                              
                                 ′
                              
                           
                           )
                           <
                           d
                           (
                           s
                           ,
                           
                              
                                 s
                              
                              
                                 ′
                              
                           
                           )
                           }
                        
                     . Path relinking is called forward when the better of the two solutions is the starting solution, and backward otherwise. The exploration stops, when the guiding solution is reached. For a good review of scatter search with path relinking see Resende, Ribeiro, Glover, and Martí (2010).

An overview of the scatter search procedure that we propose is shown in Algorithm 1. It maintains a reference set of high quality solutions as well as a reference set of diverse solutions. Pairs of solutions from these two sets will be combined using a positional combination method for the worker permutations, and path relinking for the sequence of operations. A local search improves the new solutions. The scatter search stops after a fixed number of iterations or after a time limit is exceeded. Next, we explain the individual components of the proposed scatter search in detail.
                        Algorithm 1
                        A heuristic based on scatter search for the Het-FSSP. 
                              
                                 
                                    
                                    
                                       
                                          
                                             Input: Initial pool size t.
                                       
                                       
                                          
                                             Output: Best found solution 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                
                                             .
                                       
                                       
                                          
                                             1: Create an initial pool T of t solutions.
                                       
                                       
                                          
                                             2: repeat
                                          
                                       
                                       
                                          
                                             3: Update reference sets 
                                                
                                                   
                                                      
                                                         RS
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                              and 
                                                
                                                   
                                                      
                                                         RS
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                              with elements of T (Algorithm 2)
                                       
                                       
                                          
                                             4: 
                                             
                                                
                                                   T
                                                   ←
                                                   ∅
                                                
                                             
                                          
                                       
                                       
                                          
                                             5: 
                                             for 
                                             
                                                
                                                   ∀
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ∈
                                                   
                                                      
                                                         RS
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                              
                                             do
                                          
                                       
                                       
                                          
                                             6: 
                                             for 
                                             
                                                
                                                   ∀
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   ∈
                                                   
                                                      
                                                         RS
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                              
                                             do
                                          
                                       
                                       
                                          
                                             7: 
                                             combine solutions 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                              and 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                              into solution 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         new
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             8: 
                                             apply local search to 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         new
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             9: 
                                             
                                             
                                                
                                                   T
                                                   ←
                                                   T
                                                   ∪
                                                   {
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         new
                                                      
                                                   
                                                   }
                                                
                                             
                                          
                                       
                                       
                                          10: 
                                             update 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                
                                              with 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         new
                                                      
                                                   
                                                
                                              if necessary
                                       
                                       
                                          11: Until stopping criterion is satisfied
                                       
                                       
                                          12: return 
                                             
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

A solution of the Het-FSSP consists of an assignment of workers to machines, and the sequence of the operations on each machine. It is represented by 
                           
                              S
                              =
                              (
                              ρ
                              ,
                              
                                 
                                    π
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    π
                                 
                                 
                                    m
                                 
                              
                              )
                           
                         where 
                           
                              ρ
                           
                         is a permutation of the workers which defines the assignment to the machines, and 
                           
                              
                                 
                                    π
                                 
                                 
                                    i
                                 
                              
                           
                         is the permutation of the operations on machine 
                           
                              
                                 
                                    M
                                 
                                 
                                    i
                                 
                              
                           
                        .

The diversification generation method is a randomized constructive algorithm, which produces a permutation schedule. It first generates a random, feasible assignment of the workers to the machines, and a random permutation 
                           
                              π
                           
                         of the jobs. Then, starting from an empty schedule, it iteratively inserts the next job in 
                           
                              π
                           
                         at the position that minimizes makespan of the partial schedule. Solutions for the initial pool are generated with this method.

The reference set is created from the current solution pool. The search maintains two reference sets 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                        . Reference set 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                           
                         contains high quality solutions of a certain diversity, and reference set 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                         contains more diverse solutions. Diversity is guaranteed by maintaining a minimum distance between the solutions.

The distance of the solutions is defined as the sum of the Kendall-tau distances of the permutations of the operations for each machine, plus the number of workers that have been assigned to different machines. Formally, for two n-permutations 
                           
                              π
                           
                         and 
                           
                              
                                 
                                    π
                                 
                                 
                                    ′
                                 
                              
                           
                         the Kendall-tau distance is defined as 
                           
                              K
                              (
                              π
                              ,
                              
                                 
                                    π
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              |
                              {
                              (
                              j
                              ,
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              )
                              |
                              j
                              
                              ≠
                              
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              ,
                              π
                              (
                              j
                              )
                              <
                              π
                              (
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              )
                              ∧
                              
                                 
                                    π
                                 
                                 
                                    ′
                                 
                              
                              (
                              j
                              )
                              >
                              
                                 
                                    π
                                 
                                 
                                    ′
                                 
                              
                              (
                              
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              )
                              }
                              |
                           
                        . Then, the distance between two solutions 
                           
                              S
                              =
                              (
                              ρ
                              ,
                              
                                 
                                    π
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    π
                                 
                                 
                                    m
                                 
                              
                              )
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    ′
                                 
                              
                              =
                              (
                              
                                 
                                    ρ
                                 
                                 
                                    ′
                                 
                              
                              ,
                              
                                 
                                    π
                                 
                                 
                                    1
                                 
                                 
                                    ′
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    π
                                 
                                 
                                    m
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         is 
                           
                              d
                              (
                              S
                              ,
                              
                                 
                                    S
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              |
                              {
                              k
                              |
                              ρ
                              (
                              k
                              )
                              
                              ≠
                              
                              
                                 
                                    ρ
                                 
                                 
                                    ′
                                 
                              
                              (
                              k
                              )
                              }
                              |
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    1
                                    ⩽
                                    k
                                    ⩽
                                    m
                                 
                              
                              K
                              (
                              
                                 
                                    π
                                 
                                 
                                    k
                                 
                              
                              ,
                              
                                 
                                    π
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                        .

To guarantee diverse solutions in the reference sets, we allow to add to 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                           
                         only solutions with a distance of at least 
                           
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                           
                         to all solutions in the set. Similarly, a solution may be added to 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                         only if it has a distance of at least 
                           
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                           
                         to the current solutions in 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                              ∪
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                        . A higher diversity of solutions in 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                         is achieved by setting 
                           
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              >
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                           
                        .

The reference set update procedure is shown in Algorithm 2. Reference set 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                           
                         is constructed by adding the solutions from the pool T in order of non-increasing quality, when they satisfy the diversity criterion explained above. A solution which has less distance than required is discarded. Reference set 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                         is constructed in the same manner using the remaining solutions in the pool. If the solution pool is exhausted during the construction, the missing elements of reference set 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                         are completed by newly generated solutions that are not required to satisfy the diversity criterion. This guarantees that the construction of both reference sets is always successful.
                           Algorithm 2
                           Update reference sets. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: Pool T, reference set sizes 
                                                   
                                                      
                                                         
                                                            rs
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            rs
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                , minimum distances 
                                                   
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                Output: Reference sets 
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                1: 
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ←
                                                   
                                                 { best element of T}; 
                                                   
                                                      T
                                                      ←
                                                      T
                                                      ⧹
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                2: while 
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      |
                                                      <
                                                      
                                                         
                                                            rs
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                 and 
                                                   
                                                      |
                                                      T
                                                      |
                                                      >
                                                      0
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                3: 
                                                
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      ←
                                                   
                                                 best element of 
                                                   
                                                      T
                                                      ;
                                                      T
                                                      ←
                                                      T
                                                      ⧹
                                                      {
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      }
                                                   
                                                .
                                          
                                          
                                             
                                                4: 
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            min
                                                         
                                                         
                                                            r
                                                            ∈
                                                            
                                                               
                                                                  RS
                                                               
                                                               
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                      d
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      ,
                                                      r
                                                      )
                                                      ⩾
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                5: 
                                                
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ←
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ∪
                                                      {
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      }
                                                   
                                                
                                             
                                          
                                          
                                             
                                                6: 
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ←
                                                      ∅
                                                   
                                                .
                                          
                                          
                                             
                                                7: while 
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      |
                                                      <
                                                      
                                                         
                                                            rs
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                 and 
                                                   
                                                      |
                                                      T
                                                      |
                                                      >
                                                      0
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                8: 
                                                
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      ←
                                                   
                                                 best element of 
                                                   
                                                      T
                                                      ;
                                                      T
                                                      ←
                                                      T
                                                      ⧹
                                                      {
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      }
                                                   
                                                .
                                          
                                          
                                             
                                                9: 
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            min
                                                         
                                                         
                                                            r
                                                            ∈
                                                            
                                                               
                                                                  RS
                                                               
                                                               
                                                                  1
                                                               
                                                            
                                                            ∪
                                                            
                                                               
                                                                  RS
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                      d
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      ,
                                                      r
                                                      )
                                                      ⩾
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             10: 
                                                
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ←
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ∪
                                                      {
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      }
                                                   
                                                
                                             
                                          
                                          
                                             11: fill 
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                 with newly generated solutions, if necessary
                                          
                                          
                                             12: return 
                                                
                                                   
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            RS
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

A new solution pool is created by combining solution subsets from the reference sets. Each subset has one solution of both reference sets 
                           
                              
                                 
                                    RS
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    RS
                                 
                                 
                                    2
                                 
                              
                           
                        . The two solutions are combined in two steps. The first step in the solution combination is to reassign workers. We use a positional combination method to produce a new worker permutation 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    ″
                                 
                              
                           
                         from the two worker permutations 
                           
                              ρ
                           
                         and 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    ′
                                 
                              
                           
                        . An example is given in Fig. 3
                        . A worker that has been assigned to the same machine in both permutations will also be assigned to this machine in 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    ″
                                 
                              
                           
                        . Next, a partial combination is built by randomly choosing a worker for each free machine from 
                           
                              ρ
                           
                         or 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    ′
                                 
                              
                           
                        . If the chosen worker has not been assigned yet, he is assigned in 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    ″
                                 
                              
                           
                        , otherwise the machine remains free. Finally, the yet unassigned workers are assigned randomly to the free machines.

The second step combines the schedules of both solutions using path relinking while maintaining the new worker assignment. Before path relinking, the current solution is updated to use the processing times of the new worker assignment, and the critical path of the solution is determined. If there are several critical paths, ties are broken by preferring the one having the largest sequence of consecutive operations on the same machine backwards from the latest operation. The critical path is decomposed into maximal sequences of consecutive operations on the same machine, called blocks.

Path relinking uses two neighborhoods. Both swap consecutive operations in blocks on the critical path of the current solution. The first neighborhood contains all solutions that can be obtained by swapping the order of the first or last two operations in a block on the critical path, whose processing order is inverted in the guiding solution, excluding the first two operations of the first block and the last two operations of the last block. For example, suppose that the right schedule in Fig. 2 is the current solution, and the left one the guiding solution. Then, the first neighborhood contains only the solution that is obtained by swapping operations 
                           
                              
                                 
                                    o
                                 
                                 
                                    24
                                 
                              
                           
                         and 
                           
                              
                                 
                                    o
                                 
                                 
                                    23
                                 
                              
                           
                        , since operation pairs 
                           
                              (
                              
                                 
                                    o
                                 
                                 
                                    22
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    24
                                 
                              
                              )
                           
                         and 
                           
                              (
                              
                                 
                                    o
                                 
                                 
                                    43
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    44
                                 
                              
                              )
                           
                         have the same order in the guiding solution.

The second neighborhood is used when the first neighborhood is empty. It contains all solutions that can be obtained by swapping any pair of consecutive operations in a block whose processing order is inverted in the guiding solution, since path relinking does not need to improve the current solution, but always must get closer to the guiding solution.

The exploration finishes when there are no more possible swaps in the critical path that get closer to the guiding solution. Finally, the combined solution is obtained by applying the improvement method to the best solution found on the explored trajectory.

We use a local search as the improvement method. It explores the reduced neighborhood proposed by Nowicki and Smutnicki (1996). This neighborhood is limited to swap the two first or the two last consecutive operations of a block on the critical path. Furthermore, only the two last operations in the first block, and only the two first operations in the last block are swapped. For example, the neighborhood of the right schedule in Fig. 2 contains three solutions, obtained by swapping the operation pairs (
                           
                              
                                 
                                    o
                                 
                                 
                                    24
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    23
                                 
                              
                           
                        , 
                           
                              
                                 
                                    o
                                 
                                 
                                    22
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    24
                                 
                              
                           
                        ), or (
                           
                              
                                 
                                    o
                                 
                                 
                                    43
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    44
                                 
                              
                           
                        ). In each step, the local search chooses the best neighbor to replace the current solution. It stops when there are no better solutions in the neighborhood. The solution obtained after local search is inserted into the pool T to later update the reference sets.

For the computational experiments we created instances for the Het-FSSP, based on the flow shop instances of Carlier (1978) and Taillard (1993). We assume that the processing times 
                           
                              
                                 
                                    p
                                 
                                 
                                    ij
                                 
                              
                           
                         of the instances are those of a standard worker, and modify them in two ways: First, a fixed percentage of incompatibilities is introduced. An incompatibility models the case of a worker who is unable to execute an operation at some machine, as, for example, worker 2 and machine 4 in the instance of Table 1. Based on experiences with existing SWDs, we chose to generate instances with 0%, 10% and 20% of incompatibilities per worker. Second, the processing times are randomized to simulate different abilities of workers. The processing time p of a standard worker for some operation is increased by choosing uniformly at random a processing time in the interval 
                           
                              [
                              p
                              ,
                              2
                              p
                              ]
                           
                         or 
                           
                              [
                              p
                              ,
                              5
                              p
                              ]
                           
                        . This procedure is repeated m times to create m different workers. We refer to instances in the tables below by the name of the base instance, followed by an i for processing times in 
                           
                              [
                              p
                              ,
                              2
                              p
                              ]
                           
                         or an I for processing times in 
                           
                              [
                              p
                              ,
                              5
                              p
                              ]
                           
                        , and the percentage of incompatibilities. The instances as well as the detailed computational results reported below can be obtained at http://www.inf.ufrgs.br/algopt/hetFS.

The proposed scatter search was implemented in C++, and compiled with GNU C++ 4.7.3 with optimization level 2 (-O2). The mathematical model has been solved with CPLEX 12.4 running with a single thread and a time limit of one hour. All computational tests were executed on a PC with an AMD Opteron processor running at 2.9Gigahertz, and 64Gigabytes of main memory.

We use the following parameters for scatter search: an initial pool size of 
                           
                              t
                              =
                              60
                           
                        , distances 
                           
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                              =
                              10
                           
                         and 
                           
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              =
                              20
                           
                        , and reference set sizes 
                           
                              
                                 
                                    rs
                                 
                                 
                                    1
                                 
                              
                              =
                              6
                           
                         and 
                           
                              
                                 
                                    rs
                                 
                                 
                                    2
                                 
                              
                              =
                              4
                           
                        . Those parameters were the best in preliminary tests on 12 Taillard instances (
                           
                              1
                              ,
                              6
                              ,
                              …
                              ,
                              56
                           
                        ) and all 6 combinations of incompatibilities and processing time variations. They have been obtained by varying each distance independently in 
                           
                              {
                              5
                              ,
                              10
                              ,
                              …
                              ,
                              30
                              }
                           
                         and each reference set size in 
                           
                              {
                              2
                              ,
                              4
                              ,
                              …
                              ,
                              10
                              }
                           
                        .

We also tested forward and backward path relinking strategies. Both strategies produced very similar results. We chose backward path relinking, since it performed with an average relative deviation of 
                           
                              1.5
                              %
                           
                         from the best known value slightly better than forward path relinking with a value of 
                           
                              1.6
                              %
                           
                        .

Scatter search was given a time limit of ten minutes as a stopping criterion. Since it makes random choices when initializing and updating the reference sets, we replicated each experiment 50 times and report averages. We compare the solutions obtained by scatter search to those obtained by solving the mathematical model of Section 4 and a randomized local search.


                        Tables 2–5
                        
                        
                        
                         present results for the CPLEX solver with the proposed model and for the scatter search. Tables 2 and 3 show results for Carlier instances, and Tables 4 and 5 for the first sixty Taillard instances. Tables 2 and 4 present the results for instances with processing times in 
                           
                              [
                              p
                              ,
                              2
                              p
                              ]
                           
                        , and Tables 3 and 5 for instances with processing times in 
                           
                              [
                              p
                              ,
                              5
                              p
                              ]
                           
                        . All tables report the size of the instances (
                           
                              n
                              ×
                              m
                           
                        ), the best known upper bound ub on the optimal makespan, the relative deviation in percent of a solution with makespan 
                           
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                           
                         from the best known solution 
                           
                              %
                              R
                              =
                              100
                              %
                              ×
                              (
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                              -
                              ub
                              )
                              /
                              ub
                           
                         (or its average 
                           
                              
                                 
                                    %
                                    R
                                 
                                 
                                    ‾
                                 
                              
                           
                         over a group of instances), the percentage relative gap (
                           
                              gap
                              %
                           
                        ) between the lower and upper bounds found by CPLEX (or its average 
                           
                              
                                 
                                    gap
                                    %
                                 
                                 
                                    ‾
                                 
                              
                           
                         over a group of instances), the average time 
                           
                              
                                 
                                    t
                                 
                                 
                                    ‾
                                 
                              
                           
                         that scatter search takes to reach the best value of each test, and the percentage of tests where scatter search reached the best known solution (
                           
                              %
                              ub
                           
                        ).

In 1hour CPLEX was able to prove the optimality of instances car7i00, car7i10, and car7i20. In the remaining Carlier instances the gap between the lower and the upper bound ranges from 6% to 42%. CPLEX finds solutions for all the Carlier instances, and the best known solution in 20 of the 48 instances. For the Taillard instances, the gap increases with the size of the instance from 60% to 94%. CPLEX always finds solutions for the Taillard instances up to size 
                           
                              50
                              ×
                              5
                           
                        , but only for 36 of the 60 instances of size 
                           
                              50
                              ×
                              10
                           
                        , and it is not able to solve any of the Taillard instances of size 
                           
                              50
                              ×
                              20
                           
                         within the time limit. Different from a normal flow shop, even the small Carlier instances of Het-FSSP cannot be solved optimally within one hour. This is expected since the number of possible solutions is a factor of 
                           
                              m
                              !
                           
                         larger due to the additional worker assignment.

Scatter search in 10minutes reaches better solutions than CPLEX in one hour for all the tested instances. All best known values were found by scatter search. In 43 of the 48 Carlier instances scatter search finds the same best makespan in all replications. For the remaining Carlier instances the average relative deviation from the best known value is less than 
                           
                              1.2
                           
                        %. All the best values of the Carlier instances were found in less than four minutes.

Scatter search also finds solutions for all the Taillard instances. Since the instances are substantially larger than the Carlier instances the time to find the best value is larger, and varies from about two to eight minutes with increasing size of the instance. Scatter search also exhibits more variation in the quality of the solutions for the Taillard instances: the average deviation reaches up to 5%, with larger gaps for increasing instance size, and in average 
                           
                              20
                              %
                           
                         of the replications find the best known value.

To further evaluate the performance of the scatter search, we solved the homogeneous non-permutation FSSP on Taillard’s instances 1–60. Our method finds 12 new best solutions and has an average relative deviation of 1.2% over the best known values of the non-permutation flow shop
                           1
                           These values are the smaller of the best known value for the PFSSP Taillard (2004) and the results from Vaessens (1996).
                        
                        
                           1
                         in a time comparable to other approaches (Lin & Ying, 2009; Rossi & Lanzetta, 2013). Given that the method was designed for a different problem, this indicates that it is reasonably effective in finding solutions of good quality.

The numerical results also indicate that the difficulty of solving the problem depends mainly on the instance size, and to a much lesser extent on the processing time variation and the percentage of incompatibilities. The average relative deviation from the best known value for instances with processing time in 
                           
                              [
                              p
                              ,
                              2
                              p
                              ]
                           
                         compared to instances with processing time in 
                           
                              [
                              p
                              ,
                              5
                              p
                              ]
                           
                         differs less than 0.7%, and less than 0.2% between instances with a different percentage of incompatibilities.

Finally, we were interested in assessing the benefit of solving the combined worker assignment and scheduling problem, compared to simpler approaches. To this aim we focused on the Carlier instances whose optimal non-permutation schedules are known (Carlier & Pinson, 1990), and computed two solutions: one that first finds the best homogeneous non-permutation schedule, and then assigns the workers such that the makespan of this schedule is minimized, and another that first finds the worker assignment that minimizes the total processing time of the jobs, and then determines the best non-permutation schedule. The makespan of the first solution is in average 2.7% (4.4%) longer than the best known values of the Het-FSSP for processing times chosen in the interval 
                           
                              [
                              p
                              ,
                              2
                              p
                              ]
                           
                         (
                           
                              [
                              p
                              ,
                              5
                              p
                              ]
                           
                        ). For the second solution the average increase is 1.2% (5.9%). This comparison shows that, while the increased processing times due to the disabilities of the workers obviously will increase the makespan, the solution of the combined problem is able to compensate a part of it, making the production process more efficient than solving the subproblems separately. The improvement over other ad hoc methods for scheduling heterogeneous workers, e.g. determining a flow shop schedule for the worst case processing times, is likely to be even worse.

In this paper we proposed an extension of the flow shop scheduling problem that considers heterogeneous workers. We gave a mathematical model of the problem that can be easily extended to other shop scheduling problems and proposed a scatter search with path relinking to solve it.

The Het-FSSP is considerably harder than a traditional flow shop, and therefore even small instances of its mathematical model cannot be solved by standard software. However, computational tests show that the problem can be solved satisfactorily by scatter search. The tests also indicate that its difficulty depends mainly on the size of the instance, and to a much lesser extent to the variation of the processing times and the number of worker-machine incompatibilities.

From a practical point of view, our proposal can be especially beneficial when all workers have different execution times and when, as it happens in SWDs, depending on the available resources and the workplaces assignment the optimal schedule varies. The computational tests show that solving the combined problem in such cases has benefits, compared to simpler methods.

But this first approximation to worker heterogeneity within flow shop systems is also crucial for those ordinary companies willing to integrate just a percentage of disabled workers as part of their policies of Corporate Social Responsibility. Our main conclusion is that companies can contribute to integrate people with disabilities in their production systems without important losses in productivity, and a very interesting further research line will be to study in detail the correlation between the degree of workers integration and the supposed productivity decrease.

@&#ACKNOWLEDGEMENTS@&#

We are grateful for the support by CAPES-Brazil and MEC-Spain (project CAPES-DGU258-12/PHB-0012-PC), by FAPERGS (project 12/2046-6), by Petrobras, by CNPq (project 478847/2013-0), and by the National Center for Supercomputing at UFRGS. We also thank the project “CORSARI MAGIC DPI2010-18243” of the Spanish Ministerio de Ciencia e Innovación.

@&#REFERENCES@&#

