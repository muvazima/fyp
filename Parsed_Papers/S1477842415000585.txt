@&#MAIN-TITLE@&#Declarative rewriting through circular nonterminal attributes

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A definition of circular NTAs, together with an evaluation algorithm.


                        
                        
                           
                           The introduction of the notion of computed children in an AST.


                        
                        
                           
                           Mappings between circular NTAs and rewrites, showing they are equivalent.


                        
                        
                           
                           An evaluation of the presented algorithm.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Attribute grammars

Reference attributes

Higher-order

Rewriting

@&#ABSTRACT@&#


               
               
                  Reference attribute grammars (RAGs) provide a practical declarative means to implement programming language compilers and other tools. RAGs have previously been extended to support nonterminal attributes (also known as higher-order attributes), circular attributes, and context-dependent declarative rewrites of the abstract syntax tree. In this previous work, interdependencies between these extensions are not considered. In this article, we investigate how these extensions can interact, and still be well defined. We introduce a generalized evaluation algorithm that can handle grammars where circular attributes and rewrites are interdependent. To this end, we introduce circular nonterminal attributes, and show how RAG rewrites are equivalent to such attributes.
               
            

@&#INTRODUCTION@&#

Reference attribute grammars (RAGs) [1] provide a practical declarative means to implement programming language compilers and other tools. Examples include a full Java compiler [2,3], as well as extensions to aspect-oriented, context-oriented and feature-oriented programming languages [4–6]. RAGs are an extension of Knuth׳s attribute grammars (AGs) [7], and support attributes whose values are references to remote nodes in the abstract syntax tree (AST). Reference attributes allow graphs to be computed declaratively from the AST, which is useful for a variety of purposes in a compiler, for example, the computation of inheritance graphs, control-flow graphs, etc.

Over the years, RAGs have been subject to a multitude of extensions. For instance, they have previously been extended to support higher-order attributes 
                     [8,2], from here on referred to as nonterminal attributes (NTAs). NTAs allow new nonterminals, i.e., new pieces of syntax tree, to be defined declaratively as attributes, which is useful for reifying implicit structures, for instantiating macro-like constructs, etc. Another extension to RAGs is circular attributes 
                     [9–11], that may depend (transitively) on themselves, and which can be computed by fixed-point iteration. Such attributes are useful, for instance, in data-flow analysis [12]. A third RAG extension is attribute-dependent rewrites 
                     [13], defining in-place transformations in the AST. This is useful, for example, to normalize or desugar an AST, and in name resolution, where general name nodes computed by a parser can be replaced by more specialized name nodes, e.g., class names or field names [14]. In this previous work, the extensions are considered in isolation, and possible interactions and dependencies between them have not been considered.

In this article, we introduce the notion of circular NTAs, and show that such attributes are equivalent to RAG rewrites. In mapping rewrites to circular NTAs we introduce the notion of computed children, which provides a compelling way to explain what RAGs with rewrites mean: An ordinary RAG is a function from an initial AST to an attributed initial AST; A RAG with NTAs is a function from an initial AST to an extended AST that is attributed; A RAG with rewrites is a function from an initial AST to a computed AST that is attributed. An extended AST is here an AST that is the same as the initial AST, but has additional nodes. In contrast, a computed AST does, in principle, not need to share more than the root with the initial AST.

While circular NTAs are equivalent to rewrites, the rewrite syntax is still preferable in a practical system. We introduce a new algorithm for evaluating rewrites that is based on translating them to circular NTAs. This algorithm is general and automatically handles interactions with ordinary circular attributes. The old rewrite algorithm is more complex and would have needed to be further extended to support interactions with ordinary circular attributes.

We have implemented the new algorithm for two small programming languages, and compared it to the JastAdd system [15], which is a metacompilation system based on RAGs, and which supports nonterminal attributes, circular attributes and rewrites. To evaluate the new algorithm, we have performed a number of experiments, comparing it to the JastAdd rewrite algorithm, indicating that the new algorithm gives acceptable performance on rewrite-intense test programs and sometimes better performance on more realistic programs. The contributions of this article are as follows:
                        
                           •
                           A definition of circular NTAs, together with an evaluation algorithm.

The introduction of the notion of computed children in an AST.

Mappings between circular NTAs and rewrites, showing they are equivalent.

An evaluation of the presented algorithm.

The rest of this article is structured as follows: Section 2 walks through the preliminaries of this article, describing different attribute grammar mechanisms. Section 3 gives a motivating example, explaining how circular attributes and rewrites are similar, and how they can interact. Section 4 presents the new notion of circular NTAs, and an evaluation algorithm for them. Section 5 shows that circular NTAs and rewrites are equivalent, by presenting mappings between them. Section 6 evaluates the new algorithm experimentally. Section 7 discusses related work and Section 8 concludes the article.

This article is an extended and revised version of our paper published at SLE 2013 [16]. In addition to revisions throughout the article, we include an improved motivating example, an extended background section with a new improved running example, and extensions of the evaluation and of comparison to related work.


                     Attribute grammars (AGs), introduced by Knuth [7], provide a means to compute context-sensitive information for context-free grammars. The information is defined by an equation system over a set of variables called attributes, where the attributes and equations are associated with the nonterminals and productions of the grammar. An attribute is defined by an equation (on the left-hand side), using an expression over other attributes (on the right-hand side). This expression is called the semantic function of the attribute. Each attribute and equation belongs to a specific node that we call its host.

In this section, we describe AGs and different extensions of them; reference attributes, circular attributes, nonterminal attributes, and rewrites. For the examples, we use the syntax and the algorithms provided by the JastAdd system [15].
                        1
                     
                     
                        1
                        JastAdd syntax is based on Java. We use a slightly simplified syntax here, avoiding getters and many parentheses.
                     
                  

An attribute grammar is an extension of a concrete or an abstract grammar. Reference attribute grammars use an EBNF abstract grammar that is formulated as an object-oriented model. Instead of nonterminals and productions, types and subtypes are used. As an example, consider the following abstract grammar for statements and expressions: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     


                        Stmt and Exp correspond to nonterminals, but are here modeled as abstract types. IfStmt, Assign, and Compound correspond to productions, but are here modeled as subtypes of Stmt. Children can be named. For example, IfStmt has a child cond of type Exp, a child thenpart of type Stmt, and an optional child elsepart of type Stmt (optional indicated by square brackets). The 
                           <
                           
                              id:String
                           
                           >
                         is a terminal named id of type String. Lists of children are indicated by the Kleene star, as in 
                           
                              s:Stmt
                           
                           ⁎
                        .

The object-oriented abstract grammar is not restricted to the two levels of types that nonterminals and productions correspond to. For example, it is possible to define a subtype SpecialAssign as follows: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The type SpecialAssign will inherit all children of its supertype Assign, similar to in object-oriented programming.

AGs, as introduced by Knuth, support synthesized and inherited attributes. A synthesized attribute hosted by a node n is defined by an equation also hosted by n, while an inherited attribute is defined by an equation hosted by the parent of n. An equation can access the attributes of its host node, as well as the attributes of children of the host node. This way, synthesized attributes can be used for propagating information upwards in an AST, whereas inherited attributes can be used for propagating information downwards.


                        Fig. 1
                         shows a simple example of a JastAdd attribute grammar with synthesized and inherited attributes. The grammar defines a node type Root with two children, first and second of the abstract type A. This type A has two subtypes B and C, where B has a token id of type String. A token is seen as an intrinsic attribute, i.e., an attribute whose value is defined during the AST construction, rather than by an equation. The grammar defines an inherited attribute startPos and a synthesized attribute endPos for A nodes, along with equations defining the values of the attributes. An equation has the form 
                           
                              
                                 HostType
                                 .
                                 child
                                 .
                                 inheritedattribute
                                 =
                                 
                                    
                                       exp
                                    
                                 
                              
                           
                        for an inherited attribute, or 
                           
                              
                                 HostType
                                 .
                                 synthesizedattribute
                                 =
                                 
                                    
                                       exp
                                    
                                 
                              
                           
                        for a synthesized attribute. For both equations, the right-hand-side expression 
                           exp
                         is evaluated in the context of HostType. For example, on line 10, an equation hosted by Root defines its second A׳s startPos to be equal to its first A׳s endPos. The AST, with attribute instances and their values, is illustrated to the right in the figure.

A simple and powerful way to compute the value of an attribute instance a
                        0 is to locate its defining equation and evaluate its right-hand side expression, recursively evaluating any attribute instances 
                           
                              
                                 a
                              
                              
                                 1
                              
                           
                           ...
                           
                              
                                 a
                              
                              
                                 n
                              
                           
                         used when evaluating the expression [17]. The attribute a
                        0 is said to depend on 
                           
                              
                                 a
                              
                              
                                 1
                              
                           
                           ⋯
                           
                              
                                 a
                              
                              
                                 n
                              
                           
                        . Note that these dependencies are dynamic: the dependencies themselves may depend on the values of attributes. For example, in an equation 
                           
                              
                                 a
                              
                           
                           =
                           
                              
                                 b
                              
                           
                           
                           ?
                           
                           
                              
                                 c
                              
                           
                           :
                           
                              
                                 d
                              
                           
                        , an instance of a will depend on b and on either c or d, depending on the value of b.

This dynamic evaluation technique is used in the JastAdd system. It is called demand evaluation, since only those attributes whose values are demanded are actually evaluated. The attribute values can be cached (memoized) after evaluation, so that a second demand for an attribute value will return the value immediately, rather than evaluating the equation again. This results in optimal evaluation in that each attribute is evaluated at most once. Despite being so simple, the technique is very powerful and can handle many extensions to Knuth׳s attribute grammars, including reference attributes and nonterminal attributes, and it can be extended to support circular attributes and rewrites.


                        Reference AGs (RAGs), introduced by Hedin [1], extend AGs with attributes that have references to other AST nodes as values, so-called reference attributes. The right-hand side of an equation may de-reference such attributes to access other attributes in remote AST nodes. Reference attributes can be used to superimpose graph structures on top of the AST, for example, to link variable use nodes to declaration nodes. They allow for concise solutions to, for instance, name and type analysis for object-oriented languages [14,2].


                        Fig. 2
                         shows an example of an attribute grammar with reference attributes, which we will use as a running example for the rest of this article. The language is a tiny fragment of an object-oriented language where a program consists of a list of class declarations (line 1). A class declaration, D, has a name, and can optionally have a superclass, sup (line 2). The superclass is modeled by a class use node, U which also has a name (line 3). A class use is bound to the appropriate declaration through a synthesized reference attribute, decl (line 5). The value of the decl attribute is defined by using an inherited attribute lookup, taking the class name as an argument (line 6). The lookup attribute is defined by an equation in the program root, whose right-hand side searches through the class declarations and returns the one with the appropriate name, or null if there is no such declaration (lines 7–14). The example illustrates three additional features in JastAdd:
                           
                              •
                              The lookup attribute is parameterized. While an ordinary (non-parameterized) attribute corresponds to a nullary function (i.e., it takes no arguments), a parameterized attribute corresponds to a function with one or more arguments. (The AST and the position of the hosting node are implicit arguments to these functions.) An ordinary attribute thus has a single value, whereas a parameterized attribute has one value for each possible combination of arguments. Note that due to demand evaluation, only the values actually demanded for a particular AST will need to be computed.

For practical reasons, JastAdd allows the right-hand side of an equation to be written as a method body that returns a value, instead of as an expression. This is fine as long as the body is pure, i.e., it does not result in any visible side-effects. There are techniques for inferring purity in object-oriented languages [18], but this is currently not implemented in the JastAdd system.

The equation for an inherited attribute applies not only to the specified child, D, but to its complete subtree, for all nodes that declare the attribute. This way, the equation holds for the lookup attribute of the U node, and no so-called copy attributes are needed to propagate the value down to the U node. We say that the value is broadcast throughout the subtree [15]. Note that an equation for an inherited attribute applies only to the nodes in the subtree that actually declare the attribute. Therefore, it is only the U node in Fig. 2 that has a lookup attribute. The D nodes do not declare the lookup attribute.

Note that the reference attributes superimpose a graph structure on top of the AST. Together with the child edges, cyclic graphs can be formed, but this does not imply that the attribute dependencies are cyclic. This is illustrated in Fig. 3
                         where classes A and B are defined as subclasses of each other, resulting in a cyclic graph. The dependencies for computing the attributes are nevertheless acyclic, and the demand-driven recursive evaluation algorithm works directly for both reference and parameterized attributes. In this particular case, the cyclic graph was used for representing an ill-formed program (corresponding to a compile-time error), but there are many examples of when cyclic graphs are useful in well-formed programs, for example, to represent control flow graphs or recursive data types.

Higher-order AGs, introduced by Vogt et al. [8], extend AGs with nonterminal attributes (NTAs), i.e., attributes for which the equation right-hand side uses tree constructors to compute a fresh sub-AST, rooted by a given nonterminal. An NTA is both a child and an attribute at the same time, and may itself have attributes, hence the term higher-order.

The NTAs thus extend the initial AST (that was typically built by a parser) with additional nodes, and we refer to the resulting AST as the extended AST.

While an ordinary (non-NTA) AG can be viewed as a function from an initial AST to an attributed initial AST, an AG with NTAs can be viewed as a function from an initial AST to an attributed extended AST.

NTAs thus make it possible to let the attribution decide parts of the AST structure, which otherwise would be decided entirely during the construction of the initial AST. NTAs can, for example, be used to de-sugar language constructs by constructing an alternative representation of a part of the AST. Like any attribute, an NTA is hosted by a node type of the grammar and each node of that type will host its own instance of the NTA.

Unlike other attributes, the value of an NTA is in itself attributable, and inherited attributes are evaluated in the context of the node hosting the NTA. That is, the hosting node becomes the parent of the NTA, and must provide equations defining the inherited attributes of the NTA. Because of broadcasting, there is often already a suitable equation further up in the AST, and if not, the host can provide an appropriate equation, overriding any broadcasting equation higher up in the AST. The demand-driven recursive evaluation algorithm works directly for NTAs.


                        Fig. 4
                         shows a simple example of an NTA used for reifying undefined class declarations. A D node, undef, is added to the program root using an NTA, and is used instead of null by the lookup equation. This way, uses of undefined class names will be bound to the undef node, as illustrated in the figure.

Circular attributes, that depend (transitively) on themselves, are useful for describing many problems, for example, dataflow [9,12]. Circular attributes are well-defined as the least fixed-point solution to their equations, if their semantic functions are monotonic and yield values over a lattice of bounded height [19,9]. Farrow describes how an evaluator can compute a fixed-point by successive approximation of attribute values [9], as shown in Fig. 5
                        . The algorithm solves the equation 
                           X
                           =
                           F
                           (
                           X
                           )
                         by starting from the bottom value (
                           ⊥
                        ) and then iterating until a fixed-point is reached. That is, 
                           X
                           =
                           ⊥
                           ∪
                           F
                           (
                           ⊥
                           )
                           ∪
                           F
                           (
                           F
                           (
                           ⊥
                           )
                           )
                           ∪
                           ⋯
                           
                              
                                 F
                              
                              
                                 l
                              
                           
                           (
                           ⊥
                           )
                           ⋯
                         until 
                           
                              
                                 F
                              
                              
                                 l
                              
                           
                           (
                           ⊥
                           )
                           =
                           
                              
                                 F
                              
                              
                                 l
                                 +
                                 1
                              
                           
                           (
                           ⊥
                           )
                        , where ∪is monotonic on the domain and co-domain of F.

To support circular attributes in RAGs, the recursive demand-driven evaluation is extended to do fixed-point iteration, as described by Magnusson and Hedin [11] and shown in Fig. 6
                        . When the value of a circular attribute instance is demanded, there are three different cases: Case 1 covers the case when the attribute instance is accessed from “outside”, i.e., from an attribute not involved in any cyclic evaluation. This part of the algorithm contains the loop that drives the fixed-point iteration. Cases 2 and 3 cover cases when a circular attribute is accessed from “inside”, i.e., when a circular evaluation is already ongoing. Case 2 computes the next value in the iteration for the attribute. Case 3 covers the case when the computation of the next value is already ongoing, in which case the function immediately returns the current value. A global flag, IN_CIRCLE, keeps track of if any cyclic evaluation is ongoing. Fig. 7
                         illustrates the evaluation stack for the example used in Fig. 6. The right arrows (
                           →
                        ) in Fig. 7 indicate that a value was updated and that the global variable change became true. For each evaluation round, one or more arrows at some stage starts a new round. For example, in the third round there is an arrow at the second stage and this causes a fourth iteration.


                        Fig. 8
                         shows a simple example of how to define a circular attribute in JastAdd. The attribute onCycle computes whether a class declaration is on a cyclic class hierarchy or not. For this attribute, the boolean values are regarded as being on a simple lattice with true at the bottom and false at the top.


                        Rewritable RAGs, introduced by Ekman and Hedin [13], extend RAGs with attribute-dependent declarative transformations of the AST, called rewrites. Rewrite rules are defined on node types and define a node replacement, possibly conditionally. Both the computation of the new node and the conditions may depend on attribute values.

An example use of rewrites is in name resolution [14]: the general name access nodes created by a parser can be replaced by more specific nodes, like field accesses or local variable accesses, depending on attribute values.

Rewrites are declarative in that a finally rewritten AST has no applicable rewrite rules, i.e., all the rewrite conditions will be false. To compute this final AST, the rewrite rules are applied repeatedly until no more rules are applicable. This is in essence a fixed-point computation, and it is required that the rewrite rules are written in such a way that this computation terminates and is confluent, i.e., the order of applying any set of applicable rewrite rules is irrelevant. Since rewrite rules depend on attribute values, and attribute values depend on children that might need to be rewritten, the attribute evaluator intertwines rewriting with attribute evaluation, until no applicable rewrites remain.


                        Fig. 9
                         shows an example, where a new node type (WD) is introduced, representing a well-formed class declaration. A rewrite rule replaces an ordinary class declaration by a WD node if it is not already replaced (specialized) and if it is not on a cyclic class hierarchy (onCycle).

A RAG with rewrites can be viewed as a function from an initial AST to an attributed rewritten AST. The rewritten AST has the same root node as the initial AST, but can otherwise in principle be completely different from the initial AST. In practice, however, rewrites are used for rather small adaptations of the AST, like the specialization in Fig. 9.

Like RAG attributes, rewrites are evaluated on demand, and with the use of a recursive evaluation strategy. When a node is accessed for the first time (through its parent), the rewrite rules for the node are applied repeatedly until there are no more applicable rewrites, i.e., the node is in its final state. Thus, the client accessing the child never sees the initial or any intermediate states, but only the final state of the node in the rewritten AST. The root node itself is not allowed to have any rewrite rules. Initially, the root of the AST is final, and as the AST is traversed, this final region is expanded from parent to child. For instance, after building the initial AST in Fig. 9, suppose we access first the root node, and then its child. The child will then be rewritten, and a reference to the final WD node is returned.

The evaluation of rewrites, shown as the child access method ASTNode.GetChild in Fig. 10
                        ,
                           2
                        
                        
                           2
                           
                              ASTNode is a supertype of all node types.
                         starts with a check of the current state of the child to be accessed. If the child is null, if it is already in the final state, or if it has no rewrite rules, its current value is returned immediately without any further evaluation. Alternatively, the rewrite evaluation continues. Beyond this initial part, the ASTNode.GetChild method handles two cases: Case 1 covers the case when the node is accessed for the first time, in which case a loop is entered which drives the evaluation of the rewrite. Case 2 covers the case when the node is already in the process of being rewritten, but accessed again, in which case the current value is returned.


                        Case 1 contains a driver loop, similar to the first case for circular attributes in Fig. 6. A difference is that each rewritten node is driven by its own driver loop, which is kept track of using the boolean field InCircle in the node. Another difference is that the change check is not done by comparing values, but instead using a boolean flag that is set in the beginning of each iteration (Change), and reset (to NoChange) by the RewriteTo method, in case no when clause applies. These flags are pushed on a stack (stack), so that nested rewrites of different nodes each have their own flag.

Attributes are evaluated during rewriting in order to compute the guarding rewrite conditions and to compute the resulting tree of a rewrite. It may thus happen that a particular attribute is evaluated using attributes of nodes that are not yet final. In this case, the attribute value is not cached (memoized), since that value might become inconsistent at a later point in time, when the AST has been rewritten. If the attribute is accessed again at a later time, it will be reevaluated, since there is no cached value, again possibly aborting its caching. To keep track of if an attribute can be cached or not, requires additional bookkeeping not shown in Fig. 10, see [13] for details.

In the previous section, we walked through the evaluation of attribute grammars with focus on two extensions: circular attributes and rewrites. The evaluation mechanisms of these extensions are similar; both use a loop to drive the evaluation until there is no change, both base their evaluation on some initial value, and both mechanisms may create intermediate values on their way to a final value. That is, if a circular attribute is accessed, entering Case 2 or Case 3, a potentially intermediate value is returned, and the same goes for rewrites, entering Case 2. The presented evaluation mechanisms handle circular attributes and rewrites in isolation from each other, i.e., assuming there are no interdependencies between them.

As an example of such an interdependency, consider the grammar specified in Fig. 11
                     . Here, a class use, U, is rewritten to a specialized node type, CircU, if it is in the extends clause of the same class declaration, D, that it refers to, e.g., 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

In this example, the U node is a child of a D node. The rewrite rule uses the attribute extendsD of the D node, which in turn is dependent on the rewrite since it accesses the child through u. Thus, there is a circular dependency between the attribute extendsD and the child u, as shown in the figure. The figure also shows that the value of u depends on itself, since a node is rewritten until no more rewrite rules for it apply. The values in the figure are the expected final values, that is, we expect the attribute to receive the value true, and the child to be rewritten to a node of type CircU.

In just using the algorithms from Section 2, the interdependencies are not accounted for, and if the evaluation starts with the extendsD attribute, the final value of the child becomes U rather than CircU, i.e., the rewrite terminates too soon. Fig. 12
                      illustrates the evaluation stack for the example, showing how the initial access of the circular attribute enters circular Case 1, and how the first child access enters rewrite Case 1. In both these cases, a loop is started to drive the evaluation. The first iteration of the rewrite driver loop results in an access of the circular attribute, and this access becomes the second access of the circular attribute. At this point, the circular attribute is already driving its own evaluation (Case 1), hence it enters Case 3 and returns its current value. This current value is the bottom value of the circular attribute (false), and with this value the when clause of the rewrite becomes false. With only false when clauses, NoChange is pushed on to the rewrite stack (stack), causing the rewrite evaluation to terminate.

Interdependencies, like the above, can either be disallowed or handled. Using the global evaluation state (in_circle, stack) presented in Section 2, a runtime exception can be thrown if a circular attribute instance uses a rewrite, or vice versa.

In this paper, we instead present a generalization, based on a unification of the two mechanisms. We do this by introducing the notion of circular NTAs (Section 4), of which rewrites can be seen as a special form (Section 5). This unification allows us to account for interdependencies, while using a simpler algorithm with fewer conceptual entities. It also allows us to cache more attribute values during rewrites (i.e., during the evaluation of circular NTAs), resulting in better performance.

In this section, we introduce circular NTAs (CNTAs), and show how these can be used to compute the attribute values described in Section 3.

As for ordinary circular attributes, we require that circular NTAs take their values from a lattice of bounded height, that the semantic function is monotonic, and that a bottom value is provided as the starting point of the fixed-point iteration. Consider the following circular NTA: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        Here, the HostType node is an implicit argument of the semantic function, and via this node, other attributes can be accessed from within the semantic function. The semantic function should be side-effect free, and return a fresh subtree rooted by a node of type ReturnType.

The value of a circular NTA is an AST value, an unattributed subtree defined as follows:
                           Definition 1
                           An AST value v is either null, or an AST node, where an AST node is a tuple 
                                 <
                                 
                                    Type,Tokens,Children
                                 
                                 >
                              , where Type is an AST node type, Tokens is a list of zero or more tokens, and Children is a list of zero or more AST values. Two AST values are equal if they are both null, or if their types, tokens and children are equal.

Additionally, an AST node has a reference to its parent, unless it is a root node. However, the parent reference is not seen as part of the value, but instead as a computed value that refers back to the node of which it is a child, i.e., satisfying the following child–parent invariant: 
                           n
                           .
                           child
                           (
                           i
                           )
                           .
                           parent
                           ==
                           n
                        . As an NTA is seen as a child of its host node, the host node will be its parent. The attributes of an NTA are not seen as part of its value, as they are computed values, depending on the context of the NTA.

There are many ways in which the AST values can be viewed as on a lattice of bounded height. One simple way is to consider all values with the same type to be incomparable, and to order the types. In a circular evaluation, an AST value can then be replaced by another AST value of a higher type, but not by an AST value of the same type. Another way would be to consider AST values with the same type as comparable, and to place an ordering on the children, for example, based on the types of the children. Since the number of types is bounded in any given RAG, this allows lattices of bounded height to be defined.

@&#EVALUATION@&#

To evaluate circular NTAs we alter the demand-driven fixed-point evaluation algorithm from Fig. 6, to account for AST values. The result, listed in Fig. 13
                        , maintains the three evaluation cases from Fig. 6 (Case 1, Case 2, and Case 3), but with a different change check (IsEqual) and assignment of values. The change check corresponds to a call to a boolean function IsEqual, complying with Definition 1. The assignment of values must account for the possible null value of AST values, and establish the child–parent invariant of the new AST value. For cases when there are several attributes in a cycle, ordinary or NTA, these will be driven to a common fixed point.

Given that the AST values of NTAs are attributable, circular NTAs may be nested and dependent on each other. A case where an outer circular NTA depends on an inner circular NTA, and vice versa, may arise. In such a case, there may be several possible orderings of iteration steps, for example, they may be interleaved, or one of them may take a step as soon as possible. Due to the fixed-point properties, the result will be the same, regardless of iteration order.

During the evaluation of a circular NTA, it may happen that an ordinary attribute is evaluated that uses the NTA, in which case an intermediate value of the NTA may be returned by Case 2 or Case 3. In this case, the value of that attribute should not be cached, because it depends on a non-final value. To abort the caching in this situation, a check is added to the evaluation of non-circular attributes, as shown to the left in Fig. 14
                        , where 
                           TEMP
                         is set to true before returning from Case 2 or Case 3. In addition, the number of computations of a non-circular attribute can be limited for each iteration in a circular evaluation, as shown to the right in Fig. 14, where ITER is incremented each iteration.

We will now revisit the example with interdependent rewrites and circular attributes from Section 3 and see how it can be formulated using a circular NTA instead of a rewrite. Fig. 15
                         shows the two solutions side by side. The D node has a child u of type U (lines 1–2). Normally, this child is accessed through the u reference, but in the CNTA solution, we introduce an attribute child that is used instead (see the accesses of u and child at lines 16 and 22). The child attribute is a circular NTA defined at lines 4–6 using an attribute rewriteTo corresponding to the rewrite rule (lines 8–12).

By making child circular, the same behavior as for rewrites is achieved, i.e., updating the node until no rewrite condition is fulfilled. The important difference from the rewrite solution is the unification of the evaluation cycles. The circular NTA, child, and the circular attribute, extendsD, are evaluated in the same cycle, and are aware of each others׳ changes. Fig. 16
                         shows the evaluation of the extendsD attribute in the CNTA solution, and how it, in contrast to the rewrite solution from Fig. 12, produces consistent values. That is, making the child attribute circular is the key to a unified solution, and rewrites are in fact circular NTA attributes in disguise in terms of attribute values.

The rewrite and the CNTA solutions are equivalent in that they result in the same attributed AST, modulo how the children are named. The rewrite solution uses u to refer to the U child, whereas the CNTA solution uses the name child. The CNTA furthermore still has access to the original U child through the reference u, whereas this information is lost in the rewrite solution.

In the next section, we will see how rewrites in general can be mapped to circular NTAs, allowing rewrites and circular attributes to be mixed freely.

In the previous section we replaced a rewrite with a circular NTA, in effect making a child a computed entity, just like an attribute. We will now have a closer look at what happens if we compute all children, and based on this idea, we will present a mapping of rewrites to circular NTAs.

An attribute grammar is in essence a complex function from an initial AST, typically constructed by a parser, to the attributes of nodes in that AST. What we are now considering is to instead view the attribute grammar as defining an attribution of an AST that is computed from the initial AST, using attributes. This makes sense if we consider the computed AST to initially be the same as the initial AST, which by a fixed-point computation gradually turns into the final computed AST. This way, both the computed AST and the attributes of the computed AST are functions of the initial AST. Note that the initial AST remains unchanged during the evaluation – it is only the attribution that changes, including the computed AST, until it has reached its final state, where all equations are satisfied. To consider a computed AST raises questions about the parent–child relation, and how to represent the initial and the computed AST.


                        The parent–child relation: The parent–child relation has a special role in an AG system, since parents have the obligation to provide equations defining the inherited attributes of their children. For our demand-driven evaluator, each node has a parent reference, satisfying the parent–child invariant, which is used by the evaluator when computing inherited attributes. In moving the AG to define an attribution over the computed AST, rather than over the initial AST, we have to make sure that the computed AST is actually a tree, and that the parent–child invariant holds for both the initial and the computed AST.


                        Representation of initial and computed AST: The initial child references are similar to reference attributes, but they are intrinsic, i.e., they are available from the start, and are not defined by equations, just like tokens. They can in fact be seen as tokens with reference values, and the computed child references can be defined using reference attributes. For a node where rewrites are not desired, the computed child references can simply refer to the initial children, or copies of them, by using synthesized attributes. For a node where rewrites are desired, a circular NTA can be defined in its parent, and the computed child reference can be defined to refer to this NTA. In both cases, a tree structure for the computed AST is guaranteed. For the second case, parent references are automatically added by the evaluator as the computed CNTA child is updated by the fixed-point computation.

Although equations that refer to children will access the computed children, it is still possible to explicitly access the initial child references. This is useful, for example, to define the bottom values for computed children that are defined by circular NTAs.

As will be demonstrated in this section, rewrites can be translated to circular NTAs, making use of parameterized reference attributes. We will take the solution presented in the earlier example in Fig. 15 as a starting point, but instead of defining an attribute child to represent a specific rewritten child, we will define a parameterized attribute child(int) for each node in the AST. This attribute will be used for accessing the children, regardless of if they are rewritten or not.

The original children, i.e., the initial AST, can be accessed through the intrinsic attributes getChild(int). However, the initial AST is not considered to be attributed. It is only used as an input to compute the attributed computed AST. Therefore, we disallow access of attributes of nodes accessed through the getChild references. Attributes are only allowed to be accessed for the computed tree, i.e., through the child references.

In order to make the mapping from rewrites to CNTAs efficient, we will take the following two properties into account; first, a rewrite is consistent when all when clauses are false, and therefore, no value comparison is needed to decide that the rewrite has terminated. Second, not all nodes have rewrites. We will use these properties to avoid expensive value comparisons and unnecessary creation of NTAs. Fig. 17
                         lists code for three different mappings, increasingly efficient; designs A, B, and C.


                        Design A: Design A is our simplest and least efficient design. Here we introduce a circular NTA child(int i) for each node, by defining it for ASTNode, which is the superclass of all node classes. The attribute is defined in the same way as was done for the child attribute in Fig. 15: a copy of the original child as the bottom value, and the definition is delegated to a rewriteTo attribute of the child. Like in Fig. 15, the rewriteTo attribute for a given node class, say Node, computes a new node object if a when clause is true, and otherwise returns the node itself. To mimic the behavior of rewrites, the when clauses are checked starting with the most specific node class, and ending with the most general one, which is accomplished by accessing super.rewriteTo if no when clause was true.


                        Design B: Design A is inefficient in that there is a circular NTA for every child, despite the fact that we know statically that nodes of certain types do not have any rewrites. To address this problem, design B represents the computed children by an ordinary attribute child(int) rather than by a circular NTA. This attribute accesses a circular NTA rewriteChild(int), but only in case the node actually has any rewrite rule, as indicated by the attribute hasRewrite. This attribute is simple to generate from the grammar: it is defined as false for the most general node type ASTNode, and then an overriding equation that defines it as true is added for subclasses with rewrites. Because of the demand-driven evaluation, the circular NTAs will be created only when they are actually needed. For nodes that do not have any rewrites, getChild(i) is returned, i.e., the node from the initial AST.


                        Design C: Design B is still inefficient in that it uses normal circular attributes which compare values to decide if the circular evaluation has terminated or not. To address this problem, design C takes advantage of the fact that we generate the mapping from a rewrite specification: we know if a circular NTA is a replacement for a rewrite, and we can use this knowledge to prevent value comparisons: if no rewrite is applicable, the next value will be the same as the current one, and we know that the evaluation has terminated. Design C in Fig. 17 shows how the implementation of rewriteTo uses a stack of change/no_change flags, in the same way as the rewrite evaluation in Fig. 10.

In the reverse direction, circular NTAs may be mapped to rewrites. That is, the comparison of AST values performed in the evaluation of circular NTAs can be moved into the when clause of a rewrite, as follows: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        This when clause would become false when there is no change, that is, when there is a fixed-point, and this would be in accordance with the rewrite rules. Still, to support interdependencies with circular attributes, the underlying rewrite evaluation would have to be carried out in the same cycle as circular attributes, as discussed in Section 3.

@&#EVALUATION@&#

To evaluate the performance of our new algorithm for rewrites, circular-nta, as listed in design C in Fig. 13, we compare it to the current algorithm used in the JastAdd system, rewrite-opt, i.e., the one listed in Fig. 10 extended with bookkeeping for caching.

We evaluate using two small languages, DemoJavaNames, which is a Java-like language focused on name resolution and rewrites, and ExtendedPicoJava, which is another Java-like language and for which we have a converter tool that can project real Java programs down to the smaller language.

The evaluation is done in two parts; one experiment using generated programs in the DemoJavaNames language, allowing us to get a ball-park figure of performance differences between the algorithms, and a second experiment using real Java programs projected down to ExtendedPicoJava, to get a stronger indication of potential performance benefits for real programs.

At the time of this evaluation, the circular-nta algorithm, or its mapping to rewrites, was not implemented as a part of the JastAdd system, which meant that we had to manually alter the generated code. To validate our manual changes, we analyzed the same programs using the altered and originally unaltered code and verified that they produce the same result.

We evaluate performance by measuring execution time and by counting cache and computation operations. To count these operations we instrument the generated code for each compiler, and the manually altered code for the already altered version with the circular-nta algorithm.

In total, we get four compilers per language plus two more for DemoJavaNames; one generated rewrite-opt compiler, one instrumented rewrite-opt compiler, one circular-nta compiler, one instrumented circular-nta compiler, and for DemoJavaNames another two for rewrite-init.

We now compare circular-nta with rewrite-opt using generated DemoJavaNames programs. We also include rewrite-init in the comparison, which is a variant of rewrite-opt that additionally saves initial AST values. The rewrite-init algorithm supports incremental evaluation for RAGs where rewrites need to be undone as part of the incremental evaluation, see [20]. This algorithm copies initial AST nodes in a fashion similar to circular-nta. The evaluation code for this section is available at [21].

For the experiment, we use the scaled-down language DemoJavaNames, that demonstrates name resolution for Java, where contextually ambiguous dot-expressions like a.b.c are resolved to package, type, and expression names using rewrites [14]. The rewrites directly encode the rules in the Java language specification for reclassification of parsed names, using intermediate classifications like AmbiguousName and PackageOrTypeName. Fig. 18
                         shows an excerpt from the DemoJavaNames RAG, together with a lattice over rewrite AST values. Each when clause corresponds to an arrow in the lattice.

The example programs in Fig. 19
                         each contains at least one assignment with a dot-expression on the right-hand side. To test the impact of nested dot-expressions, the examples are expanded to different sizes, where the examples shown have size 1, and an example of size K has 
                           K
                           +
                           1
                         dots in the dot-expression (second dot-expression for Program II). To obtain programs that are sufficiently large to measure performance accurately, we have scaled up the program code in two different ways. In Program I, the class is replicated 1000 times (mangling the names to avoid name conflicts), N=1000. In Program II, the class is replicated 10 times, N=10, 10 inner classes are added inside each outer class, M=10, and finally, the inner assignment is replicated 100 times. The result is that Program I has 1000 assignments and Program II has 10000 assignments.

Given a set of Programs I and II, for different values of K, we do a full traversal of each program using all three algorithms, to trigger all rewrites, or circular NTA computations. We count the number of computations using an instrumented version of each algorithm, and we measure performance on a non-instrumented version. To measure performance we use a steady state multi-iteration [22], and measure on a Lenovo X230 with OpenJDK 1.7.0/Linux.


                        Fig. 20
                         shows the results for values of K between 1 and 10, i.e., with increasingly complex dot-expressions. In the left-side diagrams, we see that the circular-nta algorithm reduces the number of attribute computations for Program I compared to rewrite-opt and rewrite-init, which both have the same number of computations. The results are reversed for Program II where circular-nta has more computations. This variation of results indicates that the structure of Program II is causing the circular-nta algorithm to do more work, while the rewrite algorithms solve the problem more efficiently. The added class nesting in Program II may be causing the circular-nta algorithm to create larger evaluation cycles. To further investigate the character of the programs causing this effect may be a source of optimization ideas for circular-nta.

The middle diagrams show the number of node copies made for each algorithm. rewrite-opt makes no copies, while circular-nta and rewrite-init both make copies in order to keep the initial AST unmodified. The rewrite-init algorithm makes a copy during initialization before Case 1. This is the same for circular-nta, and non-surprisingly they end up making the same number of copies.

The right-side diagrams show the execution times for the algorithms. As we can see, circular-nta is slower than the rewrite algorithms for all K, for both Programs I and II. Part of this extra execution time may be due to the test implementation we are using which likely can be optimized to get closer to the rewrite algorithms. Especially, for the case where the total computations are fewer.

Using generated programs we may be considering unrealistic programs. To get closer to real programs, we have created a small Java-like language, which we call ExtendedPicoJava, and converted a set of Java programs to this language.

ExtendedPicoJava as a language is larger than DemoJavaNames but much smaller than Java. As indicated by its name, it is an extension of PicoJava, a tiny object-oriented demo language created for the JastAdd tool. The basic structure of the language, in terms of blocks and statements, is as follows: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           The language supports declarations of classes, interfaces, methods, and variables, as follows: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           The language supports uses of types, variables and methods, including qualified access. A parser cannot distinguish between variable and type uses, so an initial AST will contain a Use node for each use, but that will be rewritten to either TypeUse or VariableUse depending on the kind of the use׳s declaration: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           The language has basic expressions and literals: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           The overall size of the ExtendedPicoJava specification (attributes and grammar) is 991 source lines of code (SLOC), i.e., not counting whitespace and comments. This specification contains 81 attribute declarations, 122 attribute equations and 2 rewrite declarations, implementing name analysis, type checking, and compile-time error checking.

In converting Java to ExtendedPicoJava, one should bear in mind that the purpose of the conversion is not to create running meaningful programs, but to create programs with realistic declaration-use relationships. This means, we want to preserve declarations, uses and scopes, but we do not need to preserve the behavior of the program.
                              
                                 •
                                 
                                    Type declarations: For class and interface declarations, we mangle names to include their package as there are no packages in ExtendedPicoJava. Nesting of inner classes and interfaces are preserved as uses of them can be qualified with the use of dots.


                                    Constructors: We map constructors to simple methods and let them return the enclosing class. For cases where there is no constructor we create a method according to this pattern without a method body, and for existing constructors we add a return statement returning the enclosing type (this is to comply with the requirement of having a return statement returning the right type).


                                    Type uses and literals: For types we keep all uses of reference types and map all uses of primitive types to either integer or boolean. The same goes for literals where all numbers become integers.


                                    Statements: Conditional statements are mapped to while statements, while other statements, like try-catch, are stripped down to blocks. Assignment statements are kept as is.


                                    Expressions: Expressions are converted to an expression that maps to the type returned from the expression. For instance, arithmetic expressions become additions, and boolean expressions become and expressions.


                                    Missing concepts: For cases where we lack a concept in ExtendedPicoJava, we strip away and simplify. For instance, we strip arrays and resort to the type of their elements. Similarly, we strip away generics and use Object.


                                    Corner cases: For some cases we add special treatment. As an example, the arraycopy method in Java requires two Object arguments referring to arrays. For cases where an array has been stripped down to a primitive type like integer this causes problems, so we replace those arguments with constructor calls to Object.

The converter from Java to ExtendedPicoJava was implemented as a modular extension to the JastAddJ
                              3
                           
                           
                              3
                              JastAddJ has been renamed to ExtendJ (https://bitbucket.org/extendj/extendj).
                            extensible Java compiler and is in effect a simple pretty printer. Each node type, corresponding to a Java language construct, was equipped with a method outputting a snippet of ExtendedPicoJava code. The source of a program was converted down to and including method bodies, while for libraries method bodies were skipped.

We selected a handful of Java programs of varying size and converted them to ExtendedPicoJava using the presented conversion approach. We then ran two semantic checkers for the ExtendedPicoJava language, one using rewrite-opt and one using circular-nta, and measured time and number of attribute instance computations for each of the programs. We used a compiler configuration that caches all attributes, and measured the total number of attribute computations. To measure the number of computations, we instrumented the two checkers, one for each algorithm. For measurement of execution time, we ran the uninstrumented checkers, using a steady state multi-iteration approach [22], on a Lenovo Thinkpad X230 with OpenJDK 1.7.0/Linux.

We used the following programs. Note that the converted ExtendedPicoJava programs include any library code used by the source, and are therefore larger than the original Java programs.
                              
                                 •
                                 
                                    JUnit (version 3.8.1), a testing framework with 3673 SLOC Java. The converted program has 40,701 SLOC ExtendedPicoJava with 1264 declarations, 5034 uses, nested in 845 blocks.


                                    Lucene (version 1.9.1), a full-text search engine with 33,061 SLOC. The converted program has 56,280 SLOC with 11,862 declarations, 51,545 uses, nested in 7827 blocks.


                                    ANTLR (version 2.7.2), a parser generator with 34,615 SLOC. The converted program has 39,624 SLOC with 6918 declarations, 32,692 uses, nested in 5566 blocks.


                                    PMD (version 3.7), a Java source code analyzer with 38,478 SLOC. The converted program has 84,650 SLOC with 10,395 declarations, 39,758 uses, nested in 10,584 blocks.


                                    JFreeChart (version 1.0.0), from here on referred to as Chart, a chart library with 95,664 SLOC. The converted program has 132,176 SLOC with 33,359 declarations, 147,170 uses, nested in 16,585 blocks.


                           Fig. 21
                            shows results for rewrite-opt and circular-nta running semantic checks on the converted versions of the above five programs. The plots show number of computations and execution time. Overall, circular-nta is slower across all programs, with one exception. The difference in execution time and the reduced computations suggests that we may be able to optimize our implementation to make it more efficient.


                           Fig. 22
                            drills down into the number of computations by separating them into computations leading to a cached value (Cached) and computations for which the value could not be cached due to a dependency on a non-final value (Cache aborted), as was discussed in Sections 2.6 and 4.2.

Note that cache operations are aborted for attribute instances in non-final nodes when using rewrite-opt. As an example, consider this small snippet of ExtendedPicoJava: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           The variable a is represented by a Use node for which there are two possible rewrites in ExtendedPicoJava: 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           In the snippet, the variable has no declaration, and its decl attribute will be a reference to an UnknownDecl object. Neither of the two rewrites will therefore apply, since both decl.isVarDecl and decl.isTypeDecl will be false. However, during the evaluation of the rewrite conditions, the Use node is non-final and no attribute instances may be cached in the node. The reason is that a rewrite rule may reuse the original node in constructing the resulting node, although in this case, a new node is created, and the old Use node is actually not reused. This means that in the above example, the accesses to decl will result in aborted cache operations, and for each access, the value of decl therefore needs to be recomputed.

For the circular-nta algorithm, the algorithm restrict cache aborts to the case when a computation of an attribute has actually used an intermediate value in a cyclic evaluation, which is not the case here. Therefore, the decl attribute can be cached in this case, and the second time it is accessed, the value is returned directly, instead of recomputing it. The circular-nta algorithm can thus cache attribute instances in intermediate nodes.

Returning to Fig. 22, rewrite-opt has a large number of cache aborts which explains the much larger number of total computations, since attributes for which caching was aborted need to be recomputed the next time they are accessed. circular-nta also has some cache aborts, but very few in comparison.

The experiment shows that the circular-nta algorithm is slower than the rewrite-opt algorithm on the ExtendedPicoJava programs, with the exception of Chart, despite performing fewer attribute computations. The handling of cache aborts appears to be central to the eventual performance of the two algorithms.

To connect these results to a real language, we instrumented JastAddJ (the JastAdd extensible Java compiler) [2,3], to count attribute computations, divided into cached computations, uncached computations, and computations with cache aborted, see Fig. 23
                           .

We measured this on two variants of the compiler using rewrite-opt: one with selective caching, where some attributes are left uncached (on the left-hand side), and one where all attributes are cached (on the right-hand side). In the selective variant (which is the default when running JastAddJ), caching has been hand-tuned to improve performance. While this leads to a higher number of attribute computations, it can pay off in performance, because for attributes declared as cached, there is an initialization cost for each instance of the attribute, and there may be many instances that are never evaluated at all. For JastAddJ, auto-tuning algorithms for selective caching has given around 20% speedup [23], whereas the expert hand-tuning used in Fig. 23 gives around 25% speedup.

We see that for the cache-all variant, there are many computations with aborted cache. If the CNTA algorithm leads to avoiding many of these aborted caches, it could lead to a performance gain, provided the algorithm overhead could be reduced. This would be very useful in practice, giving improved performance without having to resort to hand-tuning of caching which requires detailed expert knowledge about the evaluation algorithms.

It is also possible that the CNTA algorithm could lead to improved performance for the hand-tuned selective caching variant of the compiler. While this variant has very few cache aborts, there could be some of the uncached attributes that would fall into the cache abort category if they were cached. Caching these attributes and running the CNTA algorithm might lead to improved performance also in this case.

@&#RELATED WORK@&#

Knuth׳s original attribute grammar definition assumes non-circular attributes, and provides an algorithm for determining statically if attribute grammars are cyclic or not [7]. However, for attribute grammars with remote attribute access, like in RAGs, determining circularity statically is an undecidable problem [24]. In JastAdd, it is assumed that the user explicitly declares circular attributes as circular. If an attribute is not declared as circular, but in fact turns out to be circularly defined for a given AST, this can be detected dynamically [11].

RAG rewrites have similarities to tree transformation systems like Stratego [25], ASF+SDF [26], and TXL [27]. These systems typically rely on user-defined rewrite application strategies. RAG rewrites, in contrast, can depend on arbitrary attribute values, that may themselves depend on rewrites, and the rewriting order is implicit, and driven by the dependencies.

Bürger has developed a Scheme library, RACR, which generalizes RAG tree rewrites to graph rewrites, based on the superimposed graph defined by a RAG [28]. Instead of aborting caching during rewrites, like in JastAdd, the RACR system caches all attributes, and updates rewrite-dependent attributes incrementally during the rewrite process. While this improved caching can improve performance, there is also a substantial overhead cost for the incremental evaluation, in keeping a dependency graph up to date during evaluation.

An alternative approach to supporting transformations for attribute grammars is forwarding 
                     [29]. Here, the transformed AST is constructed as an NTA, and synthesized and inherited attributes can be automatically forwarded to the NTA, giving the effect of a transformation. Forwarding is done to an unconditionally constructed NTA in one step. In contrast, rewrite rules are applied using a fixed-point computation that can result in applying no transformation step at all, or a number of steps depending on the values of other attributes. Another difference is that the rewrite approach uses an open syntax allowing rewrite rules for the same node to be added independently in separate modules.

Martins, Fernandes and Saraiva suggest the use of functional zippers to provide a functional embedding of attribute grammars in Haskell, including support for reference attributes, higher-order attributes, and circular higher-order attributes [30]. They give an example of implementing a circular higher-order attribute using fixed-point iteration. Similar to our mapping of rewrites to circular NTAs, they terminate the iteration based on changes, rather than value equality. In contrast to our work, they use a manually encoded fixed-point iteration, rather than a general algorithm. Furthermore, they do not address rewrites or cases where several attribute instances are mutually dependent, and they do not give any performance results.

In editor applications, the initial AST can be modified as a response to edits done interactively by the user, causing attributes to become inconsistent. For demand-driven evaluators, consistency can be restored simply by flushing all cached attribute values. For large ASTs, this approach might not scale, and an alternative is to apply an incremental evaluator that reuses unaffected attribute values. Incremental evaluators have been presented both for AGs [31,32] and for RAGs [20,28]. In the case of RAGs, the initial AST needs to be kept in order to be able to flush rewrites that depend on other changes in the AST. To use the rewrite-opt algorithm in this setting, the evaluator needs to be modified to store the initial AST nodes before rewrites [20], corresponding to the algorithm rewrite-init. For the new algorithm (circular-nta), the initial AST nodes are kept as part of the algorithm.

Concerning termination, a circular NTA can be compared to constructing one new NTA for each step in the fixed-point iteration. Krishnan and Van Wyk have suggested an approach to conservatively determine termination for such multi-level NTAs [33]. It is based on ordering the nonterminals (the node types), so that each new NTA has a lower order than its host. We used a similar technique for the DemoJavaNames example, where node types were ordered in a lattice.

@&#CONCLUSIONS@&#

We have investigated the interplay between circular attributes and rewrites, and introduced a generalized evaluation algorithm that can handle grammars with interdependent circular attributes and rewrites. To this end, we have introduced circular NTAs, and shown how rewrites can be mapped to these attributes. The mapping uses the notion of computed children which provides a compelling explanation of attribute grammars with rewrites, namely as a complex function from an initial AST to a computed AST with attributes.

To evaluate the new algorithm, we have implemented it for two small languages, and run evaluations both using artificial generated programs and more realistic programs projected from well-known Java programs to one of the small languages.

Our results show that the new algorithm, while being more general, can reduce the number of attribute computations. In our experiments, we found that the computations may be reduced but the over head of the algorithm may cause it to not reduce execution time. For a full compiler like the JastAdd extensible Java compiler, there may be a gain with the new algorithm when not relying on hand-tuned caching, provided the algorithm implementation is optimized to correlate better with the number of computations. To investigate this, we plan to extend the JastAdd metacompiler with an automatic mapping from rewrites to the circular NTA implementation and further investigate possible optimization of the algorithm.

@&#ACKNOWLEDGMENTS@&#

We would like to thank Niklas Fors and Jesper Öqvist for valuable feedback. This research was partially funded by the Swedish Research Council (Vetenskapsrådet) under Grant 621-2012-4727.

@&#REFERENCES@&#

