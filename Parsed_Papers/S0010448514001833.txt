@&#MAIN-TITLE@&#Progressive point set surface compression based on planar reflective symmetry analysis

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a progressive point set surface compression algorithm.


                        
                        
                           
                           The algorithm analyzes high-level semantic information existent in a 3D model.


                        
                        
                           
                           The original surface is partitioned and encoded by different encoding techniques.


                        
                        
                           
                           The proposed algorithm is able to process surfaces of arbitrary topology types.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Point set surface

Compression

Symmetry analysis

@&#ABSTRACT@&#


               
               
                  In this work we propose an algorithm for progressive point set surface compression based on planar reflective symmetry analysis. For a given point set surface, we detect the primary symmetry plane and project the surface onto three orthogonal planes including the primary symmetry one. Then, on each projection plane, we adaptively subdivide the support domain into rectangular sub-domains. Analyzing the projected geometry on each sub-domain, we partition the original surface into portion(s), if any, that each can be modeled as a height field and the remaining portion, if any, that cannot. Further, we identify symmetric pairs of height-field portions, if any. Finally, different encoding techniques are designed for different types of surface portions, resulting in a generic progressive point set surface encoder that processes surfaces of arbitrary topological complexity and yields outstanding rate–distortion performance.
               
            

@&#INTRODUCTION@&#

In recent years, three-dimensional (3D) models have become more and more widely used, as other types of digital media (e.g., audio, image and video). They have found applications in many fields such as video gaming, 3D animation and scientific visualization. The dominant form of representation for 3D models has been polygonal mesh, mostly due to the native support in modern graphics cards. Nevertheless, supported with the increasing storage and processing power of computers and the increasing capability of 3D data scanning devices, there has been an increasing interest in point-based representation that defines a geometric shape by a cloud of points sampled on the surface. As a result, increasingly more point set surfaces data are being produced, which give rise to a growing demand on effective compression schemes to efficiently utilize the storage, the processing and/or the bandwidth resources.

Many compression schemes have been proposed for both polygonal meshes and point set surfaces in the past couple of decades. These algorithms can be divided into single-rate and progressive 3D model encoders. A single-rate encoder usually traverses the model surface driven by the local correlation in connectivity and/or geometry, while a progressive encoder typically encodes an initial coarse model and thereafter a sequence of local refinements to the model. Almost all the existing algorithms are based on the local syntax without explicitly analyzing and understanding the high-level semantics of the shape. Based on the belief that semantic understanding of the shape will help a compact representation, we in this work make our first step in detecting the symmetry in a point set surface and, based on which, designing an efficient encoding scheme.

The major contribution of this work is a novel and effective algorithm for progressive compression of point set surfaces based on symmetry analysis. Distinctive features of this work include: 
                        
                           •
                           
                              Symmetry analysis. We detect the primary symmetry plane for an input model and use it to determine three orthogonal projection planes. These planes facilitate extracting as many surface portions as possible that can be modeled with rectangular height fields and effectively retrieving symmetric pairs, if any, from them.


                              Generic applicability. Due to the effective techniques specifically designed for different types of surface portions, the proposed scheme is able to process surfaces of arbitrary topology type, with or without obvious symmetry.


                              Superior coding performance. The superior rate–distortion performance comes mainly from three aspects: rectangular height field modeling of surface portions; detection and utilization of symmetry between surface portions; state-of-the-art wavelet-based and octree-based coders for various types of surface portions.

@&#RELATED WORK@&#

In this section, we briefly review works on point-based 3D model compression and works on symmetry detection for 3D geometry, which are related to ours.

Some research on point-based 3D model compression has been conducted in the context of efficient rendering, with many algorithms  [1–7] published.

In order to facilitate efficient rendering of the point-based 3D models, Rusinkiewicz and Levoy  [1] propose the QSplat rendering system using a hierarchical bounding sphere data structure for point organization and attribute quantization; Botsch et al.  [2] use an octree data structure for hierarchical organization and representation of the points; Krüger et al.  [3] construct multiple resolutions of the original model using multiple hexagonal close packing grids; Kalaiah and Varshney  [4] use a statistical representation of the point cloud to define a level-of-detail hierarchy; Hubo et al.  [5] adopt a quantized kd-tree that allows decompression in a depth-first manner reducing the decompression overhead during rendering; Hubo et al.  [7] apply vector quantization on small surface patches to allow direct and concurrent random access during ray tracing; Schnabel et al.  [6] apply vector quantization on an atlas of height fields allowing fast parallel decompression on the GPU. Since compact representation of surfaces is not the sole aim of these works, the compression performance they have achieved may not be sufficiently high.

Many general-purpose point-based model compression algorithms have been proposed as well. They can be classified as single-rate coders  [8–10] and progressive coders  [11–19]. We only review the progressive coders which are more related to ours.

Fleishman et al.  [11] propose progressive point set surfaces based on the moving least square (MLS) surface definition  [20]. Ochotta and Saupe  [13] also make use of the MLS surface. They use a set of planar height fields to resample the surface and encode them using image-based techniques. Later, Ochotta and Saupe  [17] improve their work and extend the compression scheme for 3D mesh compression as well. It is worth mentioning that Ochotta and Saupe  [13,17] essentially conduct local parameterization to generate the height fields. For 3D mesh compression, parameterization has been utilized as well for reduced data redundancy (e.g., Gu et al.  [21]). Waschbüsch et al.  [12] parameterize a given point-based model in a hierarchical tree structure in order to recursively predict point positions from corresponding tree nodes. It compresses all point attributes including position, normal and color. Huang et al.  [14,16] propose a generic progressive point cloud encoder based on octree decomposition of the model’s bounding volume. At each level of subdivision, the 3D geometry is approximated by the geometric centers of all the current leaf cells while normals and colors are approximated by the statistical average within each current leaf cell. Schnabel and Klein  [15] and Park and Lee  [18] also propose their point-based model encoders based on the octree decomposition, but approximate the local points in each sub-cube by a planar patch  [18]. Smith et al.  [19] use pruned octree and approximate the points in the sub-cube as a least square fitting plane, as reported, they get better results than Park and Lee  [18].

It is worth noting that none of the above-mentioned algorithms have tried to analyze the overall shape of a model to help the compression. Hubo et al.  [7] make simple self-similarity analysis among local patches on the surface, but the patches are small and their formation is not well controlled, leading to only discounted coding gain.

Symmetry detection for 3D geometry has received much research attention in computer graphics and computer vision in recent years. Algorithms have been proposed to detect all sorts of symmetries of 3D geometry including global and partial symmetries, exact and approximate symmetries, extrinsic and intrinsic symmetries and so forth. Mitra et al.  [22] make a comprehensive and comparative study of these methods. Here we only review several works closely related to ours.

Podolak et al.  [23] propose the planar reflective symmetry transform (PRST) as a shape descriptor. For any given plane, the PRST indicates the degree of symmetry that the object exhibits with respect to it. For computing efficiency, the authors propose a Monte Carlo framework to retrieve the symmetry plane based on the voting of randomly selected point pairs. Mitra et al.  [24] also consider pairs of points and their determined symmetry. Additionally, they consider rotational, translational and scaling symmetries as well. They extract the representative symmetries from the transform space through mean shift clustering. Simari et al.  [25] detect planar reflective symmetries in 3D meshes using an iteratively re-weighted least squares algorithm. It finds not only symmetries in different local regions of the model but also nested symmetries within each symmetric local region.

@&#OVERVIEW@&#

Given a point set surface (i.e., a point-based 3D model), the proposed encoder works in two stages: it firstly conducts planar reflective symmetry analysis and, based on which, divides the whole surface into symmetric height field pairs, non-symmetric height fields and the remaining surface portion; it secondly encodes the three types of surface portions using different methods to maximize the coding gain.

In the first stage, we firstly detect a plane maximizing a symmetry metric for the surface, which we call the primary symmetry plane even if the surface is not perfectly symmetric. Next, we project the 3D geometry onto three orthogonal planes including the primary symmetry one and adaptively subdivide the projection domains on these planes with a quadtree structure, resulting in rectangular sub-domains. Thereafter, we identify valid sub-domains corresponding to valid parameterizations of surface portions and use a height field to represent each of those surface portions. Finally, we identify symmetric height field pairs and segment the whole surface into three types of portions: symmetric height field pairs, non-symmetric height fields and the remaining surface portion.

In the second stage, for each symmetric height field pair, we encode one height field and the prediction residual for the other both using a 2D wavelet-based image encoder; for each non-symmetric height field, we encode it using a 2D wavelet-based image encoder; for the remaining surface portion, we encode it using an octree-based point cloud encoder. Carefully mixing the coding bits for these three types of surface portions, we achieve progressive compression of the input surface.

It should be noted that the proposed encoder often resamples surface portions to obtain compressed height fields. Therefore, the original and decoded models may have different numbers of surfels and there may not be obvious correspondence between the original and decoded surfels.

Given that the decoding process is simply the reverse of the encoding one, we will only provide the details for the encoding process in the rest of this paper.


                     Notation: We adopt in this paper the surfel set representation  [26] for point set surfaces. Assuming that a surfel set contains 
                        n
                      surfels, it is denoted as 
                        S
                        =
                        
                           {
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                           |
                           1
                           ≤
                           i
                           ≤
                           n
                           }
                        
                      where 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        =
                        
                           {
                           
                              
                                 
                                    p
                                 
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 
                                    n
                                 
                              
                              
                                 i
                              
                           
                           }
                        
                      defines the 
                        i
                     th surfel, i.e., a circular disk with a center at 
                        
                           
                              
                                 p
                              
                           
                           
                              i
                           
                        
                     , a radius of 
                        
                           
                              r
                           
                           
                              i
                           
                        
                      and a normal of 
                        
                           
                              
                                 n
                              
                           
                           
                              i
                           
                        
                     . It is noteworthy that other attributes like color are omitted from the above notation, since we focus on the 3D geometry compression only in this work. Further, as Huang et al.  [14,16], we encode the position and the normal but not the radius information, since the radii can easily be reconstructed from the surfels’ positions and normals to tile the surface.

Given an input point set surface, the goal of this stage is to segment the surface into portions such that as many portions as possible can be parameterized as rectangular height fields, and as many portion pairs as possible can be identified as symmetric pairs. With a height field, a 1D coefficient instead of 3D coefficients can be used to represent one point; with symmetric portion pairs identified, only one portion in a pair needs to be encoded at coarser levels of detail (LODs) while finer details about both are encoded only at finer LODs.

An arbitrary algorithm for surface segmentation and height field modeling may produce height fields on irregular domains. We need to fill those irregular domains to rectangles before applying image-based coders, which may cause significant waste in compressing the filling bits. Further, an arbitrary surface segmentation algorithm may break the symmetry between segments even if there is obvious symmetry in the input surface. Therefore, in order to facilitate compact encoding, we propose a symmetry-aware surface segmentation scheme. It strives to generate height fields on rectangular domains and preserve reflective similarities between surface segments. Specifically, we perform symmetry detection first, the result of which guides the surface segmentation that we perform next.

For the detection of planar reflective symmetry in 3D meshes, Simari et al.  [25] have proposed a method based on an iteratively re-weighted least squares algorithm. In this work, we adapt their method to detect planar reflective symmetry for point set surfaces.

For a perfectly symmetric 3D model, the symmetry plane can usually be detected by the principal component analysis (PCA): the symmetry plane is orthogonal to one of the eigenvectors of the model’s covariance matrix and passes through its center of mass. However, the one-pass PCA process may not always accurately give the symmetry plane especially when the model is not perfectly symmetric. As such, we conduct the iteratively re-weighted PCA process, which is very similar to the iteratively re-weighted least squares process in  [25] except that we compute the distance metric (and correspondingly the symmetry metric) for point set surfaces differently, as will be detailed later.

The iteratively re-weighted PCA process works as follows. An initial approximate symmetry plane is computed through a weighted PCA process, using the area of each surfel as its weight. Thereafter, the approximate symmetry plane is refined iteratively. In each iteration, we firstly update each surfel’s weight based on a distance metric at that surfel, and secondly conduct the weighted PCA to refine the approximate symmetry plane. For each approximate symmetry plane, an associated symmetry metric is computed. The iteration will stop to give the final approximate symmetry plane when the new symmetry plane and the previous one are closely enough or the number of iterations goes beyond a threshold. Based on our experiments, this process converges in less than 10 iterations for approximately symmetric models. For highly nonsymmetric models, this process may converge slowly or does not converge at all; for this case, the threshold on iteration count will stop the process.


                        Weighted PCA. For 
                           n
                         surfel positions, 
                           
                              
                                 
                                    p
                                 
                              
                              
                                 i
                              
                           
                           
                           
                              (
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              n
                              )
                           
                        , with corresponding weights, 
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                           
                           
                              (
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              n
                              )
                           
                        , we compute its covariance matrix as 
                           
                              
                                 C
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 
                                    (
                                    
                                       
                                          
                                             p
                                          
                                       
                                       
                                          i
                                       
                                    
                                    −
                                    
                                       m
                                    
                                    )
                                 
                                 
                                    
                                       
                                          (
                                          
                                             
                                                
                                                   p
                                                
                                             
                                             
                                                i
                                             
                                          
                                          −
                                          
                                             m
                                          
                                          )
                                       
                                    
                                    
                                       T
                                    
                                 
                              
                           
                         where 
                           
                              m
                           
                           =
                           
                              
                                 1
                              
                              
                                 s
                              
                           
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 n
                              
                           
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                           
                              
                                 
                                    p
                                 
                              
                              
                                 i
                              
                           
                         and 
                           s
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 n
                              
                           
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                        . Then we compute the eigenvectors of the matrix 
                           C
                        , which together with 
                           
                              m
                           
                         define three orthogonal planes, 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 P
                              
                              
                                 3
                              
                           
                        . Of the three planes, we choose the one with the minimum symmetry metric as the primary symmetry plane. The key issues with this weighted PCA process are to determine the weights for the surfels and to compute the symmetry metric for a given plane.


                        Weights and symmetry metric. Before computing the weight, 
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                        , of the 
                           i
                        th surfel, 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        , we first compute a distance metric, 
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                        , at 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        . With respect to the current approximate symmetry plane, 
                           P
                        , we reflect 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                           =
                           
                              {
                              
                                 
                                    
                                       p
                                    
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    
                                       n
                                    
                                 
                                 
                                    i
                                 
                              
                              }
                           
                         to obtain 
                           
                              
                                 s
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           =
                           
                              {
                              
                                 
                                    
                                       p
                                    
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    
                                       n
                                    
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              }
                           
                        . For every surfel 
                           
                              
                                 s
                              
                              
                                 j
                              
                           
                           =
                           
                              {
                              
                                 
                                    
                                       p
                                    
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    
                                       n
                                    
                                 
                                 
                                    j
                                 
                              
                              }
                           
                         on the same side of 
                           P
                         as 
                           
                              
                                 s
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                        , if the angle between 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                         and 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 j
                              
                           
                         is below a threshold 
                           
                              
                                 T
                              
                              
                                 a
                              
                           
                        , which we set to 30°, we compute the Euclidean distance between 
                           
                              
                                 
                                    p
                                 
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                         and 
                           
                              
                                 
                                    p
                                 
                              
                              
                                 j
                              
                           
                        . The minimum of these distances is taken as 
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                        . Thereafter, 
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                         is computed as 
                           
                              
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             2
                                             
                                                
                                                   δ
                                                
                                                
                                                   2
                                                
                                             
                                             /
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            δ
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      )
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                          
                                          
                                             if  
                                             
                                                
                                                   d
                                                
                                                
                                                   i
                                                
                                             
                                             <
                                             δ
                                          
                                       
                                       
                                          
                                             0
                                             ,
                                          
                                          
                                             otherwise.
                                          
                                       
                                    
                                 
                              
                           
                         Here 
                           δ
                           =
                           c
                           ×
                           
                              median
                           
                           
                              (
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         and 
                           c
                         is a user-configurable constant, which we set to 1.5 in our experiments. And, the symmetry metric for plane 
                           P
                         is defined as 
                           
                              
                                 m
                              
                              
                                 s
                              
                           
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 n
                              
                           
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                        .

To illustrate the effectiveness of this planar reflective symmetry detection algorithm, we show in Fig. 1
                         the results for three point set surfaces. As shown in the figure, the symmetry is accurately detected for the face model that is perfectly symmetric; approximate symmetries are also well detected for the horse and bunny models that are partially symmetric.

With the approximate symmetry detected, we take a sequence of steps to derive the final surface segmentation: geometry projection, half domain shuffling, domain subdivision and generation and classification of surface portions.

At the end of the iteratively re-weighted PCA process (see Section  4.1), we obtain three orthogonal planes 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           . Without loss of generality, we assume that 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                            is the primary symmetry plane. Each plane divides the original 3D geometry into two parts which we project onto two sides of the plane, respectively. Specifically, we first sample a dense rectangular array of grids on each projection plane. Next, for each surfel, we orthographically project it onto 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           , respectively, and find the grid points it covers on each plane; for each covered grid point, we imagine a ray shot straight up toward the surfel, and compute and record the height and the normal of its intersection with the surfel. This rectangular grid structure is called the projection domain for the corresponding 3D geometry. It is noteworthy that we use three rather than one projection plane, aiming to increase the chance of representing each surface region with a height field on a certain plane.

For the primary symmetry plane, 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                           , there potentially is similarity between the projected geometry on its two sides. For either 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            or 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           , there potentially is similarity between the projected geometry on two half domains on each side of the plane. This is illustrated in Fig. 2
                           . As shown in Fig. 2(a), 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                            intersects with the other two planes 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                            at lines 
                              
                                 
                                    l
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    l
                                 
                                 
                                    3
                                 
                              
                           , respectively. The domains or half domains on both sides of each plane are shown in Fig. 2(b)–(d), respectively. Since 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                            is the primary symmetry plane, we expect similarity between the projected geometry on 
                              
                                 
                                    D
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    D
                                 
                                 
                                    2
                                 
                              
                           , 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                           , 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                                 
                                    ′
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                                 
                                    ′
                                 
                              
                           , 
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                           , 
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                                 
                                    ′
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                                 
                                    ′
                                 
                              
                           , respectively. In other words, we expect symmetric surface patches projected onto different sides of 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                            but onto the same side of 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            or 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           . To facilitate consistent processing in later steps, we shuffle the four half domains on the two sides for 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                            such that the potential similar counterparts are separated to two sides of the plane, reflective to each other with respect to that plane. Taking 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            as an example, we shuffle the four half domains as follows: we combine the half domains (and the associated projected geometry) 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                                 
                                    ′
                                 
                              
                            onto one side of 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                           , and combine 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                                 
                                    ′
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                            onto the other, as illustrated in Fig. 2(e). Similarly, we shuffle the four half domains on 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                            to obtain the result shown in Fig. 2(f).

With the half domains shuffled for 
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           , we will later on be able to consistently make domain subdivision and search for similarities on both sides of each plane, 
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                            or 
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                           .

For each projection plane, we subdivide the projection domain into rectangular sub-domains. Our aim is to produce sub-domains as large as possible whose corresponding portions on the point set surface can be modeled as height fields.

The domain subdivision is achieved through valid grid test and adaptive quad-tree subdivision. We conduct the valid grid test separately on each side of the projection plane. On each side, we first mark every grid in the domain as valid or invalid. A grid is invalid if it corresponds to zero or more than one well-apart intersections with the surfels (as computed in Section  4.2.1); otherwise, it is valid. As an example, the projection domain on one side of the primary symmetry plane for Igea is shown in Fig. 3
                           (a) where the valid (invalid) grid points are colored white (black). Thereafter, we conduct iterative quad-tree subdivision to the projection domain. The root quad-tree cell coincides with the bounding rectangle of the projection domain. In each iteration, we examine each current leaf cell and, if the ratio of invalid grids on both sides within that cell goes beyond a threshold, we expand it by one level down (i.e., we subdivide it into four equal-sized rectangular child cells). The iteration stops when no current leaf cells need to be expanded or a maximum tree height has been reached. As an example, for the projection domain shown in Fig. 3(a), the result of the quad-tree subdivision to the third level is shown in Fig. 3(b).

We use one global queue to maintain the prioritized valid sub-domains. Initially, all the valid sub-domains on all the projection planes are put in the queue in a descending order of their priority scores. Each valid sub-domain corresponds to two surface portions at two sides of the projection plane. We prioritize a valid sub-domain based on the corresponding surface portions’ areas, the angles between the sub-domain and the corresponding surface portions, and the similarity between the two corresponding surface portions. Specifically, denoting the two sides of the sub-domain as 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                           , the corresponding surface portions as 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                            and their corresponding height maps as 
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    H
                                 
                                 
                                    2
                                 
                              
                           , respectively, the angle between the average surfel normal of 
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                            and the normal of 
                              
                                 
                                    R
                                 
                                 
                                    i
                                 
                              
                            as 
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                            radians (
                              i
                              =
                              1
                              ,
                              2
                           ), the maximum and minimum heights in the height maps as 
                              
                                 
                                    h
                                 
                                 
                                    M
                                 
                              
                            and 
                              
                                 
                                    h
                                 
                                 
                                    m
                                 
                              
                           , respectively, the score, 
                              g
                           , of this sub-domain is defined as 
                              
                                 
                                    (1)
                                    
                                       A
                                       =
                                       
                                          Area
                                       
                                       
                                          (
                                          
                                             
                                                R
                                             
                                             
                                                1
                                             
                                          
                                          )
                                       
                                       +
                                       
                                          Area
                                       
                                       
                                          (
                                          
                                             
                                                R
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                                 
                                    (2)
                                    
                                       B
                                       =
                                       1
                                       −
                                       
                                          
                                             
                                                
                                                   θ
                                                
                                                
                                                   1
                                                
                                             
                                             +
                                             
                                                
                                                   θ
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             2
                                             π
                                          
                                       
                                       ,
                                    
                                 
                                 
                                    (3)
                                    
                                       C
                                       =
                                       1
                                       −
                                       
                                          
                                             
                                                STD
                                             
                                             
                                                (
                                                
                                                   
                                                      H
                                                   
                                                   
                                                      1
                                                   
                                                
                                                −
                                                
                                                   
                                                      H
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   M
                                                
                                             
                                             −
                                             
                                                
                                                   h
                                                
                                                
                                                   m
                                                
                                             
                                          
                                       
                                       ,
                                    
                                 
                                 
                                    (4)
                                    
                                       g
                                       =
                                       
                                          
                                             w
                                          
                                          
                                             a
                                          
                                       
                                       ⋅
                                       A
                                       +
                                       
                                          
                                             w
                                          
                                          
                                             b
                                          
                                       
                                       ⋅
                                       B
                                       +
                                       
                                          
                                             w
                                          
                                          
                                             c
                                          
                                       
                                       ⋅
                                       C
                                       .
                                    
                                 
                              
                            Here 
                              
                                 Area
                              
                              
                                 (
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            measures the area of the sub-domain 
                              
                                 
                                    R
                                 
                                 
                                    i
                                 
                              
                              
                              
                                 (
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 )
                              
                           , 
                              
                                 STD
                              
                              
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 −
                                 
                                    
                                       H
                                    
                                    
                                       2
                                    
                                 
                                 )
                              
                            measures the standard deviation of the residuals between two height maps, and 
                              
                                 
                                    w
                                 
                                 
                                    a
                                 
                              
                              ,
                              
                                 
                                    w
                                 
                                 
                                    b
                                 
                              
                            and 
                              
                                 
                                    w
                                 
                                 
                                    c
                                 
                              
                            are user-configurable parameters which we empirically set to 0.01, 1 and 2, respectively. In essence, 
                              A
                            approximates the sum of the surface areas of 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           , 
                              B
                            measures the orientation consistency between the sub-domain and the corresponding surface portions and 
                              C
                            measures the degree of symmetry between 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           .

We make the surface segmentation and surface portion classification through an iterative process. In each iteration, we pop out the first element (i.e., the valid sub-domain with the highest priority) from the queue, if its symmetry measure 
                              C
                            is above a threshold, we mark the corresponding two surface portions as a symmetric height field pair; otherwise, we mark them as non-symmetric height fields. Next, we mark each grid that these two portions cover on one side of each projection plane as invalid. Thereafter, for each of the affected sub-domain(s) in the queue, if any, we test if it is still valid based on the ratio of invalid grids on the two sides. If it is not, we remove it from the queue, conduct further subdivision to this sub-domain as described in Section  4.2.3, and insert the newly generated valid sub-domains, if any, into the queue. This process iterates until the queue becomes empty. Finally, all the unmarked surfels are treated as the remaining surface portion as a whole.

As an example, we obtain the symmetry-aware surface segmentation for Igea as shown in Fig. 4
                            where Fig. 4(a) visualizes the distinct surface portions and Fig. 4(b) the types of surface portions, each with a different color.

Before encoding the surface portions, we first encode global information including the rectangular bounding volume of the input surface, the sampling resolution on the projection domains, and the three quad-tree structures specifying valid and invalid sub-domains on the projection planes. The bounding volume and the sampling resolution can be easily encoded with a few floating point numbers. A quad-tree is encoded through a width-first traversal of the tree starting from the root. At each node, if the corresponding sub-domain is valid, we encode a bit ‘1’; otherwise, we encode a bit ‘0’. All these bits are encoded with an arithmetic coder. Thereafter, we use different methods to encode different types of surface portions in order to maximize the coding gain and achieve generic applicability at the same time.

For a symmetric pair of height fields, we encode one height field with an embedded zerotree wavelet (EZW) image coder  [27], use its reflective image to predict the other height field and only encode the prediction residual with another EZW image coder. Due to the high reflective similarity between a pair of symmetric height fields, we expect that the prediction produces tiny residuals in most cases, leading to coding gain than encoding two height fields separately.

For non-symmetric height fields, we directly use the EZW image coder to encode each of them. Due to the height field surface modeling and the effectiveness of the EZW image coder, we still achieve compact coding of these surface patches. It should be noted that we do not explicitly encode the normal information for the symmetric height field pairs and the non-symmetric height fields, which we derive at the decoder side based on the geometry of the local neighborhood around each point.

For the remaining surface portion, we encode it with an octree-based point cloud encoder  [16], a state-of-the-art generic point cloud encoder that is able to compress generic point clouds regardless of the underlying surface topologies. It should be noted that, in addition to the positions, the octree-based point cloud encoder compresses the normals of the surfels as well.

Finally, we combine the coding bits from various encoders to form a bit stream for compression of the input model. Since both the EZW encoder and the octree-based encoder are progressive, it is possible to make the combined bit stream a progressive one. Initially, a small number of each surface portion’s coding bits are put into the combined bit stream. After that, we combine the remaining coding bits for all the surface portions in an iterative process. In each iteration, we pick the currently reconstructed surface portion that has the largest distortion (whose computation will be described in Section  6), extract an incremental number of its remaining coding bits, and append it to the current combined bit stream. This iteration continues until all the coding bits of the surface portions have been combined.

@&#EXPERIMENTAL RESULTS@&#

We use eight surfel set models in our experiments. They are Igea and Face by the courtesy of Pointshop 3D, Acer Saccarinum and m1007 from Xfrog public plants, Bunny, Dragon and Happy Buddha from the Stanford 3D scanning repository, and Horse from Aim@Shape. In order to compare with previous works, we use two versions of the Bunny models in our experiments, Bunny(277k) and Bunny(32k). It should be noted that we obtained the surfel set models for m1007, Bunny(277k), Horse and Acer Saccarinum from the original 3D meshes by subdividing each triangle into four sub-triangles and placing a surfel at the center of each sub-triangle. Bunny(32k) is obtained by converting each vertex of the original mesh to a surfel. Dragon and Happy Buddha are provided by Huang et al.  [16]. The meshes are re-sampled before the converting process.

It is noteworthy that, similar to our algorithm, another one proposed by Ochotta and Saupe  [17] also makes use of height field modeling and encoding. However, it works only on manifold surfaces while our algorithm works on models of arbitrary topological complexity. Ochotta and Saupe  [17] measure the distortion between two point set surfaces as the error between the corresponding MLS surfaces rather than the discrete point sets. However, as pointed out in  [7,15], measuring closest point-pair distances is preferable to measuring MLS surface errors to evaluate the distortion between two point set surfaces, since the former takes into account the difference in sampling as well.

We adopt the distortion metric based on closest point-pair distances (as described in Section  6.2) and make quantitative comparison with three peering algorithms that are proposed by Huang et al.  [16], Schnabel and Klein  [15] and Hubo et al.  [7], respectively. We compare with these benchmarks published by the year 2008, since there have been much less research activities on point cloud compression in more recent years. Of these three benchmarks, the first two  [16,15] are state-of-the-art ones that compress arbitrary models regardless of the underlying topology, while the last one  [7] effectively compresses manifold models only. We compare with the third benchmark  [7] since, to the best of our knowledge, it is the only one that has tried exploiting similarity among small local patches in the compression.

We measure the coding bit-rate in bits per point (bpp), with respect to the number of points in the original model. The distortion is measured by peak-signal-to-noise ratio (PSNR), which is given by 
                           20
                           
                              
                                 log
                              
                              
                                 10
                              
                           
                           
                              (
                              
                                 
                                    d
                                 
                                 
                                    B
                                 
                              
                              /
                              E
                              )
                           
                        , where 
                           
                              
                                 d
                              
                              
                                 B
                              
                           
                         is the diagonal length of the original model’s tight axis-aligned bounding box and 
                           E
                         is the error (distortion) between the original and reconstructed surfel set surfaces.

When evaluating the error 
                           E
                        , we follow the method used by Waschbüsch et al.  [12] and measure the symmetric root mean square 
                           
                              RMS
                           
                           
                              (
                              U
                              ,
                              C
                              )
                           
                         between the original, unquantized point set surface 
                           U
                         and the compressed point set surface 
                           C
                        . 
                           
                              RMS
                           
                           
                              (
                              U
                              ,
                              C
                              )
                           
                         is computed by finding nearest neighbors for every point of 
                           U
                         in 
                           C
                        . The error 
                           E
                         is then given as 
                           max
                           
                              (
                              
                                 RMS
                              
                              
                                 (
                                 U
                                 ,
                                 C
                                 )
                              
                              ,
                              
                                 RMS
                              
                              
                                 (
                                 C
                                 ,
                                 U
                                 )
                              
                              )
                           
                        , which is adopted in  [7,15] as well.


                        Table 1
                         gives results for various models at various bit-rates using the proposed and the octree-based encoder (OT)  [16]. From this table, we see that our encoder has significant PSNR advantages over OT at all the bit-rates for Igea, Face, Bunny and Horse, all of which are manifold, largely symmetric, and with a high percentage of surface portions that can be modeled with height fields. Of these models, Face is the most symmetric and Face and Igea are more symmetric than Horse and Bunny. Correspondingly, if we examine the total coding bits (obtained by bpp × #points) and the corresponding PSNR values for each of these models, we observe that the bits-distortion performance for Face is better than Igea and the bits-distortion performance of Igea is still much better than Horse and Bunny. Furthermore, we experiment on large models (i.e., Dragon and Happy Buddha) each with a certain degree of symmetry, and obtain better rate–distortion performance over OT as shown in Table 1. For m1007 which contains significant manifold and non-manifold components simultaneously, our coder also leads to noticeably higher PSNR values than OT. For Acer Saccarinum, a highly complex non-manifold “point soup”, our encoder degenerates to an octree-based coder and produces the same R–D statistics as OT. From Table 1, we observe that our encoder works on models of arbitrary topological complexity but works particularly good for surfaces with a high portion of symmetric manifold components that can be modeled as height fields.

Further, we plot the R–D curves for our encoder and OT on several models in Fig. 5
                        . From this figure, we again observe that our coder leads to more coding gain on Igea and Face, which have higher degrees of symmetry, than Bunny, m1007 and Happy Buddha.

We compare our encoder with  [15,7] on Igea and Bunny(32k), with the R–D curves shown in Fig. 6
                        (a) and (b), respectively. The R–D data for  [15] is obtained from Table I in Ref.  [16], and the R–D data for  [7] is obtained from Fig. 10(d) in Ref.  [7]. From Fig. 6(a) and (b), we observe sharp R–D advantages of our encoder over  [15,7] on Igea and Bunny(32k), respectively.

We show in Table 2
                         the encoding and decoding timing statistics for our test models. From Table 2, we observe that the decoding takes a few seconds for our test models, which is generally acceptable for online and progressive transmission of large 3D models. The encoding takes more time than the decoding mainly due to the symmetry detection. It should be noted that our research code is not yet optimized for efficiency.

Visual comparison with  [16] is made in Fig. 7
                        , where the corresponding encoder, bit-rate and PSNR value are marked below each model. From Fig. 7, we observe clearly better quality of the reconstructed models using our encoder at the same bit-rates.

In Fig. 8
                        , we show the original models and the reconstructed models at selected low bit-rates for Horse, m1007, Dragon, Acer Saccarinum and Happy Buddha. From this figure, we see that a visually pleasant approximation already appears at around 1 bpp for each of the point set surfaces (i.e., Horse, m1007, Dragon and Happy Buddha), and the approximation becomes close to the original already at around 5 bpp. For the highly complex non-manifold model (i.e., Acer Saccarinum), visually pleasant approximation appears at around 2 bpp, and the reconstructed model gets close to the original at above 8 bpp.

We have presented in this paper a novel algorithm for progressive compression of generic 3D point-based models based on planar reflective symmetry analysis. To the best of our knowledge, this work pioneers in analyzing and utilizing high-level symmetry information for efficient encoding of point-based 3D models. Given a point-based model, the proposed algorithm identifies the primary symmetry plane and, based on which, determines three orthogonal projection planes. By analyzing the model surface’s projections on these planes, the surface is segmented into portions which are classified into symmetric height fields, non-symmetric height fields, and the remaining surface portion. Symmetry based prediction and embedded zerotree wavelet coders are employed for compact coding of the former two types, and octree-based encoder is employed for the last type of portion. As a result, we have made a point-based 3D model encoder that achieves generic applicability and excellent rate–distortion performance at the same time, as demonstrated by experiments.

In the future, we plan to investigate the use of local symmetries and embedded symmetries as well, in addition to the high-level symmetry, for further reduced coding cost. It is also interesting to explore more compact model representation based on a deeper semantic understanding of a 3D object. Further, it is worth exploring out-of-core compression of super large models.

@&#ACKNOWLEDGMENTS@&#

This work is supported by Shandong Provincial Natural Science Foundation, China (Grant No. ZR2011FZ004), the National Natural Science Foundation of China (Grant No. U1035004), and the Program for New Century Excellent Talents in University (NCET) in China.

@&#REFERENCES@&#

