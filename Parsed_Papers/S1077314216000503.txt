@&#MAIN-TITLE@&#Randomized low-rank Dynamic Mode Decomposition for motion detection

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Fast and robust decomposition of a matrix representing a spatial grid through time.


                        
                        
                           
                           Rapid approximation for robust principal component analysis.


                        
                        
                           
                           Competitive performance in terms of recall and precision for motion detection.


                        
                        
                           
                           GPU accelerated implementation allows faster computation.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Dynamic Mode Decomposition

Robust principal component analysis

Randomized singular value decomposition

Motion detection

Background subtraction

Video surveillance

@&#ABSTRACT@&#


               
               
                  This paper introduces a fast algorithm for randomized computation of a low-rank Dynamic Mode Decomposition (DMD) of a matrix. Here we consider this matrix to represent the development of a spatial grid through time e.g. data from a static video source. DMD was originally introduced in the fluid mechanics community, but is also suitable for motion detection in video streams and its use for background subtraction has received little previous investigation. In this study we present a comprehensive evaluation of background subtraction, using the randomized DMD and compare the results with leading robust principal component analysis algorithms. The results are convincing and show the random DMD is an efficient and powerful approach for background modeling, allowing processing of high resolution videos in real-time. Supplementary materials include implementations of the algorithms in Python.
               
            

@&#INTRODUCTION@&#

The demand for video processing is rapidly increasing, driven by greater numbers of sensors with greater resolution, new types of sensors, new collection methods and an ever wider range of applications. For example, video surveillance, vehicle automation or wild-life monitoring, with data gathered in visual/infra-red spectra or SONAR, from multiple sensors being fixed or vehicle/drone-mounted etc. The overall result is an explosion in the quantity of high dimensional sensor data. Motion detection is often the fundamental building block for more complex video processing and computer vision applications, e.g. object tracking or human behavior analysis. In practice, there are many different types of sensors giving data suitable for object extraction, however we focus here on video data provided by static optical cameras, noting the findings generalize to other data types. In this case, the change in position of an object relative to its surrounding environment can be detected by intensity changes over time in a sequence of video frames. The challenge therefore is to separate intensity changes corresponding to moving objects from those generated by background noise i.e. dynamic and complex backgrounds. From a statistical point of view this can be formulated as a density estimation problem, aiming to find a suitable model describing the background. Moving objects can then be identified by differences from the reconstructed background from the video frames, via some thresholding, as illustrated in Fig. 1
                     . In practice, the problem of finding a suitable model is difficult and often ill-posed due to the many challenges arising in real videos, e.g., dynamic backgrounds, camouflage effects, camera jitter or noisy images, to name only a few. One framework for tackling these challenges is provided by subspace learning techniques. Recently, robust principal component analysis (RPCA) has been very successful in separating video frames into background and foreground components [1]. However, RPCA comes with relatively high computational costs and it is of limited utility for real-time analysis of high resolution video. Hence, in light of increasing sensor resolutions there is a need for algorithms to be more rapid, perhaps by approximating existing techniques.

A competitive alternative is Dynamic Mode Decomposition (DMD) — a data-driven method allowing decomposition of a matrix representing both time and space [2]. Due to the unique properties of videos (equally spaced time with high temporal correlation), DMD is well suited for motion detection, as first demonstrated by Grosek and Kutz [3].

@&#RELATED WORK@&#

Bouwmans [4] or Sobral and Vacavant [5] provide recent and comprehensive reviews of methods for background modeling and related challenges. Among the many different techniques, the class of (robust) subspace models are prominent. PCA can be considered a traditional technique for describing the probability distribution of a static background. However, PCA has some essential shortcomings and many enhancements have been proposed since the method was first proposed for background subtraction by Oliver et al. [6], e.g. adaptive, incremental or independent PCA. A review of those traditional subspace models and related issues is provided by Bouwman [7]. While DMD is related to PCA and shares some of the same limitations, it can overcome others to greatly improve the performance. Grosek and Kutz [3] have shown that DMD can be seen in fact as an approximation to robust PCA (see also [8]). The idea of RPCA is to separate a matrix A into a low-rank L and sparse component S
                        
                           
                              (1)
                              
                                 
                                    A
                                    =
                                    L
                                    +
                                    S
                                 
                              
                           
                        This can be formulated as a convex optimization problem that minimizes a combination of the l
                        2 and l
                        1 norm. Applied to video data, the low-rank component describes the relatively static background environment, which is allowed to gradually change over time, while the second component captures the moving objects. This approach has gathered substantive attention for foreground detection since the idea was first introduced by Candès [9] — further extended by Zhou [10] for also capturing entry-wise noise. Bouwmans and Zahzah [1] recently provided a comparative evaluation of the most prominent RPCA implementations, whose results show LSADM [11] and TFOCS [12] algorithms perform best in extracting moving objects in terms of the F-measure. Guyon et al. [13] show in detail how the former algorithm can be used for moving object detection.

The problem formulation via RPCA leads to iterative algorithms with high computational costs. Most of the algorithms require repeated computation of the Singular Value Decomposition (SVD), so clearly the algorithms may be accelerated by using faster approximate SVD, aiming to find only the k dominant singular values. Liu et al. [14] present a Krylov subspace-based algorithm for computing the first k singular values with high precision. They showed that their LMSVD algorithm can reduce the computational time of RPCA substantially. Later they showed even greater computational savings with their Gauss–Newton method based SVD algorithm [15]. If high precision is not the main concern then approximate Monte-Carlo based SVD algorithms can be interesting alternatives [16,17]. A different approach is via randomized matrix algorithms, which are surprisingly robust and provide significant speed-ups, while being simple to implement [18]. Halko et al. [19] and Gu [20] provide comprehensive surveys of randomized algorithms for constructing approximate matrix decompositions, while Mahoney [21] gives a more general overview. One successful approximate robust PCA algorithm using a randomized matrix algorithms is given in GoDec [22].

A core building block of the DMD algorithm, as for RPCA, is the SVD. As noted, traditional deterministic SVD algorithms are expensive to compute and with increasing data they often pose a computational bottleneck. We propose the use of a fast, probabilistic SVD algorithm, exploiting the rapidly decaying singular values of video data. Randomized SVD is a lean and easy to implement technique for computing a robust approximate low-rank SVD [19]. Compared to deterministic truncated or partial SVD algorithms, we gain computational savings in the order of 10 to 30 times. The next effect is to increase speed of about 2 to 3 times with randomized DMD, rather than deterministic SVD based DMD. Hence, randomized DMD may facilitate real-time processing of videos. Moreover, randomized SVD and DMD are embarrassingly parallel and we show that the computational performance can benefit from a Graphics Processing Unit (GPU) implementation. To demonstrate the applicability for motion detection, we have evaluated and compared dynamic mode decomposition on a comprehensive set of synthetic and real videos with other leading algorithms in the field.

The rest of this paper is organized as follows. Section 2 presents randomized SVD as an approximation to the deterministic algorithms. Section 3 first introduces DMD and then shows how a low-rank DMD approximation using randomized SVD can be used for background modeling. Finally a detailed evaluation of DMD is presented in Section 4. Concluding remarks and further research directions are given in Section 5.

Matrix factorizations are fundamental tools for many practical applications in signal processing, statistical computing and machine learning. SVD is one such technique, used for data analysis, dimensionality reduction or data compression. Given an arbitrary real matrix 
                        
                           A
                           ∈
                           
                              R
                              
                                 m
                                 ×
                                 n
                              
                           
                        
                      we seek a decomposition, such that

                        
                           (2)
                           
                              
                                 A
                                 =
                                 U
                                 Σ
                                 
                                    V
                                    *
                                 
                              
                           
                        
                     where 
                        
                           U
                           ∈
                           
                              R
                              
                                 m
                                 ×
                                 m
                              
                           
                        
                      and 
                        
                           V
                           ∈
                           
                              R
                              
                                 n
                                 ×
                                 n
                              
                           
                        
                      are orthogonal matrices, and 
                        
                           Σ
                           ∈
                           
                              R
                              
                                 m
                                 ×
                                 n
                              
                           
                        
                      is a diagonal matrix with the same dimensions as A 
                     [23]. The columns of U and V are both orthonormal, called right and left singular vectors, respectively. The singular values denoted as σi
                      are the diagonal elements of 
                        Σ
                      sorted in decreasing order. While we assume a real matrix here, for generality we use the Hermitian transpose denoted as *.

In practice we may be interested in a low-rank approximation of A with target rank k ≪ m, n. Choosing the optimal target rank k is highly dependent on the task, i.e. whether one is interested in a very good reconstruction of the original data or in a very low dimensional representation of the data. The reconstruction error for a low-rank approximation:

                        
                           (3)
                           
                              
                                 
                                    ∥
                                    A
                                    −
                                 
                                 
                                    U
                                    k
                                 
                                 
                                    Σ
                                    k
                                 
                                 
                                    V
                                    k
                                    *
                                 
                                 
                                    
                                       ∥
                                    
                                    F
                                 
                                 =
                                 
                                    σ
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     is given by the singular value 
                        
                           
                              σ
                              
                                 k
                                 +
                                 1
                              
                           
                           ,
                        
                      where the index F denotes the Frobenius norm. Thus, a reasonable small singular value gives a low reconstruction error, and we can denote k in this case as the effective rank of the matrix A. It can be proven that the exact low rank approximation is provided by the deterministic SVD, however the computational costs can be tremendous for large-scale problems, in particular for unstructured data. In the following, we present a faster randomized algorithm [19].

Randomized matrix algorithms are approximate algorithms for linear algebra problems using random sampling and projections to accelerate the computation [21]. Given an input matrix 
                           
                              A
                              ∈
                              
                                 R
                                 
                                    m
                                    ×
                                    n
                                 
                              
                           
                         and a desired target rank k ≪ m, n the randomized algorithm for computing the approximate low-rank SVD can be roughly divided into two stages.

The first stage is concerned with finding a random low-dimensional subspace that best captures the column space of A. Here the idea of random projections is used to build the basis for the column space. We simply draw k random Gaussian vectors x
                        
                           i
                         and compute the following random sketch

                           
                              (4)
                              
                                 
                                    
                                       y
                                       i
                                    
                                    =
                                    A
                                    
                                       x
                                       i
                                    
                                    
                                    for
                                    
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    .
                                    ,
                                    k
                                 
                              
                           
                        As a result from probability theory, it follows that the random vectors, and hence the set {y
                        
                           i
                        } are linearly independent. We can compute (4) more compactly as matrix–matrix product

                           
                              (5)
                              
                                 
                                    Y
                                    =
                                    A
                                    Ω
                                 
                              
                           
                        where 
                           
                              Ω
                              ∈
                              
                                 R
                                 
                                    n
                                    ×
                                    k
                                 
                              
                           
                         is a random Gaussian matrix. We then compute the QR-Decomposition of Y to obtain the orthonormal matrix 
                           
                              Q
                              ∈
                              
                                 R
                                 
                                    m
                                    ×
                                    k
                                 
                              
                           
                         so that

                           
                              (6)
                              
                                 
                                    A
                                    ≈
                                    Q
                                    
                                       Q
                                       *
                                    
                                    A
                                 
                              
                           
                        is satisfied.

In the second stage we project the input matrix A onto the low-dimensional subspace

                           
                              (7)
                              
                                 
                                    B
                                    =
                                    
                                       Q
                                       *
                                    
                                    A
                                 
                              
                           
                        The action of the column space of A is now restricted to the relatively small (if k ≪ m, n) matrix 
                           
                              B
                              ∈
                              
                                 R
                                 
                                    k
                                    ×
                                    n
                                 
                              
                           
                        . Subsequently we can cheaply compute the deterministic SVD of B as

                           
                              (8)
                              
                                 
                                    B
                                    =
                                    
                                       U
                                       ˜
                                    
                                    Σ
                                    
                                       V
                                       *
                                    
                                 
                              
                           
                        The randomized algorithm can be justified as follows

                           
                              (9)
                              
                                 
                                    
                                       
                                          A
                                       
                                       
                                          ≈
                                       
                                       
                                          
                                             Q
                                             
                                                Q
                                                *
                                             
                                             A
                                          
                                       
                                    
                                    
                                       
                                       
                                          ≈
                                       
                                       
                                          
                                             Q
                                             B
                                          
                                       
                                    
                                    
                                       
                                       
                                          ≈
                                       
                                       
                                          
                                             Q
                                             
                                                U
                                                ˜
                                             
                                             Σ
                                             
                                                V
                                                *
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          ≈
                                       
                                       
                                          
                                             U
                                             Σ
                                             
                                                V
                                                *
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Thus we can recover the right singular vectors by computing

                           
                              (10)
                              
                                 
                                    U
                                    ≈
                                    Q
                                    
                                       U
                                       ˜
                                    
                                 
                              
                           
                        
                        Algorithm 1
                         shows a prototype for computing the randomized SVD.
                           1
                        
                        
                           1
                           See supplementary materials for a more detailed algorithm and Python implementation with oversampling parameter and subspace iterations.
                        
                        
                           Remark 1
                           Common choices for generating the random matrix 
                                 Ω
                               are the normal or uniform distribution.

The computational time can further reduced by first computing the QR-decomposition of B and then computing the SVD of the even smaller matrix 
                           
                              R
                              ∈
                              
                                 R
                                 
                                    k
                                    ×
                                    k
                                 
                              
                           
                         (see Voronin et al. [24] for further details).

The approximation error of a randomized SVD can be decreased by introducing a small oversampling parameter p. This means, instead of drawing k random vectors, we generate 
                           
                              k
                              +
                              p
                           
                         samples, so that the likelihood of spanning the correct subspace is increased. A small oversampling parameter p (e.g. 
                           
                              p
                              =
                              5
                           
                        ) is generally sufficient. Further, computing q power iterations can increase the accuracy:

                           
                              (11)
                              
                                 
                                    Y
                                    =
                                    
                                       
                                          (
                                          A
                                          
                                             A
                                             *
                                          
                                          )
                                       
                                       q
                                    
                                    A
                                    Ω
                                 
                              
                           
                        The power iterations drive the spectrum of Y down and the approximation error, which is proportional to the spectrum, decays exponentially with the number of iterations. Even if the signal-to-noise ratio is low, 
                           
                              q
                              =
                              1
                              ,
                              2
                           
                         power iterations already achieve good results. For numerical reasons a practical implementation should use subspace iterations instead of power iterations [20]. Halko et al. [19] showed that the approximation error of randomized SVD has the following error bound [19], if the oversampling parameter is chosen equal to k, i.e. l ≔ 2k
                        
                           
                              (12)
                              
                                 
                                    E
                                    
                                       [
                                       
                                          ∥
                                          A
                                          −
                                       
                                       
                                          U
                                          l
                                       
                                       
                                          Σ
                                          l
                                       
                                       
                                          V
                                          l
                                          *
                                       
                                       
                                          ∥
                                       
                                       ]
                                    
                                    =
                                    
                                       σ
                                       
                                          l
                                          +
                                          1
                                       
                                    
                                    
                                       
                                          [
                                          1
                                          +
                                          4
                                          
                                             
                                                
                                                   2
                                                   m
                                                   i
                                                   n
                                                   (
                                                   m
                                                   ,
                                                   n
                                                   )
                                                
                                                
                                                   l
                                                   −
                                                   1
                                                
                                             
                                          
                                          ]
                                       
                                       
                                          1
                                          
                                             2
                                             q
                                             +
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        
                     

SVD is often the bottleneck in practical large-scale applications. Many different methods for computing the SVD have been proposed and optimized for different problems, exploiting certain matrix properties. Thus, giving a detailed overview of the computational costs is difficult.

In short however, the time complexity for the ordinary deterministic SVD algorithms is O(mn
                        2) if m > n, while modern partial SVD methods based on rank-revealing QR-factorization can reduce the time complexity to O(mnk) [25]. The randomized SVD algorithm using random sampling, as we have presented it here, needs two passes over the input matrix and also has asymptotic costs of O(mnk). Hence, theoretically we have the same costs asymptotically — however, from a practical point of view, it is much cheaper to compute a matrix–matrix multiplication than a column-pivoted QR factorization. The costs can be further deceased by exploiting certain matrix properties to compute a fast matrix–matrix multiplication of (5) to O(mnlog(k)) floating point operations. For example, the Subsampled Random Fourier Transform (SRFT) as proposed by Woolfe et al. [26] can be used.

In practice, the computational time of (randomized) SVD algorithms is also heavily driven by the computational platform used, the specific implementation and whether the matrix fits into the fast memory. An advantage of randomized SVD is that it can benefit from parallel computing. For example, permitting a GPU implementation, leading to dramatic acceleration [24]. This is because the GPU architecture enables fast generation of random numbers and fast matrix-matrix multiplications.

DMD is a data-driven method, fusing PCA with time-series analysis (Fourier transform in time) [2]. This integrated approach for decomposing a data matrix overcomes the PCA short-coming of performing an orthogonalization in space only. DMD is an emergent technique in the fluid mechanics community for analyzing the dynamics of non linear systems and was originally proposed by Schmidt [27] and Rowley et al. [28]. Allowing the assessment of spatio-temporally coherent structures, with almost no underlying assumptions makes DMD interesting for video processing. Specifically, the resulting low-rank features are of interest for modeling the background of surveillance videos. In addition, DMD also allows predictions to be made about short-time future states of video streams [29].

To compute the DMD, an ordered and evenly spaced data sequence describing a dynamical system is required. This applies naturally to videos, where a data matrix 
                        
                           D
                           ∈
                           
                              R
                              
                                 m
                                 ×
                                 n
                              
                           
                        
                      can be constructed so that the columns are n consecutive grey colored videos frames 
                        
                           f
                           ∈
                           
                              R
                              m
                           
                        
                     . The elements djt
                      of D refer to the intensity of a pixel in space (j) and time (t). As is common in the DMD literature, we denote such a data matrix also as snapshot sequence. Further, it is reasonable to assume that two consecutive video frames are related to each other in time. Mathematically, we can establish the following important relationship

                        
                           (13)
                           
                              
                                 
                                    f
                                    
                                       t
                                       +
                                       1
                                    
                                 
                                 =
                                 M
                                 
                                    f
                                    t
                                 
                              
                           
                        
                     stating that there exists an unknown underlying linear operator 
                        
                           M
                           ∈
                           
                              R
                              
                                 m
                                 ×
                                 m
                              
                           
                        
                      that connects two consecutive video frames [27]. Here the index t ∈ {1, 2
                        
                           ,
                           …
                           ,
                        
                      
                     n} is denoting a frame in time. It turns out that M is the Koopman operator whose eigenvalue decomposition describes the evolution of a video sequence [30]. Hence, the goal of DMD is to find an approximate decomposition of M
                     
                        2
                     
                     
                        2
                        Traditionally, the problem of obtaining the operator M was formulated in terms of a companion matrix in order to emphasize the deeper theoretical relationship to the Arnodli Algorithm and the Koopman operator. We refer to [27,28] for further theoretical details.
                     . It is also interesting to note that, while the operator M is considered to be linear, its eigenvectors and eigenvalues can also describe nonlinear dynamical systems.

To compute the DMD we proceed by first arranging the data matrix 
                           
                              D
                              ∈
                              
                                 R
                                 
                                    m
                                    ×
                                    n
                                 
                              
                           
                         into two matrices:

                           
                              (14)
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          f
                                          1
                                       
                                       
                                       |
                                       
                                       
                                          f
                                          2
                                       
                                       
                                       |
                                       
                                       
                                          f
                                          t
                                       
                                       
                                       |
                                       
                                       .
                                       .
                                       .
                                       
                                       |
                                       
                                       
                                          f
                                          
                                             n
                                             −
                                             1
                                          
                                       
                                       ]
                                    
                                    ∈
                                    
                                       R
                                       
                                          m
                                          ×
                                          (
                                          n
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    Y
                                    =
                                    
                                       [
                                       
                                          f
                                          2
                                       
                                       
                                       |
                                       
                                       
                                          f
                                          3
                                       
                                       
                                       |
                                       
                                       
                                          f
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       
                                       |
                                       
                                       .
                                       .
                                       .
                                       
                                       |
                                       
                                       
                                          f
                                          n
                                       
                                       ]
                                    
                                    ∈
                                    
                                       R
                                       
                                          m
                                          ×
                                          (
                                          n
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        The left snapshot sequence X is approximately linked to the right sequence Y by the operator M as follows

                           
                              (16)
                              
                                 
                                    Y
                                    ≈
                                    M
                                    X
                                 
                              
                           
                        This is in fact a well known linear least squares problem

                           
                              (17)
                              
                                 
                                    
                                       m
                                       i
                                       n
                                       ∥
                                       Y
                                       −
                                       M
                                       X
                                       ∥
                                    
                                    
                                       F
                                    
                                    2
                                 
                              
                           
                        An estimate can be computed using the pseudo-inverse [31] as follows

                           
                              (18)
                              
                                 
                                    M
                                    =
                                    Y
                                    
                                       X
                                       †
                                    
                                    =
                                    Y
                                    V
                                    
                                       Σ
                                       
                                          −
                                          1
                                       
                                    
                                    
                                       U
                                       *
                                    
                                 
                              
                           
                        where 
                           
                              U
                              ∈
                              
                                 R
                                 
                                    m
                                    ×
                                    n
                                 
                              
                           
                         and 
                           
                              V
                              ∈
                              
                                 R
                                 
                                    n
                                    ×
                                    n
                                 
                              
                           
                         are denoting the left and right singular values respectively, and 
                           
                              Σ
                              ∈
                              
                                 R
                                 
                                    n
                                    ×
                                    m
                                 
                              
                           
                         the diagonal matrix with the corresponding singular values. However, this direct approach of computing the operator M might not be feasible when dealing with high dimensional data, like videos. Instead it is more desirable to reduce the dimension first using a similarity transformation in order to find an approximate operator 
                           
                              
                                 M
                                 ˜
                              
                              ∈
                              
                                 R
                                 
                                    n
                                    ×
                                    n
                                 
                              
                           
                         as

                           
                              (19)
                              
                                 
                                    
                                       M
                                       ˜
                                    
                                    =
                                    
                                       U
                                       *
                                    
                                    M
                                    U
                                 
                              
                           
                        In fact it can be shown that M and 
                           
                              M
                              ˜
                           
                         have the same eigenvalues [25]. Using the similarity transformation draws a connection between DMD and PCA by projecting M onto the principal components (left singular vectors) U. We obtain 
                           
                              M
                              ˜
                           
                         by plugging (18) into (19) as follows (note that U is a matrix with orthonormal columns and hence 
                           
                              
                                 U
                                 *
                              
                              U
                              =
                              I
                           
                        )

                           
                              (20)
                              
                                 
                                    
                                       M
                                       ˜
                                    
                                    =
                                    
                                       U
                                       *
                                    
                                    M
                                    U
                                    =
                                    
                                       
                                          U
                                          *
                                       
                                       Y
                                       V
                                       
                                          Σ
                                          
                                             −
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        It can be seen that the SVD plays a central role in computing the DMD. Computing the SVD can be computationally expensive, however exploiting the low-dimensional structure of video data (with rank k ≪ n) allows us to use fast approximate low-rank decomposition techniques, e.g., randomized SVD (rSVD) as described in Section 2. We denote this approach using rSVD for computing an approximate low-rank dynamic mode decomposition with a specified target rank k, as randomized DMD (rDMD). In this case, the dimension of the linear operator reduces to 
                           
                              
                                 M
                                 ˜
                              
                              ∈
                              
                                 R
                                 
                                    k
                                    ×
                                    k
                                 
                              
                           
                        . The structure of 
                           
                              M
                              ˜
                           
                         is revealed by computing the eigenvalue decomposition of 
                           
                              M
                              ˜
                           
                         as

                           
                              (21)
                              
                                 
                                    
                                       M
                                       ˜
                                    
                                    W
                                    =
                                    Λ
                                    W
                                 
                              
                           
                        where 
                           
                              W
                              ∈
                              
                                 C
                                 
                                    k
                                    ×
                                    k
                                 
                              
                           
                         is the eigenvector matrix and 
                           
                              Λ
                              ∈
                              
                                 C
                                 
                                    k
                                    ×
                                    k
                                 
                              
                           
                         is a diagonal matrix containing the eigenvalues λ. The dynamic modes 
                           
                              Φ
                              ∈
                              
                                 C
                                 
                                    m
                                    ×
                                    k
                                 
                              
                           
                         are then computed by relating the eigenvectors back to M as either [27]
                        
                           
                              (22)
                              
                                 
                                    Φ
                                    =
                                    [
                                    
                                       ϕ
                                       1
                                    
                                    ,
                                    .
                                    .
                                    .
                                    ,
                                    
                                       ϕ
                                       k
                                    
                                    ]
                                    =
                                    U
                                    W
                                 
                              
                           
                        or more generally as [30]
                        
                           
                              (23)
                              
                                 
                                    Φ
                                    =
                                    Y
                                    V
                                    
                                       Σ
                                       
                                          −
                                          1
                                       
                                    
                                    W
                                 
                              
                           
                        We favor the latter approach.

The original data matrix D can be reconstructed by noting that the snapshots can be represented as the linear combination [32]
                        
                           
                              (24)
                              
                                 
                                    
                                       f
                                       t
                                    
                                    ≈
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       k
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    
                                       λ
                                       
                                          i
                                       
                                       
                                          t
                                          −
                                          1
                                       
                                    
                                 
                              
                           
                        where λi
                         denotes the ith eigenvalue, ϕi
                         the ith dynamic mode and bi
                         the corresponding amplitude. Since bi
                         is time independent f
                        1 reduces to

                           
                              (25)
                              
                                 
                                    
                                       f
                                       1
                                    
                                    ≈
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       k
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    =
                                    Φ
                                    b
                                 
                              
                           
                        The parameter vector 
                           
                              b
                              ∈
                              
                                 C
                                 k
                              
                           
                         can be estimated by the linear least squares method [3]. Fig. 2
                         illustrates how the approximate low-rank DMD can be expressed as

                           
                              (26)
                              
                                 
                                    D
                                    ≈
                                    Φ
                                    B
                                    
                                       V
                                       and
                                    
                                 
                              
                           
                        where 
                           
                              B
                              ∈
                              
                                 C
                                 
                                    k
                                    ×
                                    k
                                 
                              
                           
                         is a diagonal matrix of the amplitudes

                           
                              (27)
                              
                                 
                                    B
                                    =
                                    
                                       (
                                       
                                          
                                             
                                                
                                                   b
                                                   1
                                                
                                             
                                             
                                             
                                             
                                          
                                          
                                             
                                             
                                                
                                                   b
                                                   i
                                                
                                             
                                             
                                             
                                          
                                          
                                             
                                             
                                             
                                                ⋱
                                             
                                             
                                          
                                          
                                             
                                             
                                             
                                             
                                                
                                                   b
                                                   k
                                                
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        and 
                           
                              
                                 V
                                 and
                              
                              ∈
                              
                                 C
                                 
                                    k
                                    ×
                                    n
                                 
                              
                           
                         is the Vandermonde matrix of the eigenvalues

                           
                              (28)
                              
                                 
                                    
                                       V
                                       and
                                    
                                    =
                                    
                                       (
                                       
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   λ
                                                   1
                                                
                                             
                                             
                                                ⋯
                                             
                                             
                                                
                                                   λ
                                                   
                                                      1
                                                   
                                                   
                                                      n
                                                      −
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   λ
                                                   2
                                                
                                             
                                             
                                                ⋯
                                             
                                             
                                                
                                                   λ
                                                   
                                                      2
                                                   
                                                   
                                                      n
                                                      −
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                ⋮
                                             
                                             
                                                ⋮
                                             
                                             
                                                ⋱
                                             
                                             
                                                ⋮
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   λ
                                                   k
                                                
                                             
                                             
                                                ⋯
                                             
                                             
                                                
                                                   λ
                                                   
                                                      k
                                                   
                                                   
                                                      n
                                                      −
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        From the Vandermonde matrix it is clear that temporal dynamics, retrieved by the DMD, consists of single (distinct) frequencies.

The prototype Algorithm 2 summarizes the method for computing the DMD using rSVD.
                     

In the previous section we have seen how DMD can be used to decompose and reconstruct a matrix. However, using (26) for modeling the video background directly is a bad strategy. Of course, we can hope that when computing the low-rank dynamic mode decomposition, that the dominant dynamic modes are not corrupted by any moving objects and only capture background structures. Like PCA, this works when we train DMD on a set of clean video frames. However, that is an unrealistic scenario in real world applications. More desirable is a decomposition into low-rank L (background components) and sparse components S (foreground components) similar to RPCA [9]
                        
                           
                              (29)
                              
                                 
                                    D
                                    =
                                    L
                                    +
                                    S
                                 
                              
                           
                        Unlike robust PCA, DMD is not capable of directly separating a matrix into these two components. Instead, DMD allows us to compute an approximation to it. First let us connect the DMD eigenvalues λ to the Fourier modes ω as follows [3]
                        
                           
                              (30)
                              
                                 
                                    
                                       ω
                                       i
                                    
                                    =
                                    
                                       
                                          l
                                          n
                                          (
                                          
                                             λ
                                             i
                                          
                                          )
                                       
                                       
                                          Δ
                                          t
                                       
                                    
                                 
                              
                           
                        For standard videos we simply assume the time step 
                           
                              Δ
                              t
                              =
                              1
                           
                         and hence 
                           
                              
                                 ω
                                 i
                              
                              =
                              l
                              n
                              
                                 (
                                 
                                    λ
                                    i
                                 
                                 )
                              
                           
                        . By construction, the eigenvalues are complex. Hence the Fourier modes allow us to reveal interesting properties about the relating dynamic modes. The real part of ω determines the mode’s evolution over time, while the imaginary part is related to the mode’s oscillations. Now let us rewrite (26) in terms of the Fourier modes for a k low-rank decomposition of a video matrix

                           
                              (31)
                              
                                 
                                    D
                                    ≈
                                    Φ
                                    B
                                    
                                       V
                                       and
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       k
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    exp
                                    
                                       (
                                       
                                          ω
                                          i
                                       
                                       t
                                       )
                                    
                                 
                              
                           
                        where 
                           
                              t
                              =
                              [
                              0
                              ,
                              1
                              ,
                              .
                              .
                              .
                              ,
                              (
                              n
                              −
                              1
                              )
                              ]
                           
                         is the time vector. From (31) it is clear that the Fourier modes dictate how the modes evolve, i.e., decay or grow in time. In light of this, the set of k modes {
                           ϕ
                        
                        
                           i
                        } can be separated into a set that contains only Fourier modes {wl
                        : ‖wl
                        ‖ ≪ 1} who evolve slowly over time and corresponds to background modes. The second set {ws
                        } contains modes describing fast moving objects. Exploiting this, (31) can be rewritten as

                           
                              (32)
                              
                                 
                                    D
                                    ≈
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          l
                                       
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    exp
                                    
                                       (
                                       
                                          ω
                                          i
                                       
                                       t
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          s
                                       
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    exp
                                    
                                       (
                                       
                                          ω
                                          i
                                       
                                       t
                                       )
                                    
                                 
                              
                           
                        The background video can then be reconstructed as follows

                           
                              (33)
                              
                                 
                                    L
                                    =
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          l
                                       
                                    
                                    
                                       b
                                       i
                                    
                                    
                                       ϕ
                                       i
                                    
                                    exp
                                    
                                       (
                                       
                                          ω
                                          i
                                       
                                       t
                                       )
                                    
                                 
                              
                           
                        Foreground objects (sparse components) can be identified as difference between the original video data and the background video L (discarding the imaginary part)

                           
                              (34)
                              
                                 
                                    S
                                    =
                                    
                                       
                                          ∥
                                          D
                                          −
                                          L
                                          ∥
                                       
                                       2
                                    
                                 
                              
                           
                        We illustrate the concept on a real video in the following examples. Fig. 3
                         shows the Fourier modes of a low-rank dynamic mode decomposition with target rank 
                           
                              k
                              =
                              25
                           
                        . The Fourier mode ‖ω
                        0‖ ≈ 0 identifies the background mode, shown in Fig. 4
                        (b). However, using just the zero mode leads to a static background model. Fig. 4(c) shows that the waving tree is captured as foreground object when using the zero mode only. Hence, to better cope with dynamic backgrounds, it is favorable to select a subset of modes ‖wb
                        ‖ ≪ 1 for background modeling. Using the first 3 modes decreases the false positive rate, as shown in Fig. 4(d). Deciding upon the number of modes used for modeling the background was semi-arbitrary and we achieved qualitatively good results with 3 to 5 modes — whereas using the zero mode is computationally faster.

In this section we evaluate both the accuracy and computational performance of the proposed algorithm and compare it to other state-of-the-art methods. To evaluate the effectiveness of rDMD for detecting moving objects we use two benchmark datasets. First, we test rDMD on ten synthetic videos from the BMC 2012 (Background Models Challenge) dataset [33]. Further, to evaluate the performance on real videos, we use eight videos from the ChangeDetection.net (CD) dataset [34]. The selected videos represent challenging examples in motion detection. For example:

                        
                           •
                           
                              Bootstrapping: A sequence of clean background images which are not available for training.


                              Dynamic backgrounds: Moving objects which belong to the background like waving trees, rain or snowfall.


                              Illumination changes: Gradual illumination changes of the environment due to fog or sun.


                              Camouflage: Foreground objects which have the same pixel intensity as background elements, i.e. same color.

To evaluate the performance of background subtraction algorithms, a binary foreground mask using a suitable distance measure d( · ) has to be computed

                           
                              (35)
                              
                                 
                                    
                                       X
                                       t
                                    
                                    
                                       (
                                       j
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                   
                                                      d
                                                      (
                                                      
                                                         f
                                                         
                                                            j
                                                            t
                                                         
                                                      
                                                      −
                                                      
                                                         b
                                                         
                                                            j
                                                            t
                                                         
                                                      
                                                      )
                                                      >
                                                      τ
                                                   
                                                
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        For instance, the Euclidean distance is a common choice for measuring the distance between pixels of the actual video and the re-constructed background frame [35]. However, more sophisticated measures can be formulated and allow adaptive thresholding. The resulting vector 
                           
                              X
                              t
                           
                         is called the foreground or motion mask and its elements are binary x ∈ {0, 1}. In the outcomes, 1 classifies a pixel belonging to a foreground object, otherwise 0 as a background element. Thus we can visualize the classification results as an confusion matrix

                           
                              (36)
                              
                           
                        where TP denotes the (number of) True Positive predictions, i.e. pixels which are correctly classified as belonging to a moving foreground object. Similarly TN denotes the (number of) True Negative predictions, i.e. pixels which are correctly classified as background. False Positive (FP) and False Negative (FN) are the respective misclassifications for foreground and background elements. Based on the confusion matrix we can compute the following evaluation measures.

Recall (also called sensitivity, true positive rate or hit rate) measures the algorithm’s ability to correctly detect pixels belonging to foreground objects. It is computed as the ratio of predicted true positives to the total number of true positive foreground pixels

                           
                              (37)
                              
                                 
                                    c
                                    a
                                    l
                                    l
                                    a
                                    Recall
                                    =
                                    
                                       
                                          TP
                                       
                                       
                                          TP
                                          +
                                          FN
                                       
                                    
                                 
                              
                           
                        
                     

Precision (also called false alarm rate or true positive accuracy) measures how confident we can be that a positive classified pixel actually belongs to a foreground object. It is computed as the ratio of predicted true positives to the total number of pixels predicted as foreground objects

                           
                              (38)
                              
                                 
                                    e
                                    c
                                    i
                                    s
                                    i
                                    o
                                    n
                                    a
                                    Precision
                                    =
                                    
                                       
                                          TP
                                       
                                       
                                          TP
                                          +
                                          FP
                                       
                                    
                                 
                              
                           
                        
                     

Specificity (also called true negative rate) measures the algorithm’s ability to correctly predict pixels belonging to the background. It is computed as the ratio of true negatives to the total number of true negative foreground pixels

                           
                              (39)
                              
                                 
                                    e
                                    c
                                    i
                                    f
                                    i
                                    c
                                    i
                                    t
                                    y
                                    a
                                    Specificity
                                    =
                                    
                                       
                                          TN
                                       
                                       
                                          TN
                                          +
                                          FP
                                       
                                    
                                 
                              
                           
                        
                     

The F-measure combines recall and precision as their harmonic mean, weighting both measures evenly, defined as

                           
                              (40)
                              
                                 
                                    F
                                    =
                                    2
                                    ×
                                    
                                       
                                          Recall
                                          ×
                                          Precision
                                       
                                       
                                          Recall
                                          +
                                          Precision
                                       
                                    
                                 
                              
                           
                        More general definitions of the F-measure also allow different weighting schemes.

From (35) it is obvious that the classification results depend on a pre-defined fixed threshold τ. To get a global understanding of the algorithm’s behaviors the evaluation measures can be computed over a range of different thresholds. The results can then be visualized using precision-recall and Receiver Operator Characteristics (ROC) curves. An advantage of ROC graphs, plotting precision vs 1-specificity, is the insensitivity to changes in the class distribution [36]. In particular in dynamic environments such as videos, the number of pixels belonging to foreground objects can vary significantly over frames and is generally much less than the number of pixels belonging to the background. A further advantage of using ROC curves is the convenient way to summarize the performance with a global single scalar value measuring the Area Under the Curve (AUC). The perfect ROC curve has an AUC of 1, while random guessing yields an AUC of 0.5. Thus a method with an AUC close to 0.5 or below can be considered as useless, while a method with a higher AUC is preferred.

@&#RESULTS@&#

DMD is formulated as a batch algorithm here, i.e., previous modeled sequences do not affect the following. This allows the algorithm to adapt to changes in the scene, e.g., illumination changes. Also, foreground objects that become background objects (like a recently parked car) can be better captured. On the other hand, it does not allow for dealing with ‘sleeping’ foreground objects. The performance varies with the number of modes and the length of the snapshot sequence. Our results show that a snapshot length of about 100 to 300 video frames can be separated with a very low number of modes, e.g. k ∈ {9, 11
                           
                              ,
                              …
                              ,
                           
                         15}. If the video is less noisy, a lower number of dynamic modes is sufficient. However, depending on how fast the foreground objects are moving, using less than 100 frames often leads to a poor detection performance. Another important issue is the choice of the initial condition used for computing the amplitudes. The default option is to use the first frame of the sequence, as stated in (25), however we often achieved better results using the median frame instead. Another interesting option is to recompute the amplitudes for small chunks of the sequence. This allows better capture of sudden illumination changes.

For the rDMD algorithm, two further tuning parameters p and q can be specified. The former is the oversampling parameter and the latter controls the number of power iterations of the rSVD algorithm. For computing rDMD in the following we keep the two parameters fixed as 
                           
                              p
                              =
                              2
                           
                         and 
                           
                              q
                              =
                              1
                           
                        . This parameter setting recovers almost exactly the results achieved with the ordinary DMD algorithm.

We first illustrate in Fig. 5
                         the performance of rDMD compared to ordinary DMD, PCA [6] and robust PCA [9] on two videos. While RPCA performs best both in terms of the AUC and the F-measure, rDMD and DMD can be seen as a reasonable approximation. The results also show that the performance difference between rDMD and DMD is insignificant. As expected, DMD performs significantly better than PCA in terms of the F-measure.


                        Table 1
                         shows the results of randomized DMD for the ten synthetic videos of the BMC dataset and compares them with three leading robust PCA algorithms: LSADM, TFOCS and GoDec. LSADM [11] is a principal component pursuit algorithm, while TFOCS [12] is a quantization-based principal component pursuit algorithm. GoDec [22] is an approximated RPCA algorithm based on bilateral random projections and like rDMD uses the concept of randomized matrix algorithms. Overall the average F-measure shows that the detection performance of rDMD is about 4% lower than the RPCA algorithms. The slightly poorer performance is due to the Street 512 and Rotary 522 videos, emulating windy scenes with additional noise. In these cases the background is very dynamic and the precision of the DMD algorithm is decreased. However, this problem can be compensated for by post-processing the obtained foreground mask with a median filter. The overall performance of this approach leads to an improvement of about 2%. The results on the other videos show that DMD is flexible enough to deal with illumination changes like clouds, fog or sun.

We show in Table 2
                         the evaluation results of 8 real videos from the CD dataset. The videos are from three different categories: ‘Baseline’, ‘Dynamic Background’ and ‘Thermal’. At first glance the overall performance of the rDMD algorithm looks poor. This can be related to several challenges faced here. While the performance on the two baseline videos ‘Highway’ and ‘Pedestrians’ are good, issues arise for the other two baseline videos. The PETS2006 is difficult, due to camouflage effects for the DMD algorithm, as well as because some of the objects are sleeping foreground objects. The ‘Office’ shows even more drastically that DMD cannot cope with sleeping foreground objects. However, integrating DMD into a simple system allowing for background maintenance can help to overcome this problem. The two dynamic background videos show the same problem as before with the synthetic videos. The recall rate is excellent, while the precision is lacking. But again just using a simple median filter for pre-processing increases the performance greatly. Fig. 6
                         shows some visual results for 3 selected videos.

For comparison we show in Table 2 also the results of two algorithms leading the CD ranking. The FTSG (Flux Tensor with Split Gaussian models) [37] algorithm is based on mixture of Gaussians which won the 2014 CD challenge. The PAWCS (Pixel-based Adaptive Word Consensus Segmenter) [38] is a word-based approach to background modeling. While the raw results of DMD clearly cannot compete with the two mentioned highly optimized methods, it can be seen that simple post-processing can accelerate the performance substantially. Hence the object detection rate can be improved by learning from other background modeling methods and using for example, a more elaborate threshold, or integrating DMD into a system allowing background maintenance.

We now evaluate the computational performance of rSVD and rDMD algorithm, respectively. Our implementations are written in Python
                        
                           3
                        
                        
                           3
                           Python Software Foundation. Python Language Reference, version 2.7. Available at http://www.python.org
                           
                         using the multi-thread MKL (Intel Math Kernel Library) accelerated linear algebra library LAPACK. For the GPU implementation we are using NVIDIA CUDA in combination with the linear algebra libraries cuBLAS 
                        [40] and CULA 
                        [41]. To allow the comparison of rSVD with the fast LMSVD [14] algorithm we have used Matlab. All the computations were performed on a standard gaming notebook (Intel Core i7-5500U 2.4 GHz, 8GB DDR3 L memory and NVIDIA GeForce GTX 950M). It is important to note that in order to achieve any computational advantage with rSVD the target rank has to be 
                           
                              k
                              <
                              
                                 n
                                 
                                    1.5
                                 
                              
                              ,
                           
                         otherwise truncated SVD would be faster. Another requirement is that the matrix fits into the fast memory.


                           Fig. 7
                            shows the computational time for rSVD with LMSVD and a partial SVD (svds) algorithm for two different sized matrices and a varying target rank. rSVD with one subspace iteration can achieve time savings of about a factor 10 to 30. Comparing to the LMSVD (with default options) the speed-up is about 5 to 8 times. However, the reconstruction error shows that the LMSVD algorithm is more precise, in particular when comparing to rSVD without subspace iterations.

For feasible real-time processing, our aim was to accelerate the ordinary DMD algorithm by using a randomized matrix algorithm for computing the SVD. Fig. 8
                            shows the computational times we obtain with a randomized algorithm on videos with two different resolutions. The randomized version allows us to accelerate the computational time by about a factor of 2. Even more drastic is the acceleration using a GPU implementation. This allows processing of up to 180 frames per second for a 720x480 video. For a 320x240 video it can increase the frames per second from about 300 up to 750. The GPU accelerated DMD implementation benefits in particular from the fast computations of dot products, QR-decomposition and the fast generation of random numbers. Using a high-end graphic card can further improve the results, enabling real-time processing of HD 720 videos and beyond. The limitation of a GPU implementation is that the snapshot sequence has to fit into the graphic card’s memory.

@&#CONCLUSION@&#

We have presented a fast algorithm for computing the low-rank DMD using a randomized matrix algorithm. This subtle modification leads to substantial decreases in computational time, enabling DMD to process videos with high resolutions in real-time. Furthermore, the randomized version is of particular interest for parallel processing, e.g. GPU accelerated implementations. Randomized matrix algorithms may be beneficial for many other methods built on numerical linear algebra and in particular for those that use SVD.

The suitability of DMD for motion detection has been evaluated on synthetic and real videos using statistical metrics. The results show that DMD can be seen as a fast approximation of RPCA. The results compared to other robust PCA algorithms are competitive, but the results of DMD compared to advanced statistical models leading the CD ranking are less optimal in terms of accuracy metrics. However, we have also shown that simple post-processing can enhance the results substantially. The performance can be further improved by adaptive thresholds or by integration into a background modeling system. This makes DMD interesting for applications where fast processing is more important than extremely high precision.

In addition, we note that DMD is not a method purely designed for background modeling. DMD comes with a rich mathematical framework, which offers potential for interesting further research and applications beyond video. For example, interesting research directions are opened by multi-resolution dynamic mode decomposition [42], making the algorithm particularly interesting for the task of object tracking and motion estimation. Another direction is compressed DMD for fast background modeling. Both compressed and randomized DMD offer the opportunity to use importance sampling strategies to model a more robust background.

@&#ACKNOWLEDGMENT@&#

For the many discussions and insightful remarks on dynamic mode decomposition we would like to thank J. Nathan Kutz and Steven L. Brunton. We would also like to express our gratitude to Leonid Sigal and the two anonymous reviewers for the many helpful comments to improve this paper. N. Benjamin Erichson acknowledges support from the UK Engineering and Physical Sciences Research Council (EPSRC).

Supplementary material associated with this article can be found, in the online version, at 10.1016/j.cviu.2016.02.005
                  


                     
                        
                           Supplementary Data S1
                           
                              Supplementary Raw Research Data. This is open data under the CC BY license http://creativecommons.org/licenses/by/4.0/
                              
                           
                           
                        
                     
                  

@&#REFERENCES@&#

