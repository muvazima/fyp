@&#MAIN-TITLE@&#GOLD: Gaussians of Local Descriptors for image representation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A flexible local feature representation leveraging parametric probability density functions.


                        
                        
                           
                           Projection of the covariance matrix from the Riemannian manifold to the tangent Euclidean space.


                        
                        
                           
                           Experiments demonstrate the effectiveness of our descriptor in several challenging datasets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Image classification

Concept detection

Gaussian distribution

Stochastic Gradient Descent

@&#ABSTRACT@&#


               
               
                  The Bag of Words paradigm has been the baseline from which several successful image classification solutions were developed in the last decade. These represent images by quantizing local descriptors and summarizing their distribution. The quantization step introduces a dependency on the dataset, that even if in some contexts significantly boosts the performance, severely limits its generalization capabilities. Differently, in this paper, we propose to model the local features distribution with a multivariate Gaussian, without any quantization. The full rank covariance matrix, which lies on a Riemannian manifold, is projected on the tangent Euclidean space and concatenated to the mean vector. The resulting representation, a Gaussian of Local Descriptors (GOLD), allows to use the dot product to closely approximate a distance between distributions without the need for expensive kernel computations. We describe an image by an improved spatial pyramid, which avoids boundary effects with soft assignment: local descriptors contribute to neighboring Gaussians, forming a weighted spatial pyramid of GOLD descriptors. In addition, we extend the model leveraging dataset characteristics in a mixture of Gaussian formulation further improving the classification accuracy. To deal with large scale datasets and high dimensional feature spaces the Stochastic Gradient Descent solver is adopted. Experimental results on several publicly available datasets show that the proposed method obtains state-of-the-art performance.
               
            

@&#INTRODUCTION@&#

Object and Scene Recognition have been a major research direction in computer vision, and, in particular, the task of automatically annotating images has received considerable attention. Systems extract some description from a training set of images, train a classifier and then can be used to perform their task on new images. The current “standard” approach for this task is some derivation of the Bag of Words (BoW) [1], and consists mainly of three steps: (i) extract local features, (ii) generate a codebook and then encode the local features into codes, (iii) pool all the codes together to generate a global image representation. In this approach a key step is the codebook generation, because it is the base to define a high-dimensional Bag of Words histogram. Typically this is performed through clustering methods and the most common approach is the use of k-means clustering, because of its simplicity and convergence speed.

However, introducing a quantization of the feature space tightly ties dataset characteristics to the features representation, in the choice of both the position and the number of cluster centers to use. For the codewords positions, the quantization is learned from the training set, therefore the cluster centers reflect the training data distribution. The optimal number of cluster centers varies depending on the dataset. For example, in [2], the best accuracy using regular BoW is reached at 4k clusters for the Caltech-101 dataset, while, even if the improvement is progressively lower, in PASCAL VOC 2007 it does not reach saturation even with 25k cluster centers. Another example of this “hidden” dataset dependency inclusion may be found in many specializations of the BoW approach. [3,4] propose two different solutions to learn category specific codebooks and show how this is able to improve the descriptor ability to discriminate between similar categories.

The codebook generation step has been introduced in order to obtain a fixed length representation of the distribution of the local features of an image. This is not strictly necessary, since the descriptors distribution could be directly modeled with a parametric distribution [3,5], and the parameters obtained on the single image may provide a summary of the local descriptors. In some contexts though, the information coming from the specific dataset characteristics is able to significantly boost the performance of the classification system.

Based on these considerations, in this paper we propose a solution to allow the descriptors to be obtained either in a dataset independent way or to leverage training information in their construction. Using a multivariate Gaussian distribution with full rank covariance matrix or a mixture of them it is possible to tune the system based on the context. We also show how to embed this descriptors in the Spatial Pyramid Representation [6] further removing border effects artifacts. The final image descriptor is then used both with an off-the-shelf batch classifier and with the Stochastic Gradient Descent on-line solver [7], which allows to deal with large scale datasets and high dimensional feature spaces.

We name our method Gaussian of Local Descriptors (GOLD) and demonstrate its effectiveness for automatic image annotation and object recognition. The main contributions of our work are:
                        
                           •
                           we provide a flexible local feature representation leveraging parametric probability density functions, that can be independent of the image archive (e.g. for collections that change dynamically) or specific to dataset characteristics;

our method employs the projection of the full rank covariance matrix from the Riemannian manifold to the tangent Euclidean space to obtain a fixed length descriptor suitable for linear classifiers based on dot product;

we conduct experiments on several public databases (Caltech-101, Caltech-256, ImageCLEF2011, ImageCLEF2013, PASCAL VOC07). Some examples are reported in Fig. 1
                              . The results demonstrate the effectiveness of utilizing our descriptor over different types of local features, both in dataset dependent and independent settings.

This paper is organized as follows. We introduce the state of the art on image descriptors focusing on encodings, normalizations and pooling strategies in Section 2. Then we elaborate the formulation of the GOLD descriptor in Section 3, and its combination with the spatial pyramid representation in Section 4. In Section 5 the extension to the mixture of Gaussian distributions is presented. We conduct extensive experiments in Section 6 to verify the advantage of our method for automatic image annotation and object recognition. Conclusions are drawn in Section 7.

@&#RELATED WORK@&#

The basic component of all object recognition and scene understanding systems are local descriptors [8]. The most famous and effective ones are SIFT [9], and all their color variations [10].

After describing images with unordered sets of local descriptors, we would like to directly compare them in order to get information on the images similarities. The problem could be tackled with solutions inspired by the assignment problem, but this would be infeasible as soon as we move away from tiny problems. For this reason, research has focused on finding a fixed length summary of local descriptors density distribution.

The original solution, named Bag of Words, consists in finding a set of codewords (obtained by the k-means algorithm) and assigning each local feature to a codeword. The final descriptor is given by a histogram counting the number of local features assigned to every codeword (cluster center) [1]. This last strategy was later referred to as hard-assignment.

A histogram is obviously a crude representation of the local features continuous density profile, it introduces quantization errors and it is sensitive to noise and outliers [11]. Thus, it would appear that by improving this density representation to more accurately represent the input feature set the classifiers performance could be improved as well [3]. For example, in [12] the hard-assignment of features is replaced with soft-assignment, which distributes an appropriate amount of probability mass to all codewords, depending on the relative similarity with each of them. The Locality-constrained Linear Coding [13] projects each descriptor on the space formed by its k-nearest neighbors (with small k; they propose 
                        
                           k
                           =
                           5
                        
                     ). This procedure corresponds to performing the first two steps of the locally linear embedding algorithm [14], except that the neighbors are selected among the codewords of a dictionary rather than actual descriptors, and the weights are used as features instead of being mere tools to learn an embedding.

In [15] two supervised nonnegative matrix factorizations are combined together to identify latent image bases, and represent the images in this bases space; in [16] the authors propose to combine structures of input features and output multiple tags into one regression framework for multitag image annotation.

Fisher encoding [17], models the codewords with a Gaussian Mixture Model (GMM), restricted to diagonal covariance matrices for each of the k components of the mixture. Then, they capture the average first and second order differences between the image descriptors and the centers of the GMM.

The Vector of Locally Aggregated Descriptors [18] (VLAD) can be seen as a simplification of the Fisher kernel. Each local descriptor is associated to its nearest visual word. The idea of the VLAD descriptor is to accumulate, for each visual word, the differences of the vectors assigned to it, thus characterizing the distribution of the vectors with respect to the center. As for Fisher encoding, the descriptors are pooled together with averaging. Recently a comprehensive study concerning feature coding methods that summarizes their main characteristics including motivations and mathematical representations has been presented in [19].

The techniques discussed so far have all focused on improving the local descriptors encoding, relaying on training data for codewords generation. Given that there are a great number of unlabeled images available, some works focused on semi-supervised learning in order to leverage unlabeled data for large-scale image annotation [20].

In order to overcome the dataset dependency, some authors tried to build a codebook in a fully data-independent way. In [21] the feature space is directly discretized using a regular lattice. With four subdivisions for each dimension, the number of bins is in the order of 
                        
                           
                              
                                 10
                              
                              
                                 77
                              
                           
                        
                     , most of which are obviously empty. They thus employ a hash table and store only the non-empty bins. Constant time table lookup, i.e., independent of the size of the visual vocabulary, can then be guaranteed. In [22] it is shown that this fixed quantization method performs significantly worse then other techniques, probably due to the fact that it splits dense regions of the descriptor space arbitrarily along dimension axes, and the bins do not equally split the unit hypersphere which SIFT covers, resulting in a wildly uneven distribution of points. Moreover they further highlight on Oxford [23] and Paris [24] datasets that the performance on drop of quantization approaches when generating codewords from a dataset and using them on another. Similar conclusions were also found in [25]. In short, referring to a configuration as dataset1/dataset2 (meaning that codewords are generated by dataset1 and used them for retrieval on dataset2), the Oxford/Oxford combination provides a mAP value of 0.673, against a Paris/Oxford mAP of 0.494. In a recent work [26], to avoid to recompute codewords at every dataset change, a particularly effective solution for cluster center adaptation, applicable to VLAD descriptors, is proposed. This, combined with an appropriate normalization step, shows a remarkable improvement when the codewords are generated from a different dataset. It is significant to note that the more different the codeword generation dataset is, the worse the performance are. Although the proposed adaptation is particularly efficient, it still requires to apply a transformation to all VLAD descriptors of the dataset.

A different strategy was proposed in [3], in order to avoid codeword generation completely, and in this way intrinsically remove any dataset dependency. The idea is to first model each set of vectors by a probability density function (pdf) and then compare them with a kernel defined over the pdfs. The advantage of modeling each image’s set of descriptors independently are that each image model is tailored to the specific descriptor set and hence should be more accurate. This solution received little attention, because of the need of using specific kernels for image comparison, again posing scalability issues. Recently Carreira et al. [5] proposed to use second-order analogs of the most common first-order pooling operators to describe arbitrary shaped regions in semantic segmentation contexts. In particular, they focused on multiplicative second-order interactions (e.g. outer products), together with either the average or the max operators. Following the techniques used in [27], they managed to obtain a region descriptor suitable for linear classifiers. It can be noted that, when average-pooling is used, this is exactly the proposal of [3], when the choice for the pdf is a zero-mean Gaussian distribution, improved with the mapping which allows to avoid the kernel computation between pdfs.

We propose to follow this latter way of modeling local features distributions, by choosing a multivariate Gaussian distribution with mean and full covariance as the reference pdf. By employing the log-Euclidean projection of [27], detailed in the next section, we can transform the distribution to a vectorial representation which allows to use the dot product to closely approximate a distance between distributions. Thanks to the fact that this representation is indeed modeling a Gaussian distribution, we can further extend it by changing the pdf to a mixture model, still obtaining a linear space representation. The idea of computing a Gaussian mixture model on the training set and then adapt it to each individual image as a descriptor was introduced in [28]. Although we share similar intentions, the following points mark the differences with their proposal: (i) they run a full EM algorithm on every image, while we only use the posterior probability to weight each feature contribution to every component, (ii) they employ a global diagonal covariance matrix, while we use a full one, (iii) they assume that this covariance matrix is fixed throughout the whole corpus, i.e. they do not re-estimate the image specific covariance matrix, (iv) the final image descriptor is dependent only on adapted weights and means of the various components, each scaled by the globally estimated covariance matrices.

Another proposal is strictly related to our approach: the recently introduced Vector of Locally Aggregated Tensors (VLAT) [29]. Their approach extends the VLAD descriptor by aggregating tensor products of local descriptors. They first compute a visual codebook of visual words over a sample image set using k-means. To compute the signature of an image, for each cluster, they aggregate with summation the centered tensors of centered descriptors. Each aggregated tensor is flattened into a vector and concatenated for all clusters. Strong similarities can be observed with our proposal, but: (i) we theoretically motivate our proposal by modeling a set of descriptors with a multivariate Gaussian distribution, while the second order tensor used in VLAT is centered w.r.t. the cluster mean; (ii) they do not normalize the descriptor with respect to the cardinality of the feature set; (iii) the main difference is that VLAT do not employ the log-Euclidean projection and simply simply vectorize the final tensors, assuming that these can be used with the Euclidean metric. Following our Gaussian motivation, we also include the mean to the final descriptor. The contributions of our choices are analyzed in Section 6.

As an additional improvement, we apply a spatial soft assignment over the spatial pyramid representation. A schematization of the proposed approach is presented in Fig. 2
                     .

In order to provide a tractable description of the inherently unknown pdf of an unordered set of feature vectors, we employ the most classical parametric distribution, that is the multivariate Gaussian distribution. Let 
                        
                           F
                           =
                           {
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           …
                           
                              
                                 f
                              
                              
                                 N
                              
                           
                           }
                        
                      be the set of d-dimensional local features and suppose that they are independent and identically distributed samples from a multivariate Gaussian distribution, defined as
                        
                           (1)
                           
                              N
                              (
                              f
                              ;
                              m
                              ,
                              C
                              )
                              =
                              
                                 
                                    1
                                 
                                 
                                    |
                                    2
                                    π
                                    C
                                    
                                       
                                          |
                                       
                                       
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    e
                                 
                                 
                                    -
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          (
                                          f
                                          -
                                          m
                                          )
                                       
                                       
                                          T
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          -
                                          1
                                       
                                    
                                    (
                                    f
                                    -
                                    m
                                    )
                                 
                              
                              ,
                           
                        
                     where 
                        
                           |
                           ·
                           |
                        
                      is the determinant, 
                        
                           m
                        
                      is the mean vector and 
                        
                           C
                        
                      is the covariance matrix; 
                        
                           f
                           ,
                           m
                           ∈
                           
                              
                                 R
                              
                              
                                 d
                              
                           
                        
                      and 
                        
                           C
                           ∈
                           
                              
                                 S
                              
                              
                                 +
                                 +
                              
                              
                                 d
                                 ×
                                 d
                              
                           
                        
                     , and 
                        
                           
                              
                                 S
                              
                              
                                 +
                                 +
                              
                              
                                 d
                                 ×
                                 d
                              
                           
                        
                      is the space of real symmetric positive semi-definite matrices. The mean and covariance parameters are estimated from F as follows:
                        
                           (2)
                           
                              m
                              
                              =
                              
                              
                                 
                                    1
                                 
                                 
                                    N
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              
                                 
                                    f
                                 
                                 
                                    i
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (3)
                           
                              C
                              
                              =
                              
                              
                                 
                                    1
                                 
                                 
                                    N
                                    -
                                    1
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              (
                              
                                 
                                    f
                                 
                                 
                                    i
                                 
                              
                              -
                              m
                              )
                              
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    -
                                    m
                                    )
                                 
                                 
                                    T
                                 
                              
                              .
                           
                        
                     The estimated covariance matrix encodes information about the variance of the features and their correlation, and, together with the mean, provides a good insight on the set of features F. The space of covariance matrices can be formulated as a differentiable manifold, but not as a vector space (e.g. the covariance space is not closed under multiplication with a negative scalar). Unfortunately, many efficient machine learning algorithms assume that the data points form a vector space where dot product is defined, therefore they cannot readily work with covariance matrices.

It is important to consider that a manifold is a topological space that is locally similar to a Euclidean space. In particular a Riemannian manifold is a differentiable manifold in which each tangent space has an inner product, which varies smoothly from point to point [27].

Recently, it has been shown by Pennec et al. [30] that it is possible to endow the space of covariance matrices with an affine-invariant Riemannian metric (thus defining a Riemannian manifold), which allows to map covariance matrices to points in the Euclidean space.

The first step is the projection of the covariance matrices on an Euclidean space tangent to the Riemannian manifold, at a specific tangency matrix 
                        
                           P
                        
                     . The second step is the extraction of the orthonormal coordinates of the projected vector. In the following, matrices (points in the Riemannian manifold) will be denoted by bold uppercase letters, while vectors (points in the Euclidean space) by bold lowercase ones.

More formally, the projected vector of a covariance matrix 
                        
                           C
                        
                      is given by:
                        
                           (4)
                           
                              
                                 
                                    t
                                 
                                 
                                    C
                                 
                              
                              =
                              
                                 
                                    log
                                 
                                 
                                    P
                                 
                              
                              (
                              C
                              )
                              
                              ≜
                              
                              
                                 
                                    P
                                 
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              log
                              
                                 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             -
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             CP
                                          
                                          
                                             -
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    P
                                 
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           log
                        
                      is the matrix logarithm operator and 
                        
                           
                              
                                 log
                              
                              
                                 P
                              
                           
                        
                      is the manifold specific logarithm operator, dependent on the point 
                        
                           P
                        
                      to which the projection hyperplane is tangent. The matrix logarithm operators of a matrix C can be computed by eigenvalue decomposition (
                        
                           C
                           =
                           
                              
                                 UDU
                              
                              
                                 T
                              
                           
                        
                     ); it is given by:
                        
                           (5)
                           
                              log
                              (
                              C
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       =
                                       1
                                    
                                    
                                       ∞
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          (
                                          -
                                          1
                                          )
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    k
                                 
                              
                              
                                 
                                    (
                                    C
                                    -
                                    I
                                    )
                                 
                                 
                                    k
                                 
                              
                              =
                              U
                              log
                              (
                              D
                              )
                              
                                 
                                    U
                                 
                                 
                                    T
                                 
                              
                              .
                           
                        
                     
                  

The orthonormal coordinates of the projected vector 
                        
                           
                              
                                 t
                              
                              
                                 C
                              
                           
                        
                      in the tangent space at point 
                        
                           P
                        
                      are then given by the vector operator:
                        
                           (6)
                           
                              
                                 
                                    vec
                                 
                                 
                                    P
                                 
                              
                              (
                              
                                 
                                    t
                                 
                                 
                                    C
                                 
                              
                              )
                              =
                              
                                 
                                    vec
                                 
                                 
                                    I
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             -
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             t
                                          
                                          
                                             C
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             -
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           I
                        
                      is the identity matrix, while the vector operator on the tangent space at identity of a symmetric matrix 
                        
                           Y
                        
                      is defined as:
                        
                           (7)
                           
                              
                                 
                                    vec
                                 
                                 
                                    I
                                 
                              
                              (
                              Y
                              )
                              =
                              
                                 
                                    
                                       
                                          
                                             y
                                          
                                          
                                             1
                                             ,
                                             1
                                          
                                       
                                       
                                       
                                          
                                             2
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             1
                                             ,
                                             2
                                          
                                       
                                       
                                       
                                          
                                             2
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             1
                                             ,
                                             3
                                          
                                       
                                       …
                                       
                                          
                                             y
                                          
                                          
                                             2
                                             ,
                                             2
                                          
                                       
                                       
                                       
                                          
                                             2
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             2
                                             ,
                                             3
                                          
                                       
                                       …
                                       
                                          
                                             y
                                          
                                          
                                             d
                                             ,
                                             d
                                          
                                       
                                    
                                 
                              
                              .
                           
                        
                     
                  

Substituting 
                        
                           
                              
                                 t
                              
                              
                                 C
                              
                           
                        
                      from Eq. (4) in Eq. (6), the projection of 
                        
                           C
                        
                      on the hyperplane tangent to 
                        
                           P
                        
                      becomes
                        
                           (8)
                           
                              c
                              =
                              
                                 
                                    vec
                                 
                                 
                                    I
                                 
                              
                              
                                 
                                    
                                       log
                                       
                                          
                                             
                                                
                                                   
                                                      P
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            1
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      CP
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            1
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              .
                           
                        
                     Thus, after selecting an appropriate projection origin, every covariance matrix is projected to an Euclidean space. Since 
                        
                           c
                        
                      is a symmetric matrix of size 
                        
                           d
                           ×
                           d
                        
                      a 
                        
                           (
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                           +
                           d
                           )
                           /
                           2
                        
                     -dimensional feature vector is obtained.

As observed in [31], by computing the sectional curvature of the Riemannian manifold [32], i.e., the natural generalization of the classical Gaussian curvature for surfaces, it is possible to show that this space is almost flat. This means that the neighborhood relation between the points on the manifold remain unchanged, wherever the projection point 
                        
                           P
                        
                      is located. Therefore, from a computational point of view, the best choice for 
                        
                           P
                        
                      is the identity matrix, which simply translates the mapping into applying the 
                        
                           
                              
                                 vec
                              
                              
                                 I
                              
                           
                        
                      operator to the standard matrix logarithm. This also frees us from the problem of optimizing the projection point for the specific data under consideration, leading to a generally applicable descriptor.

Finally, the unordered set of feature vectors F can be described by a Gaussian of Local Descriptors (GOLD), that is the concatenation of the mean and the orthonormal projection of the covariance matrix.

In image classification systems, feature normalization techniques have the potential to greatly decrease the error rate of the classification, and thus increase the overall performance. When dealing with classifiers relaying on dot-product (such as linear SVMs) there is some recent convergence on the combined use of power normalization and unit length normalization using a 
                           
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                              
                           
                         metric [17,2].

Power normalization consists in applying, to each dimension of the descriptor, the function:
                           
                              (9)
                              
                                 f
                                 (
                                 x
                                 )
                                 =
                                 sign
                                 (
                                 x
                                 )
                                 |
                                 x
                                 
                                    
                                       |
                                    
                                    
                                       α
                                    
                                 
                                 
                                 with
                                 
                                 0
                                 <
                                 α
                                 <
                                 1
                                 .
                              
                           
                        Perronnin et al. [17] justify the use of power normalization with the empirical observation that it has the ability of “unsparsifying” the representation, making it suitable for dot-product similarity. A different interpretation is provided in [33] where it is shown that applying the square root (a special case of the power normalization with 
                           
                              α
                              =
                              0.5
                           
                        ) is equivalent to employ the Hellinger’s kernel (Bhattacharyya’s coefficient). Moreover Safadi and Quénot [34] tested different normalization approaches and distance measures on several image descriptors, and observed that power normalization consistently leads to better performance. Moreover they optimized the 
                           
                              α
                           
                         parameter for every descriptor and distance combination, and concluded that the optimal value when using dot product is approximately 0.5.

Motivated by these results, we apply power normalization to the GOLD vector, with 
                           
                              α
                              =
                              0.5
                           
                        . While 
                           
                              α
                           
                         optimization could slightly improve the performance, it would lead to a dataset-dependent tuning, again in contrast with our purposes.

A standard way of introducing weak geometry in a Bag of Words representation is the use of spatial pyramids [6]. A spatial pyramid is a collection of feature histograms computed over subregions defined by a multilevel recursive image decomposition. At level zero, the decomposition consists of just a single region, and the representation is equivalent to the feature histogram of the entire image. At level one, the image is subdivided into four quadrants, yielding four feature histograms, and so on. The concept has been extended to several image representations by stacking the descriptors of every spatial region in a single vector.

However in this kind of representation the local features are hard-assigned to only one subregion, making the representation sensitive to border effects. For this reason, we follow an approach similar to [35], and apply a bilinear interpolation to spatial pyramids. We compute the GOLD vector of each region R, centered in 
                        
                           (
                           
                              
                                 c
                              
                              
                                 x
                              
                           
                           ,
                           
                              
                                 c
                              
                              
                                 y
                              
                           
                           )
                        
                      and with dimensions 
                        
                           w
                           ×
                           h
                        
                     , on the local features that fall in the neighborhood 
                        
                           
                              
                                 R
                              
                              
                                 ′
                              
                           
                        
                      with dimensions 
                        
                           2
                           w
                           ×
                           2
                           h
                        
                     , again centered at 
                        
                           (
                           
                              
                                 c
                              
                              
                                 x
                              
                           
                           ,
                           
                              
                                 c
                              
                              
                                 y
                              
                           
                           )
                        
                     . A local feature 
                        
                           f
                        
                     , computed at 
                        
                           (
                           x
                           ,
                           y
                           )
                        
                     , is then weighted, with respect to R, by
                        
                           (10)
                           
                              w
                              (
                              f
                              ,
                              R
                              )
                              =
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             x
                                             -
                                             
                                                
                                                   c
                                                
                                                
                                                   x
                                                
                                             
                                          
                                          
                                             w
                                          
                                       
                                    
                                 
                              
                              
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             y
                                             -
                                             
                                                
                                                   c
                                                
                                                
                                                   y
                                                
                                             
                                          
                                          
                                             h
                                          
                                       
                                    
                                 
                              
                              .
                           
                        
                     A visual representation of the weights assigned to different positions in the case of a 
                        
                           2
                           ×
                           2
                        
                      regions is provided in Fig. 3
                     .

In the original spatial pyramid formulation [6], histogram intersection was the kernel chosen to compare unnormalized BoW descriptors. This allowed to identify matches at different levels, and remove matches at finer levels (highly significant) from those at coarser ones (less significant). This led to the usually adopted per-level weights of 0.25, 0.25, 0.5, from coarse to fine, in a three levels pyramid. Later works tried to improve over the original proposal by learning the level weights [36], or the single regions weights [37,38]. Again, these solutions are tailored for a specific dataset and lack of generality. A different strategy is instead followed in HOG descriptors, and later employed on the spatial pyramid by Harzallah et al. [39], that is independent 
                        
                           
                              
                                 L
                              
                              
                                 2
                              
                           
                        
                      normalization per region before constructing the final descriptor. This solution was later confirmed as the best choice in [17] and in [2].

GOLD descriptors are extracted from the weighted set of local features of every region, then they are power normalized. Finally, 
                        
                           
                              
                                 L
                              
                              
                                 2
                              
                           
                        
                      normalization is employed, in order to avoid any learning step.

A possible extension of GOLD is to improve the model describing the local descriptors probability distribution. A natural choice would be to employ a Gaussian Mixture Model (GMM) instead of a single Gaussian. Unfortunately this is not as straightforward as it might seem, since the comparison of two GMMs would require the use of a complex kernel: the main problem for comparing GMMs is how to choose which component should be compared to whom, that is solving an assignment problem. The main advantage of GOLD was exactly the ability of avoiding kernel computations for efficient learning. We need a solution to perform a similar mapping leveraging a mixture of Gaussians.

We propose to start from a K-components GMM, learned from the training set with the EM algorithm:
                        
                           (11)
                           
                              p
                              (
                              f
                              |
                              Θ
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       =
                                       1
                                    
                                    
                                       K
                                    
                                 
                              
                              
                                 
                                    ω
                                 
                                 
                                    k
                                 
                              
                              N
                              (
                              f
                              ;
                              
                                 
                                    μ
                                 
                                 
                                    k
                                 
                              
                              ,
                              
                                 
                                    Σ
                                 
                                 
                                    k
                                 
                              
                              )
                           
                        
                     where 
                        
                           Θ
                           =
                           {
                           
                              
                                 ω
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 μ
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Σ
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 ω
                              
                              
                                 K
                              
                           
                           ,
                           
                              
                                 μ
                              
                              
                                 K
                              
                           
                           ,
                           
                              
                                 Σ
                              
                              
                                 K
                              
                           
                           }
                        
                     . Similarly to what is done in soft quantization schemes [12], we can partially assign features to the k-th GMM component, according to the posterior probability for it:
                        
                           (12)
                           
                              Pr
                              (
                              k
                              |
                              f
                              ,
                              Θ
                              )
                              =
                              
                                 
                                    
                                       
                                          ω
                                       
                                       
                                          k
                                       
                                    
                                    N
                                    (
                                    f
                                    ;
                                    
                                       
                                          μ
                                       
                                       
                                          k
                                       
                                    
                                    ,
                                    
                                       
                                          Σ
                                       
                                       
                                          k
                                       
                                    
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                    
                                       
                                          ω
                                       
                                       
                                          j
                                       
                                    
                                    N
                                    (
                                    f
                                    ;
                                    
                                       
                                          μ
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          Σ
                                       
                                       
                                          j
                                       
                                    
                                    )
                                 
                              
                           
                        
                     It is now possible to build K multivariate Gaussian distributions from all the image descriptors, weighting them with the posterior probability of the k-th component. As in the maximization step of the EM algorithm, we estimate the Gaussian distribution parameters of the k-th component with the following equations:
                        
                           (13)
                           
                              
                                 
                                    m
                                 
                                 
                                    k
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    Pr
                                    (
                                    k
                                    |
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    Θ
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    Pr
                                    (
                                    k
                                    |
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    Θ
                                    )
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    -
                                    
                                       
                                          m
                                       
                                       
                                          k
                                       
                                    
                                    )
                                    
                                       
                                          (
                                          
                                             
                                                f
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                m
                                             
                                             
                                                k
                                             
                                          
                                          )
                                       
                                       
                                          T
                                       
                                    
                                    Pr
                                    (
                                    k
                                    |
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    Θ
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    Pr
                                    (
                                    k
                                    |
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    Θ
                                    )
                                 
                              
                              .
                           
                        
                     
                  

The newly obtained Gaussian distributions are related to the GMM components originally estimated on the training set, but adapted to the specific set of local features. Their parameters can thus be used as descriptors for the local features distribution. As in Section 3 each Gaussian distribution can be mapped to a GOLD descriptor, obtaining a tuple of K GOLD vectors. These are then concatenated following the index of the corresponding GMM component. This allows us to directly compare images using a dot product operation, removing the need for non-linear kernel computations.

The concatenation of the K GOLD vectors is now our adapted projection of the original mixture. We will refer to this extension as Mixture-GOLD.

It is important to note that while this allows to have a highly informative descriptor for the feature space, it is based on a reference distribution (the GMM), whose parameters have been estimated on a training set.

The proposed technique is thus able to easily move from a codebook independent image description to a codebook based one, making it adaptable to different contexts and usage scenarios.

@&#EXPERIMENTAL RESULTS@&#

In order to analyze the proposed approach in different scenarios, we perform the experiments on five datasets: Caltech-101, Caltech-256, ImageCLEF 2011, ImageCLEF 2013 and PASCAL VOC07 (Fig. 1). Caltech datasets permit a wide comparison with a large number of techniques, while the ImageCLEF and PASCAL VOC07 datasets allow analyzing our proposal in less constrained and large-scale collections. In these two scenarios all the reported experiments are obtained with the dataset independent GOLD descriptor (single Gaussian) and the Mixture-GOLD descriptor showing the flexibility of our solution. In all experiments, SIFT feature descriptors and their color variations are extracted at four scales, defined by setting the width of the spatial bins to 4, 6, 8, and 10pixels over a dense regular grid with a spacing of 3pixels. We use the function vl_phow provided by the vl_feat library [40] with default settings.

For larger datasets (Caltech-256, ImageCLEF 2011, ImageCLEF 2013), we used the Stochastic Gradient Descent (SGD) algorithm [41], introduced for SVM classifiers training, because it is an online method and can be easily parallelized to simultaneously train several classifiers. We randomize the data on disk and we load the data in chunks which fit in memory. We then train the classifiers on further randomizations of the chunks, so that different epochs (one training epoch is defined as providing all training samples to the classifier once) will get the chunks data with different orderings.

The source code for the computation of our descriptors is publicly available for download to allow the community to reproduce our results.
                        1
                        
                           http://imagelab.ing.unimore.it/files/GOLD_image_classification.zip.
                     
                     
                        1
                     
                  

The Caltech-101 dataset is one of the most commonly used dataset for object recognition. It contains 9144 images from 101 object categories and one background category. The object categories can be very complex but a common viewpoint is chosen, with the object of interest at the center of the image at a uniform scale. The number of images per category varies from 31 to 800. The Caltech-256 dataset consists of 30,607 images divided in 256 categories (with at least 80 images each). It presents a much higher variability in object size, location, and pose with respect to Caltech-101.

For both datasets we follow their respective common experimental settings: for Caltech-101 we randomly select 5, 10, 15, 20, 25, and 30 training images and at most 50 testing images for each category (this results in 3060 images for training and 2995 for testing in the 30 images test); for Caltech-256 we consider 30 and 60 training images and at most 50 for testing per class. We report the Mean Recognition Rate per class, i.e. the results are normalized based on the number of testing samples in that class and averaged over five independent runs. In all the experiment on Caltech datasets we extract SIFT descriptors, and images are analyzed with a 3 level pyramid, respectively partitioned in 
                           
                              1
                              ×
                              1
                              ,
                              
                              2
                              ×
                              2
                           
                         and 
                           
                              4
                              ×
                              4
                           
                         blocks.

The first experiment highlights the individual contribution of the mean and the projected covariance to the performance of the GOLD descriptor on Caltech-101 using 30 training images per class. The mean alone is obviously a very poor representation and therefore achieves a Mean Recognition Rate of 30.19%, while the projected covariance obtains 80.83%. Concatenating the mean and the covariance, also due to a very high difference in dimensionality, slightly improves the performance, arriving to 80.92%.

Furthermore, to present the respective contributions of the power normalization and descriptors weighting steps, we report in Fig. 4
                         the performance gain given by these two procedures. Note that the Pyramidal-GOLD, i.e. the Gaussian of local descriptors with the classical spatial pyramid procedure, shows interesting results (P-GOLD w/o power norm), but the usage of the power normalization (P-GOLD) enhances the accuracy of about three percentage points. A similar improvement is obtained by including the weighting step (WP-GOLD w/o power norm). The combined use of both techniques (WP-GOLD), that weights the SIFT descriptors based on their spatial distribution and applies power normalization, further improves the accuracy of about three percentage points. For simplicity, we will refer to this complete solution as GOLD.

Although the GOLD achieves a very good performance, the dimensionality of the final descriptor is quite large. For this reason, in Table 1
                         we present performance obtained by reducing the dimensionality of SIFT descriptors with PCA. After an initial drop, the performance slightly decreases until the dimensionality becomes 48, while for 
                           
                              D
                              =
                              32
                           
                         we can observe a second important drop. These results motivate our choice of maintaining original (not reduced) SIFTs when using the single-Gaussian GOLD. However, when the Mixture-GOLD is employed, PCA becomes a necessary evil, in order to still have a tractable descriptors size.

As pointed out by Chatfield et al. [2] several works present results on the Caltech-101 dataset. However, missing details in the description of the methods or different tuning of the various components often make a fair comparison impossible. For this reason we firstly compare our method to VLAT [29] (that is the most similar approach) and the recently proposed approach by Vedaldi and Zisserman [33], since they provide their code.
                           2
                           
                              http://www.vlfeat.org/applications/caltech-101-code.html.
                        
                        
                           2
                         Results are shown in Table 2
                        . For all of these methods we use the same experimental settings (same local features, same spatial pyramid and same classifier). For Mixture-GOLD and VLAT we use a codebook of 512 clusters (K=512) and SIFT are compressed to 48 dimensions using PCA, following [29]. We call VLATONE the VLAT descriptor with K
                        =1 and SIFT without PCA compression, that is directly comparable with our single-Gaussian GOLD. When using a single cluster, the VLATONE descriptor describes the second order variation with respect to the training set mean, and this suffers from the lack of specificity with respect to the single image, but mostly from the lack of the projection on the tangent space. Rising the number of clusters definitely reduces the gap with respect to our proposal, but both GOLD and Mixture-GOLD show superior performance.

For completeness, Table 3
                         reports the results on Caltech-101 of several recent approaches that are quite comparable to our method. All of these use the same standard setting (15/30 samples for training, at most 50 for testing), and SIFT descriptors captured with dense sampling.

In addition, we include the results of Chatfield et al. [2] and Duchenne and Joulin [50] that rely on multiple features or test on a different number of images. Finally, we report the latest results obtained with deep convolutional neural networks presented in Zeiler and Fergus [51] and He et al. [52], which clearly outperform every other traditional method, including ours.

The results reported for the Caltech-101 dataset were obtained with LibSVM, a well known software package for batch SVMs solving. The adoption of a batch solver was appropriate because feature data could entirely fit in memory, due to the limited size of the dataset. In order to verify the applicability of on-line solvers, we also trained the SVM classifiers using the SGD algorithm, starting from the public implementation provided by Leon Bottou.
                           3
                           
                              http://leon.bottou.org/projects/sgd.
                        
                        
                           3
                         In Table 4
                         the Mean Recognition Rate over the five runs at different number of training epochs is reported. Note that the results at the first epoch are very low for all runs, but they rapidly increase after few epochs. After 2048 epochs the SGD algorithm achieves good results, but only at 4096 epochs the SGD achieves the MRR score obtained with LibSVM (with a gap of only 0.03%), proving the efficacy of the on-line solver.

Lastly, in this section we report the results obtained on Caltech-256, as shown in Table 5
                        . Since this dataset is larger than Caltech-101, for this experiment we employed the SGD solver and similar to Caltech-101 we fix the epochs equal to 4096. Also on this more challenging dataset, our method shows very competitive performance with respect to several SIFT-based techniques. Note also that the proposed approach obtains significantly better result than more complex techniques such as [50,53]. As observed for Caltech-101, the deep convolutional neural network approach [51] has a significant advantage over all reported methods.

In both Caltech-101 and Caltech-256, the improvement in performance given by the Mixture-GOLD over the GOLD is only of some decimal points. We think that this behavior can be partially explained analyzing the characteristics of the datasets: as firstly demonstrated by [6], in these datasets the spatial pyramid is really effective, due to the homogeneous location and size of the objects. A good description of the spatial regions is therefore crucial to obtain a high recognition rate. The smaller the region, the stronger is the assumption (on which GOLD is based) that local descriptors follow a (single) Gaussian distribution, reducing the advantage of the GMM model used in Mixture-GOLD.

ImageCLEF 2011 Annotation Task dataset is composed of a training set of 8000 images and a test set of 10,000 images. The ImageCLEF 2011 photo corpus is a challenging concept detection dataset (multiple labels per image) due to its high heterogeneity of classes (see samples in Fig. 1). There are 99 concepts, which are concrete objects such as “church” or “trees” as well as more abstractly defined classes like “funny” or “unpleasant”.

On this dataset we extract RGBSIFT descriptors [10] at four scales (4, 6, 8, and 10 pixels respectively) over a dense regular grid with a spacing of 3 pixels and, even in this case, we use the function vl_phow. As spatial pyramids we use 
                           
                              1
                              ×
                              1
                              ,
                              
                              2
                              ×
                              2
                           
                         and 
                           
                              3
                              ×
                              1
                           
                        . The Mean Average Precision (MAP) is used to evaluate the performance.

With larger datasets such as ImageCLEF 2011, an on-line learning approach (in our case SGD) becomes the only possible choice on common PCs. Only loading the entire training set in memory (8000 samples) occupies about 6GB, requiring to split the data in chunks.

To select an appropriate regularization parameter 
                           
                              λ
                           
                         for the SGD solver, we randomly split the training set in two and run the SGD varying 
                           
                              λ
                           
                         from 
                           
                              
                                 
                                    10
                                 
                                 
                                    -
                                    3
                                 
                              
                           
                         to 
                           
                              
                                 
                                    10
                                 
                                 
                                    -
                                    7
                                 
                              
                           
                         in power of 10 steps. Based on this preliminary experiments we fix 
                           
                              λ
                              =
                              
                                 
                                    10
                                 
                                 
                                    -
                                    5
                                 
                              
                           
                         (see Fig. 5
                        ). Furthermore Fig. 6
                         reports the results in term of Mean Average Precision (MAP) at different number of training epochs. Note that the performance increases until the 64th epoch obtaining a MAP of 36.2, but thereafter the MAP tends to slightly decrease, probably due to an over-fitting of the SVM on the training data. The experiments show that is very difficult to predict the exact number of epochs necessary to reach the best results, and that even if there is a relation with the number of training samples and the size of the feature vectors, it is not a simple one. We found that the best practice is to run a k-fold cross-validation on the training set, which closely follow the final trend on the testing set.

Lastly we report in Table 6
                         a comparison with several techniques: in the upper part of the table we directly compare our approach with Bag of Words approaches (with linear and non-linear kernels) and very successful methods that publicly share their code [33,13]. All of these methods use the same experimental settings (same local features, same spatial pyramid and same SGD classifier). For the Bag of Words approaches we use 4000 visual words since we observed that the performance tends to saturate at this codebook size, while, for the other techniques, we use the values suggested by the authors. In the table we also include the best run of the ImageCLEF workshop that obtained a MAP of 38.8 [55]. However these authors used three different color SIFT variations, different sampling strategies and improvements, and a Multiple Kernel Learning approach. Moverover, their computations required a cluster with 11,000 Core Units which had (according to cpubenchmark.net) a speed rank of 134 in August 2011. Our tests were performed on a 12 cores machine, which clearly limits the affordable computational effort. A more comparable approach, from a computational requirements point of view, was followed in [56], which used 7 color SIFT variations with both Harris and Dense sampling, leading to 14 separate classifiers per concept, combined with late fusion (averaging). They obtained a MAP of 31.1, clearly showing that the summarization properties of the GOLD and Mixture-GOLD representations, computed with only the basic RGBSIFT, are able to beat the description of the BoW approach.

ImageCLEF 2013 Scalable Concept Image Annotation dataset is composed by 250,000 training images, obtained by querying popular image search engines (namely Google, Bing and Yahoo) when searching for words in the English dictionary. It includes various precomputed visual feature descriptors, extracted using the ColorDescriptor software [10], and textual features extracted from the websites in which the images appeared. It also provides a development and test sets of 1000 and 2000 images, respectively, both manually annotated for 95 and 116 concepts [57]. The competition objective is to develop systems that can easily change or scale the list of concepts used for image annotation.

Two possible strategies have been identified: (i) finding images similar to the query, and from those extract the image concepts, leveraging the provided textual annotation; (ii) directly using the textual annotation to roughly annotate the training set and then for every concept building a classifier applicable to the query. In the competition it has been shown that the second strategy largely outperforms the first one.

We tested this dataset for several reasons: it consists of a very large number of images; it is an unconstrained and challenging dataset, because it has a high heterogeneity of classes (mixed professional and user-generated content) and training images are not manually annotated.

In this experiment, following the second strategy, we compare our approach with SVM classifiers learned by the provided precomputed BoW [57]. Since the organizers computed the BoW features using a spatial pyramid of 
                           
                              1
                              ×
                              1
                           
                         and 
                           
                              2
                              ×
                              2
                           
                        , we also used the same setting. In order to perform a fair comparison, all the techniques use the same textual annotation to select the image training set. Table 7
                         reports the performance in terms of MAP on the development set using three different local descriptors: SIFT, RGBSIFT and OPPONENTSIFT. It can be noted that our approach obtains superior MAP values with all of the three features.

In our best run at the ImageCLEF 2013 workshop [58], images are described using the GOLD descriptor computed on standard SIFT and on three different color SIFT variations, combined with a late fusion averaging approach. In this run, textual analysis on the web pages containing training images is also performed, to retrieve a relevant set of samples for learning each concept classifier based on WordNet lexical database. This run obtained the best result of the ImageCLEF 2013 workshop in terms of MAP: 45.6 (for more detailed results see [57]
                        
                           4
                           
                              http://imageclef.org/2013/photo/annotation/results.
                        
                        
                           4
                        ). Also in this dataset, the Mixture-GOLD is able to further improve the performance of the GOLD descriptor, of about 1.5 MAP points.

The PASCAL VOC07 dataset is a challenging archive for image classification with 9963 image divided in 20 classes of objects. Images are taken from Flickr and have large variations in size, illumination, scale, and viewpoint. Classification accuracy is measured using Mean Average Precision (MAP) over the 20 classes following the common experimental protocol [2]. In this experiment we use the VLFeat library [40] that includes multiple encoding methods such as BOW, LLC, Super Vectors and Fisher Vectors. All the tested methods use densely extracted multi-scale SIFT descriptors, and images are partitioned with a 3 level pyramid: 
                           
                              1
                              ×
                              1
                              ,
                              
                              2
                              ×
                              2
                           
                         and 
                           
                              3
                              ×
                              1
                           
                        . Following [2], for BOW and LLC the codebook size is set to 25,000, for Super Vectors it is set to 1024, while Fisher vectors uses a GMM with 
                           
                              K
                              =
                              256
                           
                         components, after reducing the dimensionality of the SIFT descriptor to 80 by using PCA. Similarly, for the Mixture-GOLD (M-GOLD) we used a GMM with 
                           
                              K
                              =
                              16
                           
                         components and again a 80-dimensional PCA-SIFT.


                        Table 8
                         shows the performance of our method with respect to the other approaches. Although this dataset is very challenging, without specializing the GOLD image descriptor we are able to reach the performance of the BOW technique, which on the contrary requires to learn a very large and specific codebook. In order to achieve state of the art results, obtained by the Fisher Vector technique, introducing dataset dependency with GMM modeling is required. Moving from the GOLD to the Mixture-GOLD improves the performance of 6 MAP points getting results comparable with Fisher Vectors.

Therefore, our solution enables the user to choose between a descriptor which is effectively reusable when the image collection dynamically evolves, and one that provides better performance, thanks to the specific dataset characteristics.

@&#CONCLUSIONS@&#

In this paper we presented a new way to summarize local descriptors by means of multivariate Gaussian distributions. While still providing the possibility to include all the techniques which improve system performance, such as spatial pyramids and power normalization, this allows to obtain an image descriptor totally independent on the dataset. The experimental results show that the method achieves performance which are very competitive with state-of-the art approaches on several well-known datasets. This solution could be also employed in many different situations in which the dataset changes dynamically (for example in online services such as Flickr or Google Images), still allowing to use the same feature vectors in different scenarios. Furthermore an extension to a mixture of Gaussians is proposed, enhancing the image description considering context information. Its discriminative capability allows to boost classification results in specific scenarios.

@&#REFERENCES@&#

