@&#MAIN-TITLE@&#Parametric virtual laboratory development: A hydropower case study with student perspectives

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We investigated common geometrical features of crossflow hydropower rotors.


                        
                        
                           
                           We used the results to create a parametric model to describe rotor geometries.


                        
                        
                           
                           We tested that model in constructive solid geometry.


                        
                        
                           
                           We developed prototype virtual learning software around the model.


                        
                        
                           
                           We explored student perspectives on that prototype in a pilot-study to provide direction for future work.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Graphics

Hydropower

Rotors

Parametric

Virtual learning

3D modeling

@&#ABSTRACT@&#


               
               
                  In order to take advantage of trends such as genetic-design students need to be familiar, and comfortable, with the concept of parametric computer models and how their parameters relate to physical-forms. Virtual learning software can aid in creating that understanding and help support studies at all undergraduate levels in engineering design disciplines. As an example, hydropower rotors are complex and largely rely on computational analysis of geometries for single rotor types. That problem can be significantly overcome using a parametric algorithm capable of creating an almost-infinite variety of computer models. Therefore, this paper investigates the shared parametric properties of common crossflow hydropower rotor geometries, resulting in a generic model that is then used to illustrate application in real-time interactive virtual learning software capable of producing accurate stereoscopic images and stereolithography files for 3D printing, as well as linking to constructive solid geometry software for slower, but more detailed, analysis. A pilot survey of student attitudes to the virtual learning prototype and resulting geometries is then discussed, illustrating the potential for 3D graphics as an effective addition to virtual learning of parametric design methods, and giving initial direction for future work.
               
            

@&#INTRODUCTION@&#

@&#BACKGROUND@&#

Computers have significant potential in supporting environmental sustainability. For instance, problems with energy security and climate change dictate a need to move from reliance on fossil fuels to adoption of increasing amounts of clean and reliable energy [20]. Marine and river currents are a major energy resource that can be exploited over the long term. For example, the UK is estimated to have tidal stream resources as significant as 36TWh/year, although this has been underutilized at approximately 2% of that figure [7]. Extraction of electricity from marine currents on a commercial scale is therefore an important developing sector, it being reported in 2002 as an ‘emerging market’ [9], the world’s first tidal stream power station having come online only as recently as 2008 [8].

However, the designers of the future, who will make the largest inroads into sustainable electricity generation, are the students of today. In order to develop skills suitable for efficient three-dimensional design, and trends such as genetic-algorithms for design optimization, those future designers will require a good understanding of parametric design (e.g. using measurements and rules to define geometries) and how it relates to subsequent physical-models. In terms of hydropower design, a good example is the rotor, as this is the element responsible for conversion of kinetic energy into rotational mechanical energy to drive generators. Rotor design using traditional Computer-Aided Design (CAD) techniques is complex and time-consuming, limiting the number of designs that can be created and analysed. However, parametric computer models could provide a very wide range of virtual-rotors for use in visualization and analysis.

Therefore, design of commonly used hydropower rotors has been taken as an example of parametric model construction suitable for development of virtual laboratories with real-time interactive geometry creation, and modification ‘on-the-fly’, by engineering students. That software is based on a parametric study of crossflow hydropower rotors, in order that the virtual laboratory be able to demonstrate to students both commonly used versions and a plethora of hybrid types. As described in Section 3, the software allows immediate feedback on adjustment of key parameters, as well as allowing integration with constructive solid geometry and computer aided design packages. It also includes use of the digital model to create stereolithography files for rapid prototyping on 3D printers, for subsequent physical testing and analysis.

Following from an introduction to virtual/distance learning and hydropower rotors, this paper includes the in-depth study of rotor parametric features required for development of the software prototypes, in Section 2. The parametric study was central in allowing for creation of teaching material that fully illustrates the nature of the parameters being visualized, which will be especially important for distance learning. Then, testing of the resulting parametric model is briefly demonstrated in constructive solid geometry, using the Adaptive-Modeling Language (AML) used by many engineering students at Birmingham City University, in Section 3. Section 4 then describes Java-based code designed to provide real-time interaction between students and rotor parametric-models, including discussing its integration with AML, production of stereoscopic outputs and rapid prototyping through 3D printing. Finally, in Section 5, student perspectives on the prototype virtual learning system will be demonstrated though a pilot survey of first year undergraduate students at Birmingham City University. The student perspectives then allow for future work on virtual laboratory software that respects their needs and design-requirements. Therefore, the paper can be considered to provide a route-map of the complete process undertaken in developing prototype virtual learning software for use in undergraduate study, on and off campus.

The aim of this research was to explore student perspectives on the potential for use of parametric graphics, in virtual learning software being developed for undergraduate engineering students. It therefore had a number of objectives, as detailed in Table 1
                        , the basis behind which being detailed in Section 1.3. These objectives did not seek to replace existing teaching methods, but rather extend on them to provide new resources (i.e. virtual laboratories) that can be used by teachers and students alike, and that integrate with CAD software widely used by engineering students (including Constructive Solid Geometry – CSG – systems). That allows for reinforcement of learning following lectures and, crucially, allows for additional practical learning off-campus. In developing the objectives it was also speculated that modern students may have a preference toward virtual learning systems, although not necessarily in complete-substitution for traditional teaching. The intended concept can therefore be illustrated by Fig. 1
                        , where the lower part represents traditional learning, and the upper part illustrates extension to include virtual laboratory use.

Hydropower rotor design provided a good opportunity to investigate the aim and objectives because it combines design techniques familiar to engineering students, 3D geometry creation and can be approached from a parametric perspective. Also, no study has been found by the authors showing parametric relationships between a wide range of rotor types: most studies show geometries for one main type and so ignore variations resulting in hybrid rotors that could be useful to, for example, genetic algorithm applications in design. Therefore, it allows students to learn to abstract from standard geometries, and then understand how the root of many geometries can be related, thereby encouraging creative thinking. This adds significantly to the potential for creativity and exploration on the part of students, as it is not easy to get bored after learning a handful of standard designs. It also allows them to learn that very different geometries can be mathematically related, reducing the potential for their design-mindsets to become compartmentalized.

Virtual laboratories are becoming familiar components of many higher education courses, as well as being an important aspect of many distance learning courses. The visual thinking they allow has been described as ‘crucial to the future of learning’ in science and engineering [25] and the 3D visualizations they can employ allow for much improved student-comprehension, particularly for complicated objects [37]. It has also been shown that virtual learning in engineering can be just as effective as learning in a physical setting [14], including in the work of Okutsu et al. [27] who found close correlation in performance between students engaging in virtual and real-world learning, and considered virtual reality an ‘untapped potential’ in early-undergraduate and distance learning. Virtual laboratories are now widely used in computer science teaching, such as the work of Petropoulakis and Stephen [30], who developed web-enabled MatLab for collaborative use. Similarly, Pan et al. [29] provided electronic tutorials on 2D and 3D computer graphics programming. They aimed to provide learning of computer algorithms in a network-enabled collaborative environment. However, in reporting their work on a virtual mechatronics and robotics laboratory, Potkonjak et al. [31] describe distance- and e-learning in technical disciplines as far behind the state-of-play for other areas of implementation. Also, in a ten year review of educational virtual environments, Mikropoulos and Natsis [26] concluded that little information is available on knowledge-retention in those environments and recommended longitudinal studies and further research.

However, there are notable instances of application of virtual learning in physical-engineering subjects. For instance, Budhu [4] developed a virtual laboratory for geotechnical testing, highlighting that it could allow students to develop practical skills while aiding retention of learning knowledge, as well as facilitating exploration of ‘what-if situations’ without needing access to a real-world laboratory. That is important because, as Dudulean and Staretu [6] stated, in terms of mechanical engineering, there are skills that require development through repetition and practice, which can be enhanced by providing online versions of physical equipment (in this case they suggested use within Moodle). Similarly, earlier work by Wilkins and Barratt [36] showed the potential for use of a web-based virtual construction site for teaching and García-Guzmán et al. [11] describe a web-based laboratory focussed around an AC motor, describing it as empowering students by allowing them access to practical learning in their free time. As Ahmad et al. [1] state, with virtual learning the ‘classroom’ is anywhere that students have access to a computer and internet-communications, making it ideal for the growing base of part-time and distance-learning students around the globe.

An important aspect of learning in virtual systems relates to the freedom students have to engage with them and the degree to which they can be considered analogies for real-world systems. For instance, Freitas and Neumann [10] stated that virtual environments allow students increased autonomy in their own learning. However, while Girvan and Savage [12] agreed that freedom in pursuing knowledge is good, it is also important to avoid a ‘tyranny of freedom’, implying some constraints are required in terms of use in self-directed study. In parametric systems this can, of course, be realised through incorporation of boundary-setting rules where necessary. It should also be noted that Shih [34] found that virtual reality in itself was insufficient to fully represent the real-world appearance, finding that rapid prototyping (e.g. 3D printing) not only allows students to better understand virtual models, but also provides a greater feeling of control over their virtual work.

Familiarity with computer technologies among current students is important too, Glava and Glava [13] reporting student comments that lessons became easier compared to traditional paper and blackboard presentation, and allowed learning at a personalized pace. However, while peer learning in geometric problem solving has been researched (see [18]) a review of relevant literature indicates that there is little if any current research into the potential for use of virtual laboratories that allow students to develop skills around parametric design in physical-engineering curricula. Nor does there appear to be any body of literature that attempts to integrate such tools into related software systems used by students, in order to extend their usefulness over the length of their courses (e.g. from fresher year to graduation). Therefore, it is apparent that such research is important, particularly together with gauging of student reactions and requirements in that area.

For use in extracting energy from marine and river currents three types of crossflow rotor are commonly used: Savonius, Darrieus and Gorlov [21]. The Darrieus turbine comprises a variable number of hydrofoil blades (e.g. of NACA profile: Section 2.3) spaced at a constant radius and equally around the rotor circumference. The blades are often set tangential to the rotor circumference, but this ‘attack angle’ may be varied by small amounts, generally less than ±10° [5]. This helps improve lift along the blade length [23] and helps account for variations in flow velocity between upstream and downstream blades [24]. The attack angle may even be allowed to passively vary between blades [17].

Gorlov turbines are a sub-class of the Darrieus but rotated around the vertical axis to provide a helical shape [16]. The Savonius rotor is similar to the Darrieus except for the use of semi-circular blades. Occasionally a helix angle has been applied to create a Twisted Savonius rotor to increase efficiency [33] but this appears uncommon in the literature. Mounting and support structures vary but a common method is the use of circular end plates often described as ‘squirrel cages’. For Savonius rotors end plates have been described as the simplest accessory that can be added to increase performance [2]. According to Fraenkel [9] there are a number of limitations to crossflow rotors, as compared to propellor types. These are increases in material usage, the fact that they may not self-start under all conditions, greater difficulty stopping them for maintenance and emergencies, greater need for low-drag surface finishes and major cyclical lateral forces that can cause significant vibration in low solidity rotors. However, these limitations can be offset by greater energy conversion efficiency and, in the case of lateral forces and torque fluctuations, by the helical nature of the Gorlov rotor [15,16]. They also exhibit less severe variations in efficiency with changes in flow above and below design values, compared to propellor types [28].

Energy conversion efficiencies of crossflow turbines are generally considered greater than for propellor-types, some published work suggesting 23.5% for Darrieus and 35% for Gorlov turbines, compared to less than 20% for propellors [15]. Gorlov [16] suggests that the efficiencies of Darrieus turbines can range between 30% to 50%, and that Gorlov turbines could achieve efficiencies greater than 50%. The Savonius turbine, however, while having a claimed maximum theoretical efficiency of 30% can fail to reach 10% [22]. An aspect which these crossflow turbines have in common is that they can be placed either vertically or horizontally, thereby allowing use in shallow estuary and river flows. Indeed, the Gorlov turbine was intended to provide high efficiency, high rotation speeds and low vibration characteristics in shallow (as low as 3–4m) water [16]. Due to all of these rotor design complexities, Computational Fluid Dynamics and three-dimensional visualization systems are often used (e.g. [3,32].

Despite the complexity of rotor designs important similarities were found between common rotors that can be used to develop a generic class. For instance, Gorlov turbines are, in design terms, almost indistinguishable from Darrieus versions except for addition of a helix angle. The helix angle is also pertinent to Savonius rotors, allowing creation of a twisted version (e.g. [33]. Also, the major difference between the Savonius rotor, compared to the Darrieus and Gorlov, is the blade section profile: Savonius rotors utilize semi-circular blade sections, whereas the others utilize more hydrodynamic profiles such as those developed by the National Advisory Committee for Aeronautics (NACA, see Section 2.3). These similarities are summarized in the truth table of Table 2
                        .

From the above it is apparent that parameterisation of crossflow rotors requires consideration of three key features: the rotor, its’ blades and any associated support structures. The parameters identified for each are listed in Table 3
                        , together with their abbreviated form in parentheses. These are the basic parametric requirements, variations being required for uncommon additional features, specific blade profiles, or for different support structures. As only the parameters shown in bold are set by the designer, it is apparent that crossflow rotors can be described using only eleven values and/or functions, excluding blade type specific parameters (ten if the internal support radius is considered always equivalent to the rotor radius). As will be demonstrated in Section 3, an even more limited set of parameters is required if only individual standard rotor types are required.

In dimensional terms these parameters can be defined as shown in Fig. 2
                        . It should be noted that the rotor_radius cannot be defined simply from the blade radius and edge offset. This is because the twisting of the blade to the attack angle increases the blade-associated radius. Therefore, for this implementation, the model calculates the maximum blade-vertex radius (MR) from the twisted vertices and adds the edge offset to determine the rotor radius. Fig. 3
                         shows implementation of the blade overlap distance, for the Savonius arrangement, although this parameter is also appropriate to non-semi-circular blade profiles for hybrid design. Also illustrated in Fig. 3 is the definition of the helix angle around the rotor, in this case around a circumference based on MR.

Blades within hydropower rotors are the most important element and their cross-sections can be created parametrically for subsequent extrusion. With Savonius rotors the equation of a circle can be used for the semi-circular blades, but for other rotor types a more sophisticated hydrofoil profile must be used. The most popularly used parametric hydrofoil methods in the literature are those developed by the National Advisory Committee for Aeronautics (NACA, e.g. [19]), the NACA 4-Series profiles potentially being most widely employed in hydropower literature. These provide useful data for parametric construction of hydrofoil profiles: of the four figures in the NACA reference (e.g. NACA0015) the first (m) represents the percentage slope of the profiles’ mean line at the leading edge, the second (p) represents the position of the mean-line maxima in tenths of the chord length and the last two (t) represent the maximum thickness as a percentage of the profile length. They are based on a unit chord length (i.e. the blade width), and the NACA reference is then uniform-scale independent (i.e. the profile number does not change if the two axes are scaled by the same factor). Examples of NACA 4-Series profiles, illustrating parametric variations, are shown in Fig. 4
                        . While the 4-Series is used herein to illustrate the methodology, it is a simple exercise to make use of other blade profile types. Also, there is no reason why the NACA parameters should be retained as single digits, as decimal values can be used to provide greater control within computer models.

The mean-line of a NACA profile is calculated using Eq. (1) (after [19]. This can be easily accomplished based on a unit chord length, and subsequently scaled to the correct size.
                           
                              (1)
                              
                                 
                                    
                                       y
                                    
                                    
                                       c
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         m
                                                      
                                                      
                                                         
                                                            
                                                               p
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                   (
                                                   2
                                                   px
                                                   -
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   )
                                                
                                                
                                                   (
                                                   x
                                                   <
                                                   p
                                                   )
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         m
                                                      
                                                      
                                                         
                                                            
                                                               (
                                                               1
                                                               -
                                                               p
                                                               )
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                   (
                                                   (
                                                   1
                                                   -
                                                   2
                                                   p
                                                   )
                                                   +
                                                   2
                                                   px
                                                   -
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   )
                                                
                                                
                                                   (
                                                   x
                                                   ≥
                                                   p
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where yc
                         is the y-axis offset for the mean-line and x is the distance along the unit chord length (0⩾
                        x
                        ⩽1).

The x and y coordinates of the upper and lower sides of the profile can then be calculated using Eqs. (2)–(5) 
                        [27].
                           
                              (2)
                              
                                 
                                    
                                       x
                                    
                                    
                                       u
                                    
                                 
                                 =
                                 x
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       t
                                    
                                 
                                 sin
                                 θ
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       y
                                    
                                    
                                       u
                                    
                                 
                                 =
                                 
                                    
                                       y
                                    
                                    
                                       c
                                    
                                 
                                 +
                                 
                                    
                                       y
                                    
                                    
                                       t
                                    
                                 
                                 cos
                                 θ
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       x
                                    
                                    
                                       l
                                    
                                 
                                 =
                                 x
                                 +
                                 
                                    
                                       y
                                    
                                    
                                       t
                                    
                                 
                                 sin
                                 θ
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       y
                                    
                                    
                                       l
                                    
                                 
                                 =
                                 
                                    
                                       y
                                    
                                    
                                       c
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       t
                                    
                                 
                                 cos
                                 θ
                              
                           
                        where the subscripts u and l denote the upper and lower surfaces respectively, and Yt
                         can be calculated using Eq. (6) 
                        [19].
                           
                              (6)
                              
                                 
                                    
                                       y
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       t
                                    
                                    
                                       0.2
                                    
                                 
                                 (
                                 0.2969
                                 
                                    
                                       x
                                    
                                 
                                 -
                                 0.1260
                                 x
                                 -
                                 0.3516
                                 
                                    
                                       x
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 0.2843
                                 
                                    
                                       x
                                    
                                    
                                       3
                                    
                                 
                                 -
                                 0.1015
                                 
                                    
                                       x
                                    
                                    
                                       4
                                    
                                 
                                 )
                              
                           
                        
                     

The parametric models described herein were initially tested using AML [35] for compatibility with constructive solid geometry teaching, prior to development of the real-time java code. AML is an object-oriented, knowledge-based engineering modeling framework enabling multidisciplinary modeling and integration of the entire product and process development cycle. It is also widely used with CFD and finite-element packages, as well as including import and export to industry-standard file formats such as IGES, STEP, STL, and DXF. Coding of the rotor model was based around construction of three principle components: end plates, blade cross-sectional profiles and the blades themselves. The method used is summarized in the pseudo-code of Listing 1.
                           
                              
                                 
                                 
                                    
                                       
                                          input parameters
                                    
                                    
                                       
                                          compute rotor_height, rotor_radius, support_position, support_radius
                                    
                                    
                                       
                                          for each end plate
                                    
                                    
                                       
                                          
                                             component: end plate
                                    
                                    
                                       
                                          
                                             create cylinder geometry
                                    
                                    
                                       
                                          
                                             draw cylinder
                                    
                                    
                                       
                                          next
                                       
                                    
                                    
                                       
                                          component: blade array
                                    
                                    
                                       
                                          for each blade
                                    
                                    
                                       
                                          component: blade
                                    
                                    
                                       
                                          for each length increment
                                    
                                    
                                       
                                          
                                             get blade profile
                                    
                                    
                                       
                                          
                                             twist blade profile
                                    
                                    
                                       
                                          
                                             move profile out from origin
                                    
                                    
                                       
                                          
                                             apply helix angle to profile
                                    
                                    
                                       
                                          next
                                       
                                    
                                    
                                       
                                          create blade mesh
                                    
                                    
                                       
                                          rotate (2π/num_blades)∗blade_index
                                    
                                    
                                       
                                          draw blade
                                    
                                    
                                       
                                          next
                                       
                                    
                                 
                              
                           
                        Listing 1. Pseudo-code for the parametric modeling.

Initial tests of the parametric rotor algorithm focussed on standard rotor-types (i.e. Darrieus, Gorlov and Savonius) in order to validate the methods described in Section 2. Examples of some of the resulting geometries are shown in Fig. 5
                        : (a) a Gorlov, and (b) a twisted Savonius, rotor. A number of hybrid rotors were also considered, in order to show the wide diversity of non-standard geometries possible, as shown in Fig. 5: (c) a modified Darrieus rotor and (d) a simple water wheel. The water wheel in particular shows that imaginative use of parameters can result in diverse generative geometries. The parameters required for construction of the examples in Fig. 5 are provided in Table 4
                        .

In Table 4 parameters shown in bold are rule-based, based on common usage in the hydropower literature. Therefore, for implementation of the computer model for a standard rotor type, it is necessary to implement rules to constrain the parametric geometry calculations. These rules are not necessarily simple values and so may be based around formulae for instance. An example of the latter rule-type relates to Savonius rotors, as they often require a seamless join between the two semi-circular sections. That rule was implemented using Eq. (7).
                           
                              (7)
                              
                                 overlap
                                 =
                                 chord
                                 _
                                 length
                                 -
                                 
                                    
                                       
                                          
                                             
                                                thickness
                                             
                                             
                                                100
                                             
                                          
                                          chord
                                          _
                                          length
                                       
                                    
                                 
                              
                           
                        
                     

There is also potential for increased usefulness of the base model by considering specific parameters to be functions of other parameters, rather than constant values or simple formulae. For instance, where variations in attack angles along the blade length are required, such as to mitigate the effects of structures at the rotor ends, the attack angle can be considered a function of distance along the blade. This is illustrated in Fig. 5c where the blade attack_angle parameter is based on Eq. (8) and only requires addition of a single parameter to the base model: the maximum attack angle. Similarly, passive adaptation of blade attack angles separately for each Darrieus blade [17] can be easily achieved by considering the blade attack angle to be a function of the blade number.
                           
                              (8)
                              
                                 attack
                                 _
                                 angle
                                 =
                                 sin
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                length
                                             
                                          
                                          π
                                       
                                    
                                 
                                 
                                    max
                                 
                                 _
                                 attack
                              
                           
                        where x is position along the blade and max_attack is the maximum attack angle, in this case at the midpoint along the blade.

Creation of constructive solid geometries, using the above methods, requires significant computational power and so is not necessarily suitable for real-time interaction on ‘standard’ PCs used by most students and for presentations in lectures. That requires consideration as real-time interactive parametric-graphics offer new means by which designers and students can visualize their work and immediately communicate it to academic supervisors and fellow students. For students in particular, it allows exploration of the effects of changing parameters, with immediate feedback. It also allows ‘what-if’ scenarios to be tested quickly without many hours of costly manual computer-aided design, and facilitates collaboration over the internet between non-geographically co-located participants. To demonstrate this, the virtual-learning hydropower design studio prototype shown in Fig. 6
                         was coded, which can also be described as a virtual laboratory due to it providing an accurate simulation of the rotor geometry and allowing exploration of it for experimentation and learning. The graphics also includes rotation around the vertical axis to mimic expected motion for a hydropower rotor.

The software was created using the Processing (http://www.processing.org) libraries over Java: by so doing it is possible to run the software on all major desktop operating systems, on web-browsers as applets, and even as an Android application. It was intended to run, in a 1024×768 pixel window, without detracting graphics latency on an i7 laptop with 8GB RAM, 64-bit Microsoft Windows 7 operating system and NVIDIA GeForce GT-540M display adaptor. That was considered a realistic device for use by many students and designers and so also considered a relevant base for code-development. A simple interface was chosen for parameter manipulation as shown in Fig. 6, although game controller and sensor interfaces may be added in future.

Tests showed that frame rates for four-blade rotors, generally the maximum in most applications, were in the order of 20fps, without significant optimization. For a Java-applet, 640×480 pixel, web browser version, frame rates increased to approximately 30fps. Under all circumstances rendering was considered smooth enough not to detriment visual effects or real-time feedback, although future work will include a greater level of optimization for use with slower PCs and mobile devices. The software was also designed to interface with AML, in order that designs created in real-time can be built using constructive solid geometry: the AML code also creating STEP files for CAD-interchange and structural and fluid dynamics simulations, allowing the real-time code to cover the full learning cycle from parametric-discovery to subsequent learning of CAD and AML design. The AML rotor-geometry creation code was also tested for meshing support, for further computational fluid dynamics and finite-element analysis integration (both forming elements of the student curriculum at Birmingham City University).

Interfacing to the AML code included network communications, allowing remote construction of solid geometries and preventing performance issues with the visualization. Due to the parametric nature of the models, transmission of the geometries was achieved through less than 100 bytes of data, making it a very bandwidth-efficient method of communication suitable for long-distance learning, with interaction, between students and their teachers. That factor should also help enhance the student experience in areas where internet-latency (e.g. limited bandwidth, including mobile broadband speeds) may be an issue. Other uses for the software were also explored including 3D printing and stereographic images, allowing for a hands-on approach to visualization and for creation of accurate prototypes for physical testing in water tanks and flumes if required (or in air, as the designs are very similar to wind-power systems). Fig. 7
                         shows a model 3D printed on a two-part printer, using STL export coded into the Java software, after dissolving the support material.

In terms of stereographic images, the ability to create two views of the rotor graphics, and combining them into side-by-side 3D (jps) graphics files was also explored in the real-time Java-based code. That allows for a new level of visualization in comparison to 2D images, and was successfully tested using a Sony Vaio laptop and an LG Optimus 3D smartphone. Examples of 3D rotor images from this process can be found online at http://phereo.com/50b89385e15585304d000000.

Birmingham City University first year undergraduate students, studying automotive engineering, mechanical engineering and computer-aided design, were given a demonstration of the virtual learning software in their normal lecture-room environment. They were chosen as they all study modules with practical classes involving design and modeling, ensuring that understanding 3D representations was a common need. This also helped ensure they were unlikely to be overcome by the novelty of the software, as they had prior experience with 3D engineering visualization. Immediately following the demonstration the students were asked to complete a short pilot-study questionnaire (see Table 5
                        , plus a free form box for additional comments) with explanation of each question, the model of Fig. 7 being used to illustrate Q4.

The questionnaire was designed around the need to gather focused data on the usefulness of parametric 3D graphics, and associated rapid prototyping, in virtual learning. It therefore did not simply seek to obtain data on user-experience, its design seeking perspectives on educational use. Design of the software prototypes, and collecting of student data, were undertaken by different co-authors, neither of whom had any direct role in the students education, in order to minimize bias associated with the designers views and educational intentions. For Q1, the majority of students were almost equally split between mechanical and automotive engineering, just six identifying their studies as primarily CAD/Design based.

Details of the responses for questions 2–4 of Table 5 are shown in Fig. 8
                        . Responses to Q2 (relating to Objective 1) indicated that the students had no prior experience of similar virtual learning, although two commented that they had used CAD software previously. Responses to Q3 (Objective 2) and Q4 (Objective 3), as shown in Fig. 8, showed that the majority found the software and output models useful in understanding the design and its relationship to parameters. However, while ‘yes’ answers dominate the Q3 and Q4 responses, further research will be required to investigate the reasons behind the ‘no’ answers, as well as illuminating the caveats contributing to the ‘maybe’ responses.

Using the questionnaire form anonymously, 19 students provided at least one comment each, resulting in a total of 50 comments. These were grouped and refined into seven categories as shown in Table 6
                        . The largest category simply contained positive comments about the software and graphics by 12 students. That could have been combined with the category relating to the usefulness of virtual laboratories (the second largest category at 10 students commenting) but for precision was instead taken as a general indication of high student acceptance. Also, 4 comments were received that could not be categorized, including one which was unreadable. Q5 was included essentially as a student vote, allowing them involvement in decisions on whether to progress the virtual laboratory further. The majority of students responding to Q5 would like to see virtual learning software, such as that described in this paper, used as part of university study. The results of Q5 are shown in Fig. 9
                        , vindicating the effort required to create the software, and demonstrating that further work in this area is needed, including in terms of researching exact student needs for learning-goal-specific virtual laboratories. For instance, as one student commented “a good concept and start: a little more put into it to make it perfect”.

Comments were generally positive, one student saying “the idea is good and enhances the home/domestic learning experience”, also that it helps with coursework “access away from the laboratory”, and another commenting that “it makes it easy to understand because it is easy to visualize the product”. Also, the use of a 3D printed rotor was commented on as a useful feature (“the printed out system is the added feature that provides a seamless interface”), as was the benefit of using 3D representations over more usual 2D versions (“much more useful than normal 2D instruction” and “3D modeling worked well and gave a much better impression of both the object and environment than normal”). However, an important factor also commented on was the desire not to use virtual laboratories as a replacement for human-led instruction. One student commented, for instance, that he prefers “hands on experience” and that perhaps “virtual labs are for Moodle but not instead of physical labs”, while another reminded us that “hands on knowledge and experience are always better for learning”. However, in contrast a student also commented that it “enables more practical work at university”.

It was also found that some students prefer traditional learning including from text (which may largely explain the non-yes responses in Fig. 8), and that use of other media, such as voice instructions, could usefully supplement the use of graphics. Further comments illustrated the need to ensure that the virtual laboratory provides a good depth of relevant learning material (e.g. “need proper instruction to run the software”) one student saying that some “information was lacking” in the prototype. Also, the overall design requires care, as one student put it “the coloring of the words against the background is wrong”. Also, some mentioned the requirement for integration with other 3D design software (e.g. “should be able to test the model before printing”) which has been partly addressed herein through integration with AML.

@&#CONCLUSIONS@&#

An almost inexhaustible range of crossflow hydropower rotors (and potentially also wind-powered versions) can be constructed using the single generic base model described herein. That model is fully parametric, with rule-sets differentiating between different rotor types, allowing generation of solid geometries for use in CFD, visualizations and 3D printing of prototypes. It is also suitable for use with genetic algorithms to allow optimisation and investigation of improved designs. Therefore, it provides a complete base upon which students can develop an understanding of parametric design and visualize how adjustment of key parameters leads to changes in physical form through 3D computer graphics.

That hypothesis has been tested through development of a real-time virtual laboratory and a pilot-study survey of attitudes toward the use of such virtual laboratories, in curricula, from undergraduate students. It was found that while the majority of students undertaking first year classes had not used similar virtual learning software, the majority also expressed a desire for its use as part of their studies. A number of caveats are obviously attached to that including a need to ensure that learning-goals are comprehensively covered, and a desire for such systems not to replace human-led lectures where possible.

However, the development of software discussed in this paper has been shown by first year engineering students at Birmingham City University to be an important step toward their learning systems of tomorrow, and so deserving of further research and implementation. But, it is apparent that they require virtual laboratories to provide accurate portrayals, and integration with later learning systems, which requires a considerable depth of design and testing (e.g. the work described in Sections 2 and 3) if virtual learning is to achieve its full potential in engineering design.

@&#REFERENCES@&#

