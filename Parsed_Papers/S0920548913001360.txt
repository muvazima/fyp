@&#MAIN-TITLE@&#A flexible time-triggered service for real-time CORBA

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           CORBA service for orchestrating in a timely and flexible way the tasks of a DRTS


                        
                        
                           
                           Definition of the FTT-CORBA architecture, task model and initial configuration


                        
                        
                           
                           Implementation issues of FTT-CORBA over TAO-CORBA and ACE


                        
                        
                           
                           Performance of FTT-CORBA over low end hardware on different platforms


                        
                        
                           
                           Coordination of automation applications with reconfiguration needs with FTT-CORBA.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Distributed real time systems

Middleware

Synchronous scheduling

Real-time

@&#ABSTRACT@&#


               
               
                  This paper presents a new service for CORBA applications that orchestrates the timely execution of the tasks of a distributed real-time system in a flexible way. It follows the CORBA philosophy of complementing the CORBA standard with additional services that solve specific problems and facilitate using CORBA in complex applications. The service has been designed for highly coupled applications that execute over LANs. It provides a synchronous framework to synchronize distributed applications that is open to accepting and removing components on-line, with reduced impact on the application timing. It also provides the flexibility to use different distributed scheduling policies that can override the local operating systems schedulers. This paper describes the service architecture and implementation as well as its best-case performance on low computing power hardware with the QNX OS and connected to a switched Ethernet network. Finally the usage and of the service is illustrated with one case study: the synchronization of several robots in a welding process.
               
            

@&#INTRODUCTION@&#

Modern distributed real-time systems (DRTS) are required to satisfy stringent constraints. Traditionally, these requirements led to the use of low level programming techniques that reduce portability and reusability of code and make maintenance harder. During the last decade, certain technologies have been adopted to improve the efficiency, distribution and scalability of the applications with respect to the main programming techniques used in the past [1]. One example is the adoption of distribution middleware technologies which provide certain degree of independence with respect to the underlying hardware, operating system (OS) and programming language [2] such as CORBA [3], ICE [4] or DDS [5]. These middleware technologies have become a popular alternative to develop highly coupled distributed applications of small and medium size that require certain degree of processing power, like those found in robotics, manufacturing or avionics [6]. In the particular case of CORBA, recently standardized as ISO/IEC 19500-1 [7], advanced specifications were included, such as CORBA/e [8] or RT-CORBA [9], that address the specific requirements of DRTS. Moreover, the CORBA architecture is complemented with a broad set of OMG specifications [10] that offer additional services, which simplify the construction of complex CORBA applications. In this scenario, some works such as those reported in [11–13] proposed new patterns and tools that abstract the complexity of using the CORBA architecture in new applications. This work follows the same approach by proposing a new service and tools that ease the construction of time-critical but flexible DRTS complementing existing OMG specifications.

Some DRTS applications may require the timely execution of their activities in an accurate way, such as those that require synchronous measurement by several distributed sensors, sequential measurements to mitigate interference or synchronous actuation [14]. As discussed in [15], this synchronization may be achieved by using either time-triggered techniques that schedule the execution of the tasks at appropriate time instants or event-triggered ones. Typically, event-triggered techniques are easier to implement and configure, whereas time-triggered approaches offer higher predictability and lower jitter. In addition, event-triggered techniques may cause a coupling between functionality and timing that is undesirable. For instance, it may lead to large jitter or to performance deviations upon updating a system component, e.g., by using a faster hardware or a more efficient code.

Concerning the time-triggered approach, a typical way to synchronize distributed real-time applications is to use a global clock to activate their actions [15]. This approach is effective for static environments but raises several problems in dynamic environments where the number of active nodes can vary, or when changes in the functionality of the system are demanded at runtime, e.g., upon system reconfiguration. In such cases, changing dynamically the synchronization configuration becomes a complex issue since the configuration is distributed and, typically, requires exchanging a certain number of messages among the nodes. Moreover, special care must be taken to ensure consistency and avoid undesired transient phenomena in this kind of applications.

Similar to network protocols, middleware can be decomposed in several layers [16]: from “host infrastructure middleware” at a lower level to “domain specific middleware services” at a higher level, below the “application level”. The problem addressed in this paper belongs to the second category since it provides distribution middleware technologies, CORBA in particular, with an appropriate, high-level service that supports synchronizing distributed applications in a flexible way, amenable to runtime reconfiguration.

This paper presents a flexible time-triggered service for CORBA applications that orchestrates the execution of the tasks of a DRTS in a flexible way. More specifically, it provides a synchronous framework to synchronize distributed applications that is open to accepting the integration, adaptation and removal of applications and application components on-line. CORBA has been selected for this work, despite being a mature technology, for several reasons [17]: (1) it is an international standard middleware [7] complemented with diverse infrastructure services, promoted by the OMG [10], that ease the construction of complex distributed applications; (2) it provides support for real time developments over different embedded architectures (e.g. Atom, ARM); (3) it allows programmers to develop source code reusable across multiple platforms, OS and applications, maximizing technology investments; and (4) there are open source ORBs which provide good performance. Actually, current CORBA implementations are several orders of magnitude faster and smaller than earlier enterprise CORBA versions [18]. However, most of the concepts developed in this work can be easily adapted to other middleware technologies, such as ICE or DDS, since these adopt similar approaches to those used in CORBA.

The service is deployed as a set of COTS (Commercial off-the-Self) components that activate in turn the operations of the distributed system. The objective of this service, henceforth FTT-CORBA, is twofold: (1) liberating programmers from the burden of writing the code for synchronizing the different distributed activities and (2) providing mechanisms to timely execute CORBA methods, reducing activation/termination jitter and latency in the access to shared resources. FTT-CORBA also provides mechanisms for deploying the initial configuration of the DRTS as well as interfaces that allow dynamic changes of the synchronization plan at runtime.

The FTT-CORBA service follows the flexible time-triggered paradigm (FTT) [19]. However, FTT-CORBA is implemented on top of the IP stack instead of directly over the data link layer. In addition, when compared to other works that implement the FTT paradigm, FTT-CORBA follows a different approach since it focuses on the management of the distributed CPUs rather than on the network. Naturally, as in other real-time middleware architectures built over the IP stack, the service performance is affected by the selection of the underlying technologies (e.g. network and OS), so they must be carefully selected [20].

This paper complements preliminary works reported in [21–25] where the authors defined the basics of the service. Here, the authors introduce: (1) a more refined definition of the service architecture which includes a new interface for performing dynamic reconfigurations of the system at runtime; (2) new performance results comparing the activation precision over different OS, namely a commercial RTOS, QNX, and a general purpose OS, Linux; and (3) a new case study beyond that presented in [23] that illustrates the benefits of using this service for coordinating several devices (robots in the example) in a hypothetical welding application. Finally, as proposed in [26], the approach proposed in this paper could be used in the scope of real-time service oriented applications (SOA) to orchestrate the invocation of services implemented as CORBA methods. Such work also describes how FTT-CORBA could be integrated in higher-level architectures with different scheduling algorithms to optimize the use of system resources.

The paper is organized as follows: Section 2 discusses some related work. Section 3 describes the architecture of the proposed synchronization service. Section 4 describes the initial configuration of the service as well as its reconfiguration via the OrchestratorManager interface. Section 5 describes the current implementation of the service over ACE [27] and TAO [28]. Section 6 presents a performance study with different layouts over QNX and Linux. Section 7 illustrates the use of the service with one case study. Finally, Section 8 draws some conclusions.

@&#RELATED WORK@&#

The topic of coordinating distributed applications has received substantial attention from the research community. Lately, there is an increasing interest on distributed applications that adapt at runtime to changes in the operational environment or system configuration, that support multiple modes and that are open to the addition, update or removal of components (later in this paper we give an example in the context of flexible manufacturing). In addition, the adaptation procedure should avoid that the new configuration of the system runs out of resources, be its CPU, memory or network bandwidth, for its successful completion. It is also important to note that even though DRTS are naturally dependent on the specific application domain, approaches built on top of existing middleware standards could ease their implementation.

For example, in the grid computing domain, the work in [29] proposes a scheduling algorithm aimed at optimizing at runtime the performance of systems with energy constraints. This algorithm maximizes the utility degree for all tasks and minimizes their power consumption. Other works, like [30,31] present different mechanisms to monitor the resources of grid computing systems to coordinate the use of the services that form the applications. A similar approach is followed by [32] which presents an e-Infrastructure for remote instrumentation in scientific grid systems. However, these solutions do not address real-time issues but focus on the overall performance of the distributed applications.

Other works propose some extensions to available service oriented architectures (SOAs) in order to support reconfigurable real-time applications. However, these approaches still exhibit poor temporal behavior when standard technologies are used. This is the case in [33] which concludes that Web Services are best used at the edge of networks and not as part of the core of real-time systems. The work in [34] also confirms this fact, proposing Web Services over SOAP/DPWS for non-time-critical operations and specific protocols over UDP for real-time operations.

Concerning CORBA/CORBA-RT based architectures, there are several works aimed at improving flexibility and extending the applicability of the standard. Many of these works have become extensions to the main CORBA standard: the, so called, CORBA services [10]. For example, the RT-CORBA specification includes a Scheduling Service that manages priorities on-line and is quite open about the scheduling discipline to be used. For instance, ACE TAO defines Kokyu [35] and the CORBA Real-Time Event Service [36] in order to manage the priorities of the dispatched events. Other approaches for CORBA systems are based on hierarchical architectures [37–40] with two level schedulers, one central and another in each node, that use different scheduling policies. Typically, local schedulers monitor the resources available at each distributed node and provide feedback to the global scheduler. Some of these works, such as [41,42], also provide component middleware services for admission control and load balancing of periodic and aperiodic event distribution. It is important to note that CORBA services shall never modify standard CORBA objects, but provide additional functionality seamlessly.

CORBA is a very mature middleware standard that has greatly evolved from its initial versions in the early 90s to the most recent version, standardized by ISO [7] in 2012. Several implementations are available as open source and commercial software, and their performance has reached very competitive levels [43]. Due to the size of the CORBA standard and its complexity much research has also been done in providing adequate interfaces and abstractions that helped developers and shortened technology adoption times. For example, [13] proposes standardizing the interface between CORBA and real-time distributed transducer networks. Other works show how component oriented programming could help leveraging the complexity of CORBA in concrete application domains [11,12].

The CORBA solutions referred above focus on handling the priorities in the access to servers and other shared resources. An alternative is using a time-triggered approach to manage concurrency by separating in time the object invocations according to a pre-planned schedule. Thus, both the number of concurrent tasks active at each instant and the access latencies are reduced. This procedure requires global synchronization across the distributed system to coordinate the triggering of the requests. Some examples may be found in [44,45] where time-triggered Ethernet protocols for RT-CORBA are proposed. In these works, the nodes access the network in disjoint time windows, eliminating concurrency at the network access thus reducing access delays and improving communication temporal determinism.

However, these approaches are not suitable for applications that require synchronization of distributed activities and that, nevertheless, require flexibility to adapt to changing requirements at run time. In fact, some of the previous solutions do not address the synchronization of the activities but only the optimization of the resources of the distributed system. Other approaches are based on a distributed global clock which is used to decide when to activate tasks and initiate transmissions (implicit synchronization). This kind of approaches in which the synchronization information is distributed over several nodes requires extra complexity in dynamic environments where new objects can arrive or be enabled on-line, or the number of active nodes can vary, so that an agreement is reached before committing any change. In spite of the large amount of work on synchronization and communication in DRTS and particularly in industrial automation (fieldbuses) [46,47], providing an agile and efficient support for synchronous dynamic distributed applications has been essentially an open area.

A possible approach to provide such agile support is using a unique node to concentrate the synchronization information and schedule the distributed operations by means of activation events (explicit synchronization). Thus, a coherent globally synchronized framework is established that, in addition, eases the dynamic management of the synchronization information. This is the approach followed by the flexible time-triggered (FTT) paradigm [19,48]. The so-called DREQUIEMI [49] implements a partial version of this paradigm for the distributed real time specification for java (DRTSJ) with certain differences. For example, FTT is based on the use of a low-cost mechanism i.e. a broadcast/multicast service, to disseminate data efficiently among all nodes, whereas DREQUIEMI uses a unicast approach, reducing scalability. Also, DREQUIEMI adopts a pure master–slave communication model in which all slave-to-slave traffic are carried out through the master, which may create a bottleneck in the master and its links.

FTT-CORBA implements a closer approach to the FTT paradigm, keeping most of its features, such as a global scheduler, a generalized notion of multicast trigger events to synchronize the operations, and master-to-slave and slave-to-slave communications. However, FTT-CORBA focuses on managing the use of the distributed CPUs rather than the network. Also, it uses the high abstraction level of CORBA to wrap the tasks of the DRTS and introduces a modular framework aimed at supporting flexible applications with the extra flexibility of supporting different scheduling algorithms. The design of FTT-CORBA has followed the patterns used to design other standardized CORBA services, providing additional functionality that can be used by CORBA developers without modifying the standard CORBA objects.

This section describes the fundamentals of the flexible time-triggered (FTT) CORBA service. The proposed service is aimed primarily at providing a means for the activation of periodic tasks. However, aperiodic tasks can also be included, as discussed later on. The service assumes an underlying network infrastructure capable of doing physical multicast like Ethernet or WiFi.

There are three main entities involved in the service (Fig. 1
                        ):
                           
                              •
                              Orchestrator

Synchronization Clerk

CORBA objects.

The Orchestrator is responsible for generating the multicast trigger events, or triggers, that activate the distributed tasks of a DRTS. These triggers are sent according to an internal plan that defines the sequence of the activations, which is configured at start-time and may be changed (reconfigured) at runtime. Triggers are sent in certain instants only, and refer to the tasks activations that occur within a predefined time window called elementary cycle (EC). This means that the service operates with a certain granularity defined by the duration of the EC. The EC is a configuration parameter which value depends on the hardware and underlying OS capabilities. Just as an example, performance tests show that it is possible to operate with an EC as short as 10ms even with low profile hardware.

The tasks of the DRTS that must be synchronized are wrapped as CORBA methods. However, the Orchestrator does not invoke directly these methods but the Clerks in between, separating dispatching from invocation. Actually, the concept of task only exists in the Orchestrator for scheduling purposes. The Clerks, upon receiving the right triggers, invoke the respective implementations as CORBA methods. Clerks are proxy objects that must be preconfigured at start time by specifying the trigger events they must listen to as well as the associated CORBA methods they can invoke. Typically, there will be one Clerk per node being responsible for invoking all operations in this node.

Initializing the service requires setting certain configuration files for the Orchestrator and every Clerk (see Fig. 1). These files can be created manually. However, the authors have developed a preliminary configuration and management tool, called FTT-Modeler, to assist in the system deployment and operation stages [24]. This tool, available at [50], provides a GUI (Graphical Users Interface) for generating the configuration files, initializing the distributed system and managing it at run-time.

Following a similar approach to other CORBA services (e.g. CORBA Naming or Event Services), both Orchestrator and Clerks are COTS components that solve the synchronization issues of the DRTS whereas the CORBA objects are application specific and contain the functionality of the distributed application. This approach allows separating the temporal control of the application objects, left to the service, from their functionality embedded in the objects code. This separation of concerns has a beneficial impact on the temporal behavior of the distributed application as well as on its reconfigurability and reusability since modifying the temporal control can be carried out by the service without altering the application code inside its objects. Similarly, changes in the application code can be made without modifying the temporal control. Thus, the impact of the changes on the temporal behavior of the application is reduced.

In the context of FTT-CORBA a reconfiguration means a change in the properties the Orchestrator uses to represent the state of the distributed system, such as the current active tasks, their periods or offsets. Note that the Orchestrator sends the triggers accordingly. Reconfigurations occur as a consequence of a request issued by a node to the Orchestrator. This component provides an interface, the OrchestratorManager described further on, which handles the requests of the nodes to change those properties and runs an admission test to ensure that a new configuration is feasible guaranteeing an adequate use of the system resources, e.g., to ensure timeliness and prevent overloads.

We consider a set of tasks that are executed over several nodes connected by means of a LAN. These nodes may have one or more CPUs and typically run a multitasking OS capable of doing local scheduling. Currently, for ease of applicability and analyzability, only asynchronous communication mechanisms between nodes are considered. Thus, communications among tasks either do not produce blockings in the nodes or they are negligible. If necessary, tasks may be broken into a sequence of finer tasks synchronized appropriately. For example, a task in one node communicating through a network may be broken in two tasks, one task with the execution up to the transmission and another task with the remaining execution, each one with its own parameters. Precedences can be enforced at runtime using offsets. Similarly, the proposed task model allows the concept of transaction or end-to-end flow, consisting of the sequential execution of several tasks in several nodes that exchange messages for a consistent global purpose [51]. In this case, end-to-end deadlines encompassing the execution of the tasks that compose a transaction must be broken into local task deadlines, directly by the designer or by means of an appropriate tool. Several works, such as [52], have addressed this problem and provide solutions that are applicable in this context.

The task model uses the following parameters (timing parameters are expressed as integer multiples of the EC duration):
                           
                              •
                              Task Identifier (t_IDi): Integer number that identifies uniquely the task to be executed by the FTT-CORBA service.

Method (m_IDi): Integer number that identifies in the system the CORBA method executed by the task. This identifier will be sent in the trigger event associated to a specific method invocation and it will be the same for several instances of the same method.

Period (Ti): Task activation interval. For aperiodic tasks this parameter represents the minimum interactivation time.

Offset (Oi): First activation of the task expressed in terms of integer multiples of the EC. As Fig. 2
                                  shows, this approach allows de-phasing the invocations of periodic CORBA objects in time optimizing the use of the resources and reducing access latency. As referred above, this parameter may also be used to enforce precedence among tasks that compose transactions.

Blocking Bandwidth (Bi): Bandwidth that corresponds to the time during which a task can be blocked by lower priority ones, e.g., due to the use of shared resources, relative to the task period. In the current version, this parameter is entered by the programmer upon off-line analysis and may be updated at runtime during reconfigurations.

Priority (Pi): Optional explicit task priority. This parameter is used by the Orchestrator when configured with the arbitrary fixed priorities criterion (FP).

Deadline (Di): Optional. This parameter is only meaningful for some scheduling policies executed by the Orchestrator, like deadline monotonic scheduling (DMS) or earliest deadline first (EDF).

Node ID (Node_IDj): Identifies the node where the task is executed.

Maximum Task Load (Uj): Specifies the maximum load or utilization factor imposed by a task on the node where it has been deployed. This parameter is used in the (global) admission test to accept or reject new tasks according to the current load of the system nodes.


                        Fig. 2 illustrates the meaning of the different parameters of the service. Let us assume a simple distributed application that is executed in two CPUs, in which four different periodic operations, identified by different patterns, are carried out, two in each CPU. These operations present harmonic periods in each CPU and different offsets are used so that tasks never execute simultaneously. This may be necessary, for example, to reduce the output jitter in actuators, to coordinate the access to shared resources or to reduce queuing delays. If the same offsets were used, tasks would be activated simultaneously and it would be up to the local schedulers to manage their concurrent execution.

The Orchestrator is a COTS component that synchronizes the distributed system. It is a modular component that implements a similar structure to the one proposed in [53]. It includes the following components: an Admission Controller, a Dispatcher and a Scheduler (Fig. 3
                        ). This modular design decouples the admission, scheduling and task activation roles to reduce interference. More specifically, the Admission Controller keeps track of the load of every node in order to support on-line feasibility analysis (e.g., utilization-based) and decides on the acceptance of tasks upon reconfiguration requests. The outcome is the Task Description Table with all the task parameters that have passed the admission control. The Scheduler reads the Tasks Description Table and generates the Execution Plan, which contains the sequence of tasks activation triggers that must be enforced by the Dispatcher. This module is open to use different scheduling policies that range in complexity between two extremes: (1) it may bypass local schedulers by using a global scheduler that sorts out concurrency, activating tasks so that they do not overlap. This approach has the advantage of allowing a consistent implementation of any global scheduling policy, which is enforced by the Orchestrator; and (2) it may simply generate periodic tasks activation triggers and leave concurrency to be sorted out by the local schedulers executed in the distributed nodes, which determine the local scheduling policy. Finally, the Dispatcher scans the Execution Plan every EC and sends one trigger message with the task activation triggers.

Centralizing all synchronization information of the DRTS in one node, the Orchestrator, improves its flexibility since changes in the execution pattern of the tasks, or in the composition of the task set itself, will be achieved just by modifying the information held in the Tasks Description Table. This is carried out via the OrchestratorManager interface that allows adding/removing tasks or modifying their parameters.

The Synchronization Clerk is also a COTS component. Basically, it listens to trigger events sent by the Orchestrator and subsequently invokes the corresponding CORBA method. Typically, there will be one Clerk per participant node which will be responsible for executing the methods of all CORBA objects located in this node according to the received events and its own configuration. Depending on the scheduling algorithm used by the Orchestrator, the trigger message may propagate the priority at which tasks will be executed at the distributed nodes, if necessary. In order to improve determinism the local priority of the Clerk at the node must be higher than the priorities of the local CORBA objects so the Clerk is executed immediately after the reception of a trigger message. For the purpose of feasibility analysis (see later on), the Clerk is considered the highest priority task executing in each node, with a period of one EC.

CORBA objects, which execute the logic of the applications, must be created by the application programmers. Synchronization among objects invoked within an application is left to the service, which is configured according to the synchronization requirements. These requirements must be specified at deployment time via the configuration files and may be changed at runtime via reconfiguration requests issued through the OrchestratorManager interface. Thus, CORBA objects remain independent from the synchronization service internals. It is the Clerk who instantiates these objects either at start time, for pre-configured objects, or at runtime, upon object addition, so their methods are available to be executed as soon as a trigger message is received. Currently, only static objects are supported, i.e., all objects are preloaded and ready for invocation. The FTT-Modeler eases configuration and monitoring operations by providing templates to integrate the CORBA objects in the service.

Within the scope of the applications, CORBA objects communicate among themselves directly. The FTT-CORBA service also allows orchestrating the communication of the distributed applications up to certain degree by separating the communication related code and putting it inside pseudo-tasks that are triggered by the Orchestrator at appropriate instants. Invocation chains of CORBA methods (transactions) may be also enforced by defining synchronization points with the invocation triggers distributed by the Orchestrator.

However, in CPU-bound applications, i.e., those in which the time spent communicating is much less than computing, it is generally acceptable to disregard communications. This is a valid assumption in many applications that use high speed communication links, like switched Ethernet, to transfer small amounts of data generated at relatively low rates.

Nevertheless, even when the communication is disregarded in this type of applications, there is always a small amount of code involved. These operations will be wrapped as CORBA methods, known as Communication Handlers that may be invoked by remote objects to obtain preprocessed data. For example, in Fig. 4
                         the Orchestrator activates CORBA object 2 which generates data that is consumed by CORBA object 1 upon its activation. Such communication handlers are considered for CPU scheduling purposes as aperiodic tasks, discussed below.

In real applications it is likely that certain segments of code need to be executed asynchronously in the distributed nodes with respect to the trigger messages, such as local alarm processing methods or communication handlers. These events will be managed directly by the local OS schedulers without control from the Orchestrator. In order to account for their presence in the schedulability analysis, a certain bandwidth is reserved for them at the nodes and it is assumed that such activities comply to a sporadic model with a known minimum interarrival time and their local priority is consistent with the schedulability test used. There is currently no protection against aperiodic activities that execute more or more often than declared or use inappropriate priorities. Such protection could be achieved, for example, by using adequate servers [54].

Changes in the initial Tasks Description Table can be carried out at runtime via the OrchestratorManager interface, described below. This interface provides operations to activate periodic tasks or perform reconfigurations that will be typically invoked by the system administrator, via a configuration and management tool, such as the FTT-Modeler, or directly by the distributed CORBA objects.

Dynamic reconfigurations must be applied at specific instants that ensure continued correct system operation. For this purpose, all requests for modifications at the Orchestrator's Tasks Description Table are referred to a reference task that indicates when such changes are to be committed. This reference task typically represents the start of an application cycle or sub-cycle. Thus, changes are committed in the same EC of the reference task next periodic activation and before the invocation of the Dispatcher so that it already accounts for them in that EC. Moreover, the offset parameter is specified relative to the reference task activation, which is internally converted to an appropriate absolute offset, transparently to the programmer.

Some DRTS require changing several tasks in an atomic way, for example linked to the control of a certain device. This is achieved by means of the tasks activation group concept, which allows synchronous activations, deactivations or parameter updates to be carried out atomically over a set of tasks.

The FTT-CORBA service must be initialized at start-time with certain service parameters. Some of them will not change during the application life-time such as the duration of the EC, the multicast address and the local priorities of both the Orchestrator and the Clerks. Information to invoke the CORBA objects by the Clerks must be also provided as well as an initial Tasks Description Table for the Orchestrator. This initial table may be then changed at runtime by using the OrchestratorManager interface.

A specific graphical configuration and management tool called FTT-Modeler 
                     [24] available at [50], assists in the deployment and run-time management of FTT-CORBA systems. This tool generates the initial configuration files for starting the service and it may also be used at run-time for monitoring and reconfiguration purposes.

An initial configuration, consisting of several files one for the Orchestrator and another for every Clerk in the system, must be prepared off-line and set-up at system deployment time.

The Orchestrator configuration file includes the duration of the EC in milliseconds, the UDP multicast address and port for the distribution of the trigger messages, the local priority at which the Orchestrator component will be executed on the local machine, the global scheduling policy (None/Only dispatching, FP, RMS, DMS, EDF) and the parameters of an initial set of tasks according to the task model described above.

As an example, Fig. 5
                         shows an initial configuration file for the Orchestrator in which the service triggers two tasks with the same period, 3 EC, but de-phased 2 EC by the Offset parameter. Both tasks will be executed in the same node, identified with Node_ID 1. Note that a specific amount of load is reserved at node 1 for both aperiodic operations and communication operations among CORBA objects (Server_Load).

The initial configuration files of the Clerks also include some parameters of the service such as the multicast address and port used to receive the trigger messages and the local priority at which every Clerk component executes. As explained, this priority must be higher than the priority at which CORBA objects are executed locally. Also, this file specifies the trigger messages a Clerk must listen to as well as information for invocation of the CORBA objects.


                        Fig. 6
                         shows an example of configuration file for a Clerk. It specifies the multicast address and port, the local priority of execution of the Clerk and the invocation parameters for two methods of the same CORBA object. Specific parameters for an invocation may be specified.

The Orchestrator provides a CORBA interface, the OrchestratorManager (Fig. 7
                        ), which may be invoked at runtime by the application CORBA objects or by an external monitoring tool, such as FTT-Modeler, to change (reconfigure) the Tasks Description Table parameters. Note that this interface is independent from the scheduling policy selected. These methods are grouped in three main categories:
                           
                              •
                              Reconfiguring one task: The operations addTask, removeTask and changeTaskParams are used to change the Tasks Description Table just for one task. These operations will be completed only after the admission test is satisfied otherwise, the change will not be carried out. One task, selected by the parameter refTaskID, will be used as reference for selecting the actual time instant (i.e. EC) in which changes will take effect.

Reconfiguring a group of tasks: Sometimes a set of tasks must be changed in an atomic way (e.g. linked to a specific functionality or transaction). This is achieved with the concept of group of tasks, which allows changing the Tasks Description Table consistently. Several methods allow programmers to create and manage groups (createGroup, removeGroup, addTaskToGroup, removeTaskFromGroup, changeTaskInGroup). Moreover, the activateGroup method enforces the changes after checking that the admission test is satisfied for the whole group. One task, selected by the parameter refTaskID, will be used as reference for selecting the actual time instant (i.e. EC) in which changes will take effect. Similarly, a group of tasks may be deactivated in the Orchestrator table in an atomic way by using the deactivateGroup method.

Modifying the reserved load: As described in Section 3.7 the OrchestratorManager interface also allows programmers to manage the amount of load reserved for aperiodic tasks by using the reserveServerLoad service.

The service requires a fast admission control test in order to allow runtime reconfigurations of the Tasks Description Table with low latency. This test will depend on the scheduling policy considered by the Orchestrator. For example, utilization-based tests for rate-monotonic or earliest deadline first scheduling can be readily implemented considering the load per node independently.

The numbers in circles in Fig. 3 describe the process for inclusion of a task or group of tasks upon a reconfiguration request (via the addTask or activateGroup primitives of the OrchestratorManager interface):
                           
                              1.
                              An admission test is executed for the requirements of the task (or group of tasks). If the test is passed, changes are accepted and inserted in the Task Description Table at the right moment according to the reference task phase, otherwise changes are rejected and a notification is returned to the requester. This stage requires a model of the system resources as proposed in [25].

The scheduler uses the new Task Description Table to recalculate the Execution Plan according to the scheduling policy used.

The Dispatcher enforces the new Execution Plan by triggering the distributed operations by means of a trigger message delivered to the nodes.

Clerks receive the trigger messages and invoke the CORBA objects accordingly, following the new Execution Plan enforced by the scheduler. If necessary, the Clerk may change the local priorities at which these objects execute according to the priority values recalculated by the scheduler.

The current implementation of the service, downloadable from [50], is based on ACE [27] and TAO [28]. ACE is an open-source object-oriented framework that abstracts the OS/machine specific features. It provides common data types and methods to access the powerful but complex features of most widespread OS such as QNX, VxWorks, Linux or Windows. In particular, ACE was used to access the underlying OS mechanisms such as threads, multicast sockets and exceptions with the only exception of the internal clock of the Orchestrator, since the direct use of the OS services provided higher resolution and lower jitter.

The TAO ORB has been used to implement CORBA capabilities. TAO, which was built on top of ACE, is an open-source CORBA 3.0 compliant ORB for C++ that includes most features and services of the specification. This choice was based on the fact that TAO is a mature, high-performance, freely available and open source ORB that has been successfully used in a great number of applications [55]. The implementation of the service also requires using the dynamic invocation interface (DII) from the Clerks to invoke the CORBA objects in which the functionality of the application resides.

As a consequence of this choice the service is compatible with all OS platforms for which ACE TAO has been ported to. The service was tested over a general purpose OS, namely standard Linux (without RT characteristics) and an RTOS, namely QNX. The next section describes the results obtained concerning temporal behavior. It is convenient to remark that although the service internals have been implemented over ACE and TAO, due to the multivendor philosophy of CORBA, its use is not restricted to a specific ORB vendor but objects that use any CORBA product may be invoked.

The following subsections describe the implementation details over ACE TAO, focusing on the different architecture components.

As referred before, the operational information of the distributed activities is kept by the Orchestrator in two tables (Tasks Description Table and Execution Plan) as well as in a set of variables that represent the current load of every resource of the DRTS according to [25]. Structures to support this information are created at start-time using the Orchestrator configuration file as input and may be updated at runtime by the CORBA objects through the OrchestratorManager interface described above.

Trigger messages are distributed using UDP multicast datagrams according to the information in the Execution Plan. Each message contains the list of the active tasks to be triggered during the current EC. This approach presents several advantages such as improving the synchronization accuracy when compared with a logical multicast model based on the distribution of a sequence of unicast TCP packets.

Additionally, the Orchestrator executes a CORBA object which implements the OrchestratorManager interface. The OrchestatorManager is registered within the CORBA Naming Service to make it accessible. Thus, CORBA clients will be able to use this interface to reconfigure the Tasks Description Table if necessary.

Finally, since the Orchestrator synchronizes the distributed nodes of the application by means of trigger events, the precision of its internal clock has a direct impact on the precision of the global timing. As a result, the quality of the service in terms of jitter will be determined by the quality of this clock which, in turn, depends on the underlying OS.

Clerks are implemented as a process that is permanently listening to the Orchestrator's trigger messages. They will react to the trigger messages that match the CORBA object identifiers found at their configuration file. This file contains the name of the CORBA objects to be invoked as well as their method names and invocation parameters when necessary. This information is used to build a CORBA invocation to the object by using the dynamic invocation interface (DII). The use of DII provides a higher degree of flexibility, since Clerks do not need to be recompiled to access different CORBA objects. Actually, they can invoke any objects by using only their name, methods and parameters. This characteristic simplifies the usage and implementation of the service. The CORBA Naming Service is also used to locate the references of the CORBA objects.

CORBA objects are the containers of the distributed application code. It is important to point out that for the users of FTT-CORBA both the Orchestrator and the Clerks remain black box entities. According to the philosophy of CORBA, users may build applications with objects written in different programming languages, executed over different OS, mixing different CORBA distributions. CORBA objects are only invoked either by a local Clerk or by another CORBA object in order to exchange data.

In the current version and in order to reduce the instantiation time of the CORBA objects, these are instantiated only once upon their creation at start-time as explained before. Thus, CORBA methods are ready to be executed immediately when a trigger is received. For each CORBA object, the Clerk spawns a process that will execute it with the initial priority values specified in the Clerk configuration file. These priority values may be changed at runtime according to the Scheduling policy executed by the Orchestrator, which is encoded in the trigger message delivered to the nodes.

This section analyzes the performance of the current FTT-CORBA implementation on low end hardware in several scenarios that mix different OS. This evaluation complements the results obtained for Linux in previous works [21,22]. All tests were carried out over five equal computers with Pentium II 350MHz processors and 256MB RAM memory. They were connected with an isolated 100Mbit/s switched Ethernet. This choice allowed testing the applicability of the service to systems using devices with relatively limited computing capabilities. All tests were carried out with the 1.6a version of TAO provided by OCI [56]. Regarding the OS platforms we used the Debian 4.0 Etch Linux distribution with kernel 2.6.18 as general purpose OS and QNX Neutrino version 6.3 SP3 as an RTOS.

In particular, the following tests were carried out: (1) a reference test to measure the invocation jitter of the CORBA object with QNX, (2) another test to measure the invocation latency of a remote CORBA object, (3) a test for synchronizing the access to a shared resource in an heterogeneous environment and (4) a test to measure the interference of unmanaged TCP traffic in the worst-case delivery time of the FTT-CORBA trigger messages.

This test is aimed at measuring the invocation jitter of a remote periodic task in a simplified setup to serve as reference for comparing the service performance in more complex scenarios. In this case, only two computers were used, one running the Orchestrator and another running both a Clerk and a CORBA object. The Orchestrator and Clerk were executed with the highest priorities by their local OS. Then, at runtime, both the Orchestrator and the CORBA object took local timestamps of all invocation instants, in order to observe the inter-invocation intervals. Fig. 8
                         shows the layout of this test.

In this case, the EC of the service was set at 5ms. The OS tick for the node with the Orchestrator was set at 1ms. Typically, in a tick based OS like QNX a substantial increase in precision is achieved when the EC is set to an integer multiple of the OS tick. Otherwise, the OS would try to meet the EC duration on average, automatically, using a varying number of OS ticks, thus causing high jitter. Regarding the end node, the resolution was set at a very low value: 200μs. This choice causes a substantial computing overhead in the end node but reduces the OS latency to handle the reception of the trigger messages, also reducing the invocation jitter. Such low values were chosen to measure the limits of the service in a favorable scenario. However, the applications to which the service is oriented typically use higher values for both the EC and OS tick.

The test was carried out for 120,000 ECs of 5ms corresponding to 10min. We measured the jitter introduced by the Orchestrator, which remained under a very low value, namely +/−260ns. Thus, the authors concluded that all the remaining jitter detected in the CORBA object invocations were introduced by the network and the end node.

The worst-case object invocation jitter detected in the CORBA object was below +/−400μs. This value corresponds to two OS ticks at the end node (200μs). Note that the tick is the resolution achievable when measuring time intervals with a tick based OS like QNX in which the tick determines when the interrupts are handled. Thus the invocation of an object may require up to two ticks, one for the trigger message and another for the local invocation of the CORBA object. Anyway, the tick period must be selected carefully because of the OS computing overhead it implies, which may affect negatively the performance of the end node.

This test evaluates the invocation latency introduced by the service in the experimental layout. The actual latency measurement depends on the hardware platform used. However, the data obtained using a setup with limited resources is a good indicator of the minimum performance of the service.


                        Fig. 9
                         shows the layout used to measure the latency of the service. This test required small modifications in the source code of the Orchestrator in order to invoke an external CORBA target whose clock was used to measure the latency of the service. The Orchestrator invoked this object every EC immediately before sending the multicast trigger to the Clerk. In turn, the CORBA object invoked locally by the Clerk invoked the same CORBA target, too, in the beginning of its execution. Fig. 10
                         explains the sequence of the test. Assuming that the CORBA target invocation latency is similar when it is invoked by the Orchestrator or by the CORBA object, we obtain two consistent timestamps in the CORBA target, t1 and t2 that bound the service invocation latency, i.e., the time to send the trigger message, to run the Clerk and to invoke the application object. Thus, the latency of the service can be approximated by ∆ as determined by expression (1):
                           
                              (1)
                              
                                 
                                    Δ
                                    =
                                    
                                       t
                                       2
                                    
                                    −
                                    
                                       t
                                       1
                                    
                                    .
                                 
                              
                           
                        
                     

Every invocation sent a sequence number that allowed detecting possible invocation losses or order inversions but none of these phenomena occurred during the experiment. The remaining operational parameters were set up as depicted in Fig. 9. The experiment was repeated for several EC durations.

The test results showed that the average latency introduced by the service remains quite steady, at approximately 1.3ms in this setup, even for an EC duration as low as 5ms and up to 50ms.

One of the objectives of the service is to minimize latencies in the access to shared resources. Fig. 11
                         shows a simple scenario in which the Orchestrator invokes in turn several CORBA objects that access a shared resource, namely a CORBA target object resident in a separate CPU. A heterogeneous setup is used, involving nodes with different OS, namely QNX and Linux. Fig. 11 also shows a timeline for the activations of the shared resource and the respective invocator. The EC of the service was configured at 20ms. The invocation periods were set to 2 and 4 ECs, i.e., 40 and 80ms, respectively, and were de-phased in order to avoid using a local queue to resolve the access to the resource. This method provides a simple and deterministic way of accessing a shared resource while minimizing the average access latency.


                        Fig. 12
                         shows the CORBA object inter-invocation intervals measured in one of the Linux nodes. The jitter was in average below +/−100μs with occasional variations of +/−400μs. Note that such a low jitter was achieved due to using an EC that was an integer multiple of the OS clock resolution set to 4ms, and to the fact that no other CORBA objects with higher priority were running in the node.


                        Fig. 13
                         shows the inter-invocation intervals in the CORBA target, which are alternately, invoked every EC by one node executing QNX and one of the nodes executing Linux (Fig. 11). Different OS produce different invocation latencies yielding two bands in the plot of Fig. 13, namely at +/−300μs and +/−450μs. The largest variations detected were of +/−600μs. Note that the resolution of these measurements is 150μs which is the tick period of QNX in the node running the CORBA target. This experiment was carried out for 30,000 ECs lasting 10min.

This test analyzes the interference of unmanaged TCP traffic in the worst case delivery time of the FTT-CORBA trigger messages. This is relevant as we are not currently managing network traffic directly and we expect this traffic to impact directly on the latency of trigger messages as the traffic is not synchronized with them.

In this test the Orchestrator activates periodically, every 10ms, a CORBA object via its local Clerk. This test involves two additional CORBA objects which are not controlled by FTT-CORBA, one for sending a configurable size data block and another for receiving it. The object that receives the data executes concurrently at the same node as the Clerk and the FTT-CORBA activated object, but at a lower priority. Thus, the trigger messages and unmanaged traffic share the same network link. Moreover, such node runs QNX with an OS tick of 250μs. The sender object executes in a different node. The test was performed for different data block sizes.


                        Table 1
                         shows the results of the worst-case jitter affecting the invocations of the FTT-CORBA object. Comparing these results with the ones of the previous experiments, which were interference-free, we see that the impact of low unmanaged traffic is rather low and the jitter remains under 750μs up to 7.2Mbps with blocks of 9kB. Whether such interference is acceptable or not clearly depends on the specific application but we would conjecture that for practical cases with EC durations of 20ms or higher, a maximum invocation jitter of 2ms would be acceptable, meaning that the unmanaged traffic load could be as high as 21.6Mbps with blocks of 27kB in a 100 Mbps Ethernet link.

This section illustrates the use of FTT-CORBA in a hypothetical application that requires synchronization and reconfiguration at runtime. This case study presents a simplified welding process in which several robots are involved. Note that industrial devices such as robots, PLCs and CNCs are increasingly adopting open platforms based on RTOS like RT-Linux, QNX or VxWorks, or real-time adaptations of general purpose OS such as Windows or Linux. These platforms are capable of executing CORBA and consequently are potential candidates to benefit from the service [57]. A good example of this trend is the interesting initiative of the OROCOS project [58] which has adopted CORBA as communication middleware for heterogeneous environments.

A set of four robots (Welding Robots 1–4 in Fig. 14
                        ) are involved in the welding application proposed in this case study. Two additional robots (Robots 5 and 6) are used for feeding the process and removing the processed parts. Finally, a camera is attached to a node. It carries out three main tasks: (1) image processing aimed at calculating the exact position of the part in the operation area and determining the trajectory of the welding robots (2) quality control of the welding process after its finalization and (3) computation of statistics and logging of the welding operation. In order to improve fault-tolerance, every welding trajectory must be feasible by at least three of the welding robots yielding several working configurations. However, one requirement of the process is that the welding trajectory must be done simultaneously in pairs of welding robots. According to several reasons such as variations in the production needs or due to maintenance tasks at the robots, the production rate and the number of welding robots involved in the process may vary. These changes produce reconfigurations that must be allowed at runtime and bounded in time. Some tasks such as obtaining statistics of the parts produced or logging of the welding operation do not need to be synchronized, so may be executed at lower local priorities.

The welding process of one part is divided in several subtasks that execute in different nodes. Roughly, this process is as follows: (1) Robot 5 takes one part to the operation area (2) The welding robots move close to the welding point (3) The image processor node determines the actual position of the part and sends a message with the trajectory each welding robot must follow (4) Welding is done (5) The image processing node checks whether the part has been correctly welded (6) Robot 6 removes the part taking it to different places depending on whether the quality tests were passed or not.

The service proposed in this paper is well suited to a case like the one presented above in which different periodic activities have to be synchronized accurately. In fact, the time-triggered nature of the service allows optimizing the performance of the overall application improving the synchronization of the operations in a simple way, while the centralization of the synchronization information allows prompt on-line reconfigurations as well as the separation between the application code and the synchronization information promoting a separation of concerns.

All devices, robots and camera, are connected via an Ethernet switched network (Fig. 14). Every device provides a CORBA interface with the operations that the device can carry out during the process. The configuration of the application requires setting up the configuration files for the Orchestrator and one clerk per device. This section describes the main steps to complete these files.

The configuration of the Orchestrator requires setting up several parameters such as the multicast IP address and port, its local priority, the duration of the EC (in this case a value of 100ms provides an adequate degree of granularity) and the information of the tasks to build initially the Tasks Description Table. This information includes the following parameters per task: period, offset, priority, node id and maximum task load. In this case, the Orchestrator will act as a Dispatcher only (without scheduling) and the priority of the tasks will not change. These parameters are shown in Table 2
                        .

Once the initial configuration is deployed the welding application runs according to the timeline in Fig. 15
                        . At a certain point a reconfiguration is issued so the process must follow with just two robots. Diverse causes may produce a reconfiguration like this such as a fault in one of the robots, a change of design in the welded part, maintenance at the robots or just a change in the production rate.

When so happens, the node that requires the reconfiguration, which may be one of the robots, the image processing node, or an external user via an HMI (Human Machine Interface) produces new configuration parameters that must be entered in the Tasks Description Table using the OrchestratorInterface methods described above, specifically, addTaskToGroup and activateGroup, setting the task parameters described in Table 3
                        .


                        Fig. 15 shows the timeline of the welding process for the first 70s, during which a reconfiguration takes place at time=36s. Until then, two parts were welded with the four welding robots. However, after reconfiguration, the dispatching plan must be adapted to a new scenario in which only two robots are involved for a longer time than before. Fig. 15 also shows the statistics task (task 8), which is a lower priority task, being preempted by other tasks of higher priority that require synchronization.

Note that the code of the operations that compose this application is synchronization agnostic, being the synchronization information kept by the Orchestrator in the Tasks Description Table. Other applications could be easily developed with the same CORBA objects just by using them in a different timeline.

@&#CONCLUSIONS AND FUTURE WORK@&#

This work presents a flexible-time-triggered service for CORBA applications, named FTT-CORBA. Following the CORBA philosophy, the service complements the CORBA standard [7] facilitating the development of applications that require dealing with synchronous operations in a flexible way. However, the service goes beyond since it also allows the creation of applications by sequences of tasks wrapped as standard CORBA objects. More specifically, the service, which is aimed at medium and small scale DRTS connected via multicast capable LANs, such as Ethernet or WiFi, orchestrates the invocation of CORBA objects in a global synchronous framework. However, as opposed to other previous synchronous approaches to system design, the FTT-CORBA service supports on-line changes to the synchronization parameters and system re-composition with low and limited latency. Thus, the service assists programmers in the creation of synchronous, yet flexible, applications that are required to adapt to changing requirements. The proposed service also promotes a separation of concerns between the functionality of the application code, wrapped as CORBA objects, and its synchronization, provided by the FTT-CORBA service. In addition, the proposed service architecture is open to different scheduling policies for managing the tasks of the distributed system.

A preliminary version of the service, available in [50], was tested using relatively low end computing nodes on a general purpose OS (Linux), an RTOS (QNX) and in heterogeneous environments. These tests showed an acceptable performance in terms of activation latencies and jitter. In particular, we observed that, despite the complexity of the software/communications stack, remote objects could be invoked with a jitter below 400μs on low end hardware, in interference-free situations. Finally, one case study illustrated the use of the proposed FTT service.

As future work the authors plan to focus on the global scheduling of the DRTS addressing both the schedulability analysis adequate for prompt runtime reconfigurations as well as the extension of the scheduling model to include other resources such as the network, battery and memory. Moreover, we will also consider the replication of the Orchestrator for fault-tolerance purposes following the ideas in [59].

@&#ACKNOWLEDGMENTS@&#

This work has been supported in part by the ARTEMIS JU through the CRAFTERS project (grant no. 295371), by the Spanish Ministry of Economy and Competitiveness (MINECO) under project DPI2012-37806-C02-01 and by the University of the Basque Country (UPV/EHU) through grants EHU13/42 and UFI11/28.

@&#REFERENCES@&#

