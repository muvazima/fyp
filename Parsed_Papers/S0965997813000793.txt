@&#MAIN-TITLE@&#Pareto process optimization of product development project using bi-objective hybrid genetic algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We develop four types of time model for computing project duration.


                        
                        
                           
                           We embed Pareto genetic algorithm with variable neighborhood search strategy.


                        
                        
                           
                           We propose three VNSs combing of process optimization specific knowledge.


                        
                        
                           
                           The results show that PGVNS can obtain a better Pareto solution than NSGA-II.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Product development process

Process optimization

Hybrid genetic algorithm

Variable neighborhood search

CD-DSM

Pareto solutions

@&#ABSTRACT@&#


               
               
                  Overlapping and iteration between development activities are the main reasons to cause complexity in product development (PD) process. Overlapping may not only reduce duration of a project but also create rework risk, while iteration increases the project duration and cost. In order to balance the duration and cost, this article presents four types of time models from the angle of time overlapping and activities dependent relationships based on Collaboration Degree Design Structure Matrix (CD-DSM) and builds the cost model considering the negation cost. On basis of the formulated model, a hybridization of the Pareto genetic algorithm (PGA) and variable neighborhood search (VNS) algorithm is proposed to solve the bi-objective process optimization problem of PD project for reducing the project duration and cost. The VNS strategy is implemented after the genetic operation of crossover and mutation to improve the exploitation ability of the algorithm. And then, an industrial example, a LED module PD project in an optoelectronic enterprise, is provided to illustrate the utility of the proposed approach. The optimization model minimizes the project duration and cost associated with overlapping and iteration and yields a Pareto optimal solution of project activity sequence for project managers to make decision following different business purposes. The simulation results of two different problems show that the proposed approach has a good convergence and robustness.
               
            

@&#INTRODUCTION@&#

As competitive pressure increases and time to market compresses, companies are outsourcing some design activities to more professional organizations and paying more attentions to core design activities for shortening the cycle time of PD process. At the same time, development activities of complex products are increasingly undertaken by multidisciplinary team members from geographically distributed departments in a virtual and collaborative environment [1]. And modern product structure is increasingly complex and PD process presents the trend of integrating, networking and distribution [2]. Thus, PD process will be more strongly time-oriented and collaborative, while still focusing on cost and quality. As a result, how to better manage and enhance PD processes to cater for various customer requirements becomes a core issue for each single manufacturing enterprise.

The PD process can be regarded as an organized group of related design activities involving project initiation, task assignment, product design, process design, etc. Traditionally centralized and sequential product design, planning and scheduling activities are inadequate to respond to the dynamic variations in new PD cycles [3]. Iteration and overlapping of design activities are the fundamental characteristics of complex PD process [4]. Iteration usually leads to rework risk [5], while overlapping activities usually impact project duration. Iteration implies redoing or revising the related design results, which makes the PD process more complex due to the coupled and intermixed activities. Overlapping involves the concurrent execution of two successive activities and allows the second activity to begin before the first one is finished. Overlapping activities also increase communication and excessive information exchange [6]. It is well known that good collaborative and concurrent performance can help to achieve shortened project duration and reduced costs. However, the downstream activity has to iterate to accommodate changes throughout the iteration process, which will lead to additional time at a small amount of rework cost. In this way, the activity sequence of PD determines the development cycle time and cost to certain extent. In addition, overlapping between activities is a good strategy to reduce total project duration. However, the development cost is added because of reworks of downstream activity caused by overlapping with dependent upstream one. Therefore, how to optimize the PD process to reduce the rework delay time and added cost of development activities and improve its concurrent and collaborative capability amongst distributed cooperative members is an important issue. Consequently, an analytical and optimal model of the trade-off between the total project duration impacted by iteration and overlapping and the total development cost is needed in PD.

The remainder of this paper is organized as follows. The next section reviews the relevant literature related to process optimization of PD. The problem description and mathematic model of process optimization of PD are developed in Section 3. Section 4 details the proposed hybridization of PGA with VNS to approximate the Pareto optimal solutions. An application case of a LED module development process in an optoelectronic enterprise is demonstrated in Section 5 and conclusions are given in Section 6.

@&#LITERATURE REVIEW@&#

Process model is the set of tasks and the related information flow between them that sum to produce the final product [7]. Structuring the PD process is essential for scheduling the PD activities to execute effectively, and thus reducing iteration and rework times. Much research has been done about time-computing, cost-computing and process improving approaches to the PD process. Generally, two problems need to be solved to optimize PD process. One is focused on how to construct the mathematical model of PD process optimization problems. The other one is on how to apply intelligent algorithms to achieve the optimal solution of the process model.

Research effort has been made towards developing process model and applying it to engineering problems over the last two decades. Minimum cycle time and cost are two common objectives targeting in the optimization of PD process. Concurrent engineering is one of the prominent tools often employed to reduce PD time. The advantages of concurrent engineering surrounding the task of speeding and improving the PD cycle were discussed in [8,9]. Moatari Kazerouni et al. [10] investigated the success criteria during different phases of the product lifecycle. The outcomes showed that managers do perceive the success of new PD differently depending on the perspective. Tatikonda and Rosenthal [11] enumerated the technological novelty, the magnitude of the design tasks, the interactions between the design tasks in the new PD project, and the balancing between projects as being the most important causes leading to project delays. Therefore, some methods were proposed to estimate the development time. Ahmadi et al. [12] formulated the structuring PD process as an integer program, presented two Markov models for estimating the total development time, and developed several procedures to minimize iterations during the development process which adversely affect development time and costs. Jun et al. [13]provided a heuristic algorithm that can estimate the lead time of a complex PD process by series-parallel network transformation and network reduction methods with estimates of the makespans of branch–merge types. Dragut and Bertrand [14] developed a mathematical model based on queuing theory concepts for the solving-time distribution of design tasks for new PD accounting for both structural design tasks technological uncertainties and human factor characteristics for the first time. Yan et al. [15] modeled the time characteristics in the concurrent development process and set up a time-computing model involving rework probability, and design time of uncoupled and coupled activities to estimate the rework cost and completion time of each of the activities.

Cost management is another factor for the success of PD project. Activities may have uncertain cost and duration, rework caused by changes in particular inputs, and reduced cost and duration in successive iterations [5]. Moreover, the cost of a product design will be strongly influenced by the correctness and accuracy of the product definition. A correct understanding of customer’s requirements and a clear product definition will obviously result in a quick and cheap PD [16]. As thus, PD cost can be treated deterministically or purely as a function of process parameters such as process duration, activity rework rate and process changes. Various mathematical models of development process have been developed to study the cost modeling of PD process so far. Broadly, a PD cost consisting of product definition, design and sample production cost. In terms of the complexity of iteration and rework, some researchers ignored the information exchange cost between development teams throughout the PD process. For example, Shehab and Abdalla [17] estimated the manufacturing cost modeling of a product at the conceptual design stage of the product life cycle and the estimated cost included material, processing, machine set-up and non-productive costs. Yang et al. [18] proposed evolution and sensitivity design structure matrix to present the schedule and cost model associated with iteration, overlapping, and rework. Of course, communication cost was also discussed as the one item of PD cost in building the cost function [19]. In addition, Time-cost tradeoffs were also the focus in some existing literature [19,20]. Savin and Terwiesch [21] modeled the trade-off between the lost revenues resulting from a delayed launch and the lower unit-production costs. The results showed that a firm facing a launch time delay from a competing product might benefit from accelerating its own product launch, as opposed to using the softened competitive situation to further improve its cost position.

Another attention need to be focused on the various methods to optimize the PD process models. The common methods for PD process optimization can be categorized as: (1) Applying intelligent optimization algorithms. Meysam Mousavi et al. [22] presented a new model integrating the support vector regression (SVR) and the imperialist competitive algorithm (ICA) for time estimation in new PD projects. Tyagi et al. [23] estimated simultaneously the optimal amount of overlapping and communication to minimize PD lead time and cost for the entire PD process adopting the fuzzy goal programming-based approach, and then, proposed a novel approach of Gaussian Adaptive Particle Swarm Optimization (GA-PSO) to optimize the formulated objective function. Meier et al. [24] investigated the use of a competent GA: the ordering messy GA (OmeGA) for the information flow models of PD process to cope with the SGA deficiency. Tests confirmed the superiority of the OmeGA over a SGA for hard DSM problems. (2) Simulation-based method. For example, Abdelsalam and Bao [25] presented a simulation-based optimization framework that determines the optimal sequence of activities execution within a product DP that minimizes project total iterative time given stochastic activity durations. Yang and Lü [26] developed a discrete-event simulation algorithm for DSM to estimate the probability distribution of duration and cost so as to evaluate risk. Li et al. [27] proposed a process simulation based method to select the most economic propagation path for each design change, which can reduce the total process time for changes occurring in the complex PD process. Kang and Hong [28] adopted simulation-based method to evaluate the acceleration effect of dynamic sequencing of design process in a multi-project environment by introducing the factor of waiting time to model the design delays. Wang et al. [29] realized human-centered simulation of PD process based on multi-agent modeling principle considering the process evaluation indices, planning deviation rate, process risk, and design error level.

Significant research efforts in the modeling of PD process and development of optimization approaches have been made. However, few studies have been focused on obtaining the Pareto optimal solution of PD process. Thus, our work is different from the aforesaid works in two major aspects. First, this paper simultaneously establish the time characteristic model considering of overlapping and iteration in order to simultaneously minimize PD project duration and cost. Additionally, the novel approach of hybridization of PGA with VNS is proposed to optimize the formulated objective function (i.e., project duration and cost), which are incommensurate in nature. In this way, Pareto solution of PD process can be provided for project managers to manage and coordinate different activities.

DSM can visually represent the information workflow and network of interactions among development activities in modeling PD process. DSM has very strong computing ability for representing and analyzing interaction relations among system elements [30,31]. It is suitable for engineers to analyze and optimize the complex PD process to reduce the information feedback between activities by providing a clear view of the interdependencies between its tasks. In terms of the iteration and overlapping in complex PD process, a activity decomposition method based on information input/output points is introduced in [2]. As a result, the atomic coupled activities have only once information input and output during each rework. And collaborative degree design structure matrix (CD-DSM) was established to describe the relationship of those atomic activities. Therefore, in this paper, we will employ CD-DSM as the analysis tool to establish the time and cost model of PD process.

DSM being a modeling and analyzing tool can express the interdependencies between activities of PD. In the Numeric DSM, tasks or activities are listed in the first row and the first column of the matrix. Off-diagonal cells indicate the interactions of tasks. Element values below the diagonal represent forward information transfer which affects the later activities. Element values above the diagonal represent information feedback or iteration. On the basis of DSM, the authors proposed CD-DSM and developed the transferred relationship from DSM to CD-DSM in [2]. It shows the collaboration degree between any two atomic activities in the cell grid of DSM. In this way, the CD-DSM is constructed, and shown in formula (1). As an example, a DSM of six activities is expressed in a CD-DSM shown in Fig. 1
                        .
                           
                              (1)
                              
                                 
                                    
                                       M
                                    
                                    
                                       nxn
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            11
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            12
                                                         
                                                      
                                                   
                                                   
                                                      ⋯
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            1
                                                            n
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            21
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            22
                                                         
                                                      
                                                   
                                                   
                                                      ⋯
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            2
                                                            n
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      ⋮
                                                   
                                                   
                                                      ⋮
                                                   
                                                   
                                                      ⋱
                                                   
                                                   
                                                      ⋮
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            n
                                                            1
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            n
                                                            2
                                                         
                                                      
                                                   
                                                   
                                                      ⋯
                                                   
                                                   
                                                      
                                                         
                                                            acd
                                                         
                                                         
                                                            nn
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       nxn
                                    
                                 
                              
                           
                        
                     

Before formulating a mathematical model of the optimization problem, we define the notation in Table 1
                         used throughout the remainder of this paper.

In this section, we establish models to reconstruct the PD process in certain controllable development risk. There exists no resource shortage during the PD process. Taking inspiration from relevant literature [12,15,23], a mathematical formulation is developed for PD time and cost. And other factors such as precedence of activities, due date and development risk are considered as constrains of the model.

There are many development stages involved in the PD process, and at the same time plenty of activities are existed in each stage. A certain amount of information is shared by some or all activities once an activity has performed its functionality and generated output information. Therefore, the relationships amongst activities present important position in calculating the development time of the whole process. Three types of activity dependence classified in greater detail by Kusiak and Larson [32] are independent parallel, dependent sequential and interdependent coupled relationship from the angle of information dependence. And activities with parallel relationship must exist sequential or coupled relationships with other activities, so it can be overlooked here. In addition, there also exist overlaps between development activities from the view of time dependence. As a result, four types of time model of PD process are deduced shown in Fig. 2
                           , including sequential and non-overlapped, sequential and overlapped, coupled and non-overlapped and coupled and overlapped types.

In order to calculate the project duration of whole PD process, it is assumed that there are N activities in the development process and that the nominal duration for each activity is Ti
                            working days. Activities are executed sequentially with no interaction in the sequential and non-overlapped pattern. Therefore, total PD time in the case of the sequential and non-overlapped pattern is the duration accumulation of each activity shown as follows:
                              
                                 (2)
                                 
                                    T
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                        

The overlapping enables early information sharing of the downstream activity, which facilitates acceleration of the completion time of activities. However, it may delay the execution time of the downstream activity when the preliminary information of the upstream turns out to be false and misleading [33]. When there exists overlapping in sequential pattern, i.e., sequential and overlapped one, rework of downstream activity is probably generated due to the rudimentary information from upstream activity and it is continuously updated until the upstream activity finishes. It is generally known that reworks of downstream activity caused by overlapping with dependent upstream one generate extra rework time of downstream activity. Moreover, there exists only once rework of downstream activity due to once information input/output in two dependent activities. The longer the overlapping interval 
                              
                                 
                                    
                                       T
                                    
                                    
                                       ij
                                    
                                    
                                       o
                                    
                                 
                                 /
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           , the greater the rework probability is. The coefficient λ is introduced for the complex product or unskillful designers as project technology index. And then, the rework is related to aij
                            describing the dependence of information in the CD-DSM. Without loss of generality, the rework time of downstream activity can be formulated as follows:
                              
                                 (3)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          ij
                                       
                                       
                                          ro
                                       
                                    
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          ij
                                       
                                    
                                    
                                       
                                          (
                                          
                                             
                                                T
                                             
                                             
                                                ij
                                             
                                             
                                                o
                                             
                                          
                                          /
                                          
                                             
                                                T
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       
                                          λ
                                       
                                    
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        

Coupled activities are the main reasons to cause iteration and collaboration in PD. In order to formulate the rework probability, a coupled factor 
                              
                                 
                                    
                                       e
                                    
                                    
                                       -
                                       
                                          
                                             a
                                          
                                          
                                             ji
                                          
                                       
                                       /
                                       
                                          
                                             a
                                          
                                          
                                             ij
                                          
                                       
                                    
                                 
                              
                            is introduced to express the coupled relationship. In terms of the relationship aij
                           
                           +
                           aji
                           
                           =1 in CD-DSM, when aij
                            limits to zero, coupled factor converges to zero, while it limits to 1, coupled factor converges to 1. This expresses weak and strong coupling conditions. In addition, learning effect caused by repetitive operation is an important characteristic within the iterative process. And design engineers can apply the accumulated experience, knowledge, and skills to the testing and analysis, which reduces the execution time of an iterated design activity. Therefore, the learning effect is considered during establishing the time model of coupled pattern including non-overlapped and overlapped. In this way, the rework time will be reduced throughout the self-study and self-adaptive iteration process. Then, a learning function e
                           −
                           
                              θk
                            is introduced to model the improvement curve according to [12,15], where 0<
                           e
                           −
                           
                              θk
                           
                           <1, θ is the improvement curve parameter of in each iteration and k is the iteration number. A larger θ results in a faster learning process. So the rework time function due to coupling can be expressed as
                              
                                 (4)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          ij
                                       
                                       
                                          rc
                                       
                                    
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          ij
                                       
                                    
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          
                                             
                                                a
                                             
                                             
                                                ji
                                             
                                          
                                          /
                                          
                                             
                                                a
                                             
                                             
                                                ij
                                             
                                          
                                       
                                    
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          θ
                                          k
                                       
                                    
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          ij
                                       
                                    
                                    
                                       
                                          e
                                       
                                       
                                          (
                                          1
                                          -
                                          1
                                          /
                                          
                                             
                                                a
                                             
                                             
                                                ij
                                             
                                          
                                          )
                                       
                                    
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          θ
                                          k
                                       
                                    
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        

There exist couples and overlaps in the coupled and overlapped pattern. And a portion of downstream activity is executed in parallel to upstream activity on the basis of the output information in each iteration process. The coupled and overlapped factors are discussed in the above. So in order to integrate these two parts, a coupled parameter β, 0<
                           β
                           ⩽1, is introduced to model the time characteristic in the coupled and overlapped pattern. Hence, the rework time function due to overlapping and coupling can be modeled as
                              
                                 (5)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          ijk
                                       
                                       
                                          roc
                                       
                                    
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          ij
                                       
                                    
                                    β
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          θ
                                          k
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         o
                                                      
                                                   
                                                   /
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                
                                                   λ
                                                
                                             
                                             +
                                             
                                                
                                                   e
                                                
                                                
                                                   (
                                                   1
                                                   -
                                                   1
                                                   /
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         ij
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        

Moreover, the iteration number is another important parameter affecting the cycle time of PD process. Given a small enough threshold value, it can be determined by the following,
                              
                                 (6)
                                 
                                    |
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          θ
                                          k
                                       
                                    
                                    -
                                    
                                       
                                          e
                                       
                                       
                                          -
                                          θ
                                          (
                                          k
                                          -
                                          1
                                          )
                                       
                                    
                                    |
                                    ⩽
                                    ε
                                 
                              
                           
                        

At each rework, updated information is transferred to the downstream. Interpreting and comprehending those information changes cause a delay which is called negotiation time. Therefore, total PD time in terms of the four patterns can be expressed as the maximum accumulation of start time, duration, rework time and negotiation time of each activity shown as follows:
                              
                                 (7)
                                 
                                    T
                                    =
                                    
                                       
                                          
                                             max
                                          
                                          
                                             1
                                             ⩽
                                             i
                                             ⩽
                                             N
                                          
                                       
                                    
                                    (
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          s
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          ro
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          rc
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          rco
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          c
                                       
                                    
                                    )
                                 
                              
                           
                        

Another optimized objective, i.e. PD cost, associated with PD process performance is estimated in this section. PD cost is the collection of the following several constituents, which include actual working cost, rework cost, negotiation cost and risk cost. Due to the difficulty of describing risk, herein we only consider that risk is caused by the late time-to-market. Thus, this formulation incorporates different types of costs can be shown in the following.
                              
                                 (8)
                                 
                                    C
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                       
                                          r
                                       
                                    
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          n
                                       
                                    
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          R
                                       
                                       
                                          c
                                       
                                    
                                    (
                                    T
                                    -
                                    
                                       
                                          T
                                       
                                       
                                          d
                                       
                                    
                                    )
                                 
                              
                           
                        

Considering the overlapping durations are unknown, the project duration and cost can be optimized through rational arrangement of execution order for all design activities.

In order to enhance the practical ability of the model, some factors such as precedence of activities, maximum allowed PD makespan and cost integrating of development risk are considered as constrains of the model.
                              
                                 (9)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          s
                                       
                                    
                                    ⩾
                                    0
                                 
                              
                           
                           
                              
                                 (10)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          s
                                       
                                    
                                    ⩽
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                       
                                          s
                                       
                                    
                                    
                                    j
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    i
                                    <
                                    j
                                 
                              
                           
                           
                              
                                 (11)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          s
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          d
                                       
                                    
                                    ⩽
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                       
                                          s
                                       
                                    
                                    +
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                       
                                          d
                                       
                                    
                                    
                                    j
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    i
                                    <
                                    j
                                 
                              
                           
                           
                              
                                 (12)
                                 
                                    C
                                    ⩽
                                    
                                       
                                          C
                                       
                                       
                                          max
                                       
                                    
                                 
                              
                           
                           
                              
                                 (13)
                                 
                                    T
                                    ⩽
                                    
                                       
                                          T
                                       
                                       
                                          max
                                       
                                    
                                 
                              
                           
                        

Eq. (9) is the nonnegative constrain for the PD activities. Eq. (10) ensures that the starting time of upstream activity i is no later than that of downstream activity j. Eq. (11) is used to ensure that the upstream activity rework stops before the downstream activity is finished. And Eqs. (12) and (13) are used to ensure that the development cost and time are less than the cost and time allowed by managers.

This paper proposes modified PGA with VNS strategy (PGVNS) to approximate the Pareto optimal solutions of the bi-objective scheduling problem for collaborative development process to minimize project duration and total cost in certain development risk. The hybridization of different heuristics (population-based and local search) provides more efficient search methods since the two goals of exploration and exploitation simultaneously [34]. Exploration allows extensive search to determine the part of the solution space that has a higher chance of containing the global optimum whereas exploitation refines the search and focuses on a special part of the space. The flowchart of the PGVNS is shown in Fig. 3
                      and the details of it are illustrated in the following.

Encoding is first step to translate a genetic solution of the problem into a chromosome string suitable to the application of genetic operators. For our problem, the chromosome represents an execution sequence of different activities. Therefore, the chromosome is coded with integer. The value at each gene position is the activity code and the number of position corresponds to activity sequence as shown in Fig. 4
                        . For example, consider the individual 1 (2→3→1→5→4→6→7) in Fig. 4. The first activity A2 is executed with the earliest start time, and then the second one A3 is done and so on. The downstream activities can start after the beginning of the upstream activities.

The quality and size of the initial population can largely affect the efficiency of a genetic algorithm. As a result, a carefully crafted heuristic based on CD-DSM is required to generate random chromosomes with all constraints satisfied. The steps can be summarized as follows:
                           
                              (i)
                              Identify the activity i without any input, that is the elements of the activity p row are zero, namely, apj
                                 
                                 =0, (j
                                 =1,2,…,
                                 n), and put activity p on the top of the DSM. Activity p is the first activity of the process.

Identify the activity j without any output that is the elements of the activity q column are zero, namely, aiq
                                 
                                 =0, (i
                                 =1,2,…,
                                 n)=0, and put activity q on the right of the DSM. Activity q is the last activity of the process. In this way, the length of chromosome is lowered by removing the first and last activities.

For each activity k, accumulate the sum of akj
                                  of the row k(k,j
                                 =1,2,…,
                                 n,k
                                 ≠
                                 p) and calculate the sum of aik
                                  of the column k(i,k
                                 =1,2,…,
                                 n,k
                                 ≠
                                 p) then calculate the ratio of information input and output of activity k by formula (14).


                        
                           
                              (iv)
                              Rank the activity sequence according to ascending order of ratio rk
                                  and obtain the first individual. Calculate the normalized ratio rk
                                 .

Generate n
                                 −1 random numbers with range from 0 to 1

Multiply ratio rk
                                  by the random numbers and rank the activity sequence again. Add the new individual to the population.

Repeat steps (v) and (vi) until population number is satisfied.

In order to calculate of fitness value, the first step is to obtain each separate objective function value, T and C. However, it is difficult to calculate the duration directly. As a result, we obtain the duration of each activity including normal and rework time firstly, and then accumulate the time according the different type of dependency. The algorithm for computing the total PD duration is shown in the Algorithm 1. Moreover, the cost function can be obtained easily following Eq. (8).
                           
                              
                                 
                                 
                                    
                                       Algorithm 1: Algorithmic flow for calculating duration of PD project
                                    
                                 
                                 
                                    
                                       1. initialize parameter λ, θ, β, ε, D, Ti
                                          , 
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      ij
                                                   
                                                   
                                                      o
                                                   
                                                
                                             
                                          , T=0 and 
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      d
                                                   
                                                
                                                =
                                                0
                                             
                                          
                                       
                                    
                                    
                                       2. calculate the rework time of each activity
                                    
                                    
                                       3. for each activity i in the individual x from current population curpop 
                                          do
                                       
                                    
                                    
                                       4. 
                                          for other activity j(j
                                          ≠
                                          i) in the individual x 
                                          do
                                       
                                    
                                    
                                       5. 
                                          
                                          switch type of activity i 
                                          then
                                       
                                    
                                    
                                       6. 
                                          
                                          
                                          case: coupled activity
                                    
                                    
                                       7. 
                                          
                                          
                                          
                                          calculating the value of ki
                                           by Eq. (5)
                                       
                                    
                                    
                                       8. 
                                          
                                          
                                          
                                          Loop to update 
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                           by Eq. (3) for non-overlapped or (4) for overlapped ones.
                                    
                                    
                                       9. 
                                          
                                          
                                          case: sequent activity
                                    
                                    
                                       10. 
                                          
                                          
                                           
                                          if 
                                          pos(i)<
                                          pos(j) then
                                          
                                          /*activity i is prior to activity j*/
                                    
                                    
                                       11. 
                                          
                                          
                                          
                                          
                                          if 
                                          aij
                                          
                                          ≠0 then
                                          
                                          /*activity i (upstream) depends on activity j (downstream)*/
                                    
                                    
                                       12. 
                                          
                                          
                                          
                                          
                                          update 
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                           by Eq. (3) for non-overlapped or (4) for overlapped ones.
                                    
                                    
                                       13. 
                                          
                                          
                                          
                                          
                                          end if
                                       
                                    
                                    
                                       14. 
                                          
                                          
                                          else
                                          
                                          
                                          /*activity i is posterior to activity j*/
                                    
                                    
                                       15. 
                                          
                                          
                                          
                                          if 
                                          aji
                                          
                                          ≠0 then
                                          
                                          /*activity j depends on activity i */
                                    
                                    
                                       16. 
                                          
                                          
                                          
                                          
                                          update 
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                           by Eq. (2) for overlapped ones.
                                    
                                    
                                       17. 
                                          
                                          
                                          
                                          end if
                                       
                                    
                                    
                                       18. 
                                          
                                          
                                          end if
                                       
                                    
                                    
                                       19. 
                                          
                                          end switch
                                       
                                    
                                    
                                       20. 
                                          end for
                                       
                                    
                                    
                                       21. identify the sequent, parallel and coupled activity blocks
                                    
                                    
                                       22. computing the duration of each block
                                    
                                    
                                       23. 
                                          if there is overlapping then
                                       
                                    
                                    
                                       24. update 
                                             
                                                T
                                                ←
                                                T
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                
                                                -
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      ij
                                                   
                                                   
                                                      o
                                                   
                                                
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       25. 
                                          else
                                       
                                    
                                    
                                       26. update 
                                             
                                                T
                                                ←
                                                T
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      d
                                                   
                                                
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       27. end for
                                       
                                    
                                    
                                       28. Return T of this activity sequence
                                    
                                 
                              
                           
                        
                     

And then, the population is sorted in terms of the objective function value of each chromosome into different fronts based on the non-domination method from [35]. The non-dominated solution individuals are selected from the population and defined as rank 1 and those individuals are removed from the population. Next set of non-dominated individuals is searched and rank 2 is assigned to them. The procedure is repeated for the subsequent fronts until the entire population is sorted and non-dominantly divided to different fronts. The individual assigned the smaller rank value, represents it is the better one. Furthermore, map the rank value to fitness value with the following formula for normalization modified from [36].
                           
                              (15)
                              
                                 f
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             r
                                             =
                                             1
                                          
                                          
                                             r
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                       (
                                       r
                                       ×
                                       
                                          
                                             n
                                          
                                          
                                             r
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             r
                                             =
                                             1
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       r
                                       ×
                                       
                                          
                                             n
                                          
                                          
                                             r
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where f(xi
                        ) represents the fitness function value for individual xi
                        , m signifies the maximum rank, r(xi
                        ) denotes the grade for individual xi
                        , and nr
                         denotes the number of individuals for rank r.

During the evolution, to ensure the diversity of population, a niche technology is introduced to adjust the fitness value of individuals [37]. A sharing function is formulated in Eq. (16) to realize the purpose, in which S(xi
                        , xj
                        ) denotes the shared function for different individuals and Rshare
                         is the niche radius. d(xi
                        , xj
                        ) is the Euclidean distance of two different individuals formulated as Eq. (17), where fk
                         is the kth objective of h ones.
                           
                              (16)
                              
                                 S
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                   -
                                                   
                                                      
                                                         d
                                                         (
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         
                                                            
                                                               R
                                                            
                                                            
                                                               share
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   d
                                                   (
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                   ⩽
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         share
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   d
                                                   (
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                   >
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         share
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 d
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             =
                                             1
                                          
                                          
                                             h
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   f
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             -
                                             
                                                
                                                   f
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The collection of sharing function on the whole population (population size, n) estimates how crowded is the neighborhood of individual xi
                        . So the fitness function can be degraded by sharing shown in the following.
                           
                              (18)
                              
                                 f
                                 ’
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       f
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       S
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

The integrated method of roulette wheel and elite preservation strategy is applied in this study to selection operator. The procedure is the roulette wheel selection is implemented on the whole individuals and then a certain number of elite individuals based on the fitness value in results of roulette wheel selection are preserved to the next generation directly with probability pe
                        .

The main purpose of crossover operator is to generate better offspring by combining the genetic alleles of two randomly selected parents from the population with probability pc
                        .

A position and order based crossover method is employed here and crossover position is generated randomly. A fitness-based crossover method is formulated to identify the number of crossover gene as Eq. (19), in which, Num is the number of crossover gene, and Len is the length of chromosome. Floor signifies the floor function.
                           
                              (19)
                              
                                 Num
                                 =
                                 Floor
                                 
                                    
                                       
                                          
                                             
                                                f
                                                (
                                                i
                                                )
                                             
                                             
                                                f
                                                (
                                                i
                                                )
                                                +
                                                f
                                                (
                                                j
                                                )
                                             
                                          
                                          ×
                                          Len
                                       
                                    
                                 
                                 +
                                 1
                              
                           
                        
                     

As explained in Section 4.1, the sequence of gene is equivalent to the scheduling sequence of the problem. Hence, it is desirable to inherit the sequence of genes. As a result, the genes from parents appear in offspring following the order they have in themselves. When the identical gene appears in the chromosome, skip the repeated gene from another parent and screen the next gene until the offspring is obtained. The process is illustrated in Fig. 5
                        .

In addition, each offspring is assigned a small probability of mutation so that the solutions are more diversified. With probability pm
                        , select an individual from the population and swap two random genes.

GA has been proved to be very good at exploring the solution space but fail to exploit the search in promising regions; however local search can intensify the ability of climbing upward from a local optimum. Hence, we apply VNS strategy to search for the better neighborhood solutions to improve the local search ability of GA. VNS being a metaheuristic local search algorithm uses the idea of changing the neighborhood systematically and has been successfully applied to different combinatorial optimization problems [38]. This method is different from the most local search heuristics in that it uses two or more neighborhoods, instead of one, in its structure. The main steps of VNS in our proposed approach are described in Algorithm 2.
                           
                              
                                 
                                 
                                    
                                       Algorithm 2: Algorithmic flow of VNS in the PGVNS
                                    
                                 
                                 
                                    
                                       1. Sample the sub-population subpop for VNS
                                    
                                    
                                       2. for each individual x in the subpop 
                                          do
                                       
                                    
                                    
                                       3. Select the set of neighborhood structure, NK
                                          (x)(k
                                          =1,2,…,
                                          k
                                          max)
                                    
                                    
                                       4. 
                                          k
                                          ←1
                                    
                                    
                                       5. 
                                          while 
                                          k
                                          ⩽
                                          k
                                          max 
                                          do
                                       
                                    
                                    
                                       6. 
                                          Shaking: find a random solution x′,x′∊
                                          NK
                                          (x)
                                    
                                    
                                       7. 
                                          Performing a local search on NK
                                          (x) to find a local optimal solution x’’
                                    
                                    
                                       8. 
                                          
                                          if 
                                          x’’ is better than the incumbent then
                                       
                                    
                                    
                                       9. 
                                          
                                          
                                          x
                                          ←
                                          x’’
                                    
                                    
                                       10. 
                                          
                                          return step 3
                                    
                                    
                                       11. 
                                          
                                          end if
                                       
                                    
                                    
                                       12. 
                                          
                                          k
                                          ←
                                          k
                                          +1
                                    
                                    
                                       13. 
                                          end while
                                       
                                    
                                    
                                       14. end for
                                       
                                    
                                    
                                       15. Return the updated subpop to the current population
                                    
                                 
                              
                           
                        
                     

In terms of preserving good individuals to the next population by selection operator, the VNS algorithm is only applied to the individuals, to which the crossover and mutation operators are applied. It is essential to obtain efficient neighborhood structures integrating of some problem-specific knowledge for guiding the search process towards more promising regions in the search space as well as improving the searching efficiency. In addition, to avoid costing too much computational time, the best number of neighborhoods is often three [39], which is followed by our algorithm. As a result, we propose three different neighborhood structures for shaking in PGVNS algorithm, which are swap, insertion and loop detailed in the following.
                           
                              
                                 Swap: change two activities execution sequence at random and others keep the original.


                                 Insertion: generate a random number r range from 1 to n
                                 −1. Select an activity randomly and insert it into r position.


                                 Loop: generate a random number r range from 1 to n
                                 −1, and move all the activity in a loop r gene position.

And then local search is performed to find the best neighborhood of the initial solution.

After the above operations, the individuals preserved in the previous step become a new population.

When the stopping criterion is satisfied, output the Pareto optimal solution which provides the optimal strategy for decision-makers to plan and schedule the PD process.

In order to demonstrate the application of the proposed model and algorithm, authors investigate the PD process and interview with the designers in an optoelectronic company located in Guangdong of China. The case enterprise had become a public company in 2010 and mainly produces LED products (e.g. LED parts, LED module and LED lighting). In the case company, the PD process consists of five phases: project initiation, design and review, design verification, trial production and design validation. Table 2
                      shows all of activities involved in PD of the considered example of one LED module, along with their parameters (normal times, costs and overlaps). The authors investigated that there exist four overlapped groups of successive activities. These are (A, B), (C, F), (I, J) and (M, O). The dependent relationships of those atomic activities are described in the CD-DSM according to the practical experience shown in Fig. 6
                     . The execution cost related to each activity also was assigned to calculate the total amount of the PD cost. Suppose that the cost for each rework time unit 
                        
                           
                              
                                 C
                              
                              
                                 i
                              
                              
                                 r
                              
                           
                        
                      is 2.0 (i
                     =1,2,…,15), negotiation cost for each rework Cn
                      is 0.5, and risk cost for the unit tardiness Rc
                      is 1.5.

Parameters of the proposed PGVNS algorithm are elite selection ratio, crossover ratio, mutation ratio, population size, and generation number. The PGVNS algorithm has been coded in MATLAB 7.8.0 and run on a 2.2GHz AMD E2-3000M PC with 2GB of random access memory (RAM). After running some pilot tests, we set the parameters as follows: elite selection ratio: 0.2, crossover ratio: 0.6, mutation ratio: 0.2, population size: 400, and generation number: 400. In addition, we take model parameters λ
                     =2, θ
                     =0.3 and β
                     =0.7 following the design experience. After executing the MATLAB codes with input parameters, a Pareto optimal solution set is obtained. The Pareto optimal solution set includes 4 Pareto optimal solutions, and its distribution is as shown in Fig. 7
                     . One of the Pareto optimal solutions with overlapping is compared with the original activity sequence shown in Table 3
                     . It is evident that this solution is optimal to the original sequence with reduction of the project duration drops from 47.2 to 38.3 and total cost drops from 142.3 to 128.7. Moreover, the performance of overlapping strategy is shown in Table 4
                     . The project duration drops from 44.7 to 38.3 (14.32% reduction) at a 0.94% increment of cost from 127.5 to 128.7. This increased cost is due to the additional time for rework and communication caused by the overlapping. Therefore, the overlapping is an important strategy to reduce project duration in terms of its a little added cost.

In the following subsections, we analyze the performance of the PGVNS by considering three performance measures [40], and each of them is listed below.
                        
                           (1)
                           Convergence metric 
                                 
                                    ϒ
                                 
                               measures the extent of convergence to a known set of optimal Pareto solutions. 
                                 
                                    ϒ
                                 
                               is the average of minimum Euclidean distances from obtained Pareto solutions to the known optimal Pareto solutions.

Diversity metric Δ measures the extent of spread achieved among the obtained solutions. Δ is calculated as follows:


                     
                        
                           (3)
                           Dominance metric Ω measures the percentage of obtained optimal Pareto solutions among the obtained and known optimal Pareto solutions. It can be calculated in the following.

The above three measures all involve the optimal Pareto solutions. But we do not know them for the considering problem. Thus we regard the Pareto solution of all the test algorithms as the Pareto optimal solutions.

In addition, two problems are defined for comparison between PGVNS and Non-dominated Sorting Genetic Algorithm (NSGA-II) [35] with the same genetic operator to show the robustness of the proposed algorithm and assess its performance, and the two problems are listed below.
                        
                           Problem 1: Min C and Min T with a loose due-date

Problem 1: Min C and Min T with a tight due-date

We first use PGVNS and NSGA-II based on the parameter combination obtained in the previous test to calculate the Problem 1 with a loose due-date 40days.

The average values of the objective functions are employed as metric to illustrate the evolution process shown in Fig. 8
                        . And the two algorithms approach optimal/near-optimal value as the number of iteration increases. When the number of evolution receives near 120, two objectives change alternatively and do not decrease simultaneously. This implies that the two objectives are conflict indirectly. Although the quality of the final solution obtained for both approaches is approximately equivalent for engineering application, there is a slight difference among the optimal value returned by them.

We compare the performance of NSGA-II with PGVNS by performing 30 runs. The proposed PGVNS can find better Pareto solutions (see Table 5
                        ) of the structuring the PD process problem as compared to NSGA-II. The minimum, average and maximum of each performance measure are calculated shown in Table 6
                        . As shown in Table 6, it seems that there is slight difference between the algorithms for this problem. In order to verify above statement, we apply hypothetical test to the problem and the result is shown in Table 9
                        
                        
                         with 10% significance level. The details of hypothetical test are similar to that in Section 5.2.

Now we reduce the due-date to 35days, and it will cause risk cost due to the tight due-date. We still use the same parameter combination to compare the performances of PGVNS and NSGA-II.

We perform the algorithm test for 30 runs again with a tight due-date 35days. And the average results are shown in Table 7. The results show that both algorithms have certain project tardiness and cost increase compared with problem 1. PGVNS has a relatively significant drop of duration (6.45%) and cost (2.82%) from NSGA-II in this problem. And the minimum, average and maximum of each performance measure are calculated shown in Table 8. As shown in Tables 7 and 8, it seems that PGVNS shows better performance than NSGA-II with a tight due-time constrain. This statement can be verified by hypothetical test as shown in Table 9.

We perform paired T-test for the following null hypothesis and the alternative hypothesis with respect to 
                           
                              ϒ
                           
                         and Δ:
                           
                              H0: μ
                                 NSGA-II–μPGVNS
                                 
                                 ⩽0

H1: μ
                                 NSGA-II–μPGVNS
                                 
                                 >0

For performance measure Ω, we considered the following test:
                           
                              H0: μ
                                 NSGA-II–μPGVNS
                                 
                                 ⩾0

H1: μ
                                 NSGA-II–μPGVNS
                                 
                                 <0

If the null hypothesis is rejected with a certain significance level, we can conclude that PGVNS performs better than NSGA-II statistically. The statistical analysis was done using software MINITAB 16 with 200 samples. Table 9 shows the p-values of the test for the two problems. PGVNS has a better significance level for the problem 2. Therefore, the VNS is much effective in improving the exploitation ability. But NSGA-II is relatively efficient than PGVNS in computation time. And PGVNS has a time complexity of 
                           
                              O
                              (
                              
                                 
                                    N
                                 
                                 
                                    g
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              (
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                                 
                                    2
                                 
                              
                              (
                              M
                              +
                              N
                              )
                              )
                              )
                           
                        , where Ng
                         is generation size, Np
                         population size, Na
                         activity number, M number of objective function and N number of neighborhood of VNS. The main difference of time complexity between NSGA-II and PGVNS is in the VNS process.

@&#CONCLUSIONS@&#

Overlapping and iteration between activities are basic properties in the complex PD process. It is highly desired to obtain the optimal sequencing of the activities for shortening PD project duration and cost. To enhance the performance and efficiency of development process, this article proposes a process optimization model to capture the time characteristics and cost risks due to overlapping and complex interaction in PD processes. In terms of the fact that minimization of time is not synonymous with minimization of cost, we apply Pareto approach to obtain the optimal solution set. So a novel PGVNS method is proposed to approximate the Pareto optimal solutions of the bi-objective process optimization problems. The method is demonstrated with an example from a LED module PD process in optoelectronic enterprise. Simulation results of two different problems indicate that the performances of the proposed approach are better than that of NSGA-II. Moreover, the proposed process model considers overlapping and iterations, which can help project managers to plan and improve the PD process.

In consideration of collaboration performance of PD process, there still exists many challenges and research work to do. Therefore, as further research, the following can be considered. First, how to construct collaboration performance measures of PD process, and the tradeoff among project duration, cost and risk. Second, we will consider integrating optimization and simulation algorithm into a decision support system to optimize the activity sequence that uses the variance of collaboration, duration and cost as an objective and evaluate the performance of process from a systematic viewpoint.

@&#ACKNOWLEDGMENTS@&#

This research is supported by the National Science Foundation of China under the Grant Nos. 71171154 and 71101072 and the China Scholarship Council Postgraduate Scholarship Program. The authors would like to express their great appreciation for the valuable comments and constructive suggestions by the anonymous reviewers and the Editor.

@&#REFERENCES@&#

