@&#MAIN-TITLE@&#MOEPGA: A novel method to detect protein complexes in yeast protein–protein interaction networks based on MultiObjective Evolutionary Programming Genetic Algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A method of multiobjective problem based on network topological property is proposed.


                        
                        
                           
                           A method of identifying protein complexes based on MOEPGA in PPI network is proposed.


                        
                        
                           
                           Results show MOEPGA is superior to several prediction algorithms.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Protein–protein interaction (PPI) network

Protein complex

Multiobjective evolutionary

Normalized clustering score

@&#ABSTRACT@&#


               
               
                  The identification of protein complexes in protein–protein interaction (PPI) networks has greatly advanced our understanding of biological organisms. Existing computational methods to detect protein complexes are usually based on specific network topological properties of PPI networks. However, due to the inherent complexity of the network structures, the identification of protein complexes may not be fully addressed by using single network topological property. In this study, we propose a novel MultiObjective Evolutionary Programming Genetic Algorithm (MOEPGA) which integrates multiple network topological features to detect biologically meaningful protein complexes. Our approach first systematically analyzes the multiobjective problem in terms of identifying protein complexes from PPI networks, and then constructs the objective function of the iterative algorithm based on three common topological properties of protein complexes from the benchmark dataset, finally we describe our algorithm, which mainly consists of three steps, population initialization, subgraph mutation and subgraph selection operation. To show the utility of our method, we compared MOEPGA with several state-of-the-art algorithms on two yeast PPI datasets. The experiment results demonstrate that the proposed method can not only find more protein complexes but also achieve higher accuracy in terms of fscore. Moreover, our approach can cover a certain number of proteins in the input PPI network in terms of the normalized clustering score. Taken together, our method can serve as a powerful framework to detect protein complexes in yeast PPI networks, thereby facilitating the identification of the underlying biological functions.
               
            

@&#INTRODUCTION@&#

Proteins are critical components of cell activities and are essential to our understanding of molecular function as well as biological process. In biological organisms, proteins are usually organized into a protein complex, in which they carry out specific biological functions cooperatively (Zhang et al., 2013). For example, proteins YDL105W, YDR288W, YEL019C, YER038C, YLR007W, YLR383W, YML023C, and YOL034W form a complex “Smc5-Smc6” and regulate both recombination and kinetochore sumoylation to promote chromosomal maintenance during growth process (Yong-Gonzales et al., 2012). Therefore, studies have been focused on elucidating protein functions in PPI networks based on their interacting partners (Girvan and Newman, 2002; Jin et al., 2015; Mering et al., 2002), which further strengthen our biological knowledge on protein assembly processes for cellular organization.

Although there are a number of ways to detect protein complexes experimentally, such as yeast-two-hybrid (Zhang et al., 2013) and tandem affinity purification with mass spectrometry (Chen and Wu, 2013; Zhang et al., 2013), they were shown to have certain limitations (Li et al., 2005). Specifically, PPI data derived from high-throughput experiments usually have high false-positive and false-negative rates, which substantially affects the accuracy of the experiment results (Chen and Wu, 2013). Therefore, computational approaches to detect protein complexes are developed as useful complements to the experimental methods.

Several methods based on density have been proposed to identify densely connected subgraphs in PPI networks, where subgraphs with density above a pre-defined threshold were considered as protein complexes, such as MCODE (Bader and Hogue, 2003), DPClus (Altaf-UI-Amin et al., 2006), NEMO (Rivera et al., 2010), SPICi (Jiang and Singh, 2010), and graph entropy based algorithms (Chen, 2013; Kenley and Cho, 2011). Notably, such methods tended to discard the peripheral proteins as they connected to the core clusters with weak links. Nevertheless, these peripheral proteins can display true interactions that have been experimentally validated (Luo et al., 2007; Pizzuit and Rombo, 2012). Another type of approaches for identifying protein complexes employed tradition hierarchy clustering techniques, which were mainly based on the distance between proteins to identify significant clusters (Pizzuit and Rombo, 2012) and include such methods as HC-PIN (agglomerative approach) (Wang et al., 2011) and G-N algorithms (divisive approach) (Girvan and Newman, 2002). In Wang et al. (2011), HC-PIN showed strong performance with high accuracy because it mainly depended on the local metric of edge clustering value. In addition, there were some variants of network topology features. For example, Nepusz et al. (2012) proposed a ClusterONE algorithm based on the notion of the cohesiveness score to identify protein complexes in PPI networks. Such cohesiveness showed that proteins in a complex displayed strong and frequent connections within the complex and weak and rare connections to proteins out of the complex. Liu et al. (2012) proposed an algorithm based on the clique percolation and distance restriction to identify protein complexes in PPI network, which can effectively identify middling scale protein complexes and compensate for the drawback of clique structure. Although a variety of computational approaches have been introduced during the past decade, it still remains a challenge to effectively identify protein complexes by means of network topological features, especially for those methods which only take single network topological property into account.

To address this issue, we develop a novel method for protein complex prediction called MultiObjective Evolutionary Programming Genetic Algorithm (MOEPGA) based on multiple network topological properties, namely, density, size, and characteristic path length (CPL). Our algorithm first analyzes these common network topological characteristics of known protein complexes in yeast PPI networks, and then formulates the objective function according to the distribution of the network topological features, finally we describe our algorithm, which mainly consists of three steps, population initialization, subgraph mutation and subgraph selection operation. To evaluate the performance of our method, we apply MOEPGA as well as several state-of-the-art algorithms on two well-studied yeast PPI network of DIP and GAVIN. The experiment results show that our method can not only cover a certain number of proteins in the input PPI network in terms of the normalized clustering score but also achieve higher accuracy in terms of fscore. The remainder of this paper is organized as follows: Section 2 presents the terminologies used in this study and describes the MOEPGA approach for protein complex prediction in detail. Section 3 shows the evaluation metrics and the experimental results. Finally, we draw some conclusions and address our future work.

We first present the relative terminologies used in our experiments and then describe the MOEPGA algorithm in detail.

A PPI network can be denoted by a simple undirected graph G
                        =(V,E), where nodes V represent proteins in the PPI network, and edges E correspond to an interaction between two different proteins. A subgraph S is a subset of G, which is described as S
                        ⊂
                        G, where S
                        =(V′,E′), V′⊂
                        V, E′⊂
                        E). Protein complexes are usually supposed to be subgraphs of PPI networks. The density of a subgraph S (Chen and Wu, 2013) is defined as the ratio of the number of edges within S to the maximum number of possible edges, which is described as Eq. (1).
                           
                              (1)
                              
                                 
                                    D
                                    e
                                    n
                                    s
                                    i
                                    t
                                    y
                                    (
                                    S
                                    )
                                    =
                                    
                                       
                                          2
                                          ×
                                          
                                             N
                                             e
                                          
                                       
                                       
                                          
                                             N
                                             v
                                          
                                          ×
                                          (
                                          
                                             N
                                             v
                                          
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        where N
                        e is the number of edges in S, and N
                        v is the number of vertices within it. For a subgraph S, the size of subgraph denoted by Size(S) (Shelokar et al., 2014) is the sum of edges N
                        e and vertices N
                        v in the subgraph,
                           
                              (2)
                              
                                 
                                    S
                                    i
                                    z
                                    e
                                    (
                                    S
                                    )
                                    =
                                    
                                       N
                                       e
                                    
                                    +
                                    
                                       N
                                       v
                                    
                                 
                              
                           
                        
                     

The subgraph S of the CPL (Watts and Strogatz, 1998) is defined as the average number of edges in the shortest paths between all vertex pairs given by
                           
                              (3)
                              
                                 
                                    C
                                    P
                                    L
                                    (
                                    S
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                >
                                                j
                                             
                                          
                                          
                                             
                                                D
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                       
                                          (
                                          1
                                          /
                                          2
                                          )
                                          ×
                                          
                                             N
                                             v
                                          
                                          ×
                                          (
                                          
                                             N
                                             v
                                          
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        
                     

In Eq. (3), the numerator indicates the sum of the shortest paths between all vertex pairs (V
                        
                           i
                        ,V
                        
                           j
                        ), whereas the denominator presents the number of the all possible edges within subgraph S. In our experiment, the shortest path is evaluated using the Floyd algorithms (Shier, 1981).

In this section, motivated by Shelokar et al. (2014), which employs mulitobjective evolutionary programming method for mining three-objective (i.e., support, size, and diameter of subgraph) frequent subgraphs, and is tested on five synthetic as well as the world scientogram database, the results highlight the application of the method proposed in Shelokar et al. (2014) and discover more diversified subgraphs, we propose MOEPGA for identifying protein complexes from PPI networks with the aim of solving the defects of the single network topological property. First, we present the problem description of multiobjective in terms of identifying protein complexes from PPI networks. Second, we achieve the calculation formula of the objective function by analyzing protein complexes in benchmark dataset. Third, we describe the MOEPGA in detail. MOEPGA generates next generation subgraphs with edge mutation and selection operation, and extracts nondominated subgraphs (Shelokar et al., 2014) by optimizing the three objective functions at each evolutionary process and then saves them to the Archive. Finally, our algorithm is performed on yeast PPI network of DIP and GAVIN, and the identified protein complexes are evaluated by using fscore, clustering score, and normalized clustering score. The framework is illustrated in Fig. 1
                        .

We first define the objective functions of the MOEPGA in terms of identifying protein complexes from PPI networks. Given a graph G, we extract the nondominated subgraphs representing all the connected subgraphs in G defined by three user-defined objectives from formulas (1)–(3):
                              
                                 (4)
                                 
                                    
                                       F
                                       (
                                       S
                                       )
                                       =
                                       (
                                       
                                          f
                                          1
                                       
                                       (
                                       S
                                       )
                                       ,
                                       
                                          f
                                          2
                                       
                                       (
                                       S
                                       )
                                       ,
                                       
                                          f
                                          3
                                       
                                       (
                                       S
                                       )
                                       )
                                    
                                 
                              
                           where
                              
                                 
                                    f
                                    1(S)=Max. density


                                    f
                                    2(S)=Min. size


                                    f
                                    3(S)=Min. CPL


                                    S
                                    ∈
                                    X
                                 


                                    F(S)∈
                                    Y
                                 

The solution x is no worse than x′ in all objectives.

The solution x is strictly better than x′ in at least one objective.

If any of the above conditions is violated, the solution x does not dominate solution x′. To mine the all possible nondominated subgraphs from PPI networks, we employ the linear summation of objective function values obtained from every subgraph. Based on the analysis of the single topological structures as well as a large number of experiments, we find that the combination of three objectives can compensate for the shortcoming of single objective, which lead to improve quality of the identified protein complexes. Finally, we construct the following formula:
                              
                                 (5)
                                 
                                    
                                       F
                                       (
                                       S
                                       )
                                       =
                                       
                                          f
                                          1
                                       
                                       (
                                       S
                                       )
                                       +
                                       
                                          3
                                          
                                             
                                                f
                                                2
                                             
                                             (
                                             S
                                             )
                                          
                                       
                                       +
                                       
                                          1
                                          
                                             
                                                f
                                                3
                                             
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

We set 3 with f
                           2(S) in the numerator to fix the value of 3/f
                           2(S) in (0, 1].

The MOEPGA algorithm roughly consists of three steps. First, MOEPGA initiates the subgraph population and preprocesses data from PPI networks. Second, MOEPGA performs the mutation procedure to generate the child population. Finally, MOEPGA executes subgraph selection and produces the next generation of subgraphs.

In the first step, MOEPGA first initiates subgraph population R with graph G, i.e., one-edge subgraphs from the original PPI network and then judges whether overlapping vertices exist between subgraphs. If no overlap exists, we extract and discard these nondominated subgraphs in R.

In the second step, MOEPGA performs the mutation operation to generate child subgraphs. To generate a child subgraph S′, a mutation operation is executed on a subgraph S encoded in a parent individual in the population R. If an overlapping vertex exists between two parent subgraphs, the mutation creates child subgraphs by extending all instances of the parent subgraph S in the dataset G by an edge. Fig. 2
                           a shows an example of mutation through an edge. In Fig. 2a, the parent subgraph “
                              
                           ” in level 1 creates two child subgraphs “
                              
                           ”, “
                              
                           ” by an edge “
                              
                           ”, “
                              
                           ”, respectively.

If more than one edge may be extended between two subgraphs, mutation will be executed by randomly selecting an edge (see Algorithm 1). For example, in Fig. 2b, for subgraph S
                           1, S
                           2, the three subgraphs below are reasonable child subgraphs. Mutation is applied to all parent individuals in R to create the child population Qgen. Every child subgraph in Qgen is assessed using F(S) in Eq. (5).

In the third step, MOEPGA constructs a new parent population R with temporary population R
                           ∪Qgen. To create the next generation, MOEPGA first sorts all subgraphs in R
                           ∪Qgen according to F(S) and then removes the repeat subgraphs. The next generation subgraphs with probability P
                           s are finally generated from the temporary population. In Fig. 2a, only one subgraph is present in level 3 because the other two subgraphs are removed. Notably, MOEPGA can generate some nondominated subgraphs during evolutionary, such as “
                              
                           ” in Fig. 2a. In order to store the nondominated subgraphs, MOEPGA apply an external archive Archive which is updated at the end of each generation (see Algorithm 2). The output of MOEPGA is the set of nondominated subgraphs saved in Archive after the algorithm is run. The description of MOEPGA algorithm is presented in Table 1
                           .
                              Algorithm 1
                              
                                 
                                    
                                       
                                          Mutation operator.
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                   Mutation (Qgen, R, P
                                                   
                                                      m
                                                   
                                                   )
                                                
                                             
                                             
                                                
                                                   Input:
                                                
                                             
                                             
                                                
                                                Parent subgraphs set R;
                                             
                                             
                                                
                                                   Output:
                                                
                                             
                                             
                                                
                                                Child subgraphs set Qgen
                                             
                                             
                                                1.
                                                
                                                   total
                                                   =
                                                   size(R)×
                                                   P
                                                   
                                                      m
                                                   ;
                                             
                                             
                                                2.
                                                for(i
                                                   =1; i
                                                   ≤
                                                   total; i++)
                                             
                                             
                                                3.
                                                {
                                             
                                             
                                                4.
                                                
                                                   for(j
                                                   =
                                                   i
                                                   +1; j
                                                   ≤
                                                   total; j++)
                                             
                                             
                                                5.
                                                
                                                   
                                                   {
                                             
                                             
                                                6.
                                                
                                                   
                                                   
                                                   
                                                   if (V
                                                   =
                                                   V
                                                   
                                                      i
                                                   ∩
                                                   V
                                                   
                                                      j
                                                   )≠∅ then
                                                   //S
                                                   
                                                      i
                                                   
                                                   =(V
                                                   
                                                      i
                                                   , E
                                                   
                                                      i
                                                   ), S
                                                   
                                                      j
                                                   
                                                   =(V
                                                   
                                                      j
                                                   , E
                                                   
                                                      j
                                                   )
                                             
                                             
                                                7.
                                                
                                                   
                                                   
                                                   
                                                   {
                                             
                                             
                                                8.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   VtTemp.push_back(V),
                                             
                                             
                                                9.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   Random_shuffle(VtTemp),//shuffle randomly the order of the set V
                                             
                                             
                                                10.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   v
                                                   =VtTemp[0],//extract a vertex with equal probability in VtTemp
                                             
                                             
                                                11.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   if 
                                                   
                                                      
                                                         |
                                                         
                                                            V
                                                            ′
                                                         
                                                         =
                                                         {
                                                         
                                                            v
                                                            1
                                                         
                                                         |
                                                         
                                                            v
                                                            1
                                                         
                                                         ∈
                                                         
                                                            V
                                                            j
                                                         
                                                         ,
                                                         (
                                                         v
                                                         ,
                                                         
                                                            v
                                                            1
                                                         
                                                         )
                                                         ∈
                                                         
                                                            E
                                                            j
                                                         
                                                         ,
                                                         
                                                            S
                                                            j
                                                         
                                                         =
                                                         (
                                                         
                                                            V
                                                            j
                                                         
                                                         ,
                                                         
                                                            E
                                                            j
                                                         
                                                         )
                                                         }
                                                         |
                                                         ≥
                                                         1
                                                      
                                                    then
                                             
                                             
                                                12.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   {
                                             
                                             
                                                13.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   VtTemp.push_back(V′),
                                             
                                             
                                                14.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   Random_shuffle(VtTemp),
                                             
                                             
                                                15.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   v′=VtTemp(0),
                                             
                                             
                                                16.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         
                                                            E
                                                            i
                                                         
                                                         =
                                                         
                                                            E
                                                            i
                                                         
                                                         ∪
                                                         (
                                                         v
                                                         ,
                                                         
                                                            v
                                                            ′
                                                         
                                                         )
                                                      
                                                   , //mutate S
                                                   
                                                      i
                                                    with edge 
                                                      
                                                         (
                                                         v
                                                         ,
                                                         
                                                            v
                                                            ′
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                17.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   }
                                             
                                             
                                                18.
                                                
                                                   
                                                   
                                                   
                                                   }
                                             
                                             
                                                19.
                                                
                                                   
                                                   }
                                             
                                             
                                                20.
                                                
                                                   Qgen=Qgen∪Si,
                                             
                                             
                                                21.
                                                }
                                             
                                             
                                                22.
                                                
                                                   Return Qgen
                                             
                                          
                                       
                                    
                                 
                              


                                 
                                    
                                       
                                          Update archive operator.
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                   UpdateArchive(Archive,Qgen)
                                                
                                             
                                             
                                                
                                                   Input:
                                                
                                             
                                             
                                                
                                                Child subgraphs set Qgen;
                                             
                                             
                                                
                                                   Output:
                                                
                                             
                                             
                                                
                                                
                                                   Archive, Qgen;
                                             
                                             
                                                1.
                                                
                                                   for (i
                                                   =1; i
                                                   ≤
                                                   size(Qgen); i++)
                                             
                                             
                                                2.
                                                
                                                   {S
                                                   
                                                      i
                                                   
                                                   →m_bIsNonDominateSubgraph=ture;}
                                             
                                             
                                                3.
                                                
                                                   for (i
                                                   =1; i
                                                   ≤
                                                   size(Qgen); i++)
                                             
                                             
                                                4.
                                                {
                                             
                                             
                                                5.
                                                
                                                   
                                                   for(j
                                                   =
                                                   i
                                                   =1; j
                                                   ≤
                                                   size(Qgen); j++)
                                             
                                             
                                                6.
                                                
                                                   
                                                   
                                                   if (V
                                                   =
                                                   V
                                                   
                                                      i
                                                   ∩
                                                   V
                                                   
                                                      j
                                                   )≠∅ then //S
                                                   
                                                      i
                                                   
                                                   =(V
                                                   
                                                      i
                                                   , E
                                                   
                                                      i
                                                   ), S
                                                   
                                                      j
                                                   
                                                   =(V
                                                   
                                                      j
                                                   , E
                                                   
                                                      j
                                                   )
                                             
                                             
                                                7.
                                                
                                                   
                                                   
                                                   {
                                             
                                             
                                                8.
                                                
                                                   
                                                   
                                                   
                                                   
                                                   S
                                                   
                                                      i
                                                   
                                                   →m_bIsNonDominateSubgraph=false;
                                             
                                             
                                                9.
                                                
                                                   
                                                   
                                                   
                                                   break;
                                             
                                             
                                                10.
                                                
                                                   
                                                   
                                                   
                                                   }
                                             
                                             
                                                11.
                                                
                                                   
                                                   
                                                   if (S
                                                   
                                                      i
                                                   
                                                   →m_bIsNonDominateSubgraph=ture)
                                             
                                             
                                                12.
                                                
                                                   
                                                   
                                                   {
                                             
                                             
                                                13.
                                                
                                                   
                                                   
                                                   
                                                   Add(S
                                                   
                                                      i
                                                   , Archive);
                                             
                                             
                                                14.
                                                
                                                   
                                                   
                                                   
                                                   Del(S
                                                   
                                                      i
                                                   , Qgen);// Delete subgraph S
                                                   
                                                      i
                                                    from Qgen
                                             
                                             
                                                15.
                                                
                                                   
                                                   
                                                   }
                                             
                                             
                                                16.
                                                }
                                             
                                             
                                                17.
                                                
                                                   Return 
                                                   Archive, Qgen
                                             
                                          
                                       
                                    
                                 
                              

@&#RESULTS@&#

In this section, we first describe the validation measures and data sources as well as evaluation metrics used in our experiment. We then study the effect of P
                     m, P
                     s on MOEPGA. Finally, we compare MOEPGA with some state-of-the-art methods.

All experimental evaluations in our study were executed by running MOEPGA for 50 generations and 10 times on each group of parameters. In our experiments, the values of fscore from each group test outperform to state-of-the-art algorithms on two yeast PPI datasets. To highlight the effectiveness of experiment results, we then consider the maximum values of the validation measures described below over the 10 times (Supplementary Table S1). MOEPGA requires only three input parameters, P
                     m, P
                     s, and MaxIter. In particular, MaxIter refers to the maximum iteration times. P
                     m, P
                     s represent the probability of mutation and selection. We set the former to 0.1 and the latter to 0.9 in our study.

To evaluate the quality of the results, we consider both the biological relevance of the identified protein complexes and the capability of the approach to cover a significant proportion of PPI networks. We validate our approach by testing it on two different yeast PPI networks, the DIP dataset (Xenarios et al., 2002) and the GAVIN dataset (Gavin et al., 2006), respectively.

After removing isolated proteins and self-interactions, the original protein interaction network of yeast includes 4930 proteins with 17,201 interactions and 1430 proteins with 6531 interactions. The details of the two datasets are listed in Table 2
                        .

CYC2008 (Pu et al., 2009) is used as the benchmark complex dataset to evaluate the performance of the proposed method. It consists of 428 complexes with an average size of 4.703. These benchmark protein complexes are mainly from three sources: (I) MIPS (Mewes et al., 2004), (II) Aloy et al. (2004), and (III) SGD database (Dwight et al., 2002). To understand the benchmark dataset, we study the distribution of the different network topology features of the protein complexes in the PPI networks. In this work, the density, size, and CPL of the complexes are investigated. The details are shown in Tables 3 and 4
                        
                        .

As illustrated in Table 3, 374 out of 428 protein complexes are found in the PPI network constructed from DIP. Among the 374 protein complexes, the majority with a density of 1 accounted for 38.8%. Most complexes with size of less than 10 accounted for 51.3%, and those with size equal to 3 (two vertices and one edge) accounted for 27%, which show that majority of small size protein complexes exists in benchmark dataset. The distribution of CPL indicates that a smaller value of CPL results in a higher ratio. This observation suggests that the most of the protein complexes have a CPL value of smaller than 2 and are significantly smaller than the value of 4.142 obtained in DIP dataset. A similar tendency is observed in the GAVIN dataset as shown in Table 4. Taken together, these analyses clearly show that most validated protein complexes are highly connected and their sizes are relatively small.

To evaluate the predicted complexes, the following evaluation metrics are employed in our study:


                        MatchRate. Let p be a predicted complex and b be a complex in the benchmark database. The match rate MR(p,n) is defined as
                           
                              (6)
                              
                                 
                                    M
                                    R
                                    (
                                    p
                                    ,
                                    b
                                    )
                                    =
                                    
                                       
                                          |
                                          
                                             N
                                             p
                                          
                                          ∩
                                          
                                             N
                                             b
                                          
                                          
                                             |
                                             2
                                          
                                       
                                       
                                          |
                                          
                                             N
                                             p
                                          
                                          |
                                          ⋅
                                          |
                                          
                                             N
                                             b
                                          
                                          |
                                       
                                    
                                 
                              
                           
                        where |N
                        p| is the size of the predicted complex, |N
                        b| is the size of the benchmark complex, and 
                           
                              
                                 
                                    
                                       N
                                       p
                                    
                                    ∩
                                    
                                       N
                                       b
                                    
                                 
                              
                           
                         is the common protein number from predicted complexes and benchmark complexes. If MR(p, b)≥
                        ω, we consider p and b to match each other. In our experiment, we set ω
                        =0.2, which is the same as many experiments for protein complex discovery (Altaf-UI-Amin et al., 2006; Bader and Hogue, 2003; Pizzuit and Rombo, 2012; Li et al., 2005; Sharan et al., 2007; Wang et al., 2011; Zhang et al., 2013).


                        Precision, Recall and fscore. For a predicted complex, we employ Precision and Recall introduced in Wang et al. (2011) to illustrate the identification results. Precision is the fraction of the number of the predicted protein complexes matched by the benchmark complexes with MR(p, b)≥
                        ω out of the size of the predicted protein complex. Recall is the fraction of the number of the predicted protein complexes matched by the benchmark complexes with MR(p, b)≥
                        ω out of the size of the benchmark complex. The computation formulas of Precision, Recall and fscore are
                           
                              (7)
                              
                                 
                                    
                                       N
                                       
                                          cp
                                       
                                    
                                    =
                                    |
                                    {
                                    p
                                    |
                                    p
                                    ∈
                                    P
                                    ,
                                    ∃
                                    b
                                    ∈
                                    B
                                    ,
                                    M
                                    R
                                    (
                                    p
                                    ,
                                    b
                                    )
                                    ≥
                                    ω
                                    }
                                    |
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       N
                                       
                                          cb
                                       
                                    
                                    =
                                    |
                                    {
                                    b
                                    |
                                    b
                                    ∈
                                    B
                                    ,
                                    ∃
                                    p
                                    ∈
                                    P
                                    ,
                                    M
                                    R
                                    (
                                    p
                                    ,
                                    b
                                    )
                                    ≥
                                    ω
                                    }
                                    |
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       Precision
                                    
                                    =
                                    
                                       
                                          
                                             N
                                             
                                                cp
                                             
                                          
                                       
                                       
                                          |
                                          P
                                          |
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       Recall
                                    
                                    =
                                    
                                       
                                          
                                             N
                                             
                                                cb
                                             
                                          
                                       
                                       
                                          |
                                          B
                                          |
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    f
                                    s
                                    c
                                    o
                                    r
                                    e
                                    =
                                    
                                       
                                          2
                                          ×
                                          
                                             Precision
                                          
                                          ×
                                          
                                             Recall
                                          
                                       
                                       
                                          
                                             Precision
                                          
                                          +
                                          
                                             Recall
                                          
                                       
                                    
                                 
                              
                           
                        The fscore is defined as the harmonic mean of Precision and Recall, which can evaluate the overall performance of the different identification methods.


                        p-value. The p-value is typically used to measure the probability that a predicted complex is enriched by a given GO term by chance and is computed by exploiting the software modules called SGD GO Term Finder (http://search.cpan.org/dist/GO-TermFinder/) according to (Pizzuit and Rombo, 2012). p-value is defined by the hypergeometric distribution as
                           
                              (12)
                              
                                 
                                    p
                                    -
                                    v
                                    a
                                    l
                                    u
                                    e
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          m
                                       
                                       n
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            M
                                                         
                                                      
                                                      
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               N
                                                               −
                                                               M
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               n
                                                               −
                                                               i
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                      
                                                      
                                                         
                                                            n
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where N is the number of proteins in the PPI network, M is the number of proteins in a GO term, and n is the number of proteins that are annotated with the same GO term. Thus, a smaller p-value makes the predicted complexes more biologically significant. If the p-value of the predicted complex is greater than or equal the cutoff, the predicted complexes are regarded as insignificant. In our evaluations, we adopt a cutoff equal to 0.05, which is commonly employed in the literature.

As described by Pizzuit and Rombo (2012), a global measure of an identified complex should be used to instead of the p-value of a single metric. The following methods are useful for this purpose:


                        Clustering score. The clustering score of a complex is defined as
                           
                              (13)
                              
                                 
                                    C
                                    -
                                    s
                                    c
                                    o
                                    r
                                    e
                                    =
                                    1
                                    −
                                    
                                       
                                          
                                             ∑
                                             i
                                             
                                                
                                                   n
                                                   s
                                                
                                             
                                          
                                          
                                             min
                                             (
                                             
                                                p
                                                i
                                             
                                             )
                                             +
                                             (
                                             n
                                             −
                                             
                                                n
                                                s
                                             
                                             )
                                             ×
                                             c
                                             u
                                             t
                                             o
                                             f
                                             f
                                          
                                       
                                       n
                                    
                                 
                              
                           
                        where min(p
                        
                           i
                        ) is the p-value of the partition i that is less than the cutoff. The partition is one of three hierarchies in the Gene Ontology database, which includes BP, MF, and CC. n is the number of the identified complexes, and n
                        s is the number of significant complexes.

The clustering score is employed to evaluate the complexes found by an algorithm. However, clustering score cannot thoroughly evaluate the performance of an approach because it does not consider the number of proteins included in a complex. Thus, a method may have a high clustering score but with only a few clustered proteins contained in the PPI network. To solve this problem, we introduce coverage proportion to measure how much a method can cover a certain proportion of the network under analysis. Given a network with p vertices, let p′ be the number of proteins assigned to any of the complexes that an algorithm can identify. The coverage proportion is given by
                           
                              (14)
                              
                                 
                                    c
                                    p
                                    =
                                    
                                       
                                          p
                                          ′
                                       
                                       p
                                    
                                 
                              
                           
                        
                     

High coverage means that a method can identify the majority of proteins from a PPI network, as described by Sharan et al. (2007). The clustering score or coverage proportion cannot solely explain the execution of a method that mines protein complexes from PPI network. A method that considers both the biological significance of the protein complexes and the coverage proportion can be defined as follows:


                        Normalized clustering score. The normalized clustering score (Pizzuit and Rombo, 2012) for a given protein complex obtained by an approach is defined as
                           
                              (15)
                              
                                 
                                    n
                                    c
                                    -
                                    S
                                    c
                                    o
                                    r
                                    e
                                    =
                                    C
                                    -
                                    S
                                    c
                                    o
                                    r
                                    e
                                    ×
                                    c
                                    p
                                 
                              
                           
                        
                     

To study the effects of P
                        m, P
                        s on the performance of MOEPGA, we first study how the algorithm behaves in terms of fscore and let P
                        m, P
                        s take values from 0.1 to 0.9. The detailed experimental results with different P
                        m, P
                        s values are presented in Fig. 3
                        . Notably, in Fig. 3a, when P
                        m
                        =0.1 in DIP dataset, the value of fscore increases gradually until P
                        s
                        =0.9 with the increase in P
                        s, such that the maximum value (0.451) of fscore is obtained. With the gradual increase in P
                        m, the value of P
                        s shows different change trends, which are all below the achieved value of P
                        m
                        =0.1, P
                        s
                        =0.9. Meanwhile, in the GAVIN dataset, when P
                        m
                        =0.1, fscore increases with the addition of P
                        s, reaching up to 0.527 when P
                        s
                        =0.9, as shown in Fig. 3b. With the increases in selection probability, more child subgraphs will be generated, which will aid in identifying more protein complexes. Another condition is that the fscore increases from 0.1 to 0.9 of P
                        s when P
                        m is equal to 0.2. The majority of aspects show that the fscore decreases from 0.1 to 0.9 of P
                        s. These conditions are explained by the fact that when mutation probability has a low value, MOEPGA finds more protein complexes matched with benchmark dataset. A higher mutation probability weakens the accuracy of the identified protein complexes. From the above analysis, we infer that mutation probability should be set to 0.1, whereas selection probability should be set to 0.9.

Based on the analysis of the single topological structure as well as a large number of experiments, we find that the combination of three objectives can compensate for the shortcoming of single objective. To justify the performance of the proposed algorithm, we calculate the Pearson correlation coefficient for each predicted protein complex between the match ratio (MR) and F(S). As illustrated in Fig. 4
                        ., for both DIP and GAVIN datasets, we observe significant positive Pearson correlations between MR and F(S) for predicted protein complexes (p-value
                        <5.54e−05 for DIP and p-value
                        <2.25e−01 for GAVIN dataset, respectively). These results clearly show that protein complexes with higher F(S) tend to be correct.

We further analyze the number of a known protein complex being matched by predicted protein complexes and the times of some match pattern occurs. We calculate the distribution of the number of times a known protein complex being matched by predicted protein complexes (Fig. 5
                        ). We find that for both datasets, a majority of the known protein complexes are predicted only once (43% (117/272) for DIP and 39.2% (78/199) for GAVIN dataset, respectively). Moreover, none of the known protein complexes in DIP dataset and only two of the known protein complexes in GAVIN dataset are predicted more than 10 times. These observations illustrate that the high precision obtained by MOEPGA is unlikely due to the known protein complexes being predicted multiple times. Finally, we also compare the performance of MOEPGA with the state-of-the-art algorithms using the same number of protein complexes. We first sort the predicted protein complexes in decreasing order of F(S) and then compare the top-k complexes with other algorithms predicting exactly k complexes. Details are described in the supplementary files (Supplementary file S1).

We compare the results of MOEPGA with those of other methods. In our experiments, we consider MCODE (Jin et al., 2015), DPClus (Chen and Wu, 2013), NEMO (Li et al., 2005), SPICi (Bader and Hogue, 2003), HC-PIN (Chen, 2013), and ClusterONE (Pizzuit and Rombo, 2012). For the above methods, we consider only complexes with size greater than or equal to 2 by eliminating singletons in our study. Furthermore, for each approach with which we compared our method, we set the corresponding parameters suggested by the authors to obtain the configuration corresponding to the best results for the considered method. The results are listed in Tables 5 and 6
                        
                        , and the highest value of each dataset is in bold.

First, we compare MOEPGA with MCODE, DPClus, NEMO, SPICi, HC-PIN, and ClusterONE on the DIP dataset. As shown in Table 5, MOEPGA outperforms other methods on this dataset. In particular, MEOPGA achieves the highest fscore of 0.451 with the values of N
                        cp, N
                        cb being 430, 272, respectively, which are significantly superior to the other methods.

MOEPGA also identifies 1230 complexes, which is beneficial for achieving high recall of 0.636. We also note that HC-PIN achieves the highest precision of 0.703, and the number of complexes is 64. MCODE only finds 59 complexes, which results in a better precision of 0.525 but worst recall of 0.143. Although DPClus identifies 974 complexes, the precision is the lowest at 0.163 among the all methods. SPICi finds 583 complexes, the fscore of which is among top 3, only lower than MEOPGA and HC-PIN. ClusterONE finds 343 complexes and achieves a precision of 0.347 and fscore of 0.358, which are lower than those of MCODE, HC-PIN, and MOEPGA.

Second, we also compare the seven methods using the GAVIN dataset. Table 6 shows that the results obtained by using the GAVIN dataset are similar to those obtained using the DIP dataset. MOEPGA predicts 524 complexes and achieves the highest fscore, Recall, N
                        cp, and N
                        cb with values of 0.527, 0.465, 319, and 199, respectively. HC-PIN only predicts 66 complexes and achieves the highest precision of 0.879. MCODE finds 69 complexes and achieves a better precision of 0.710. DPClus predicts 226 complexes and achieves the top 2 fscore of 0.463. NEMO finds 246 complexes and achieves an fscore of 0.424, which is slightly higher than that of SPICi and MCODE. ClusterONE predicts 243 complexes, achieving a precision of 0.391 and fscore of 0.368. From the above analysis, we find that MOEPGA achieves the best performance in the overall evaluation metrics, with the exception of precision, mainly because the number of predicted complexes is too large.

To evaluate the overall performance of all methods, we compare the above methods using clustering score and normalized clustering score. In Fig. 6
                        , both the clustering and normalized clustering scores for the three GO hierarchies (BP, MF, and CC) are graphically illustrated for the above approaches on the DIP and GAVIN datasets. For clustering score, Fig. 6a shows that MOEPGA is slightly worse than the other six methods for the three hierarchies on the DIP dataset. In particular, HC-PIN achieves the highest values of 1, 0.997, and 0.997 for BP, MF, and CC, respectively. Similarly, in Fig. 6c, HC-PIN obtains the same results for BP and MF on the GAVIN dataset. However, for CC, MOEPGA scores the highest value of 0.999, which is equal to the clustering score of HC-PIN. For the normalized clustering score, on the DIP dataset, MOEPGA achieves satisfactory values for the three hierarchies, as shown in Fig. 6b. MOEPGA returns significantly better results than MCODE and HC-PIN. DPClus can obtain the best values for the three hierarchies. Although both SPICi and NEMO are below DPClus, they return comparable normalized clustering scores and achieve better results than ClusterONE, MCODE, HC-PIN, and MOEPGA. By contrast, in Fig. 6d, some differences are observed among the three hierarchies on the GAVIN dataset. MOEPGA returns significantly better results than those of MCODE, but slightly worse results than those of HC-PIN.


                        Tables 5 and 6 give rise to the issue of why MCODE and HC-PIN achieve very high values for precision and clustering score in Fig. 6a and c but not for the normalized clustering score in Fig. 6b. Indeed, the two methods are highly accurate. However, these approaches can cover only a small portion of the PPI network.

Finally, we also test the ability of MOEPGA to identify small protein complexes. Identifying small protein complexes is not a common feature of all complex-detection methods. In fact, it is important to identify such complexes in PPI networks (Hanna and Zaki, 2014). For instance, among the 428 protein complexes included in the CYC2008 (Pu et al., 2009), 157 complexes consist of 2 or 3 proteins, accounting for 36.7%. Here, we use the same yeast datasets that were employed in the previous experiments and CYC2008 (Pu et al., 2009) is still used as the benchmark dataset. Results are shown in Table 7
                        . The table presents the advantage of MOEPGA in detecting small protein complexes in terms of the number of identified protein complexes as well as the Precision and fscore. From Tables 5–7 we can clearly find that MOEPGA is slightly difference on the small protein complexes identification and the others.

In conclusion, MOEPGA can identify many protein complexes using the DIP and GAVIN datasets and can achieve state-of-the-art performance. The experimental results show that MOEPGA is very useful in identifying protein complexes in PPI networks.

@&#CONCLUSIONS@&#

Protein complex identification is an important analysis method that enables us to uncover and understand the cellular organizations and biological functions in PPI networks. Generally, existing approaches mainly identify protein complexes by using a single network topological property, such as density, distance, and so on. However, a single objective makes it difficult to find more protein complexes. After analyzing the three network topological characteristic of benchmark protein complexes in PPI networks, we propose MOEPGA to identify protein complexes by integrating single network topological property. MOEPGA requires three parameters, namely, maximum iteration times MaxIter, mutation probability P
                     m, and selection probability P
                     s. We set MaxIter
                     =50, P
                     m
                     =0.1, and P
                     s
                     =0.9. MOEPGA obtained satisfactory experimental results. MOEPGA is implemented in C++, and all experiments are performed on an Intel Xeon(R) X5670 with 2.93GHz and 56GB RAM running Windows 7.0.

We compare the performance of our algorithm MOEPGA with that of several other algorithms based on single network topological property: MCODE, DPClus, NEMO, SPICi, HC-PIN, and ClusterONE. The experimental results show that MEOPGA can identify a greater number of predicted protein complexes and achieve the highest value of fscore. In addition, MOEPGA outperforms the MCODE and HC-PIN algorithms on the DIP dataset in terms of the normalized clustering score.

In the future, we will apply our approach to study other types of biological networks, such as transcriptional regulatory networks and metabolic networks. Furthermore, we also aim to apply the proposed method to study weighted biological networks further.

@&#ACKNOWLEDGMENTS@&#

This work is supported by National Natural Science Foundation of China (Grant no. 61474267) and Hunan Provincial Natural Science Foundation of China (Grant no. 13JJ2017)and Hunan Provincial Graduate Student Research Innovation Project (Grant no. CX2014B152). We are also grateful to Prahash Sheloker for sharing his source code.

Supplementary material related to this article can be found, in the online version, at http://dx.doi.org/10.1016/j.compbiolchem.2015.06.006.

The following are Supplementary data to this article:
                        
                           
                        
                     
                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

