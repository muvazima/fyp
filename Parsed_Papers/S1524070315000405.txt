@&#MAIN-TITLE@&#A two-stage approach to align two surfaces of deformable objects

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Align two partial overlapping surfaces of deformable objects.


                        
                        
                           
                           Deformation is divided into a single global rigid motion and local deformations.


                        
                        
                           
                           Combine probability approach and geometry approach to avoid deformation assumptions.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Registration

Deformation

Correspondences

Optimization

@&#ABSTRACT@&#


               
               
                  This paper introduces a new approach for non-rigid registration which is able to align two surfaces under large deformation. At the first stage, the two surfaces are remeshed to create two sub-meshes. Then, correspondences between the two sub-meshes are obtained by employing a robust probabilistic method. Reliable correspondences are used to find a global rigid transformation to bring the two surfaces closer. Using these correspondences and taking one sub-mesh as a deformation graph, the second stage applies a deformation model to align the two surfaces together. This stage solves for more correct correspondences as well as for a local transformation at each node simultaneously. With these two stages, the method deals robustly with large motion and preserves small details during the alignment process of the two surfaces. The efficiency of the method is demonstrated by comparing the alignment results it achieves with the results obtained by state-of-the-art methods.
               
            

@&#INTRODUCTION@&#

With the development of 3D scanning technology, recent scanners can capture accurate data at high frame rates. However, occlusion is an inevitable issue since only data in a limited part of an object is captured by each scan. So, obtaining a complete model of an object at any given point in time is achieved by assembling two or several frames together using registration methods. Current rigid registration methods effectively solve the alignment problem for rigid objects by globally describing the motion between two surfaces using a rotation matrix, a translation vector and/or a scaling factor. However, these methods are not efficient when partial data is acquired from an object under non-rigid movement and when the movement between two surfaces cannot be expressed simply by a single global transformation. In the case of non-rigid motion, each point in the scan must be moved by a specific transformation with constraints to maintain the coherence between this point and its neighbors. Compared to the case of rigid registration, the solution space of non-rigid registration is high-dimensional and the number of parameters depends on the selected model to describe the deformation between the two scans.
                  

To optimally align two surfaces in a non-rigid registration process, finding correct correspondences plays a fundamental role in the outcome of the algorithm. This is achieved very well for rigid registration by using 3D descriptors which are invariant under rigid motion. However, for a deformable object, employing such descriptors is not reliable due to the local deformation (bending and/or stretching) of the surface. To overcome this issue, some assumptions can be used. For instance, the motion between two surfaces may be considered as small, some artificial markers can be used, or the deformation may be considered as being approximately isometric. However, using one of these assumptions restricts the algorithms to a given class of data. Therefore, it is highly relevant to design a non-rigid registration algorithm that is not constrained by these assumptions to improve efficiency for practical applications.

In this paper we present a two-stage method to register two partially overlapping non-rigid surfaces, as shown in Fig. 1. These surfaces are represented as triangular meshes, which are the common output of many current scanners. Two sub-meshes of the two respective surfaces are created and their topologies are kept similar to those of the original surfaces in order to reduce the interpolation error associated with linear blending. In the first stage, a probability-based algorithm (CPD: coherent point drift) is used to find initial correspondences between the two sub-meshes by describing the deformation in an elastic manner. Wrong correspondences found by CPD are then eliminated to retain reliable correspondences before using singular value decomposition (SVD) to obtain one global rigid transformation T. In the second stage, under a general deformation model, a sub-mesh is used as a deformation graph in which each vertex is called a node. Because the deformation is elastic, each node is transformed into its corresponding point by an affine transformation under the influence of the movement of neighboring nodes. In addition, the obtained transformation T is used to bring the deformation graph closer to the target surface before running the optimization process. During optimization, the corresponding point of each node is refined by searching in or around a pre-defined region (potential region) on the target surface. Moreover, distances between the nodes and their corresponding points are also constrained to be as smooth as possible to adjust the movement of the deformation graph toward the target surface. Combined with a 3-cycle strategy in the optimization process, this approach converges to an optimal solution in a small number of iterations before the solution is used to interpolate the registration on the whole source surface.

The main contributions of the proposed method include:

                        
                           •
                           Automatic separation of the deformation between two surfaces of deformable objects into a single global rigid transformation and many local deformations. The obtained rigid transformation brings the deformation graph closer to the target surface. It not only accelerates the convergence of the optimization for local transformations but also prevents this process from becoming trapped in an incorrect minimum due to tangential drift in non-rigid registration.

Reliable correspondences between deformation graph and the target surface are obtained by combining a probability-based method and a geometry-based correspondence elimination process. These correspondences play a role as initial markers to allow the algorithm to solve for non-rigid registration of elastic deformation without user intervention, avoiding the aforementioned assumptions between the two surfaces.

A 3-cycle optimization process is proposed in which updated corresponding points are detected quickly in potential regions, the motion of the deformation graph toward the target surface is constrained more by a smoothed correspondence field and two distortion measures. So, the optimization converges toward the correct minimum and solves the non-rigid registration problem for challenging data sets.

The remainder of the paper is organized as follows: The related work and its limitation is discussed in Section 2. In Section 3, we describe the deformation model employed in our work. The first stage of the proposed method is addressed in Section 4 before moving to the second stage in Section 5. Section 6 shows the experimental results and discussion. The conclusion is drawn in Section 7.

@&#RELATED WORK@&#

By allowing the object to be non-rigid during the scanning process, the complexity of the calibration step can be reduced and applications can be more diverse such as modeling, recognition, dynamic reconstruction and animation. In contrast, the collected data becomes more complex to process in these applications. One such task, registering two scans of a deformable object is challenging because it requires solving for both global motion and local deformation during the alignment process. Many registration methods have been proposed to address this problem.

Applying the idea of the ICP (iterative closest point) algorithm [6,14,27,37], a variety of techniques were proposed for non-rigid registration. However, these methods are only effective when a good initial value is available or when the motion between the two surfaces is small. In [1,2,4,23,35,48], a template model, which has the same pose as the scanned data, provides a strong geometric prior for reconstructing high-quality models with automated hole-filling and noise removal. Moreover, user-defined markers can be used to prevent the optimization algorithm from becoming trapped in a local minimum. In [10,17,38], it is assumed that local deformation is small to validate local feature descriptors used for searching corresponding points.

When the motion between two scans is small, the noise level is negligible and the deformation is not large, registration methods designed for sequences acquired by real-time scanners can be used. In [31,41], registration is achieved by aggregating all scans into a 4D space–time surface and estimating inter-frame motion from the kinematic properties of this surface. Without computing correspondences explicitly, these algorithms do not require templates or artificial markers to facilitate the alignment. Developed from the work in [43], in [44], a hierarchical scheme is applied by aligning every two frames, merging them, then aligning every two pairs of frames, merging them, and so on until the entire sequence is assembled.

Some algorithms attempt to get rid of templates and artificial markers. Chang and Zwicker [12] use spin images to find correspondences before grouping transformations into clusters and then associating each transformation for each pair of points on the two surfaces. Because some transformations do not exist in the motion sampling process, some parts of the source surface miss a precise transformation to align correctly with the respective parts of the target surface. Employing the deformation model proposed by Sumner et al. [40], Li et al. [22] exploit a 2D parameterization of range scans to search corresponding points and guide the optimization to converge to an optimal minimum. Although this algorithm does not depend on any 3D feature descriptors, it is limited to depth images to search corresponding points. To improve the algorithm for its application to other digital representations, a template is used as prior knowledge and is combined with a dynamic sampling scheme to correctly align two surfaces and preserve fine-scale details [23]. To remove the dependency on templates, in the work [24], a hole filling method is applied to each surface before they are aligned. However, as in [22] and [23], the optimization can converge to an incorrect minimum when the motion between two surfaces is large. Consequently, 2D feature descriptors from color images are exploited to impose more constraints on the optimization process. When the motion between two surfaces is small, Papazov and Burschka [34] formulate the non-rigid registration problem as one of solving an ordinary differential equation (ODE) iteratively, which describes the motion between the two surfaces. In another work, Bonarrigo et al. [7] describe the transformation of each node by a rigid transformation and employ dual quaternion skinning to reduce the interpolation error between the reduced deformable model and the original data.

The methods in [28,46,47] are based on conformal mapping and minimize the maximal conformality distortion to register the two surfaces of the deformable objects. With some specified landmarks, these methods attempt to follow these constraints to find an appropriate mapping which leads to promising results. Currently, they are demonstrated on 3D face recognition and medical applications.

Other methods are based on probabilistic approaches to align the two surfaces. In [5], by formulating a Markov Random Field optimization that best fits the observed data and preserves the shape of the template, the method establishes a good correspondence assignment with a given template shape. The method is able to recover significant movements of articulated parts and non-rigid deformation when the geodesic distance between any two vertices is not changed before and after deformation, and one of the input shapes is a subset of the others. The method proposed by Myronenko and Song [32] fits Gaussian mixture model (GMM) centroids (source point set) to the data (target point set) by maximizing the likelihood and considers the registration of any two point sets as a probability density estimation problem. The GMM centroids are moved coherently as a group to preserve the topological structure of the point sets. Results show that this method outperforms another well-known method [15]. In a similar work, the algorithm proposed by Jian and Vemuri [18] minimizes a statistical discrepancy measure between two mixture models in which each model is a Gaussian mixture model and presents an input point set. However, a bottleneck of these methods is that they impose a large computational burden to identify correspondences when describing the relationship between each point of the first point set and each point of the second point set at each iteration during optimization (for more details, we refer the reader to [32]). Therefore, this approach is mostly applied to 2D data or small 3D datasets and needs to be improved in order to adapt to real-world scanned data.

To obtain the final alignment between two surfaces of deformable objects, identifying corresponding points plays an essential role in many non-rigid registration algorithms. Currently, the methods based on intrinsic metrics have become prominent to establish correspondences between deformable shapes. In [9,20,33,39,42], the correspondences are found by establishing an isometric map between the two surfaces of deformable objects. These algorithms assume that the geodesic distance between two points on the surface is preserved before and after the deformation. Because geodesic distance is sensitive to noise, topological changes, missing data and holes on the surface, a solution is to use other distance measures. Bronstein et al. [8] use the diffusion distance computed by averaging all paths connecting two points to eliminate the influence of noise and topological changes. Lipman et al. [26] claim that the biharmonic distance is better than the geodesic distance and the diffusion distance in many aspects including sensitivity to noise, topology changes, missing parts, and holes. (We refer the reader to [19] for a detailed discussion.)

Based on the deformation model proposed by Sumner et al. [40], our method should also identify corresponding points for nodes of the deformation graph during the optimization process. Therefore, a robust scheme for establishing such correspondences is desired. Methods for obtaining correspondences based on intrinsic geometry are robust for deformable surfaces for which issues such as missing data, hole existence, noise, topological changes are negligible. Such methods are suitable for applications such as shape retrieval, shape analysis, symmetry detection and mesh parameterization, but are less useful for non-rigid registration of surfaces in which these issues have to be considered carefully. Moreover, these methods require a high density of points to compute the intrinsic distance correctly. In contrast, the point density of the deformation graph that we use is very sparse. In this case, CPD is sufficient for our deformation graph. After the elimination of some incorrect correspondences found by CPD, the remaining correspondences are updated during the optimization process to ensure that the cost function converges correctly toward the global minimum. Another reason to extend the CPD approach is that, as mentioned in [11] and demonstrated in our experiments, CPD cannot properly align small details or abrupt changes between two parts on the two surfaces. This is because the smoothness of the deformation field of CPD remains global to the whole surface of the source point set during the deformation process. Consequently, the deformation field cannot change suddenly to align locally in regions of the source point set with small details or abrupt changes on the target point set. From the above discussion, through an effective scheme for optimizing the cost function, our method provides a bridge between probability-based approaches and extrinsic geometry-based approaches to obtain an optimal solution for non-rigid registration.

In non-rigid registration, a transformation is associated with each point of the source surface to move it toward the target surface. However, this problem rapidly becomes impractical since 12 degrees of freedom (dof) per each affine transformation must be computed. A reduced model of the source surface is preferred instead and interpolation is then applied on the reduced model. In this paper, we adopt the deformation model proposed by Sumner et al. [40]. For this model, a deformation graph is created by down-sampling the original surface (source surface). The deformation graph consists of nodes 
                           
                              
                                 g
                                 j
                              
                              ∈
                              
                                 R
                                 3
                              
                              ,
                              j
                              ∈
                              1
                              ⋯
                              m
                              ,
                           
                         and edges in which each node is associated with an affine transformation (a 3 × 3 matrix R
                        
                           j
                         and a 3 × 1 vector t
                        
                           j
                        ) and the connectivity between nodes indicates mutual influence. Under the influence of a node g
                        
                           j
                        , any point p in 
                           
                              R
                              3
                           
                         is moved to position 
                           
                              p
                              ˜
                           
                         according to:

                           
                              (1)
                              
                                 
                                    
                                       p
                                       ˜
                                    
                                    =
                                    
                                       R
                                       j
                                    
                                    
                                       (
                                       p
                                       −
                                       
                                          g
                                          j
                                       
                                       )
                                    
                                    +
                                    
                                       g
                                       j
                                    
                                    +
                                    
                                       t
                                       j
                                    
                                 
                              
                           
                        When a point v
                        
                           i
                         on the source surface is under the influence of a set of nodes, its deformed position 
                           
                              
                                 v
                                 ˜
                              
                              i
                           
                         is computed using linear blending as follows:

                           
                              (2)
                              
                                 
                                    
                                       
                                          v
                                          ˜
                                       
                                       i
                                    
                                    =
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          N
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       
                                          w
                                          ¯
                                       
                                       k
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    
                                       [
                                       
                                          R
                                          k
                                       
                                       
                                          (
                                          
                                             v
                                             i
                                          
                                          −
                                          
                                             g
                                             k
                                          
                                          )
                                       
                                       +
                                       
                                          g
                                          k
                                       
                                       +
                                       
                                          t
                                          k
                                       
                                       ]
                                    
                                 
                              
                           
                        where 
                           
                              N
                              (
                              i
                              )
                           
                         is a set of nodes surrounding v
                        
                           i
                        , weight 
                           
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         indicates the contribution of each individual node in the blended transformation of 
                           
                              
                              
                                 
                                    v
                                    ˜
                                 
                                 i
                              
                           
                         . Contrarily to the original equation, we do not fix the number of surrounding nodes for each v
                        
                           i
                        . A detailed explanation of this weight is given in Section 4.2.

Once the deformation graph has been specified (see Section 3.2 for details), the optimization considers per-node affine transformations as unknowns for the deformation. To properly preserve the detail of the surfaces, a deviation of each transformation from a pure rigid motion is penalized in the first energy term E
                        rot:

                           
                              (3)
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          rot
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       Rot
                                    
                                    
                                       (
                                       
                                          R
                                          j
                                       
                                       )
                                    
                                 
                              
                           
                        where

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                Rot
                                             
                                             (
                                             R
                                             )
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      1
                                                   
                                                   ·
                                                   
                                                      c
                                                      2
                                                   
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      1
                                                   
                                                   ·
                                                   
                                                      c
                                                      3
                                                   
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      2
                                                   
                                                   ·
                                                   
                                                      c
                                                      3
                                                   
                                                   )
                                                
                                                2
                                             
                                             +
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      1
                                                   
                                                   ·
                                                   
                                                      c
                                                      1
                                                   
                                                   −
                                                   1
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      2
                                                   
                                                   ·
                                                   
                                                      c
                                                      2
                                                   
                                                   −
                                                   1
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   (
                                                   
                                                      c
                                                      3
                                                   
                                                   ·
                                                   
                                                      c
                                                      3
                                                   
                                                   −
                                                   1
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        and c
                        1, c
                        2 and c
                        3 are column vectors of R
                        
                           j
                        .

To maintain the smoothness of the deformation, the affine transformations of adjacent graph nodes should agree with each other. This is expressed by Ereg:

                           
                              (4)
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          reg
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          N
                                          (
                                          j
                                          )
                                       
                                    
                                    
                                       
                                          w
                                          ¯
                                       
                                       k
                                    
                                    
                                       (
                                       j
                                       )
                                    
                                    ∥
                                    
                                       R
                                       j
                                    
                                    
                                       (
                                       
                                          g
                                          k
                                       
                                       −
                                       
                                          g
                                          j
                                       
                                       )
                                    
                                    +
                                    
                                       g
                                       j
                                    
                                    +
                                    
                                       t
                                       j
                                    
                                    −
                                    
                                       (
                                       
                                          g
                                          k
                                       
                                       +
                                       
                                          t
                                          k
                                       
                                       )
                                    
                                    
                                       ∥
                                       
                                          2
                                       
                                       2
                                    
                                 
                              
                           
                        where 
                           
                              N
                              (
                              j
                              )
                           
                         is a set of neighbors of node j and weight 
                           
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 j
                                 )
                              
                           
                         is proportional to the degree of overlap between node j and node k.

To ensure that the deformation graph will move toward the target surface, the two energy terms Erot and Ereg are combined with a fitting constraint so that the deformation proceeds in a natural manner, preserves the topology of the source surface and aligns well with the target surface. For this goal, the third energy term minimizes the deviation of each deformed point from its corresponding point.

                           
                              (5)
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          pos
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       M
                                    
                                    ∥
                                    
                                       
                                          v
                                          ˜
                                       
                                       i
                                    
                                    −
                                    
                                       u
                                       i
                                    
                                    
                                       ∥
                                       
                                          2
                                       
                                       2
                                    
                                 
                              
                           
                        where 
                           
                              
                                 v
                                 ˜
                              
                              i
                           
                         is the deformed point of v
                        
                           i
                         according to Eq. (2) and u
                        
                           i
                         is its corresponding point on the target surface.


                        Fig. 2
                         illustrates the role of the 3 energy terms in Sumner’s deformation model. The cost function for the optimization process is formulated as follows:

                           
                              (6)
                              
                                 
                                    
                                       E
                                    
                                    =
                                    
                                       w
                                       
                                          rot
                                       
                                    
                                    
                                       
                                          E
                                       
                                       
                                          rot
                                       
                                    
                                    +
                                    
                                       w
                                       
                                          reg
                                       
                                    
                                    
                                       
                                          E
                                       
                                       
                                          reg
                                       
                                    
                                    +
                                    
                                       w
                                       
                                          pos
                                       
                                    
                                    
                                       
                                          E
                                       
                                       
                                          pos
                                       
                                    
                                 
                              
                           
                        where {w
                        rot, w
                        reg, w
                        pos} refers to the weights of the contribution of each energy term.

With a deformation graph of m nodes, the optimization for the cost function E has to identify optimal values for 12m unknowns. All unknowns are stacked into a column vector z and the optimal value of z is obtained by our non-rigid alignment strategy combined with the Levenberg–Marquardt algorithm [29].

In the model proposed by Sumner et al. [40], the structure of the deformation graph plays an essential role in the deformation process. In [22,34], the connectivity between nodes of the deformation graph is based on a pre-defined radius without considering the topology of the original surface. This can cause errors at the interpolation step from the deformation graph to the original surface if the number of nodes is not large enough. Increasing the number of nodes is not a practical solution since the number of parameters also increases and the optimization process becomes more complex. To reduce the interpolation error and preserve small details of the original surface, Li et al. [23] update nodes and their links using a dynamic sampling scheme during a complex optimization process. In our method, we aim to reduce both the number of nodes and the complexity of the optimization process while still keeping the interpolation error small. To achieve this, a topology-aware sampling scheme is employed.

Based on the fidelity criterion described in [3], our deformation graph approximates the geometry of the original surface as closely as possible while keeping the number of nodes small. Given this goal, we use the remeshing method proposed by Peyré and Cohen [36], which is based on the Fast Marching algorithm (FMA) [21] (Fig. 1, block S). The FMA enables the non-linear Eikonal equation 
                           
                              ∥
                              ∇
                              U
                              (
                              p
                              )
                              ∥
                              =
                              P
                              (
                              p
                              )
                           
                         to be solved, where U is the distance function to a given set of points, and 
                           
                              F
                              =
                              1
                              /
                              P
                           
                         is the speed of the front propagation. In our case, the fronts propagate at a constant speed 
                           
                              F
                              =
                              1
                           
                         since we create a uniform deformation graph.

In the first step, this method selects a point p
                        1 randomly on the original surface and computes geodesic distances based on FMA from p
                        1 to other points v
                        
                           i
                         on the whole surface to create a distance map U
                        1. Next, a second point p
                        2 that has the largest value on the map U
                        1 is selected. A new distance map U
                        2 is computed based on the fact that 
                           
                              
                                 U
                                 2
                              
                              
                                 (
                                 p
                                 )
                              
                              =
                              m
                              i
                              n
                              
                                 (
                                 
                                    U
                                    1
                                 
                                 
                                    (
                                    p
                                    )
                                 
                                 ,
                                 
                                    U
                                    
                                       p
                                       2
                                    
                                 
                                 
                                    (
                                    p
                                    )
                                 
                                 )
                              
                              ,
                           
                         where U
                        
                           p2 is the distance map of p
                        2. This point selection process continues until a given number of points is reached.

After obtaining a point set S
                        
                           m
                         = {p1, p2,…, pm
                        }, the second step of the method determines which points should be linked to create a new triangular surface. To do this, during the above point distribution process, we keep track of saddle points which are points s that satisfy two constraints. First, when the value of U
                        
                           s
                         is set by FMA, two fronts originating from different basis points p
                        
                           i
                         and p
                        
                           j
                         must meet for the first time at s. Secondly, adding the edge [p
                        
                           i
                        , p
                        
                           j
                        ] to the triangular surface must keep the triangulation valid (e.g. the edge must have at most two adjacent faces). Then, the set of saddle points indicates which points should be linked together so as to obtain a valid triangular surface.

Using this method, the deformation graph 
                           G
                         of our method is created such that the connectivity between the nodes is based on the geometry at each local region of the original surface rather than based on a pre-defined radius or a given number of neighbors. Note that, in our case, the points of the deformation graph are also the points of the original surface since we do not use point interpolation during this remeshing process. Fig. 3
                         shows remeshing process to generate the deformation graph of an arm surface.

According to Eq. (5), given a point set on the source surface, it is required to determine corresponding points on the target surface in order to bring the deformation graph toward the target surface. Obtaining the corresponding points using a closest point search is only acceptable when the motion between the two surfaces is small or an initial value is available. When these conditions are not met, closest point search may identify incorrect correspondences and cause the deformation graph to be destroyed and the optimization to converge to a local minimum that is far from the correct solution. To address this issue, our method determines potential regions in which the corresponding points should exist before the optimization process applies a refinement step at each iteration to improve the accuracy of these correspondences.

Given the two surfaces 
                           
                              S
                              ,
                              T
                              ,
                           
                         the front propagation algorithm in Section 3.2 is used to create two sub-meshes 
                           Y
                         and 
                           X
                         respectively. With a small number of points y
                        
                           j
                        , x
                        
                           t
                        
                        
                           
                              (
                              j
                              =
                              1
                              …
                              m
                              ;
                              t
                              =
                              1
                              …
                              
                                 m
                                 ′
                              
                              )
                           
                         on these two sub-meshes, applying CPD is sufficient to establish initial correspondences (Fig. 1, block 1A). The CPD algorithm defines the correspondence probability between a point y
                        
                           j
                         (centroid) on 
                           Y
                         and a point x
                        
                           t
                         (data point) on 
                           X
                         as the posterior probability of the GMM centroid given the data point 
                           
                              p
                              
                                 (
                                 
                                    y
                                    j
                                 
                                 ∣
                                 
                                    x
                                    t
                                 
                                 )
                              
                              =
                              p
                              
                                 (
                                 
                                    y
                                    j
                                 
                                 )
                              
                              p
                              
                                 (
                                 
                                    x
                                    t
                                 
                                 ∣
                                 
                                    y
                                    j
                                 
                                 )
                              
                              /
                              p
                              
                                 (
                                 
                                    x
                                    t
                                 
                                 )
                              
                           
                        . Because the number of points on 
                           Y
                         and 
                           X
                         is different, a point on 
                           Y
                         can thus have more than one corresponding point on 
                           X
                        . We need to determine which points are actual correspondences (Fig. 1, block 1B).

CPD is used to deform sub-mesh 
                           Y
                         and align it with sub-mesh 
                           X
                        . This process provides a set of correspondences C
                        0YX
                        . In C
                        0YX
                        , in addition to correct correspondences, there are many incorrect ones that must be removed. At each corresponding point x
                        
                           t
                        , we select incident facets to this point on the original mesh 
                           T
                        . We then compute the Euclidean distance from the deformed point 
                           
                              
                                 y
                                 ˜
                              
                              j
                           
                         to these facets, select the smallest distance and store it in a set of distances (distance distribution). We do not directly compute the Euclidean distance between the deformed point 
                           
                              
                                 y
                                 ˜
                              
                              j
                           
                         and its corresponding point x
                        
                           t
                         because the point density of sub-meshes 
                           Y
                         and 
                           X
                         is very sparse and a correct correspondence can have a large distance. Consequently, the direct distance does not reflect the distance distribution correctly.

There are two cases for which some distance values may differ significantly from other distance values in the distribution. Because CPD can provide incorrect alignment of some patches between the two sub-meshes, some correspondences belonging to these patches will be erroneous and thus result in large distances. In addition, due to partial overlap between the two sub-meshes, some patches on 
                           Y
                         do not exist on 
                           
                              X
                              ,
                           
                         and vice-versa. However, CPD always provides a corresponding point for each point on these patches, so these correspondences are also erroneous and result in large distance values. In both cases, these large values are treated as outliers in the distance distribution. In the first step, to remove these outliers, a standard statistical procedure is to determine the “fourth spread” of the distance distribution [16]:

                           
                              (7)
                              
                                 
                                    
                                       f
                                       s
                                    
                                    =
                                    
                                       m
                                       u
                                    
                                    −
                                    
                                       m
                                       l
                                    
                                 
                              
                           
                        where mu
                         is median of the largest 
                           
                              L
                              /
                              2
                           
                         measurements, ml
                         is median of the smallest 
                           
                              L
                              /
                              2
                           
                         measurements and 
                           L
                         is the number of distance values (note that 
                           
                              L
                              =
                              m
                           
                        ).

Statistically, moderate outliers are 1.5fs
                         units above the upper fourth, and extreme outliers are 3fs
                         units above the upper fourth. In our experiments, we remove a correspondence if its distance is larger than a moderate threshold 
                           
                              
                                 T
                                 d
                              
                              =
                              1.5
                              
                                 f
                                 s
                              
                              +
                              
                                 m
                                 u
                              
                           
                        .

Outlier detection in the distance distribution can eliminate some wrong correspondences, but some other incorrect correspondences still remain because they have small distance values. To enhance outlier detection even more, normal-based consistency is applied in a second step. Specifically, we compute the normal vector at each point on the deformed sub-mesh 
                           
                              Y
                              ˜
                           
                         by applying the method of Chen and Wu [13] which is efficient for meshes with a sparse point density. If the angle between normal vectors of the deformed point and its corresponding point is larger than 15°, the correspondence is removed from the set C
                        0YX
                        . The remaining correspondences are stored in a set C
                        1YX
                        . Normal-based outlier detection is efficient when the sub-mesh 
                           Y
                         is deformed incorrectly to align with the sub-mesh 
                           X
                        . For example, CPD attempts to align the upper arm on the sub-mesh 
                           Y
                         and the lower arm on the sub-mesh 
                           X
                         as shown in Fig. 15(c).

Although the above two steps can remove many erroneous correspondences, incorrect ones still exist since these steps are based on explicit geometry in local regions of the meshes and the influence of noise can cause errors in the computation. In the third step, we detect the incorrect correspondences in a reverse process. Maintaining all parameters the same as in the forward process – deforming and aligning 
                           Y
                         with 
                           
                              X
                              ,
                           
                         in the reverse process, we deform and align 
                           X
                         with 
                           Y
                        . Similarly to the forward process, we obtain a set of correspondences C
                        
                           XY
                        . Then, we compare each pair of correspondences between C
                        1YX
                         and C
                        
                           XY
                        . A correspondence y
                        
                           j
                         ↔ x
                        
                           t
                         in C
                        1YX
                         is accepted as a correct one if a correspondence x
                        
                           t
                         ↔ y
                        
                           j
                         also exists in C
                        
                           XY
                        . We store such correspondences in another set C
                        
                           cYX
                         and use them to determine potential regions for the optimization process in the second stage.

We do not throw away the remaining correspondences, but store them in a set C
                        2YX
                        . CPD can identify two or more corresponding points on 
                           X
                         for each point on 
                           Y
                        . Therefore, if a corresponding point x
                        
                           t
                         in set C
                        2YX
                         also exists in set C
                        
                           cYX
                        , its correspondence is considered as an incorrect one and it is removed from set C
                        2YX
                        . The remaining correspondences in the set C
                        2YX
                         will also be used to determine the potential regions. Some correspondences in sets C
                        
                           cYX
                        , C
                        2YX
                         of hand model is shown in Fig. 4
                        .

In order to apply the deformation model described in Section 3.1, a deformation graph is required for the alignment process between the source surface 
                           S
                         and the target surface 
                           T
                        . For this, we use sub-mesh 
                           Y
                         as a deformation graph 
                           G
                        . More specifically, the vertices of this sub-mesh become nodes g
                        
                           j
                         of the deformation graph, the edges between two vertices are links and define the mutual influence between two respective nodes. The number of edges at each node depends on the local geometry and defines the number of neighboring nodes 
                           
                              N
                              (
                              j
                              )
                           
                        . The influence radius 
                           
                              r
                              j
                           
                         of each node is defined as the maximum length of edges between the node and its 1-ring neighbors.

Some points v
                        
                           i
                         (called enhancing points) are selected on the source surface 
                           S
                         and inserted in the fitting energy term (Eq. (5)). For this purpose, around the centroid of each facet △
                           i
                         of 
                           
                              G
                              ,
                           
                         we select an enhancing point v
                        
                           i
                         on 
                           S
                         as the nearest point to this centroid. The number of enhancing points v
                        
                           i
                         is thus equal to the number of facets △
                           i
                         in 
                           G
                         (Fig. 3(d)). With such an enhancing point v
                        
                           i
                        , transformations of three nodes of the facet △
                           i
                         always influence this point’s transformation. Moreover, at each node g
                        
                           j
                         of this facet, we compute the distance from v
                        
                           i
                         to the 1-ring neighbors g
                        
                           k
                         of g
                        
                           j
                        . If the distance is smaller than the influence radius 
                           
                              
                                 r
                                 k
                              
                              ,
                           
                         then g
                        
                           k
                         is included in the set of influence nodes 
                           
                              N
                              (
                              i
                              )
                           
                         of v
                        
                           i
                        . Fig. 5
                        (a) shows influence regions of nodes on an enhancing point.

Given the number of nodes 
                           
                              N
                              (
                              j
                              )
                           
                         and 
                           
                              N
                              (
                              i
                              )
                           
                         that will impact the node’s transformation and the point’s transformation respectively, the two weights 
                           
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 j
                                 )
                              
                           
                         in Eq. (4) and 
                           
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         in Eq. (2) are determined by 
                           
                              
                                 w
                                 k
                              
                              
                                 (
                                 j
                                 )
                              
                              =
                              
                                 
                                    (
                                    1
                                    −
                                    
                                       d
                                       j
                                       2
                                    
                                    /
                                    
                                       
                                          (
                                          
                                             r
                                             j
                                          
                                          +
                                          
                                             r
                                             k
                                          
                                          )
                                       
                                       2
                                    
                                    )
                                 
                                 3
                              
                              ,
                           
                        
                        
                           
                              
                                 w
                                 k
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              =
                              
                                 
                                    (
                                    1
                                    −
                                    
                                       d
                                       i
                                       2
                                    
                                    /
                                    
                                       r
                                       k
                                       2
                                    
                                    )
                                 
                                 3
                              
                              ,
                           
                         where dj
                         is the distance from node j to node k, di
                         is the distance from point v
                        
                           i
                         to node k; rj, rk
                         are the influence radii of nodes g
                        
                           j
                        , g
                        
                           k
                        . The two weights wk
                        (j) and wk
                        (v
                        
                           i
                        ) are then normalized to sum to one according to the number of influence nodes at each node g
                        
                           j
                         or each point v
                        
                           i
                         respectively (denoted as 
                           
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 j
                                 )
                              
                              ,
                              
                                 
                                    w
                                    ¯
                                 
                                 k
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                        ).

After determining the manner in which to transform each node and each point under the influence of surrounding nodes, we can apply the deformation model and run the optimization in order to align the deformation graph to the target surface. For large rigid transformations as well as large deformation, a robust correspondence searching scheme is required to replace the traditional closest point-based method to guide the optimization to converge toward the global minimum without using any assumption on the two surfaces. To achieve this, we first determine potential regions on the target surface 
                           T
                         where corresponding points 
                           
                              
                                 u
                                 i
                                 ′
                              
                              s
                           
                         for 
                           
                              
                                 v
                                 i
                                 ′
                              
                              s
                           
                         may exist (Fig. 1, block 1C). Note that the correspondence sets C
                        
                           cYX
                         and C
                        2YX
                         are now referred to as C
                        
                           cGX
                         and C
                        2GX
                         respectively-correspondences between the deformation graph 
                           G
                         and the sub-mesh 
                           X
                        . At each enhancing point v
                        
                           i
                         on 
                           
                              S
                              ,
                           
                         we check the three nodes (vertices) of facet △
                           i
                         of 
                           G
                         to determine whether or not they have corresponding points in the sets C
                        
                           cGX
                         and C
                        2GX
                         to identify potential regions on the target surface 
                           T
                        .

                           
                              •
                              In the first case, if all three nodes have respective corresponding points, potential region 
                                    
                                       A
                                       
                                          a
                                          i
                                       
                                    
                                  on 
                                    T
                                  for searching a corresponding point u
                                 
                                    i
                                  of v
                                 
                                    i
                                  is limited in a sphere whose center is at the centroid of the three corresponding points of the three nodes and the radius is computed based on the maximum distance hai
                                  from this centroid to the three corresponding points, 
                                    
                                       
                                          R
                                          
                                             a
                                             i
                                          
                                       
                                       =
                                       ρ
                                       *
                                       
                                          h
                                          
                                             a
                                             i
                                          
                                       
                                    
                                  where ρ is equal to 1.5 in our experiments.

In the second case, only two nodes have respective corresponding points among three nodes, the potential region 
                                    
                                       A
                                       
                                          b
                                          i
                                       
                                    
                                  is based on a sphere whose center is the center of the line connecting the two corresponding points of nodes, and its radius is computed using length hbi
                                  of this line, 
                                    
                                       
                                          R
                                          
                                             b
                                             i
                                          
                                       
                                       =
                                       ρ
                                       *
                                       
                                          h
                                          
                                             b
                                             i
                                          
                                       
                                    
                                 .

If there is only one node having the corresponding point, the sphere for the potential region 
                                    
                                       A
                                       
                                          c
                                          i
                                       
                                    
                                  has its center at the corresponding point and the radius 
                                    
                                       
                                          R
                                          
                                             c
                                             i
                                          
                                       
                                       =
                                       ρ
                                       *
                                       
                                          h
                                          
                                             c
                                             i
                                          
                                       
                                       ,
                                    
                                  where hci
                                  is the influence radius of this node.

Finally, when all three nodes do not have corresponding points, instead of searching a corresponding point for v
                                 
                                    i
                                  purely based on the closest point on the whole target surface 
                                    
                                       T
                                       ,
                                    
                                  we determine the nearest node g
                                 
                                    k
                                  for v
                                 
                                    i
                                  which has a corresponding point on 
                                    T
                                 . The center of the sphere is at the corresponding point of g
                                 
                                    k
                                 , the radius is chosen based on the distance hdi
                                  from v
                                 
                                    i
                                  to the node g
                                 
                                    k
                                 , 
                                    
                                       
                                          R
                                          
                                             d
                                             i
                                          
                                       
                                       =
                                       ρ
                                       *
                                       
                                          h
                                          
                                             d
                                             i
                                          
                                       
                                    
                                 . To eliminate some redundant points, the points from the center of the sphere to a radius 
                                    
                                       R
                                       =
                                       0.5
                                       *
                                       
                                          h
                                          
                                             d
                                             i
                                          
                                       
                                    
                                  are not included in potential region 
                                    
                                       A
                                       
                                          d
                                          i
                                       
                                    
                                  in this case. Fig. 5(b) shows the potential regions for the four different cases.

Generally, the motion between the two surfaces 
                           S
                         and 
                           T
                         consists of global rigid motion and non-rigid deformation (stretching, bending, bulging for example). When the motion between the two surfaces is large, tangential drift, a common issue in non-rigid registration, can cause misalignment because the source surface slides on the target surface instead of aligning with it. To solve this issue and to benefit from initial correspondences, we bring the two surfaces closer before running the optimization process. With the correspondences in set C
                        
                           cGX
                        , which are obtained by inspecting their relation based on both local geometry and a globally reverse alignment, SVD is used to obtain a rigid transformation between the two surfaces (Fig. 1, block 1D). One example of such a rigid transformation is shown in Fig. 12(b).

After applying the steps in the first stage, we can proceed with the optimization of the alignment. However, determining the potential regions and bringing the two surfaces closer by a rigid transformation only prevents the optimization of our method from converging toward the wrong minimum. While almost all potential regions contain correct corresponding points for enhancing points 
                        
                           
                              v
                              i
                              ′
                           
                           s
                        
                      , a few of these regions may not contain any correct corresponding point. The search in the regions 
                        
                           
                              A
                              
                                 c
                                 i
                              
                           
                           ,
                           
                              A
                              
                                 d
                                 i
                              
                           
                        
                      is the most vulnerable since these regions are obtained from just a single corresponding point of a node. If this node is in the set C
                     2GX
                     , its corresponding point may be incorrect. To eliminate such incorrect corresponding points of 
                        
                           
                              v
                              i
                              ′
                           
                           s
                           ,
                        
                      each corresponding point u
                     
                        i
                      is updated after it has been selected (Fig. 1, block 2A) when searching a closest point in the potential region at each iteration n of the optimization process. To achieve this, we employ the procedure proposed by Papazov and Burschka [34] to smooth the correspondences at each iteration n of the optimization process (Fig. 1, block 2B). The corresponding points 
                        
                           
                              u
                              i
                              ′
                           
                           s
                        
                      are updated on the target surface in order to form a smooth correspondence field 
                        
                           f
                           :
                           S
                           →
                           
                              R
                              3
                           
                        
                     . The smoothing procedure at each iteration n of the optimization process minimizes the following energy term:

                        
                           (8)
                           
                              
                                 
                                    
                                       E
                                    
                                    
                                       s
                                    
                                 
                                 
                                    (
                                    f
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    M
                                 
                                 ∥
                                 
                                    f
                                    
                                       (
                                       
                                          v
                                          i
                                          n
                                       
                                       )
                                    
                                    −
                                    
                                       f
                                       ¯
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                          n
                                       
                                       )
                                    
                                 
                                 
                                    ∥
                                    
                                       2
                                    
                                    2
                                 
                              
                           
                        
                     where 
                        
                           f
                           
                              (
                              
                                 v
                                 i
                                 n
                              
                              )
                           
                           =
                           
                              u
                              i
                           
                           −
                           
                              v
                              i
                              n
                           
                        
                      and 
                        
                           
                              f
                              ¯
                           
                           
                              (
                              
                                 v
                                 i
                                 n
                              
                              )
                           
                           =
                           
                              1
                              
                                 N
                                 i
                              
                           
                           
                              ∑
                              
                                 k
                                 ∈
                                 
                                    A
                                    i
                                 
                              
                           
                           f
                           
                              (
                              
                                 v
                                 k
                                 n
                              
                              )
                           
                        
                      is the mean of f over Ni
                      neighbors of u
                     
                        i
                     , 
                        
                           
                              v
                              i
                              n
                           
                           ,
                           
                              v
                              k
                              n
                           
                        
                      are enhancing points at the nth iteration, 
                        M
                      is the number of enhancing points.

In the first iteration l
                     0 of the smoothing procedure, we find a corresponding point u
                     
                        i
                      in the respective potential region. At the next iterations l, for the potential regions
                     
                        
                           
                              A
                              
                                 c
                                 i
                              
                           
                           ,
                           
                              A
                              
                                 d
                                 i
                              
                           
                           ,
                        
                      a corresponding point is found by searching in a new region determined by a sphere whose center is at the previous corresponding point and whose radius is equal to the maximum influence radius 
                        
                           r
                           
                              m
                              a
                              x
                           
                        
                      of nodes. While the regions 
                        
                           
                              A
                              
                                 c
                                 i
                              
                           
                           ,
                           
                              A
                              
                                 d
                                 i
                              
                           
                        
                      are updated during the smoothing procedure, regions 
                        
                           
                              A
                              
                                 a
                                 i
                              
                           
                           ,
                           
                              A
                              
                                 b
                                 i
                              
                           
                        
                      remain unchanged. Therefore, in contrast to the original procedure described in [34] , in our case, this process does not terminate with the condition 
                        
                           
                              
                                 E
                              
                              
                                 s
                              
                           
                           
                              (
                              
                                 f
                                 
                                    l
                                    +
                                    1
                                 
                              
                              )
                           
                           =
                           
                              
                                 E
                              
                              
                                 s
                              
                           
                           
                              (
                              
                                 f
                                 l
                              
                              )
                           
                           ,
                        
                      but rather when 
                        
                           
                              
                                 E
                              
                              
                                 s
                              
                           
                           
                              (
                              
                                 f
                                 
                                    l
                                    +
                                    1
                                 
                              
                              )
                           
                           >
                           
                              
                                 E
                              
                              
                                 s
                              
                           
                           
                              (
                              
                                 f
                                 l
                              
                              )
                           
                        
                      or when the maximum number of iterations is reached (10 in our experiments). Fig. 6
                      shows correspondences between the two surfaces before and after smoothing.

Although we already impose many constraints to bring the two surfaces together, these constraints cannot solve the missing data issue between the two surfaces. In this case, there are some enhancing points which do not have any correct corresponding point due to partial overlap between the two surfaces or due to the presence of holes. Searching for correspondences in such potential regions provides completely incorrect corresponding points 
                        
                           
                              u
                              i
                              ′
                           
                           s
                        
                      and causes distortion on the deformation graph. So, we detect such enhancing points and do not include them in the fitting energy term (Eq. (5)). The following two measures are employed to detect the distortion (Fig. 1, block 2C).

First, at each node g
                     
                        j
                      of the deformation graph, we measure the distortion before and after this node and its neighbors are deformed by using the area of facets incident to this node:

                        
                           (9)
                           
                              
                                 
                                    
                                       M
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    1
                                    
                                       |
                                       F
                                       (
                                       j
                                       )
                                       |
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       F
                                       (
                                       j
                                       )
                                    
                                 
                                 
                                    
                                       
                                          |
                                       
                                       
                                          a
                                          
                                             j
                                             k
                                          
                                          n
                                       
                                       −
                                       
                                          a
                                          
                                             j
                                             k
                                          
                                          0
                                       
                                       
                                          |
                                       
                                    
                                    
                                       a
                                       
                                          j
                                          k
                                       
                                       0
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              a
                              
                                 j
                                 k
                              
                              0
                           
                           ,
                           
                              a
                              
                                 j
                                 k
                              
                              n
                           
                        
                      are respective areas of the incident facet △
                        k
                      before deformation and at iteration n and 
                        
                           F
                           (
                           j
                           )
                        
                      is the set of indecent facets of this node.

Secondly, at each enhancing point, we use a second distortion measure M2 defined as:

                        
                           (10)
                           
                              
                                 
                                    
                                       M
                                    
                                    2
                                 
                                 =
                                 
                                    1
                                    
                                       |
                                       e
                                       (
                                       i
                                       )
                                       |
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       e
                                       (
                                       i
                                       )
                                    
                                 
                                 
                                    
                                       
                                          |
                                       
                                       
                                          d
                                          
                                             i
                                             k
                                          
                                          n
                                       
                                       −
                                       
                                          d
                                          
                                             i
                                             k
                                          
                                          0
                                       
                                       
                                          |
                                       
                                    
                                    
                                       d
                                       
                                          i
                                          k
                                       
                                       0
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              d
                              
                                 i
                                 k
                              
                              0
                           
                           ,
                           
                              d
                              
                                 i
                                 k
                              
                              n
                           
                        
                      are distances between the enhancing point v
                     
                        i
                      and its neighbor v
                     
                        k
                      before deformation and at iteration n and e(i) is the set of neighboring points.
                  

If the value of M1 for node g
                     
                        j
                      is larger than a threshold T
                     
                        M1, the enhancing points in incident facets are transformed without the influence of their corresponding points. The distortion detection is also computed at each enhancing point when its measure M2 exceeds a threshold T
                     
                        M2.

The value of T
                     
                        M1 is not constant but depends on the data as well as on the node density of the deformation graph. We use the deformed sub-mesh 
                        
                           Y
                           ′
                        
                      in order to estimate a value for T
                     
                        M1. Specifically, at each point y
                     
                        j
                      (which is also the node g
                     
                        j
                     ), the value measuring the distortion between the sub-mesh 
                        Y
                      and its deformed version 
                        
                           Y
                           ′
                        
                      is computed with Eq. (9). Among these values, an initial value t
                     
                        M1 is obtained by employing the “fourth spread” scheme in Eq. (7). The value of T
                     
                        M1 is in the range ± 10% of t
                     
                        M1. Choosing the initial value t
                     
                        M2 for T
                     
                        M2 is performed in a similar manner where centroids of facets are used to measure the distortion between 
                        Y
                      and 
                        
                           Y
                           ′
                        
                     . The selection of T
                     
                        M1 and T
                     
                        M2 is a trade-off between convergence speed of the optimization process and smoothness of the deformation.

We begin the optimization process by setting 
                        
                           
                              w
                              
                                 rot
                              
                           
                           =
                           100
                           ,
                        
                     
                     
                        
                           
                              w
                              
                                 reg
                              
                           
                           =
                           1
                           ,
                        
                     
                     
                        
                           
                              w
                              
                                 pos
                              
                           
                           =
                           1
                        
                      in Eq. (6) (Fig. 1, block 2D). At each iteration n of the Levenberg–Marquardt algorithm, the contribution to the third energy term Epos depends on weights w
                     1pos of enhancing points, as shown in Table 1. These weights are different by considering how corresponding points 
                        
                           
                              u
                              i
                              ′
                           
                           s
                        
                      are identified from initial correspondence sets C
                     
                        cGX
                     , C
                     2GX
                     . If a corresponding point u
                     
                        i
                      of an enhancing point v
                     
                        i
                      is found based on the potential regions
                     
                        
                           A
                           
                              a
                              i
                           
                        
                      or 
                        
                           
                              A
                              
                                 b
                                 i
                              
                           
                           ,
                        
                      their final weight in the third energy term is w
                     pos*w
                     1pos. If the corresponding point is obtained based on the potential regions
                     
                        
                           A
                           
                              c
                              i
                           
                        
                      or 
                        
                           
                              A
                              
                                 d
                                 i
                              
                           
                           ,
                        
                      the final weight is w
                     pos*w
                     1pos*w
                     2pos in which the value w
                     2pos is computed as 
                        
                           
                              w
                              
                                 2
                                 pos
                              
                           
                           =
                           
                              (
                              1
                              −
                              α
                              )
                           
                           
                              μ
                              1
                           
                           +
                           α
                           *
                           
                              μ
                              2
                           
                        
                      (
                        
                           α
                           =
                           0.3
                        
                      in our experiments). The value of μ
                     1 is computed from the distance γi
                      between the deformed enhancing point v
                     
                        i
                      and its corresponding point u
                     
                        i
                     :

                        
                           (11)
                           
                              
                                 
                                    μ
                                    1
                                 
                                 =
                                 2
                                 
                                    
                                       (
                                       
                                          
                                             γ
                                             i
                                          
                                          
                                             γ
                                             
                                                m
                                                a
                                                x
                                             
                                          
                                       
                                       )
                                    
                                    3
                                 
                                 −
                                 3
                                 
                                    
                                       (
                                       
                                          
                                             γ
                                             i
                                          
                                          
                                             γ
                                             
                                                m
                                                a
                                                x
                                             
                                          
                                       
                                       )
                                    
                                    2
                                 
                                 +
                                 1
                              
                           
                        
                     where γmax
                      is the maximum distance among 
                        
                           
                              γ
                              i
                              ′
                           
                           s
                        
                      after the correspondences are smoothed. The value of μ
                     2 is based on the consistency between the transformed normal 
                        
                           
                              n
                              ˜
                           
                           
                              v
                              i
                           
                        
                      of the enhancing point and the normal n
                     
                        u
                        i
                      of the corresponding point, 
                        
                           
                              μ
                              2
                           
                           =
                           m
                           a
                           x
                           
                              (
                              0
                              ,
                              
                                 
                                    n
                                    ˜
                                 
                                 
                                    v
                                    i
                                 
                              
                              ·
                              
                                 n
                                 
                                    u
                                    i
                                 
                              
                              )
                           
                        
                      where the transformed normal is given by:

                        
                           (12)
                           
                              
                                 
                                    
                                       n
                                       ˜
                                    
                                    
                                       v
                                       i
                                    
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       N
                                       (
                                       i
                                       )
                                    
                                 
                                 
                                    
                                       w
                                       ¯
                                    
                                    k
                                 
                                 
                                    (
                                    
                                       v
                                       i
                                    
                                    )
                                 
                                 
                                    R
                                    k
                                    
                                       −
                                       1
                                       T
                                    
                                 
                                 
                                    n
                                    
                                       v
                                       i
                                    
                                 
                              
                           
                        
                     
                  

In the first optimization cycle, the process proceeds until the cost function E meets one of two following convergence criteria at iteration n:

                        
                           (13)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             |
                                             
                                                
                                                   E
                                                
                                                n
                                             
                                             −
                                             
                                                
                                                   E
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             |
                                          
                                          <
                                          
                                             10
                                             
                                                −
                                                4
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             ∥
                                             
                                                z
                                                n
                                             
                                             −
                                             
                                                z
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             ∥
                                          
                                          <
                                          
                                             10
                                             
                                                −
                                                6
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Once the convergence criteria are reached, the optimization process is restarted for a second cycle according to the above scheme in which the value z in the first cycle is used as the initial value of the second cycle. The value of α is 0.5 in this cycle, the weights w
                     rot, w
                     reg are reduced by half. The weight w
                     pos depends on distance γi
                     . At the last iteration of the first cycle, the distances 
                        
                           
                              γ
                              i
                              ′
                           
                           s
                        
                      are computed and the “fourth spread” scheme is employed again. If a distance γi
                      is an outlier in the distance distribution, the weight w
                     pos for an enhancing point v
                     
                        i
                      and its corresponding point u
                     
                        i
                      is increased by 10 times while that of other points are kept as in the first cycle. Moreover, if a corresponding point u
                     
                        i
                      is on the boundary of the target surface, it is not considered at the current iteration (Fig. 1, block 2E). The optimization process of this cycle terminates when 
                        
                           
                              |
                              
                                 
                                    E
                                 
                                 n
                              
                              −
                              
                                 
                                    E
                                 
                                 
                                    n
                                    −
                                    1
                                 
                              
                              |
                           
                           <
                           
                              10
                              
                                 −
                                 6
                              
                           
                        
                      or 
                        
                           
                              ∥
                              
                                 z
                                 n
                              
                              −
                              
                                 z
                                 
                                    n
                                    −
                                    1
                                 
                              
                              ∥
                           
                           <
                           
                              10
                              
                                 −
                                 7
                              
                           
                        
                     .

Then, the optimization is carried out for a final cycle (third cycle). For this last cycle, the values of weights w
                     rot, w
                     reg, w
                     pos are computed as for the second cycle. However, the correspondence search is not limited to potential regions, but based on closest point search on the whole target surface. The alignment process between the deformation graph and the target surface is stopped by conditions: 
                        
                           
                              |
                              
                                 
                                    E
                                 
                                 n
                              
                              −
                              
                                 
                                    E
                                 
                                 
                                    n
                                    −
                                    1
                                 
                              
                              |
                           
                           <
                           
                              10
                              
                                 −
                                 7
                              
                           
                        
                      or 
                        
                           
                              ∥
                              
                                 z
                                 n
                              
                              −
                              
                                 z
                                 
                                    n
                                    −
                                    1
                                 
                              
                              ∥
                           
                           <
                           
                              10
                              
                                 −
                                 8
                              
                           
                        
                     . The optimization process at different cycles of a hand model is shown in Fig. 7
                     
                     .

@&#RESULTS AND DISCUSSION@&#

In this section, we evaluate and compare the robustness of our method with other methods for a wide variety of datasets. The proposed method has been implemented in MATLAB on a 3.2 GHz Intel Core i7 platform. These datasets are triangular meshes for which there is no prior knowledge on the source surface or the target surface. In Section 6.1, we compare our method with two other probability-based methods for non-rigid registration. In Section 6.2, we evaluate our method against two other methods which are based on idea of ICP in the non-rigid registration.

In Fig. 8, we compare our method with the CPD method by aligning the surface 
                           S
                         of frame 0 to the surface 
                           T
                         of frame 70th from a hand sequence obtained from the work of Weise et al. [45]. A similar comparison is also shown in Fig. 9
                         where two surfaces illustrate different expressions of a human face. To meet the computational requirements of CPD, these surfaces are down-sampled before running the registration process. To compare how the evaluated methods deal simultaneously with missing data and abrupt changes both occurring in the same region, we also create small missing patches at the bottom-left and right-middle of the pinky finger of the hand’s target surface (Figs. 7 and 8).

A corresponding point is assumed to exist for each point v
                        
                           i
                         of the source surface. In this case, we compute the distance between each deformed point 
                           
                              
                                 v
                                 i
                              
                              ˜
                           
                         to the target surface 
                           T
                         based on the corresponding point to compare the alignment quality between CPD and our method. If the Euclidean distance γi
                         is used for which a closest point u
                        
                           i
                         is a corresponding point (computed at the final iteration of the last optimization cycle), these distances might not be correct due to low point density as well as missing data between the two surfaces. Instead, we compute the distance σi
                         based on the squared distance function 
                           
                              F
                              +
                           
                         as follows:

                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             F
                                             i
                                             +
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   δ
                                                   ^
                                                
                                                
                                                   1
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      
                                                         1
                                                         i
                                                      
                                                   
                                                   ·
                                                   
                                                      (
                                                      
                                                         
                                                            v
                                                            i
                                                         
                                                         ˜
                                                      
                                                      −
                                                      
                                                         u
                                                         i
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   δ
                                                   ^
                                                
                                                
                                                   2
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      
                                                         2
                                                         i
                                                      
                                                   
                                                   ·
                                                   
                                                      (
                                                      
                                                         
                                                            v
                                                            i
                                                         
                                                         ˜
                                                      
                                                      −
                                                      
                                                         u
                                                         i
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             +
                                             
                                             
                                                
                                                   (
                                                   
                                                      n
                                                      
                                                         u
                                                         i
                                                      
                                                   
                                                   ·
                                                   
                                                      (
                                                      
                                                         
                                                            v
                                                            i
                                                         
                                                         ˜
                                                      
                                                      −
                                                      
                                                         u
                                                         i
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where e
                        1i
                        , e
                        2i
                        , n
                        
                           u
                           i
                         form a local coordinate system at u
                        
                           i
                        , 
                           
                              
                                 δ
                                 ^
                              
                              
                                 1
                                 i
                              
                           
                        
                        
                           
                              (
                              
                                 
                                    δ
                                    ^
                                 
                                 
                                    2
                                    i
                                 
                              
                              )
                           
                         is computed using the principal radius of curvature δ
                        1i
                         (δ
                        2i
                        ) in the direction e
                        1i
                         (e
                        2i
                        ) and the distance γi
                         (for more details, we refer the reader to [30]).

The distance 
                           
                              
                                 σ
                                 i
                              
                              =
                              
                                 
                                    F
                                    i
                                    +
                                 
                              
                           
                         is computed for each point on the deformed surface 
                           
                              S
                              ′
                           
                         to form an error map (indicating the distance σi
                         relative to bounding box diagonal of the target surface 
                           T
                        ) between 
                           S
                         and 
                           T
                        . In addition, we also measure the RMS error after completing the alignment process using the following quality measure:

                           
                              (15)
                              
                                 
                                    R
                                    M
                                    S
                                    
                                       (
                                       S
                                       ,
                                       T
                                       )
                                    
                                    =
                                    
                                       
                                          
                                             1
                                             
                                                |
                                                S
                                                |
                                             
                                          
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                |
                                                S
                                                |
                                             
                                          
                                          
                                             F
                                             i
                                             +
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              |
                              S
                              |
                           
                         is the number of points on 
                           
                              S
                              .
                           
                        
                     

Statistics of the comparison are shown in Table 2
                         while computation times for non-optimized MATLAB code are shown in Table 3
                        . Based on error maps and RMS errors, we observe that the CPD algorithm does not perform well when it attempts to impose the deformation field to be globally smooth during the deformation. Changes on the target surface such as abrupt bending at the ring finger and the pinky finger in Fig. 8, or small details in the mouth region in Fig. 9 cause CPD to perform poorly in these regions. In contrast, the optimization process of our method considers both local deformation and global deformation to deal with such abrupt changes and small details between the two surfaces. Moreover, while our method can achieve a more precise alignment when the number of nodes increases, as shown in Fig. 11(e, f), increasing the number of points for CPD does not significantly change the alignment quality due to its inherent deformation field.

The next experiment is performed on the same models of the hand and face to compare our method with the method of Jian and Vemuri (the GMM method) [18]. We apply the two methods on the original data, but keep the same number of nodes in our deformation graph. Although the GMM method can exploit two different deformation models, thin plate spline (TPS) or Gaussian radial basis functions (GRBF), we only compare our method with the TPS-based GMM method because its results are better than GRBF-based results. The error maps and RMS errors for this experiment (Figs. 10
                         and 11) indicate that our method outperforms the GMM method. Similar to CPD, GMM cannot align well in regions where the target surface has small details and abrupt changes. The errors in Figs. 10 and11 also show that large alignment errors for the GMM method occur in the same regions of the target surface as for CPD. In contrast, our method improves the alignment result (around the mouth region of the face, for example) when the density of points on the surfaces is increased. This is because the optimization process identifies more correct corresponding points in moving the deformation graph toward the target surface. Note that our method directly aligns frame 0 and frame 70th without prior knowledge. In a similar experiment for 3D scans of this hand sequence, Papazov and Burschka [34] align consecutive scans together in which the final value of the previous registration is used as an initial value for the current registration.
                     

In Fig. 13, we evaluate our method on a challenging dataset (the garments) in which a target surface is a twisted version of the source surface. The deformation between the two surfaces consists of a large rigid transformation as well as complex local deformations. For such a deformation, a rigid transformation is essential to bring the two surfaces close together to avoid convergence toward a incorrect minimum. The method of Papazov and Burschka [34] requires manual markers between the two surfaces while the work of Li et al. [25] assumes that the rigid transformation is known. Applying the scheme proposed in the first stage, our method obtains a robust rigid transformation automatically before running the second stage to align the two surfaces together (Fig. 12). To compare the alignment results with those of GMM, we reduce the original dataset before implementing our two-stage algorithm. The statistics for our method are listed in Table 4. While an optimal value allows our method to align the two surfaces correctly with a small number of iterations (Fig. 12(c)), GMM reaches a local minimum and causes misalignment (Fig. 13 (middle)).

Keeping the same number of deformation nodes for the garment dataset but implementing our method on the two original surfaces, we compare our results with those of Huang et al. [17], namely NICP (non-rigid ICP), and Bonarrigo et al. [7], namely PWSM (patch wise shape matching). NICP clusters vertices into different groups and then each group is deformed by a respective rigid transformation, PWSM uses a reduced deformation model to assemble the two surfaces. Due to missing data between the two surfaces, we do not calculate the error maps or RMS errors for comparison. The large motion between the
                        
                         two surfaces causes the probability-based method GMM to converge to an incorrect minimum in this case (Fig. 13), the two geometry-based methods NICP, PWSM and our method align the two surfaces correctly (Fig. 14). While the number of groups in NICP is determined by its optimization process, PWSM and our method are required to use a small number of nodes for the deformation model. PWSM uses 1905 nodes for its model and our deformation graph uses 1493 nodes. Despite using less nodes, Fig. 14 indicates that our alignment result is better than both NICP and PWSM.

An interesting question is whether or not we can employ the deformed sub-mesh 
                           
                              Y
                              ′
                           
                         given by CPD as a deformation graph 
                           
                              G
                              ′
                           
                         and run the optimization based on this deformation graph to accelerate the alignment process. However, one must be aware of a potential pitfall because a wrongly deformed sub-mesh 
                           
                              Y
                              ′
                           
                         can ruin the subsequent optimization. As shown in Fig. 15(a, b), the registration between two surfaces in this case is very challenging since the deformation is very complex. The deformation between the two surfaces consists of rigid transformations between parts of the torso and arm as well as other local deformations. Moreover, in addition to other large missing data between the two surfaces, we have also removed the data of the lower arm on the source surface. With this data, we run the CPD algorithm for sub-meshes and the GMM method for reduced data. Consequently, both methods result in a misalignment between the two surfaces (Fig. 15(c, d)). A common characteristic of the CPD and GMM methods is that they deform the upper arm on the source surface and align wrongly with whole arm on the target surface. With CPD, the misalignment also provides many incorrect correspondences between the two sub-meshes. Therefore, we prefer to use the sub-mesh 
                           Y
                         as our deformation graph and use some potential correspondences from CPD. By proceeding this way, the two surfaces align well as shown in Fig. 15(i, j). Due to the complexity of the deformation and missing data between the two surfaces, NICP gives a completely wrong alignment (Fig. 15(e, f)). Although both the proposed method and PWSM successfully register this data, the alignment results are different. Our method results in the upper arm on the source surface aligning precisely with this part on the target surface while the PWSM method causes this part to be shorter after alignment (Fig. 15(g, h)).

To demonstrate the efficiency of our method in preserving details of a surface, we register two surfaces of a deformed pillow in which the surfaces consist of several creases acquired by a high-resolution scanner, as shown in Fig. 16. Among the three methods, NICP result is the worst one because it cannot deform the source surface to align well with the sharp creases on the target surface. The RMS error of NICP is 0.41 compared with that of PWSM and our method by 0.198 and 0.164 respectively. Based on the error maps, we observe that the source of these errors of PWSM and the proposed method manifests itself in different ways. PWSM distributes the error uniformly on the whole surface while our method rather concentrates the error at some small local regions. This is because PWSM employs dual quaternion skinning for the interpolation which is known to be complex but more accurate than linear blend skinning.
                        
                     

In the next experiment, we applied our method to data of an arm acquired with a Creaform scanner in our lab. We asked a user to keep his arm static during the first scan. Then the user moved his arm to a second position before bending it. The relative position between fingers also changes after bending. The collected data is complex since the deformation between the two surfaces includes global rigid displacement, global bending, local deformation as well as missing data, especially in the region of the fingers. Fig. 17
                         shows the collected data and the alignment result achieved by our method. The method overcomes all the challenges associated with this data and deforms the source surface toward the target surface correctly.

In this paper, we have introduced an algorithm for non-rigid registration between two partially overlapping surfaces of deformable objects. Our method proposes a two-stage framework where the deformation is separated into one global rigid transformation and other local deformations. This framework allows two surfaces to be registered for which the deformation is large and the deformation occurs in an elastic manner. The algorithm preserves small details during deformation and can also deal with large regions with missing data in a small number of iterations of the optimization process. The method also prevents this process from becoming trapped in a incorrectly local minimum due to tangential drift, a common issue when addressing large deformations. To the best of our knowledge, the proposed method is the first one to combine probability-based approaches and explicit geometry-based methods to solve the general deformation problem without assumptions on the surfaces or initial values for the optimization process. The performance of the proposed method is evaluated and compared with other methods on realistic datasets to validate its robustness.

Currently, the FMA-based sampling method can generate a broken sub-mesh when the original surface is acquired in separate patches. In future work, we plan to investigate a non-uniform sampling method in which the deformation graph is a seamless sub-mesh and the sampling process distributes the nodes based on both topology and details of the original surface.

Although the proposed method converges in a small number of iterations, it requires more than 10 minutes on average for optimization in the current implementation because the normal equation of the Levenberg–Marquardt algorithm is not solved efficiently. Cholesky factorization, for example, may be exploited to overcome this issue. Moreover, the implementation of the entire method in C++ is also considered to align many partial surfaces in a framework of global non-rigid registration to create the complete surface of deformable objects.

@&#ACKNOWLEDGMENTS@&#

We are grateful to Myronenko and Song, Jian and Vemuri, Huang et al. and Bonarrigo et al. for providing us with implementations of their methods. We would also like to thank Weise et al., Bradley et al., Allen et al. and Robert W. Sumner for providing the 3D datasets. This research was supported by the NSERC-Creaform Industrial Research Chair on 3D Scanning.

@&#REFERENCES@&#

