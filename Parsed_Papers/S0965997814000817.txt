@&#MAIN-TITLE@&#A consistent octree hanging node elimination algorithm for hexahedral mesh generation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Practical hanging node elimination in octree structures is proposed.


                        
                        
                           
                           New mesh conditioning technique is introduced based on decoupling templates.


                        
                        
                           
                           Decoupling templates insert circular loops in mesh dual to avoid full refinement.


                        
                        
                           
                           Hanging nodes are eliminated in concave regions without excessive refinement.


                        
                        
                           
                           The method is consistent and complete for producing quality conformal octaves.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Octree

Hexahedral mesh generation

Conformal refinement

Refinement templates

Hanging node elimination

Decoupling templates

@&#ABSTRACT@&#


               
               
                  A new algorithm for hanging node elimination in octree structures is developed. The proposed algorithm utilizes hanging node elimination by refinement templates and a new mesh conditioning technique based on decoupling templates. Refinement templates insert transition elements to eliminate hanging nodes. Decoupling templates insert circular loops in the dual mesh without introducing or removing hanging nodes. Decoupling templates are introduced to avoid full refinement in the cases that do not match any of the available refinement templates. The proposed algorithm eliminates hanging nodes for concavely refined regions without excessive refinement. Another advantage of the proposed algorithm lies in eliminating narrow gaps of coarse meshes between refined regions. This step has a positive effect on the mesh quality as it avoids introducing non-regular templates with a limited penalty of uniform refinement. The presented algorithm produces good quality meshes and provides a consistent and complete method for producing conformally refined octree structures.
               
            

@&#INTRODUCTION@&#

In this paper we consider the problem of hanging node elimination in octree-based hexahedral meshes. Mesh generation is an essential step in numerical-based predictive modelling. Typically, the problem domain of interest is discretized into tetrahedral or hexahedral elements using various mesh generation algorithms. In this paper we focus on hexahedral meshes. High quality hexahedral meshes are known to offer efficiency and accuracy for some numerical solvers [1]. A review and comparison of different hexahedral mesh generation techniques can be found in Ref. [2] and the references within. Most of practical engineering problems involve complex geometrical domains with varying feature sizes. Hence, one of the design requirements of a mesh generation algorithm is to produce meshes conforming to the local feature sizing. Using uniform hexahedral meshes which cover the whole domain based on the smallest feature size produces unnecessarily large meshes.

Grid-based hexahedral mesh generation scheme is one of the few existing fully automated hexahedral mesh generation algorithms. Using octrees as background grids was first proposed by Schneiders et al. [3]. Hierarchical trees of mesh blocks (e.g. quad-trees, oct-trees) have been widely employed for adaptive mesh refinement, see for example [4,5]. Octrees enable producing hexahedral meshes with different element sizing. However, the resulting meshes contain hanging nodes which present challenges to some numerical solvers. The presence of hanging nodes also complicates the process of sharp feature extraction [6] and subsequent mesh optimization steps.

A mesh node n is hanging if it falls on an edge or a face of a hexahedron h but n is not a vertex of h. Handling hanging nodes in numerical simulators is challenging. For example, in conforming finite element simulators, special constraints have to be defined for each hanging node [7,8]. In finite volume simulators, hanging nodes produce a coarse/fine interface which needs a special care [9, Chapter 8]. However, some solvers such the Discontinuous Galerkin method [10] can handle non-conforming meshes without difficulty.

The problem of hanging node elimination can be described as follows: Given a hexahedral mesh 
                           
                              M
                              =
                              (
                              N
                              ,
                              H
                              )
                           
                         consisting of a set of nodes N and a set of hexahedrons H, our goal is to modify M into 
                           
                              
                                 
                                    M
                                 
                                 
                                    ′
                                 
                              
                              =
                              (
                              
                                 
                                    N
                                 
                                 
                                    ′
                                 
                              
                              ,
                              
                                 
                                    H
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                        , such that 
                           
                              
                                 
                                    N
                                 
                                 
                                    ′
                                 
                              
                           
                         contains no hanging nodes, and 
                           
                              
                                 
                                    M
                                 
                                 
                                    ′
                                 
                              
                           
                         remains a valid hexahedral mesh. Furthermore, it is desired that the resulting mesh 
                           
                              
                                 
                                    M
                                 
                                 
                                    ′
                                 
                              
                           
                         does not suffer from excessive refinement. In other words, the sizes of 
                           
                              
                                 
                                    N
                                 
                                 
                                    ′
                                 
                              
                           
                         and 
                           
                              
                                 
                                    H
                                 
                                 
                                    ′
                                 
                              
                           
                         stay under control. Finally, the quality of the mesh 
                           
                              
                                 
                                    M
                                 
                                 
                                    ′
                                 
                              
                           
                         should be maximized.

Several schemes have been proposed for hanging node elimination. We briefly discuss two major schemes: refinement templates and pillowing. For more discussion see [11,12,3,13].

Schneiders et al. [3] proposed using a hierarchical set of refinement templates shown in Fig. 1
                         which can eliminate hanging nodes. Templates propagate from solid refinement to face refinement followed by edge refinement and ends with a node refinement template. Elements that do not match any of the pre-defined refinement templates are fully refined by the solid refinement template shown in Fig. 1d, which can introduce additional hanging nodes. This method successfully handles both convex and concave regions. However, concave regions are converted into fully-refined meshes, and hence the mesh size increases. This is attributed to the lack of refinement templates for elements with two refined non-parallel faces and for elements with three refined faces meeting at a point. Schneiders [14] later proposed a sheet refinement method that starts from a balanced octree and manages to produce a conformal mesh by a shrink and connect strategy, known as pillowing [15]. For each refinement layer, one direction at a time is handled by pillowing. Tchon et al. [16] extended the sheet refinement method to a 3D anisotropic refinement scheme. In contrast to Schneiders’s sheet refinement method, the method proposed by Tchon et al. [16] starts from a conformal uniform mesh. It was proposed to search for refinement layers to be pillowed using a prescribed Riemannian metric to control the refinement process. However, both sheet refinement methods [14,16] are difficult to implement and lack the simplicity of template-based methods. In addition, Parrish et al. [12] shows that sheet refinement schemes suffer from poor scalability as the time required for sheet refinement grows rapidly as a function in the number of initial mesh elements. This is attributed to the large number of intermediate hexahedral elements created during sheet refinement.

Harris et al. [17] proposed using templates instead of pillowing for conformal mesh refinement. In some sense, pillowing was implicitly introduced by a special set of templates. However, this method suffers from poor performance because the management of template insertion requires a multi-directional hexahedral sheet tracking which has limited effectiveness in the cases of self-intersecting sheets and concavities. Parrish et al. [12] introduced a selective refinement method which combines two refinement methods: element-by-element refinement templates, and directional refinement. A ranking system propagation scheme was used to order the directional refinement operations within the algorithm. This method is one of the few practical and complete solutions to the conformal refinement problem. However, the ease of implementation of a complete template-based method is still not achieved. Ito et al. [11] proposed a solution for 2D convexity embedded in 3D meshes by a new template mimicking a pillowing [15] of one element. Similarly, Sun et al. [18,19] proposed a set of refinement templates which have many common features with those proposed by Ito et al. [11] with the addition of two corner refinement templates. However, the quality of these transition elements is questionable. Fig. 2
                         demonstrates the application of both methods by Parrish et al. [12] and Ito et al. [11] on a 2D hanging node elimination problem. The method of Parrish et al. [12] is directional and the resulting mesh is not symmetric for a symmetric refinement field and depends on the order of operations. It is observed that all these methods [12,11,18,19] introduce small-sized elements at the corner of concavely refined regions. Similarly, methods that rely on the dual contouring [20] might also introduce elements at the coarse/fine mesh interface that have smaller feature size than that of the fine refinement field.

In [21] 2-templates and 3-templates were used for hanging node elimination within an all-hex meshing framework. The method relies on identifying core regions where all elements are marked for refinement and transition regions where elements are refined along one or many faces. Hanging nodes are eliminated at transition layers using templates. However, interaction among transition regions at convex and concave regions result in elements with many transition faces and hence no matching templates. Full refinement of such elements could lead to propagation of the solid refinement, and result excessive refinement. A remedy was introduced in [22] by preconditioning the refinement field using pillowing so that a new layer matches the templates were introduced.

In this paper, we present a general algorithm for hanging node elimination in octrees. Our approach is template-based. We aim at ease of implementation and mesh quality. We introduce topological preconditioning to control interactions among templates, especially at concavities, to prevent inserting poor quality elements. The algorithm is based on two sets of templates: decoupling templates shown in Fig. 3
                         and refinement templates shown in Fig. 4
                        . The combined use and the order of operations is novel.

The general idea of topological preconditioning is that decoupling templates insert circular loops in the mesh dual in order to decouple concave refinement regions and pave the way for applying refinement templates. In turn, refinement templates insert transition elements at the interface of fine and coarse mesh elements in order to eliminate hanging nodes. In a way, this preconditioning is similar to pillowing at transition layers used in [22]. However, our method is template-based which is arguably easier to implement than pillowing. Furthermore, the topological preconditioning step (i.e., applying the decoupling templates) eliminates the need to refine elements that do not match a standard refinement template. Hence over-refinement is avoided. For example, the 2D refinement field shown in Fig. 2a will be fully refined by the algorithm of Schneiders et al. [3]. The proposed preconditioning step for the same refinement field is shown in Fig. 5
                        a, where a circular loop is inserted at the interface of a concavely refined field. Subsequently, standard hanging node elimination templates can be applied as shown in Fig. 5b. The quality of this mesh can be further improved by smoothing as shown in Fig. 5c. However, there is a trade-off at this stage between improving mesh quality by way of smoothing, and enabling further processing on the mesh. For example, moving the mesh hinders subsequent mesh refinement at the interface, and multilevel solvers become harder to implement after smoothing. In terms of advantages, the proposed algorithm is the first template-based algorithm that can handle general 3D concavely-refined regions. We argue that our algorithm is a logically-consistent algorithm as it uses an edge-based marking scheme and a hierarchy of refinement templates that ends with an edge-based template. This is to be contrasted with other algorithms that use node-based marking systems [13,11].

In an octree, a hexahedral element h is internal if it is neither the root nor a leaf node. The parent p of an internal hexahedral element h is its immediate predecessor in the tree. Each non-leaf hexahedral element has a set of sub-elements which is called children set. In our implementation of octree, a non-leaf hexahedron has 27 child nodes. The middle child element is the central hexahedron among the 27 children. The set of siblings of h is the set of hexahedral elements that share the same parent as h, including h.

In the rest of the paper, algorithm listings are written for ease of presentation. We assume that the octree data structure provides efficient iterators on subsets of elements, e.g. all siblings of a given hexahedron, or all leaf hexahedrons in the mesh. We also assume the availability of fast template matching operations. Efficient implementation details are omitted to focus on the key ideas of preconditioning, decoupling nodes and refinement templates.

The rest of the paper is organized as follows: Section ‘Preconditioning’ provides an analysis of the mesh preconditioning steps. Section ‘The algorithm’ provides a complete hanging node elimination algorithm based on the combined use of decoupling and refinement templates. Section ‘Applications’ presents several test problems demonstrating the capabilities of the algorithm in handling 3D concavely-refined regions. Section ‘Conclusions and discussion’ lists the conclusions of the paper.

The objective of the mesh conditioning step is to modify the refinement field such that concavely-refinement regions do not interact. In simple 2D cases, as shown in Fig. 5, mesh conditioning utilizes the decoupling templates without introducing any new hanging nodes to the octree structure. However, for more general cases the quality of produced meshes might be quite poor. Therefore, we introduce a general conditioning scheme that includes three steps: refining the sibling step, followed by a gap filling step and finally eliminating any remaining interacting decoupling nodes by refinement. Each of these steps (along with the corresponding notations) will be detailed in the next subsections. For the sake of clarity, the presentation order of these sections does not correspond to the exact order of application in the final algorithm. The overall algorithm is discussed in Section ‘The algorithm’.

The proposed hierarchy of refinement templates can be categorized as volume refinement, face refinement and edge refinement as shown in Fig. 4. In the current work we utilize an edge base marking scheme where the application of refinement templates corresponds to counting the number of edges in a given hexahedron containing hanging nodes. For example, the edge refinement template is applied to any hexahedron that contains one edge with hanging nodes. The general number of combinations of marked edges incident to a given hexahedron can be obtained by the Polya counting theorem [23]. For different 2-colorings of cube edges, the total number of combinations is 218. Taking into account the 48 symmetries of a cube, only 144 distinct cases exist. Fortunately, the application of the sibling refinement step (detailed later in Section ‘Sibling refinement’) results in a large reduction in the number of combinations that may exist. Fig. 6
                         shows the different patterns of edges with hanging nodes incident to a given hexahedron for a general octree after applying refining the sibling step. Only the pattern 1E and 4E, shown in Fig. 6, can be eliminated by the refinement templates (shown in Fig. 4). A mesh conditioning by using decoupling templates (shown in Fig. 3) is needed to deal with all the remaining combinations. The edge marking is assumed to be available for any hexahedral element in the octree structure in any step of the algorithms discussed later.

In a 3D mesh, we define two types of concavely-refined regions: 2D regions and 3D regions. The 2D regions are essentially 2D concavely-refined regions embedded in a 3D space, typically by extrusion. For example, Fig. 7
                         shows an extruded version of the 2D refinement field shown in Fig. 2a. On the other hand, in a general 3D mesh, elements with 3 refined neighbours often exist. We call these elements 3D regions. Fig. 8
                         shows sections through a refinement field containing 3D concavely refinement region. This field is similar to the 2D concavely refinement field shown in Fig. 7 while refining the bottom layer of hexahedral elements.

For 2D concavely-refined regions embedded in 3D mesh a two step approach similar to the 2D case shown in Fig. 5 is capable of eliminating hanging nodes and producing conformal meshes without converting the concave regions into a convex regions. However for 3D concavely-refined regions, the mesh conditioning is more challenging. Our proposed solution for 3D concavities is based on identifying two levels of conditioning discussed below, followed by the application of decoupling templates in a consistent manner that do not introduce additional hanging nodes in the mesh by either refining around a vertex or around a connected set of edges.

The decoupling step utilizes the templates shown in Fig. 3 by refining around an edge or a node. In order to mark these edges and nodes we introduce a two level node based marking scheme. We denote some nodes as decoupling nodes as shown in Figs. 9 and 10
                        
                        . Recall that in Fig. 6 only two patterns (1E and 4E) can be eliminated using refinement templates (shown in Fig. 4). We need to eliminate the rest of the patterns from the octree structure before applying the refinement templates. We highlight that the 5 cases of Fig. 6 which cannot be handled directly by refinement templates correspond to the two different decoupling node marking as 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         shown in Fig. 9 or 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         shown in Fig. 10. 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         decoupling nodes result from co-dimension of 3D concave regions, whereas 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         decoupling nodes result from 2D concave regions. The levels are not exclusive. Some nodes can be marked as both 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         and 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                        . However, 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         marking is given precedence over 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                        . The ultimate goal after marking nodes as either 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         or 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                        , is to apply vertex- and edge-decoupling templates of Fig. 3.

The decoupling node analysis procedure is listed in Algorithm 1. First, all decoupling nodes are marked based on the templates shown in Figs. 9 and 10. Decoupling nodes are then analyzed by looping on each hexahedral element and analyzing the number and configuration of incident decoupling nodes. The only allowed cases are shown in Fig. 11
                        . All other cases are marked for full refinement using the template shown in Fig. 4c.
                           Algorithm 1
                           Decoupling node analysis procedure 
                                 
                                    
                                 
                              
                           

In special cases, the decoupling node analysis algorithm returns an empty refinement hexahedral list. In this case, the decoupling templates can be applied immediately. All the nodes that are marked as 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         are matched to the vertex refinement template shown in Fig. 3a. Then this template is applied to all hexahedral elements incident to this vertex to insert a spherical loop in the mesh dual around this node. Following that, if a hexahedral element has two 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         decoupling nodes along an edge, the edge refinement template of Fig. 3b is applied. If a hexahedral element has one 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         decoupling node, the node refinement template shown in Fig. 3a is applied.

As an example, Algorithm 1 is applied to the refinement field of Fig. 7. This will only result in marking a set of 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         nodes. Therefore, the application of decoupling templates followed by refinement templates will produce a conformal mesh (conformal closure) as shown in Fig. 12
                        a. We also show the result of applying the method of Ito et al. [11] in Fig. 12b. In order to assess the quality of the two meshes, all the boundary nodes were fixed and five Laplacian smoothing iterations were applied followed by a mesh optimization scheme as implemented in the mesh quality improvement toolkit Mesquite [24]. The standard shape improvement wrapper class is used, where the mesh quality is improved by using the feasible Newton algorithm applied to the composition of the mean ratio quality metric with the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    2
                                 
                              
                           
                         norm objective function (Section 4.2 in [25]). The quality of both optimized meshes is measured by the scaled Jacobian metric as implemented in the mesh verification library Verdict [26]. Fig. 13
                         shows the quality metric histograms for both meshes. Only the elements with the lowest 
                           
                              10
                              %
                           
                         scaled Jacobian are plotted. The proposed algorithm produces higher quality meshes with a minimum scaled Jacobian value of 0.3203 in comparison to a minimum of 0.2757 for the mesh produced by Ito et al. [11] method. This is attributed to applying decoupling on a larger length scale in comparison to confining a decoupling step inside one element as shown in Fig. 12. The proposed algorithm produces slightly larger meshes as the total number of mesh elements is 5839 in comparison to 5797 for the mesh produced by Ito et al. [11] method. This increase in the total number of elements can be justified by the corresponding increase in mesh quality.

For 3D concave refinement field shown in Fig. 8, both 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         and 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         nodes are marked by Algorithm 1. Thus, the node decoupling template is initially applied by refining around 
                           
                              
                                 
                                    level
                                 
                                 
                                    0
                                 
                              
                           
                         nodes. The resulting mesh is shown in Fig. 14
                        a. Following that, node and edge decoupling templates are applied around 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         to produce the mesh shown in Fig. 14b. After this step, this mesh can be easily converted to a conformal mesh by applying the refinement templates. Fig. 15
                         shows different sections through the resulting fully-conformal mesh.

The quality of the resulting mesh is improved initially by Laplacian smoothing followed by a standard shape improvement wrapper as implement in the Mesquite toolkit [24]. The histogram of the scaled Jacobian quality measure for the 
                           
                              10
                              %
                           
                         of the elements with the lowest quality is plotted in Fig. 16
                         with a minimum value of 
                           
                              0.3163
                           
                        . The resulting mesh is topologically symmetric similar to the refinement field. This symmetry improves the performance of geometry-based optimization techniques (without any topological changes). The resulting minimum scaled Jacobian is lower than the case of 2D concave regions due to the introduction of two levels of mesh conditioning by inserting decoupling templates.

In many cases, decoupling is not easy to perform without deteriorating the mesh quality. For instance, if the refinement field has a staircase shape as shown in Fig. 17
                        a, then decoupling templates produce asymmetric meshes which depends on the order of operations (see Fig. 17b). The resulting conformal mesh shown in Fig. 17c has a poor quality. This behaviour is attributed to interactions between decoupling templates. If the refinement size is not small enough to capture the local feature size, then forcing templates into the refinement field (or a layer of templates, e.g. a pillowing layer) will result in a transition region with an irregular quality. Sibling refinement is a step introduced to avoid these situations. The refinement field is regularized by refining all the children of a given hexahedral element if one of the children is refined. The new refinement field is then conditioned by inserting non-interacting decoupling templates. The proposed solution is pictured in Fig. 18
                         for the case of 2D concavely refinement region. This step is simple to implement and can be applied to 2D and 3D problems. The steps of Sibling refinement are listed in Algorithm 2.

Sibling refinement has an additional benefit. It results in a large reduction in the number of combinations of marked edges incident to a given hexahedron. The number is reduced from 144 distinct cases to only 7 canonical cases (see Fig. 6).
                           Algorithm 2
                           Refining the sibling algorithm 
                                 
                                    
                                 
                              
                           

Another case of decoupling template interaction occurs when the refinement field contains narrow coarse grids located between two refined regions. This is referred to as gaps. Also, templates interact when two refinement fields are very close to each others. In these cases, additional refinement is introduced to eliminate narrow-coarse mesh gaps between refined elements. Fig. 19
                         shows an example of a refinement field in 2D where inserting decoupling templates produces a low-quality mesh as shown in Fig. 19b. In this case, additional refinement is applied as shown in Fig. 19c to fill these gaps.

The gap filling procedure is listed in Algorithm 3. Gaps are eliminated recursively until no more gaps are found. Gap filling could be performed during octree balancing. However, the current implementation utilizes decoupling nodes. 
                           
                              
                                 
                                    level
                                 
                                 
                                    1
                                 
                              
                           
                         decoupling nodes are initially marked and if the central child (see Section ‘Notation’ for notation) of a refined element matches one of the cases in Fig. 20
                        , then all the sibling are marked for refinement.
                           Algorithm 3
                           Gap filling procedure 
                                 
                                    
                                 
                              
                           

In this section the overall algorithm for hanging node elimination is presented. The general steps of the algorithm are: conditioning the mesh such that decoupling templates do not interact (mesh conditioning step), application of the decoupling templates in two stages for general 3D concave regions (mesh decoupling step) and finally, applying the refinement templates to eliminate hanging nodes (hanging-node elimination step). The procedure is listed in Algorithm 4. Below is a description of the steps, where the line number is written between parenthesis.

The input is an octree mesh with hanging node. Before any decoupling or refinement takes place, a series of mesh topological preconditioning steps are performed. The first step is to call Algorithm 2 for sibling refinement (step 1). This step will effectively eliminate any interactions between decoupling templates. The next step is to call Algorithm 3 to fill the narrow gaps (step 3). After the refinement field is conditioned, Algorithm 1 is called (step 4) for decoupling node analysis. If the analysis discovers any hexahedrons not matching the cases listed in Fig. 11, then these hexahedrons are refined (steps 8). If refinement is applied at this stage, then gap filling is repeated again to account for any newly-introduced narrow gaps. This loop repeats until every element incident to a decoupling node matches a case from Fig. 11.

Once the refinement field is conditioned, all remaining decoupling nodes can be handled by templates. First, decoupling templates of Fig. 3a are applied to all hexahedrons incident to 
                        
                           
                              
                                 level
                              
                              
                                 0
                              
                           
                        
                      decoupling nodes (step 11). Following that, the mesh contains only 
                        
                           
                              
                                 level
                              
                              
                                 1
                              
                           
                        
                      decoupling nodes that exists in two cases: one per hexahedron, and two per hexahedron (i.e. sharing an edge). Both node and edge decoupling templates of Fig. 3 are applied. The last step of the algorithm (step 13) is a direct application of the refinement templates shown in Fig. 4.
                        Algorithm 4
                        Hanging node elimination algorithm 
                              
                                 
                              
                           
                        

In this section we present some simple test problems showing the success of the proposed hanging node elimination algorithm. The proposed algorithm is implemented as a part of a grid-based hexahedral mesh generation package. However, we do not present the complete hexahedral meshes with the projection and sharp feature extraction steps as they fall beyond the scope of this paper. Interested readers can find detailed techniques for these steps in [27,28,6]. In the test problems, the refinement field is selected to demonstrate the success of the algorithm in handling general three dimensional concavely refined regions.

The mesh for this test case is a cubical domain with a side length 20 units. The mesh is locally refined around a spherical domain of radius 5 units co-centered in the cube. The size of the initial grid is used as a parameter of n elements in each direction and then globally refined to build the octree structures. Elements intersecting the spherical domain are then locally refined once, followed by an application of the hanging node elimination algorithm. To show the performance of algorithm on different mesh resolutions, the parameter n was varied in two different refinement fields: RF1 where 
                           
                              n
                              =
                              6
                           
                         and RF2 where 
                           
                              n
                              =
                              10
                           
                        . Figs. 21 and 22
                        
                         show cross sections of both refinement fields.

The resulting conformal mesh for RF1 is shown in Fig. 23
                        , where the internal concave domain inside the sphere is fully refined since the decoupling nodes interact and thus decoupling templates are not introduced. However, the domain outside the spherical domain shows a staircase shape where the 3D concave regions are handled in a symmetrical way.

The resulting conformal mesh for RF2 is show in Fig. 24
                        . The internal domain of the sphere is not totally refined and the merits of the algorithm are demonstrated. The 3D concavely-refined regions are not propagated to fill the total domain.

In this test case, a triangulated surface of a mechanical jack is used to define the problem domain. The bounding box is divided into 20 elements in each direction and then a global solid refinement is applied to obtain an octree structure. All elements intersecting the triangulated surface are refined once and then all elements outside the domain are deleted. The triangulated surface along with the initial hexahedral mesh are shown in Fig. 25
                        . The conditioned mesh after the sibling refinement step, gap filling step and eliminating interacting decoupling nodes is shown in Fig. 26
                        a. A cross section through the conformal mesh is shown in Fig. 26b. Cross sections in the two other directions are omitted due to the symmetry of the domain and the symmetry of the resulting mesh. The results assures the capabilities of the algorithms in dealing with general 3D concave regions.

The input for this test case is a triangulated surface of a tooth, shown in Fig. 27
                        a. The initial mesh was build by dividing the bounding box into 60 elements in each direction. Then the octree structure was built in a similar fashion to test case II. The initial voxelization after refining the intersecting elements and eliminating elements outside the triangulated domain is shown in Fig. 27b. Cross sections through the initial mesh are shown in Figs. 28
                        a and b. Different cross sections of the resulting conformal mesh after applying the different steps of the hanging node elimination algorithm are shown in Fig. 29
                        . The narrow regions at the bottom of the domain are fully refined by the algorithm to eliminate narrow concave regions. However, the internal region of the model is not fully refined in the upper part of the model. The internal structure is irregular with different 3D concave parts to fit the problem domain. The algorithm successfully managed to detect the narrow parts and avoided adding low quality non-regular templates if the penalty is low as it is the case for the narrow regions at the bottom of the current model.

A general algorithm for hanging node elimination based on a new concept of mesh preconditioning using decoupling templates was developed. The steps of the algorithm were presented and discussed. Several test cases demonstrated the capabilities of the algorithm.

The proposed algorithm is capable of dealing with 3D concavely-refined regions without excessive use of uniform refinement templates. The resulting meshes are symmetric if the input is symmetric which is a big advantage over directional refinement methods. The use of decoupling templates around nodes and connected edges produces conformal meshes with a gradually changing feature size from fine to coarse without introducing excessively small volumes at the coarse/fine element interface. This smooth transition allows for better optimized meshes by simple smoothing techniques.

The proposed preconditioning steps produce a balance between full refinement and inserting transition elements. Another advantage of the proposed algorithm lies in eliminating narrow-coarse mesh regions if surrounded by fine regions. These regions are eliminated by full refinement as it avoids introducing small-sized elements at the coarse/fine interface in regions with small local feature sizes. For example, consider the mechanical jack in Fig. 30
                     . Let the refinement size denote the size of the largest unrefined hexahedron. The refinement field at the tip of the jack consists of a single layer of coarse elements surrounded by layers of refined elements. If one were to eliminate hanging nodes by templates insertion and/or pillowing, then the coarse layer will be effectively split into 3 layers. The outer 2 layers would interface the refined elements and the innermost layer would interface the transition elements. A smaller choice of the refinement size, particularly 
                        
                           1
                           /
                           3
                        
                     rd the current size would have led to 3 layers of coarse elements before any hanging node elimination. The natural question is: in situations such as Fig. 30, how should a hanging elimination algorithm proceed? Should it defy the small local feature size and insert transition templates and/or use pillowing, or should it detect this imbalance in the octree tree and simply refine the coarse elements? We argue that the former choice will produce meshes with irregular qualities since the local feature size in such cases induces a refinement field with little room for multiple layers of coarse elements. The Sibling Refinement preconditioning algorithm presented in this paper, detects this geometric-induced irregularity in the mesh topology, and refines the coarse layers and eliminates the need to perform hanging node elimination in such cases.

The next question is: does the preconditioning imply excessive propagation of refinement from the refined regions to the coarse mesh region? The answer generalizes the argument above to sharp corners and regions with small features. Even though the preconditioning algorithms presented in the paper are not parametric in the feature size, they incorporate the feature size implicitly. As long as the local feature sizes are encoded in the grid (which is the case in octree meshes), the preconditioning algorithms presented here will try to eliminate irregularities from the refinement field and propagate the refinement until the refinement size in the coarse regions matches the local feature size.

In addition, the sibling refinement step has a positive effect on the mesh quality as it avoids introducing non-regular templates with a limited penalty of uniform refinement. For example, the challenging case of non-axis aligned sharp features will be dealt with as a staircase refinement field similar to those shown in Figs. 17 and 18. Instead of inserting layers of transition elements that could introduce asymmetric meshes with poor quality, the sibling refinement algorithm is capable of dealing with these cases effectively.

Moreover, the combined use of mesh conditioning and gap filling procedures is fully automatic and the resulting conformal meshes are of good quality that outperforms recently published results.

@&#FUTURE WORK@&#

The presented results demonstrated successful elimination of hanging nodes at the coarse–fine interface in the presence of one level of refinement. By induction, one may conclude that multiple levels of refinement will be handled as a sequence of interfaces between fine and coarse elements. However, in practice the refinement levels can interfere if the gap between the levels is small. This is because the Gap Filling Step of our algorithm will over refine in an attempt to regularize the refinement field. This does not present a challenge in 2D/3D concavely refined regions (see Figs. 14 and 15). We are currently investigating a new algorithm for which the decoupling step inserts a layer similar to pillowing layers of [22] rather than the full refinement approach in the current algorithm.

@&#ACKNOWLEDGEMENTS@&#

The Jack model is provided courtesy of the National Design Repository at Drexel University by the Gamma research group at INRIA (http://www-roc.inria.fr/gamma/) and the Tooth model is provided courtesy of CNR-IMATI by the AIM@SHAPE Shape Repository (http://shapes.aim-at-shape.net). The authors would like to thank the two anonymous reviewers for their insightful and constructive comments.

@&#REFERENCES@&#

