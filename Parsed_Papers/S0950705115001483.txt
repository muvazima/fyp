@&#MAIN-TITLE@&#PHandler: An expert system for a scalable software requirements prioritization process

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A scalable software requirement prioritization system is proposed.


                        
                        
                           
                           The system utilizes RV function of VIRP technique for requirement value.


                        
                        
                           
                           The neural network is used to predict the requirement value.


                        
                        
                           
                           The initial competition is resolved with the application of proposed exceptions.


                        
                        
                           
                           The AHP is applied to resolve the final competition among requirements.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Software requirement prioritization

Artificial neural networks

Expert systems

Hybrid model

Decision support

@&#ABSTRACT@&#


               
               
                  Software requirements engineering is a critical discipline in the software development life cycle. The major problem in software development is the selection and prioritization of the requirements in order to develop a system of high quality. This research analyzes the issues associated with existing software requirement prioritization techniques. One of the major issues in software requirement prioritization is that the existing techniques handle only toy projects or software projects with very few requirements. The current techniques are not suitable for the prioritization of a large number of requirements in projects where requirements may grow to the hundreds or even thousands. The research paper proposes an expert system, called the Priority Handler (PHandler), for requirement prioritization. PHandler is based on the value-based intelligent requirement prioritization technique, neural network and analytical hierarchical process in order to make the requirement prioritization process scalable. The back-propagation neural network is used to predict the value of a requirement in order to reduce the extent of expert biases and make the PHandler efficient. Moreover, the analytical hierarchy process is applied on prioritized groups of requirements in order to enhance the scalability of the requirement prioritization process.
               
            

@&#INTRODUCTION@&#

Software requirement prioritization is a process in which requirement engineers find the most important stakeholders’ requirements in order to develop a system [65], particularly an innovative system. These core requirements must be implemented within the defined constraints of time, resources, cost and quality, in order to satisfy the customers [2,34,64,71,73]. The software requirement prioritization process helps to identify conflicts among various requirements and ultimately helps in the resolution of these conflicts; it also provides a future road map [72]. Nonetheless, the selection of the right requirements is the main challenge in order to satisfy all the key needs of the stakeholders and maximize the business value of the product [60]. The wrong set of requirements for an innovative system leads to an increased cost in the modification of the system. The wrong requirements also have an adverse effect on the quality of the system. The value of the requirements is calculated by using a suitable requirement prioritization technique. For decision making, the prioritization of requirements is also considered as highly significant [7]. The requirement prioritization process is also a very complex decision-making process [21,33,47,52]. In order to apply requirement prioritization techniques, the experts must have sound knowledge of the domain and possess the relevant professional skill set [40].

The satisfaction of the stakeholders is taken into account when a quality software system fulfills all the requirements of the stakeholders or users [18,49]. The consideration of all requirements in the development of a software system is not possible because of the constraints such as the time to market, budget, and other resources. Thus, only important requirements are taken into account in a single release [35]. Software requirements have different features such as risk [7,52,64,71], importance [47], volatility [52], cost, penalty and time [71] and dependencies with other requirements based on cost, technical importance or value, customers and changes in the requirements [24,61]. On the basis of the above-mentioned features, the unimportant requirements are not given consideration; rather they are totally rejected. Only value-added requirements are considered in the requirements set in order to develop a valuable system of high quality. The value of the system may be in terms of profit, efficiency, the services, good performance, correct data, fulfillment of the right user needs and acceptance by a wide community [12].

Different software requirement prioritization techniques are used in order to prioritize the most important requirements, and the requirement prioritization process is still immature [7]. Software engineers use multiple techniques on the basis of factors such as cost, time, and relevant importance, but such an approach is the cause of certain conflicts. These conflicts are initiated due to the effect of one aspect on another aspect. For instance, cost has an immense effect on the requirement prioritization process. If the cost of an important requirement is high, then there is a possibility that the stakeholders may change their mind about the requirement. Such a change in the mind of the customer also results in the change of the priority of that very requirement [43]. In the software requirement prioritization process, the requirements’ attributes or aspects are directly affected by the role of the customers or stakeholders involved in the development process of an innovative system. In addition, it is pointed out that different stakeholders perceive the term “prioritizing requirement” differently [27].

This paper comprises eight major sections. This paper first describes the research background in Section 2. Section 3 is about the value-based intelligent requirement prioritization (VIRP) technique. Section 4 describes the proposed expert decision support system PHandler followed by a description of the experimental setup in Section 5. Section 6 discusses the experiments, while Section 7 presents the experimental results. Section 8 presents an overview of the related works and discussion. Lastly, Section 9 concludes the paper.

Different software requirement prioritization techniques are used to select the user requirements in order to develop systems of high quality. Some of the most prominent software requirement prioritization techniques are the analytical hierarchical process (AHP), binary search tree, ranking, the numerical assignment, top ten requirements, cumulative voting or hundred dollar test, and many different hybrid techniques are presented. Different methods are used to prioritize the requirements. In one study, the researchers applied different software requirement prioritization techniques “to prioritize 13 well-defined quality requirements on a small telephony system” [38]. The results obtained from the different prioritization techniques demonstrated that the bubble sort technique and AHP are more reliable than the other techniques. It is also noted that in the case of bubble sort and AHP, the time consumption is very high due to the rising number of decisions. The implementation of the AHP is complex, and in it the pairwise comparisons consume too much time for larger datasets. Karlsson et al. [38] conclude that the AHP and bubble sort are problematic for larger projects, and these techniques face the issue of scalability. In a research study, it is concluded that the AHP is not suitable for resolving the problem of scalability due to the exponential increase in the number of comparisons [44]. Laurent et al. [44] stated that the existing techniques are suitable for smaller or medium sized projects, and they are not suitable for larger projects with a large number of requirements. The AHP is only suitable for a small number of requirements [46]. Some of the existing software requirement prioritization techniques are described as follows:

Due to the high reliability of the results, the AHP is used in this research. The AHP is a statistical assessment technique proposed by Saaty [62]. The AHP is used to determine the best alternative, to set priorities and to allocate the resources [62]. Saaty [62] did not present the AHP for requirement prioritization; rather it was presented to solve the problems in the domains of social science, economics and management sciences. In this research, the AHP is applied for requirement prioritization. For n number of software requirements, the following formula is used to calculate the number of comparisons:
                           
                              
                                 n
                                 ×
                                 (
                                 n
                                 -
                                 1
                                 )
                                 /
                                 2
                              
                           
                        If there will be 25 requirements in a software project, then the total number of comparisons will be 300. In this research, the divide and conquer approach is applied on the requirements dataset based on some key aspects. The smaller clusters of the requirements are gathered which comprise competing requirements. In order to resolve such a situation, the AHP is chosen. The AHP is then applied on these clusters in order to provide a scalable solution for projects with a large number of requirements. The technique is suitable for software requirements with different dimensions or goals; for example, time, significance, associated risks, accuracy and benefits. The AHP works in an efficient and reliable way to solve the problem of requirement prioritization for projects with a small number of requirements. A complete description of the steps of the AHP is given in Section 5.2. Table 1
                         describes the pairwise comparison method of the AHP.

The Hierarchy AHP (HAHP) is introduced in order to solve the scalability issue of the AHP [38]. As the number of requirements increases in the AHP then the number of comparisons also increases. An increase in the number of comparisons reduces the efficiency of the AHP. Moreover, the AHP is only suitable for projects with few requirements and is not suitable for projects with large-scale requirements. Hence, in order to overcome this deficiency of the AHP the new approach HAHP is introduced. However, the HAHP is difficult to apply and is less reliable as compared to the AHP.

The Minimal Spanning Tree (MST) is presented in order to reduce the pairwise comparisons among requirements [38]. The redundant comparisons are eliminated, and the number of comparisons is reduced to n
                        −1 as compared to the AHP. The MST claims that the reduced number of comparisons is sufficient to measure the relative importance of the requirements.

The cost-value approach is presented in order to prioritize the requirements [37]. This approach focuses on the relationship between requirement value and implementation cost. The term value is taken as a benefit associated with the requirement, and the term cost is taken as expenditure in terms of finance and time in order to implement the requirement. Later, the AHP is applied in order to find out the cost-value relationship of the requirements.

In numerical assignment technique, the ordinal scale is used for grouping. The requirements are classified into different groups by the stakeholders [41]. The technique suffers from severe issues like how to define the exact group of a given requirement. In this technique, all the requirements are placed in the critical group. Hence, the implementation of all the requirements is considered as essential. It makes the technique less effective, and it loses its real purpose [4]. There are three major groups that are introduced in this technique like critical, standard and optional. Thus, all the requirements will be part of these three classes, and there may be some more. However, the requirements in each group possess same priority, and the competition exists among the requirements [15].

Theory W, also known as Win–Win Model, is based on initial planning, risk assessment and handling. The stakeholders rank all the requirements in the first stage based on the VBSE practices. Hence, all negotiations, related to the requirement value, are carried out in the first stage. The two main principles of this theory are ‘What values are important?’ and ‘How is success assured’ [20]. The technique is heavily based on expert judgments and is costly in terms of time consumption.

This technique is based on the principle of selection of top ten valuable requirements by the stakeholders. However, in this technique the individual priority of the requirement is not taken into account. The technique is suitable for a limited dataset of requirements in order to select a critical set of requirements. The granularity of the technique is not good [41]. The stakeholders are treated at par, and the same importance is given to all the entities. Hence, the technique loses its credibility as a prioritization technique.

Planning game is a customer-oriented prioritization technique. The representation of the requirements is made in the form of stories, and these stories are comprised of small sentences. Experts decide the inclusion and exclusion of a story in the first release and the effort, in terms of time, is also calculated by the experts. The stories are selected by the customers for the next releases of the software based on the time or effort estimated by the experts [17]. The technique is suitable for innovative developmental models, like extreme programming, due to the flexible behavior. In this technique, the two major parts of the planning process are release planning and iteration planning. In release planning, it is determined that which requirements must be realized in the first and the later releases of the software. In iteration planning, the different developer actions are planned after finalization of the requirements.

Cumulative voting (CV) or the hundred dollar test [45] is based on discussions. The requirements are analyzed holistically in the discussions. The stakeholders have an authority of 100$ money that they can assign to different requirements based on the significance of the requirements. Any number of dollars can be assigned to any requirement by a stakeholder. The dollars assigned by the different stakeholders to a given requirement are calculated and based on the sum of the dollars the final priority of the requirement is defined. The technique works well for a small number of requirements and is not suitable for projects that comprise large number of requirements.

The B-Tree prioritization technique is presented in [14]. The technique can cope with the issue of requirements volatility and a change in the dynamics of the requirements. In the B-Tree, the function f is used in order to plot the requirements based on the calculated priority values as given in the prioritized set of the requirements.

Ranking and numerical assignment are similar to each other due to the application of the ordinal scale [15]. The requirements are prioritized in a linear fashion, and the requirement with high priority is assigned a value of 1, the requirement with second highest priority is assigned a value of 2 and so on. However, the last requirement is assigned a value of n where n is the total number of requirements in the set. In the ranking approach, different algorithmic ways can be adopted to prioritize the requirements which may include bubble sort, quick sort, binary search tree and many others [74].

In bubble sort, the ranking approach is adopted to prioritize the requirements [38]. The priority is decided based on the importance of the requirement. However, it is not taken into account that to which extent a requirement is important. The steps adopted in the bubble sort technique are as follows:
                           
                              (a)
                              The requirements are arranged in the form of a column.

The top two requirements are compared and based on the priority the swapping is performed. The requirement with the higher priority is placed at the top.

All the requirements are compared and swapping is performed in order to define priority of each requirement.

Repetition is carried out from the start, and the top two requirements are compared again.

The hierarchical cumulative voting (HCV) deals with the issue of scalability [16]. The concept of HCV is same as in CV. In the HCV, the points are allocated to the requirements as the points are assigned in the CV. The only difference is in the selection process for a given set of requirements. In the HCV, the requirements are divided into different hierarchies or groups and later the requirements are prioritized based on the concept of CV.

The following steps are performed in the priority groups technique [38].
                           
                              (a)
                              Prepare a set of all requirements.

Define the priority groups of the requirements like high priority, medium priority and low priority.

More sub-groups may be created based on the number of requirements, and the requirements may be adjusted in these sub-groups.

Repeat step 3 until a relationship of one on one is not achieved.

Read the requirements from the left to right.

This technique is suitable for a small number of requirements. However, in the case of large number of requirements the technique is not viable.

It is a priori or posteriori approach which is based on the interactive genetic algorithm (GA) and pairwise comparison [67,68]. The main purpose of this technique is to “extract the relevant knowledge from the user”. In the existing techniques, the exhaustive pairwise comparisons are impractical. Hence, the GA is introduced in order to reduce the number of comparisons. In this technique, the input to the fitness function is incremental and in the beginning it is partially known.

The case-based ranking (CBR) technique is proposed to design a decision-support system for interactive preference elicitation [10]. The pairwise comparison, in order to support the elicitation of preferences, is based on the Boolean values. The CBR technique provides an acquisition policy to recommend that which pairs of the cases must be analyzed in the first attempt. The machine learning approach is adopted to predict or approximate the preference values of the pairs that are unknown. The error and effort minimization approach is adopted to achieve the accurate approximated ranks of the requirements.

The value-based intelligent requirement prioritization (VIRP) technique comprises three major steps. In step one, the requirements are elicited and prioritized by the stakeholders. The step two is based on expert level prioritization in which the value of a requirement is calculated based on the RV function. The RV function comprised two types of requirement factors. There are requirement specific requirement classification factors which are denoted by rRCFs and project specific requirements classification factors which are denoted by pRCFs. In step three of the VIRP, fuzzy c-means is used in order to classify the requirements into different clusters. Step 2 of the VIRP technique is used in this research. The VIRP technique is described in detail in Section 3.

The existing techniques are not suitable for the projects that have large or medium datasets [13]. The aim of this research paper is to solve the problem of the scalability of larger projects when the requirements grow to the hundreds or even thousands. The problems of existing software requirement prioritization techniques are as follows:
                           
                              •
                              The existing techniques do not provide a scalable solution when the requirements are scaled up in the case of a large number of requirements [3,13,69].

The existing techniques do not provide sufficient automation and are not intelligent enough [55].

Most of the techniques are time-consuming [4,13,70].

Difficult to implement due to the complexity [42,70].

The results are faulty and do not recall [13,39].

The existing techniques mostly solve the issues of small-scale requirements but with errors [13,31,42].

This research focuses on the first problem, namely, that the existing techniques do not provide a scalable solution when the requirements are scaled up in the case of a large number of requirements. An expert decision support system, called PHandler, is proposed for the requirement prioritization process in order to make the prioritization process scalable and effective. In this research paper, three different research approaches are used to develop an expert system for a scalable software requirement prioritization process: the VIRP technique, neural networks, and the AHP.

The requirement prioritization process shows a higher degree of opinions about requirements’ values, and estimates of the different requirements’ attributes add a higher level of uncertainty in the process. The different degrees of opinions and uncertainty make the process highly nonlinear. However, the Artificial Neural Network (ANN) can solve both linear and non-linear problems without the prior assumptions that are normally required in statistical models. In this research, the ANN is applied for requirement value prediction which works as an information processing system and has a resemblance to biological neural networks [26,54]. The ANNs are normally used to predict, approximate and solve the linear and nonlinear problems [28,66]. The ANNs can map a relationship between the given inputs and the intended outputs for the intended process without taking into account the phenomenon of physics explicitly [75]. The application of ANN is described in detail in Section 5.1.

VIRP is a multi-level iterative technique for the prioritization and classification of software requirements and works in collaboration with stakeholders, experts and automated fuzzy logic [55]. The purpose of iteration in VIRP is to evaluate the requirements iteratively with the help of different actors in order to achieve reliable results. The VIRP model is shown in Fig. 1
                     .

The VIRP technique consists of the following three major steps [55]:
                        
                           (i)
                           Requirement elicitation and stakeholder level prioritization

Expert level prioritization

Fuzzy logic-based requirement prioritization

The three steps are briefly described below.

There are two main activities in the requirement elicitation and stakeholder level prioritization step. First, all the requirements are gathered and stored in the database using a web-based application along with the requirement priorities set by the stakeholders. Second, by using the same web-based application the stakeholders will also submit their profiles by giving a brief description. Based on the profiles, the quantification of stakeholders is also performed in order to know the worth of the stakeholders. The profiles of the quantified stakeholders are later used to resolve the conflicts among competing requirements.

In the second step of expert level prioritization, the experts have to play a vital role. Three main tasks are performed by the experts at this level. In the first task, the experts review the requirements in quick sessions without taking into account the profiles of the stakeholders. The modifications of the priorities are performed by the experts in this task. In the second task, the quantification of the stakeholders is performed by the experts using a ranking method. Stakeholders are the key entities which may help to improve the software quality to a great extent. A high priority is given to stakeholders in the STAR triangle [11]. In the VIRP, a score or value is assigned to each stakeholder in the range of 1–10 for their quantification. The stakeholder values are defined on the basis of key attributes such as significance, domain knowledge, participation level, dependency, control and level of decision making. The third task in this step is to assign a value to each requirement based on certain requirements classification factors (RCFs). The valuation is performed to prioritize the requirements. RCFi denotes factor whose degree of presence or absence in a requirement can have a direct bearing on its value [55]. The RCFs are of two main types. The first type is the project specific RCFs denoted by pRCFs, that show the requirement’s value or importance with respect to the project. The pRCFs are feasibility, modifiability, urgency, traceability, and testability. The second type is the requirement specific RCFs, denoted by rRCFs. The rRCFs illustrate the requirement attributes in order to find the value of a requirement. The rRCFs are completeness, consistency, understandability, within the scope and non-redundancy. Once again, a ranking system is used by the experts to score all the RCFs. A value is assigned to each RCF in the range of 0–5. The scores of all these RCFs are used to determine the value of a requirement (RV) using Eq. (1):
                           
                              (1)
                              
                                 RV
                                 =
                                 0.35
                                 +
                                 0.02
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFi
                                          +
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          rRCFi
                                       
                                    
                                 
                              
                           
                        In Eq. (1), i denotes the requirement classification factors (RCFs) and the integer 5 shows the total input to the RV function in the form of five pRCFs and five rRCFs. The RV obtained is in the range of 0.35–1.35 with an interval of 0.02 between each consecutive value. Thus, there is a total of 51 data classification values. A situation may arise during prioritization when the values of two or more requirements will be the same. Hence, the following five exceptions are given to solve this problem.


                        Exception 1: When two or more requirements have similar RV, then the value of pRCF is used as a deciding measure. A high priority is given to a requirement that possess higher pRCF value. For example for any two requirements i and j when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                          
                                          then
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          
                                          pRCFi
                                          >
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   i
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          
                                          pRCFj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          
                                          ⇒
                                          
                                          RVi
                                       
                                    
                                    
                                       
                                          else
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          
                                          ⇒
                                          
                                          RVj
                                       
                                    
                                 
                              
                           
                        
                     


                        Exception 2: When the value of requirements i is equal to the requirement j and the value of pRCFi is equal to the value of pRCFj. For example, for any two requirements i and j, when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                          
                                          then
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          
                                          pRCFi
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   i
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          
                                          pRCFj
                                       
                                    
                                 
                              
                           
                        Then the prioritized profiles of the stakeholders are used. The stakeholder profile value (vST) helps to determine which stakeholder is more important among the competing ones [55]. Based on the importance of the stakeholder profiles, the priority of a requirement is defined. The stakeholders are divided into the following three categories based on their profile scores or values.
                           
                              •
                              The stakeholders with high profile value

The stakeholders with medium profile value

The stakeholders with low profile value.

The following criterion is used to categorize the stakeholders based on their profile values.
                           
                              (2)
                              
                                 Avg
                                 (
                                 all
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       vST
                                    
                                    
                                       N
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 Stakeholder
                                 
                                 with
                                 
                                 higher
                                 
                                 vST
                                 =
                                 vST
                                 ⩾
                                 Avg
                                 (
                                 all
                                 )
                              
                           
                        Take the average of the vST of all the selected stakeholders who are part of the requirement elicitation phase. In Eq. (2), the sum of the vST of all stakeholders 
                           
                              (
                              n
                              )
                           
                         is taken and is divided by N, which represents the total number of selected stakeholders. The stakeholders with the vST greater than or equal to the average of all stakeholders are placed in the stakeholder category with higher vST or profile values. The stakeholders with the vST less than Avg(all) are denoted as remaining stakeholders (RS), and their number Nr is calculated by subtracting the total number of stakeholder with higher vST from N. The average of the vST of the remaining stakeholders (RS) is calculated by using Eq. (3):
                           
                              
                                 Nr
                                 =
                                 N
                                 -
                                 Stakeholder
                                 
                                 with
                                 
                                 higher
                                 
                                 vST
                              
                           
                        
                        
                           
                              (3)
                              
                                 Avg
                                 (
                                 RS
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       vST
                                    
                                    
                                       Nr
                                    
                                 
                              
                           
                        The stakeholders with the vST less than Avg(all) and greater than or equal to Avg(RS) are placed in the stakeholder category with medium vST or profile value:
                           
                              
                                 
                                    
                                       
                                          Stakeholder
                                          
                                          with
                                          
                                          medium
                                          
                                          vST
                                          =
                                          Avg
                                          (
                                          RS
                                          )
                                          ⩽
                                          vST
                                          <
                                          Avg
                                          (
                                          all
                                          )
                                       
                                    
                                    
                                       
                                          Stakeholder
                                          
                                          with
                                          
                                          low
                                          
                                          vST
                                          =
                                          vST
                                          <
                                          Avg
                                          (
                                          RS
                                          )
                                       
                                    
                                 
                              
                           
                        However, the stakeholders with vST value less than Avg(RS) are placed in the stakeholder category with low vST or profile value.

Exception 1 and Exception 2 are not sufficient to resolve the competition among requirements when the requirements increase in number. Hence, based on the vST three more exceptions are derived from Exception 2 of the VIRP for requirement conflict resolution and scalability. Exception 2 is formulated based on the vST and is denoted by Exception 2a.


                        Exception 2a: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is greater than the value of stakeholder j, then the stakeholder with a stakeholder value vST greater than the other stakeholder is used as a deciding measure. For example, for any two requirements, i and j, when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFi
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   i
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          vSTi
                                          >
                                          vSTj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          
                                          ⇒
                                          
                                          RVi
                                          
                                          of
                                          
                                          vSTi
                                       
                                    
                                    
                                       
                                          else
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          
                                          ⇒
                                          
                                          RVj
                                          
                                          of
                                          
                                          vSTj
                                       
                                    
                                 
                              
                           
                        
                     


                        Exception 3: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, then the requirements of the stakeholders with high vST values are given high priority as compared to the stakeholders with medium and low stakeholder values. For example, for any two requirements i, and j, when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFi
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   i
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          vSTi
                                          =
                                          vSTj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          ⇒
                                          RVi
                                          
                                          of
                                          
                                          stakeholder
                                          
                                          of
                                          
                                          high
                                          
                                          vST
                                       
                                    
                                 
                              
                           
                        
                     


                        Exception 4: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, Then the requirements of the stakeholders with medium vST values are given high priority as compared to the stakeholders with low stakeholder value. For example, for any two requirements i, and j, when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFi
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          vSTi
                                          =
                                          vSTj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          high
                                          
                                          priority
                                          
                                          ⇒
                                          
                                          RVi
                                          
                                          of
                                          
                                          stakeholder
                                          
                                          of
                                          
                                          medium
                                          
                                          vST
                                       
                                    
                                 
                              
                           
                        
                     


                        Exception 5: When two or more requirements have similar RV and the value of pRCFi is equal to the value of pRCFj and the value of stakeholder i is equal to the value of stakeholder j, then the last priority is given to the requirements of the stakeholders with low vST values. For example, for any two requirements i, and j, when the situation is:
                           
                              
                                 
                                    
                                       
                                          RVi
                                          =
                                          RVj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          if
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFi
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   5
                                                
                                             
                                          
                                          pRCFj
                                       
                                    
                                    
                                       
                                          and
                                       
                                    
                                    
                                       
                                          vSTi
                                          =
                                          vSTj
                                       
                                    
                                    
                                       
                                          then
                                       
                                    
                                    
                                       
                                          priority
                                          
                                          ⇒
                                          
                                          RVi
                                          
                                          of
                                          
                                          stakeholder
                                          
                                          of
                                          
                                          low
                                          
                                          vST
                                          
                                          value
                                       
                                    
                                 
                              
                           
                        The second step is non-scalable, manual and is the cause of biases induced by the experts. It also reduces the performance of the technique in terms of time. The Back Propagation Neural Network (BPNN) is applied in the second step (expert level prioritization) of the VIRP technique in order to make the technique scalable and less prone to biases. The function used to calculate the RV of a requirement is the base of input parameter or data for the BPNN. The RV is predicted using the BPNN. The use of the BPNN reduces the experts’ bias and improves the performance in terms of time. Section 5.1 describes the application of the BPNN.

In the third step of the VIRP technique, the fuzzy c-means (FCM) clustering method is used in order to create clusters of the requirements. The FCM clustering method was presented in order to divide data into different clusters of similar types of data sets [25]. An improved version of the FCM was later presented in [19]. There are two major types of clustering, namely, fuzzy clustering and hard clustering based on the fuzzy problem and hard problem. In clustering, the data possess two properties, namely, homogeneity and heterogeneity. In the case of homogeneity, the objects of one class or cluster are similar to each other. In the case of heterogeneity, the objects in one class are dissimilar to the objects of other classes [57,59]. The data points in fuzzy clusters possess a degree of fuzzification that shows their links with different clusters instead of showing their association with a single cluster. However, the situation is different in the case of RV. The RV data are homogenous and the set of requirements with the same RV cannot be associated with other clusters or sets of requirements which have a different RV. Based on the RV, the RV function divides requirements into 51 key clusters which are an example of hard clustering. The RV data in the current research belong to a hard problem and not a fuzzy problem. Hence, the fuzzy clustering in the case of the VIRP model is unable to provide a scalable solution for large-scale projects with a large number of requirements. In this research, the AHP is applied in order to achieve scalability.

An expert decision support system deals with a planning problem. “Very often a planning problem can be formulated as a ranking problem: i.e. to find an order relation over a set of alternatives. This order relation is usually interpreted as a sort of priority index that supports a selection policy” [10]. Hence, in this paper the planning problem approach is adopted. An expert system is a computer program which mimics the reasoning and behavior of a human specialist or expert [29,51]. In an expert knowledge-based system, the expert heuristics is applied in order to produce optimum results.

The proposed expert system, PHandler, is shown in Fig. 2
                     . The PHandler expert system heavily relies on expert knowledge in order to make the requirement prioritization process efficient and scalable. The PHandler system comprises three stages. The first stage of the PHandler is based on the VIRP approach. In the first step of VIRP, the stakeholder analysis is carried out as per the given ranking criteria and the requirements are gathered by conducting regular sessions with stakeholders. In the next step, the requirements are prioritized using the RV function that comprises the requirement classification factors, pRCF and rRCF. The values assigned to the pRCF and rRCF, by the experts, are given as an input to the BPNN for RV prediction. In order to resolve the conflicts among the requirements, which have same RV, the five exceptions are proposed in the VIRP as described above in Section 3.2. The exceptions are based on the stakeholders’ profile values. The stakeholders’ profile values are given as an input to the exceptions along with the RV. The data flow of the stakeholders’ profiles is represented by brown arrows in Stage 2 of the PHandler system as illustrated in Fig. 2. In the second stage of the PHandler system the exceptions are applied in order to resolve the competition. In the third and last stage of the PHandler system, the AHP is applied in order to resolve the conflicts among the requirements that are prioritized after the application of the proposed exceptions. In Fig. 2, the parallelogram symbols are the inputs and outputs of the system; the rectangles represent the processes, and the arrows represent the flow of the data and process at the same time.

The proposed exceptions divide the requirements with the same RV into five sub-clusters as shown in Fig. 2. Firstly, the requirements with the same RV and higher pRCF values are given a priority of 1 (P1). Secondly, the requirements with the same RV and higher stakeholder value (vST) are given a priority of 2 (P2). Thirdly, the requirements with same RV, the same vST but stakeholders with high values are assigned a priority of 3 (P3). Fourthly, the requirements with the same RV, the same vST but stakeholders with medium values are assigned a priority of 4 (P4). Lastly, the requirements with the same RV, the same vST but stakeholders with low values are assigned a priority of 5 (P5). In the case of P1 and P2, the requirement sets consist of the requirement values that are already prioritized. However, the clusters of P3, P4 and P5 are later prioritized using the AHP due to the induced competition. After applying the AHP on P3, P4 and P5, there will be five prioritized lists of the requirements as an output in the form of data. By combining them, a final prioritized list of the requirements data is obtained. The next Section 5 describes the experimental setup.

In this section, the experimental setup related to the application of the BPNN and AHP is described in detail.

In the PHandler system, the requirement value is predicted by using the BPNN in order to reduce the expert biases and make the VIRP efficient and scalable. The BPNN consists of three main layers i.e. weighted input layer, a hidden layer, activation or transfer function and the output layer. In Fig. 3
                        , b is the bias that is normally added in order to force a network to learn a pattern. The circles represent the weights ‘ω’ that are multiplied with the inputs. The weights are initialized randomly, and the network is trained to minimize the mean squared error (MSE) in order to obtain the optimized results. However, overtraining leads to the reduced performance of the BPNN due to several training epochs [22]. In order to overcome this issue, the BPNN is simulated using different activation and training functions for optimized results.

The two main types of learning approaches are supervised and unsupervised learning. Normally, a supervised ANN is used for real world problems. In the supervised learning process, historical data are required in terms of examples, cases and instances of all participating classes. The data are used to know the similarities in the data in unsupervised learning and are used to predict the class of an object by using supervised learning [5]. In the case of requirement prioritization, the historical data are not available. Hence, the training data for the ANN are gathered from ten factors of pRCF and rRCF as described in the RV function of the VIRP. We have selected seven projects for data collection. The stakeholders of the projects were prioritized as per the criteria given in the VIRP. The requirement sets were handed over to industry professionals in order to assign values to factors of pRCF and rRCF for each requirement. The experts assigned a value in the range of 0–5 to each factor. The input to the ANN can be represented as:
                              
                                 
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          x
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          3
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          n
                                       
                                    
                                    }
                                 
                              
                           For example, an expert selects the values 
                              
                                 x
                                 =
                                 {
                                 4
                                 ,
                                 3
                                 ,
                                 1
                                 ,
                                 5
                                 ,
                                 2
                                 ,
                                 3
                                 ,
                                 5
                                 ,
                                 4
                                 ,
                                 5
                                 ,
                                 2
                                 }
                              
                            for the ten factors of pRCF and rRCF for a given requirement. The net input to the RV function is the sum of all ten factors (i.e. 34), and the value of the RV is 1.03 according to Eq. (1). The input data P or RCF values are added here and given as an input to the ANN as they are homogenous mixtures. There are 51 classes of input data P in the range of 0–50 with a geometric progression of one. The target data T is in the range of 0.35–1.35 with a geometric progression of 0.02. The input and target data represent all the possibilities that may occur in a given problem domain. The summation of the ten factors is directly mapped with the output of the RV function in order to train the BPNN. The experts also calculated the RV of each requirement in the range of 0.35–1.35 by applying Eq. (1). Table 2
                            describes a partial dataset sample.

In order to train and optimize the BPNN, different training functions are applied to predict the RV for an optimum solution of the problem. For an optimized solution, the knowledge of the process is also highly desirable which means the key aspects of all the procedures must be well defined. Moreover, for optimized results, the input data are pre-processed by using normalization in order to obtain an even distribution of data in the range of −1 to 1. The ‘tanh’ hyperbolic tangent activation function is used in the hidden layer and is represented by the following formula:
                              
                                 (4)
                                 
                                    tanh
                                    =
                                    
                                       
                                          
                                             
                                                e
                                             
                                             
                                                x
                                             
                                          
                                          -
                                          
                                             
                                                e
                                             
                                             
                                                -
                                                x
                                             
                                          
                                       
                                       
                                          
                                             
                                                e
                                             
                                             
                                                x
                                             
                                          
                                          +
                                          
                                             
                                                e
                                             
                                             
                                                -
                                                x
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           Table 3
                            presents the initial training results after using different training functions before the validation phase. The training functions used in the BPNN application are trainlm, trainbr, trainbfg, trainrp, trainscg, traincgf, traincgp, trainoss, traingdx, traingdm and traingd. The BPNN is trained by applying all the specific training parameters in order to obtain the optimized results. The results are reported after several cycles of the training. Initially, the RV of a requirement is predicted by using the BPNN architecture of 1-10-1 (input-hidden nodes-output). However, in the validation phase of the BPNN application, the different architectures are applied in order to find out the impact of the hidden nodes on accuracy of the results. The BPNN architecture mainly depends on the number of hidden units in the hidden layer. Such an application of the BPNN methodology helps in finding out the most optimized BPNN architecture that best resolves the problem of requirement prioritization.

The results in Table 3 show that the RV obtained from the trainlm and trainbr functions are highly optimized as compared to other functions. The other functions are unable to produce the optimized results due to the following reasons:
                              
                                 (i)
                                 The training cycles have met the stated threshold.

The time threshold to train the network has been reached.

The performance goal is not met.

The performance gradient has fallen below the adjusted value of mingrad.

The threshold of mu_max is exceeded.

The max_fail times increased the validation performance since its last decrease.

The MSE of the BPNN decreases with an increase in the training iterations. The observation of the MSE helps in the verification and validation of the BPNN with the change of each epoch [30]. The initial training results show that the training functions of trainlm (Levenberg–Marquardt backpropagation) and trainbr (Bayesian regularization) are the possible solutions for the RV problem. Hence, initially the trainlm and trainbr training functions are selected for further experimentation. The results of the selected training algorithms for the validation data are given in Table 4
                            as a sample.

The predicted output of the trainlm and trainbr training functions shows that the results produced by trainlm are more optimized as compared to the trainbr function. The error in the case of trainbr is higher than in trainlm. Fig. 4
                            shows that the predicted RV, using trainbr, do not map the training data, and the deviation from the training data points is very high. The software requirements with a higher RV have higher errors in the case of trainbr. However, in the case of trainlm the predicted RV shows a lesser deviation trend from the training data in Fig. 5
                           . The solution given by the trainlm training algorithm is more optimized as compared to the other training algorithms. Moreover, trainlm is an efficient and fast back-propagation training function and is highly recommended for supervised learning [50]. Hence, the trainlm training function is selected for the requirement prioritization process and is used in different neural network architectures in order to optimize the BPNN. The BPNN architecture depends mainly on the use of hidden layers, hidden nodes and activation functions. The results of the different BPNN architectures, based on the hidden nodes, are shown in Table 5
                           . The best-generalized results are achieved using BPNN architecture 1-16-1 and are shown in Table 6
                           . The results achieved with the 1-16-1 BPNN architecture have less error than the results achieved with the 1-10-1 BPNN architecture as shown above in Table 4. Moreover, the same BPNN architecture has been tested for trainbr and resulted in the over-fitting problem and bad performance generalizations [32].

Different BPNN architectures were used to obtain an optimized solution. The change in the number of hidden nodes results in the evolution of new BPNN architectures. The results are analyzed carefully, and the BPNN architecture of 1-16-1 is selected as the best solution for the said problem. Table 5 presents the results of the different BPNN architectures for single input 35 and single target output 1.0500. However, the whole training dataset is used in the experimentation. Table 6 presents the optimized results of the selected architecture. The other BPNN architectures are not suitable due to the higher errors and over-fitting problems. The architectures with hidden nodes greater than 16 resulted in the over-fitting problem.

For larger requirement datasets, the VIRP is not scalable. Hence, during requirement prioritization, several requirements are competing with each other in terms of having the same RV as predicted by the BPNN. Initially, the competition can be resolved by using the exceptions (Section 3.2]. The proposed five exceptions divide the requirements with the same RV into five sub-clusters. Later, to resolve the competition of sub-clusters, the AHP is applied as “a tool of information communication and signification” [62]. The AHP is concerned with semiotics in which a semantic system is used for signal codification using a pre-defined set of rules [63]. The AHP is applied on competing requirements and for each sub-cluster of competing requirements the eigenvalues are estimated in order to find out the priority matrix (PM). The consistency index (CI) and consistency ratio (CR) are calculated in order to identify the consistency or accuracy of the results. The AHP comprises the following five steps:
                           
                              Step 1: Matrix formulation of order n
                              

In the first step of the AHP, a matrix of order n is formulated. A matrix of order n is actually an n x n matrix where n represents the number of rows and columns. In this research, we assume n as the candidate requirements.

Step 2: Pairwise comparisons of the requirements

In this step, the pairwise comparisons of all the requirements in the matrix of order n are performed. The fundamental comparison method for pairwise comparisons is shown above in Table 1. The requirements are compared with each other (starting with R1 and R1, R1 and R2, R1 and R3 and so on). Here, R represents a requirement. The main diagonal of the matrix must be a 1 because when a requirement in the matrix is compared with itself then it is treated as equally important. Hence, a value of 1 is inserted in all positions of the diagonal. The case of R1 and R2 is taken here. When R1 of the matrix is compared with R2 of the matrix, then the relative value is placed in a position where the row of R1 meets the column of R2. The reciprocal value is placed in a position where the row of R2 meets the column of R1.

Step 3: Normalization of matrix and estimation of eigenvalues

Saaty [62] proposed the averaging over normalized columns method to normalize the matrix in order to estimate the eigenvalues. The value of each requirement in the column is divided by the sum of the column and later the average value is computed for each row. This mechanism results in a normalized matrix and estimation of eigenvalues. The estimation of the eigenvalues results in the priority matrix.

Step 4: Assignment of value to each requirement

In this step of the AHP, a relative value is assigned to each requirement of the matrix based on the eigenvalues.

Step 5: Result accuracy estimation

In order to estimate the accuracy of the results, the first step is to calculate the CI. The CI is calculated using the following formula:
                                    
                                       (5)
                                       
                                          CI
                                          =
                                          
                                             
                                                (
                                                λ
                                                max
                                                -
                                                n
                                                )
                                             
                                             
                                                (
                                                n
                                                -
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 The λ max is the maximum principle eigenvalue, which is estimated by multiplying the comparison matrix with the priority matrix. In Eq. (5), n refers to the total number of requirements. Then each element of the resulting vector is divided by the respective element in the priority vector. Element 1 of the resulting vector is divided by Element 1 of the priority vector, Element 2 of the resulting vector is divided by Element 2 of the priority vector, and so on. In order to identify the acceptability of the CI value, the CR is calculated by using the following formula:
                                    
                                       (6)
                                       
                                          CR
                                          =
                                          
                                             
                                                CI
                                             
                                             
                                                RI
                                             
                                          
                                       
                                    
                                 where RI is the random index based on the scale of 1–9 as shown above in Table 1. The RI values applied in this research are taken from [6]. Alonso and Lamata [6] gave the RI values for a matrix where the value of n (number of requirements) is 39.

@&#EXPERIMENTS@&#

In order to prove the hypothesis of this research, seven experiments are conducted based on the above-mentioned experimental setup. The different datasets of the requirements are taken in seven experiments which comprised 14, 25, 50, 100, 200, 400 and 500 requirements. This “research treats 1 to 14 (inclusive) requirements as a “small” number of requirements, 15–50 (inclusive) requirements as a “medium” number of requirements, and more than 50 requirements as a “large” number of requirements” [48]. Hence, in this experimentation the project requirements are categorised into small, medium and large datasets as per the description given by Ma [48]. In this research, four experiments are performed on larger datasets in order to validate the hypothesis. Table 7
                      describes the details of the datasets of the different experiments.

The results of the seven experiments obtained from the BPNN are shown in Figs. 6–12
                     
                     
                     
                     
                     
                     
                     . The frequency of the same RV is shown in the form of clusters in each figure. As the number of requirements increases, the competition among the requirements also increases. The VIRP divides the prioritized requirements into 51 clusters based on the RV. In order to resolve this competition between requirements, initially the proposed exceptions are applied which serve well for addressing the scalability problem. The use of the proposed exceptions enhances the scalability of the requirement prioritization process. For Experiments 1–4 the exceptions resolved the competition effectively. However, in Experiments 5–7 it is observed that, after the application of the exceptions, the competition still exists within the sub-clusters which are developed by the application of the exceptions; this is, due to the large number of requirements. In order to resolve this competition among these small clusters of requirements, the AHP is applied as a decision support tool to determine the best among several alternatives. In Figs. 6–12, the x-axis shows the RV predicted by the neural network and the y-axis shows the frequency or total number of requirements in each cluster with the same RV. The number of requirements with the same RV increases with an increase in the number of requirements in the dataset.


                     Table 8
                      presents a summary of the datasets of seven experiments based on the total number of requirements in each RV-based cluster with respect to the RV. The datasets with 400 and 500 requirements consist of more competing requirements as compared to the other datasets. The requirement values are shown in ascending order. In the first four experiments, the competition among the requirements is not very high and can easily be solved. However, the competition among the requirements of Experiments 5, 6 and 7 is high as compared to the first four experiments. For example, in Dataset 5, there are 32 requirements which have the same RV of 1.0279. Initially, the competition is resolved with the exceptions and, on average; the five sub-clusters possess six requirements. However, the case may vary after application of the exceptions. In the case of Dataset 7, there are 66 requirements which have the same RV of 1.0279. The initial competition among the requirements is resolved by the application of the proposed exceptions. Later, the AHP is applied to resolve the competition among the competing requirements in all the cases. In Dataset 7, the highest competition exists among the 66 requirements due to the same RV. Hence, the case of Dataset 7 is selected for further investigation and is described in detail in Section 7.

Dataset 7 with 500 requirements is selected in order to justify the claim of the proposed PHandler expert system in terms of scalability. Initially, the requirements are divided into 27 major clusters based on the RV as shown in Table 9
                     . Later on, the RV-based clusters are divided into sub-clusters by using the proposed exceptions. Column 2 of Table 9 shows the RV predicted by the BPNN. Column 3 describes the frequency of occurrence of the RV, which means how many requirements have this same value. Column 4 describes the results after the application of the first exception (E1), and the priority is denoted as P1. Column 5 describes the results of the application of the second exception (E2), and the priority is denoted as P2. Column 6 describes the results of the application of the third exception (E3), and the value of all stakeholders is high which is denoted by priority P3. Column 7 describes the results of the application of the fourth exception (E4), and the value of all stakeholders is medium which is denoted by priority P4. Column 8 describes the results of the application of the fifth exception (E5), and the value of all stakeholders is low which is denoted by priority P5. Columns 9, 10 and 11 describe the number of requirements that are stated by the same stakeholders.

The requirement with an RV of 1.3149 has the highest priority and must be implemented first under all circumstances. There are two requirements in the RV cluster with Identity 2 and have the same RV 1.2869. The requirements are divided into different clusters based on their RV. However, for a dataset of 500 requirements, the RV cluster with Identity 15 consists of the largest number of 66 requirements that have the same RV of 1.0279 and the highest competition exists among these requirements. These 66 requirements are divided into 5 sub-clusters, which comprised 5, 8, 20, 14 and 19 requirements after the application of the exceptions. These exceptions enabled the AHP to be easily applied in the next phase. Initially, the data is divided into RV-based clusters which are divided into sub-clusters after the application of the proposed exceptions that are represented by E1, E2, E3, E4 and E5 in Table 9. Later, the AHP is applied on these sub-clusters in order to resolve the requirement competition and finally the prioritized dataset is achieved.


                     Table 9 shows the 27 different clusters of requirements that are differentiated based on their RV predicted by the BPNN. All these clusters are listed based on the higher RV. In the case of projects with a large number of requirements, the initial considerations are given to the prioritized clusters in consecutive order. For example, initially, the requirement cluster with Identity 1 is given a high priority and then the requirement cluster with Identity 2 is given the next priority and so on. In order to prioritize the existing prioritized sub-clusters, the AHP technique is applied on each of the sub-clusters. The technique worked effectively to resolve the competition among the various requirements. Thus, the AHP works well for smaller sets of requirements with high accuracy.

The results for Identity 13 show that there are a total of 35 requirements with an RV of 1.0665 as shown in Table 9 and the sub-clusters comprised 5, 13, 7, 6 and 4 competing requirements. The priority P4 of Identity 13 consisted of six competing requirements and in order to resolve the competition among them the AHP is applied. The different steps taken in the application of the AHP are described here.
                        
                           Step 1: Matrix formulation of order n
                           

In the first step of the AHP, a matrix of order n is formulated which comprised six requirements (R1, R2, R3, R4, R5 and R6).

Step 2: Pairwise comparisons of the requirements

In this step, the comparison of the requirements is carried out based on the scale as given in Table 1. In this experiment, there are a total of six requirements; hence, the total number of comparisons is 15. Table 10
                               shows the pairwise comparisons of the requirements.

Step 3: Normalization of matrix and estimation of eigenvalues

In this step, the averaging over normalized method is used (as described above in Section 5.2]. The requirements matrix is normalized in order to estimate the eigenvalues. The estimated eigenvalues are also called the PM. Table 11
                               shows the normalized requirements matrix and eigenvalues.

The estimation of the eigenvalues resulted in the PM which represents the individual value of each requirement in the cluster. The PM is shown below in the form of values rounded to the three significant digits:
                                 
                                    
                                       PM
                                       =
                                       
                                          
                                             
                                                0.218
                                             
                                          
                                          
                                             
                                                0.117
                                             
                                          
                                          
                                             
                                                0.236
                                             
                                          
                                          
                                             
                                                0.121
                                             
                                          
                                          
                                             
                                                0.109
                                             
                                          
                                          
                                             
                                                0.199
                                             
                                          
                                       
                                    
                                 
                              
                           

Step 4: Assignment of value to each requirement

In this step, the values are assigned to the requirements based on the eigenvalues or PM. The PM shows that R1 adds a value of 21.8% to the total value of the requirements, R2 adds a value of 11.7%, R3 adds a value of 23.6%, R4 adds a value of 12.1%, R5 adds a value of 10.9% and R6 adds a value of 19.9% to the total value of the requirements. Fig. 13
                               shows the individual impact of each requirement which is added to the total value of the requirements. The y-axis shows the number of requirements where a requirement is represented by R with its respective number, and the x-axis shows the impact of each requirement. R3 has the highest impact. Based on the requirement impact the implementation order of the requirements will be R3, R1, R6, R4, R2 and R5.

Step 5: Result accuracy estimation

In order to check the consistency of the results, the value of λmax is calculated and then used to calculate the CI. The value of the CI is used to calculate the value of the CR. In order to estimate the λmax, the comparison matrix shown in Table 10 is multiplied by the PM. This resulted in a new vector as shown in Table 12
                               which is referred to as a resulting vector (ReV).

Each element of the ReV is divided by the respective element of the PM as shown in Table 12. Then, the average of the ReV/PM column is calculated which resulted in the value of λ max. Hence, the value of λ max is:
                                 
                                    
                                       λ
                                       
                                       
                                          max
                                       
                                       =
                                       
                                          
                                             9
                                             +
                                             4.5
                                             +
                                             10
                                             +
                                             5.333333
                                             +
                                             4.5
                                             +
                                             8
                                          
                                          
                                             6
                                          
                                       
                                       =
                                       6.888889
                                    
                                 
                              The value of the CI is calculated by using Eq. (5). The value of the CI is 0.177778. The value of the CI and RI is used to calculate the value of the CR. The value of CR is calculated by using Eq. (6). The CR value for the selected requirements matrix is 0.143369. The ideal CR value should be <0.10 under ideal circumstances, and the CR value is acceptable up to <0.20. However, it is usual that the CR value normally exceeds the ideal value.

For better justification of the PHandler system, the AHP results of the requirements cluster with Identity 15 are also shown. The sub-cluster of the Identity 15 with priority P3 comprises 20 requirements. Table 13
                               shows the pairwise comparisons of the requirements. Table 14
                               shows the normalized requirements matrix and estimated eigenvalues. Table 15
                               shows the calculations related to the CI.

The estimated PM or eigenvalues for 20 requirements and their impacts are shown in Fig. 14
                              . Among the requirements, R7 has the highest impact and adds a value of 6.4% to the total value of the requirements.


                              Fig. 14 shows the individual values added by all 20 requirements to the total value of the requirements. The calculated CR value for the 20 requirements is 0.1769, which is less than the acceptable threshold value. Hence, the AHP is applied to all the sub-clusters of the requirements in order to refine the prioritization process. The application of the AHP makes the system more scalable. Moreover, the total number of comparisons also reduced in the case of the AHP. Otherwise, the application of the AHP on 500 requirements would be impractical.

The AHP approach is applied consecutively to all other sub-clusters of the RV-based requirement clusters. The AHP is applied in order to resolve the competition and achieve a prioritized and managed list of all the requirements. Fig. 15
                               shows an abstract view of the prioritized list of the requirements. However, in the list, the RV cluster with Identity 1 comprised only one requirement with the highest value of 1.3149. In Fig. 15, R1 refers to the first requirement in a sub-cluster, while Rn is the last or nth requirement.

Different researchers have performed a comparative analysis of the different software requirement prioritization techniques in order to measure the performance of these techniques. In this section, some well-known requirement prioritization techniques are considered and compared in order to evaluate the performance of the proposed expert system, PHandler. Performance can be measured in terms of the accuracy of the results and the number of requirements to be prioritized by a given software requirement prioritization technique. The different software requirement prioritization techniques are evaluated, based on the number of software requirements as per the given evidence, in Table 16
                     . Most of the techniques prioritize only a small set of requirements that is less than (<) 20 requirements. When the number of requirements increases, the existing techniques are unable to handle the requirements and may result in higher time consumption and faulty results. However, the case-based ranking (CBRank), technique provides the evidence of prioritization of 100 requirements as shown in Table 16 and serves as a base for this research. The existing prioritization techniques applied three major assessment criteria, namely, comparison, ranking and evaluation. In the pairwise comparison, when the number of requirements increases it becomes difficult to compare a large number of requirements due to which most of the techniques suffer from the issue of scalability. The ranking and evaluation are normally used to rank the requirements in the initial phase of the prioritization and later the requirements enter into a competition due to having the same ranks. The ranking and evaluation methods work well for a small set of requirements. The existing software requirement prioritization techniques are not suitable for projects where the requirements are in the hundreds or even in the thousands.

Most of the studies conducted in the domain of software requirement prioritization show that the existing techniques support the prioritization of small-scale requirements. If we analyse the results shown in Table 16, with the exception of CBRank, interactive GA-based prioritization and cumulative voting, all the other approaches support the prioritization of a few requirements. The CBRank and interactive GA-based prioritization approaches focus on the issue of scalability in requirement prioritization using machine learning approaches. The CBRank [8,9,53] is presented based on case-based reasoning [1]. The CBRank approach follows the case-based ranking as proposed in [10] and focuses on the reduction of requirement comparisons. However, the interactive GA-based prioritization approach utilizes the genetic algorithm in order to provide a scalable software requirement prioritization. In both techniques, the experimentation has been carried out on a limited dataset as compared to the proposed expert system, PHandler.

In this research, the divide and conquer rule is applied in order to achieve the optimum throughput. Due to the divide and conquer rule, the proposed PHandler system achieves a prominent position among other requirement prioritization techniques. The experiments are conducted on smaller and larger datasets in order to measure the efficiency of the PHandler system in terms of scalability. The key effectiveness of the PHandler system is in the hybridization of the RV function of the VIRP, BPNN, proposed exceptions and AHP. The role of the RV is obvious as it helps initially in dividing the requirements into small clusters of requirements as shown in Figs. 6–12. For accurate RV function approximation, the BPNN is used. The application of the BPNN not only reduces the extent of the bias induced by the experts but also reduces the complexity by hiding the inner details of the RV function. Later, the exceptions are applied in order to reduce the extent of competition among the requirements. The application of stakeholder-based exceptions reduces the competition of the requirements and further divides them into smaller clusters. Lastly, the AHP is applied on the small requirement clusters which are achieved after the application of the stakeholder value exceptions. In most of the existing techniques, the estimation of the stakeholders is not performed; nonetheless, in the proposed PHandler system their role is obvious. From experimentation, it is apparent that the PHandler system outperforms the existing techniques, as stated in Table 16, based on the number of requirements.


                     Table 8 shows the results of the RV function as predicted by the BPNN, which are in the form of small prioritized clusters based on the RV scores. The results of the experiment with Dataset 7 show that 66 requirements with an RV of 1.0279 have the highest competition. Initially, the competition is resolved by applying the exceptions and later the AHP is applied. The AHP is a successful approach for resolving competition among the small number of requirements. As seen in the results in Tables 8 and 9, the main achievement is the reduction in the number of comparisons when the AHP is applied. Otherwise, it is difficult to prioritize a dataset comprising more than 20 requirements using the AHP. For a dataset of 500 requirements the total comparisons are 124,750, which is practically difficult to implement. The RV function of the VIRP provides initial support in dividing the data into main clusters, and the sub-clusters are achieved with the application of the exceptions as shown in the case of Dataset 7 in Table 9. This makes the application of the AHP feasible for the smaller datasets with the reduced number of comparisons. The hybridization of VIRP, BPNN and AHP solves the problem of scalability to a greater extent as shown in the results, and the efficiency of the PHandler system is far better as compared to the other techniques. The results show that the PHandler system will also work well for the experiments with a dataset of more than 500 requirements.

The relative performance of the PHandler system in percentage is shown in Fig. 16
                      with respect to the other techniques. The relative performance is measured based on the number of prioritized requirements by each technique mentioned in Table 16. A comparison of the PHandler system with other techniques is made based on the number of prioritized requirements and the performance of the PHandler system is shown in percentage as compared to the other techniques. If the CBRank is considered as a baseline for comparative performance analysis, then the efficiency of the PHandler system is 80% better based on the number of requirements. However, another way to assess the performance of the PHandler system is to take the average of the performances of the PHandler system against all the existing techniques in different studies. Hence, the average performance of the PHandler system against all the existing techniques shows that the PHandler system is 93.89% better in performance as compared to the other approaches based on the number of prioritized requirements. The performance of the PHandler system in percentage is calculated, against each existing technique, based on the highest number of requirements prioritized in a technique.

The other techniques which deal with large scale requirements and do not use machine learning approaches are presented in [14,23,44]. There is another study that focuses on the stopping criteria for pairwise comparisons in order to reduce the overall effort of the requirement elicitation and prioritization [35]. The B-Tree and Pirogov methods are used in these techniques in order to solve the problem of large-scale requirements. However, in the PHandler system, the pairwise comparisons of the AHP are automatically controlled and reduced with the application of the RV function of the VIRP and proposed exceptions. The reduction in pairwise comparisons results in reduced complexity and enhanced efficiency.

In the case of the proposed PHandler system for software requirement prioritization, the only major limitation is linked with the involvement of highly professional business analysts. An initial assessment of the pRCF and rRCF plays a vital role in the whole prioritization. The skills and domain knowledge of the professionals are highly vital in order to successfully estimate the values of the pRCF and rRCF and later to apply the AHP. Another minor limitation of the proposed system is the small increased effort due to the hybridization of the RV function of the VIRP and AHP. In the RV function, the ranking of the pRCF and rRCF factors and comparisons in the AHP increase the effort. The application of the BPNN reduces the effort that is associated with the manual calculation of the RV. However, the small increased effort can be compromised in order to achieve a scalable and reliable software requirement prioritization solution. Moreover, the effort can be reduced with the development of a tool that may support the proposed PHandler expert system.

@&#CONCLUSION@&#

Software requirement prioritization is the backbone of the software development life cycle. The requirements are gathered, prioritized and realized in order to launch the successful release of the software system. So far, a number of different software requirement prioritization techniques have been presented which meet the needs of projects with a small or medium set of requirements. The existing techniques are unsuccessful in the case of projects where the requirements are large in number. In this research, an expert decision support system called the PHandler is proposed in order to prioritize the large scale requirements efficiently for larger projects. The proposed PHandler system is an extensively knowledge-based system, and the resulting product is a hybridized sort of product. The proposed PHandler system is a combination of three main approaches, namely, VIRP, BPNN and AHP. The BPNN is applied to predict the value of the software requirement for prioritization purposes. The software requirement prioritization process is highly non-linear due to the expert judgments which result in expert biases. Hence, the RV is predicted with the help of the BPNN. Exceptions are applied for prioritizing those requirements where the RV is same, and lastly the ambiguity is removed with the application of the AHP. The exceptions help in dividing RV-based large clusters of requirements into sub-clusters, and the requirements of the sub-clusters are prioritized by using the AHP. The results show that the proposed PHandler expert decision support system works effectively in solving the problem of prioritization in projects with a large number of software requirements and that it overcomes the requirement scalability issue.

@&#ACKNOWLEDGEMENTS@&#

This research was initiated at the Universiti Teknologi Malaysia by the Software Engineering Research Group (SERG) in which innovative research is under way to solve different software engineering problems. Research is also ongoing into different high profile embedded software applications at the Embedded and Real-Time Software Engineering Laboratory (EReTSEL) Universiti Teknologi Malaysia. The authors give special thanks to all members of SERG and EReTSEL for their kind support and to the anonymous reviewers for their valuable comments.

@&#REFERENCES@&#

