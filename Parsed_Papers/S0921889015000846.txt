@&#MAIN-TITLE@&#Category-based task specific grasping

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A probabilistic approach for task-specific category based grasping is proposed.


                        
                        
                           
                           The grasp stability is maximized probabilistically over shape uncertainty.


                        
                        
                           
                           The approach integrates information over all training objects for better generalization.


                        
                        
                           
                           The technique can cope with a sparser training set than most data-driven methods.


                        
                        
                           
                           Only incomplete point clouds obtained from a single RGB-D image are needed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Category-based grasping

Task-specific grasping

Probabilistic grasping

Shape uncertainty

@&#ABSTRACT@&#


               
               
                  The problem of finding stable grasps has been widely studied in robotics. However, in many applications the resulting grasps should not only be stable but also applicable for a particular task. Task-specific grasps are closely linked to object categories so that objects in a same category can be often used to perform the same task. This paper presents a probabilistic approach for task-specific stable grasping of objects with shape variations inside the category. An optimal grasp is found as a grasp that is maximally likely to be task compatible and stable taking into account shape uncertainty in a probabilistic context. The method requires only partial models of new objects for grasp generation and only few models and example grasps are used during the training stage. The experiments show that the approach can use multiple models to generalize to new objects in that it outperforms grasping based on the closest model. The method is shown to generate stable grasps for new objects belonging to the same class as well as for similar in shape objects of different categories.
               
            

@&#INTRODUCTION@&#

Interaction with objects is an important ability for a robot acting in a real environment. Most manipulation tasks require grasping of objects. Grasping has been traditionally studied in the context of attaining a form or force closure but not all stable grasps are viable for all tasks. For example, tools usually need to be grasped by their handles for them to be usable. Task-specific grasps are then primarily meaningful in cases where the object belongs to a category compatible with the required task. Thus, for more complex tasks task-specific grasping relates then either to grasping of a known object or grasping a familiar object, i.e., an object of a known category.

Category-based grasping is most often performed by data-driven approaches. In case when a comprehensive database of objects and appropriate grasp configurations are available, the problem is relatively easy to solve because there is always a model in the database that is a good fit to the particular object to be grasped. In practice this is not realistic because constructing such databases is computationally expensive and time consuming. Moreover, determining the correct object in the database is not trivial because fitting of incomplete and noisy measurements obtained with e.g. an RGB-D sensor is difficult.

This paper proposes a task-specific grasping method that (a) is able to generalize from a sparse set of examples of objects and related grasps to novel objects; and (b) can cope with incomplete measurements included in a single RGB-D image. The main contributions of the work are: (i) a probabilistic approach for task-specific stable grasping of objects with shape variations inside the category is proposed; (ii) the idea of maximizing the grasp stability is taken in the novel context to cover the shape uncertainty; (iii) the approach accounts for all training objects in the category during the optimization process, which allows to better generalize for new objects and handle larger shape variations; (iv) the techniques can cope with a sparse training set unlike most data-driven methods; (v) the method uses incomplete point clouds obtained from a single RGB-D image.

With task-based grasps, e.g., grasping an object to pour liquid from it, the category is usually known as the actions only make sense when using an object from a compatible category. To concentrate on grasping, we assume that the category is known from task planning and the closely connected problem of category recognition is left outside the scope of the paper. Similarly, the detection of affordances, i.e. if an object affords a particular action, is not considered.

The paper is structured as follows: after discussing related work in the next section, we will present our general category-based task specific grasping framework as well as details of models in Section  3. In Section  4, we describe our experimental setting in simulation environment and discuss the results for the mugs and bottles categories and several tasks. In Section  5 we show how our technique allows to generalize for similar objects in other categories. Next, we present the implementation of our approach on a real robot and analyze the experimental results in Section  6. Finally, we discuss the benefits and improvements of the method in Section  7 and conclude in Section  8.

@&#RELATED WORK@&#

A broad review of data-driven approaches for grasp synthesis as well as sampling and ranking candidate grasps is given by Bohg et al. in  [1]. The authors divide approaches into three categories: grasping of known objects, familiar objects and unknown objects. Our method belongs to the class of grasping familiar objects and more concretely to the category of grasp synthesis by comparison. So, grasp hypothesis for a specific object is generated by finding in a database similar objects, for which good grasps have already been found.

The usual assumptions for category-based grasping approaches are the known a-priori category and availability of full 3D object models. Thus, Curtis and Xiao  [2] construct the database of 3D object types represented by Gaussian distributions over primitive shape features. To generate a good grasp for a novel object they use its low-level features to find out the most similar object type in the knowledge base. Higher-level features are used by Hillenbrand and Roa  [3]. They treat the problem of transferring grasps to new objects of the same functional category through warping and subsequent local replanning to ensure grasp stability. As in our work, they used the mug category consisting of six instances from Princeton Shape Benchmark (PSB), but they did not test their approach on other classes. Moreover, the procedure of contact warping requires full 3D models of both source and target objects (dense point clouds), which are not always available especially for the target object. Failures on one particular mug mark the limit of the methodology applicability for cases of large shape variabilities, as this mug is the most dissimilar in the category. One more important aspect is that all experiments are done in simulation only, without validation on a real robot. Similar idea of warping contact points onto new objects is proposed by Ben Amor et al. in  [4]. They test their approach on a real robot using mugs similarly to our technique. However, their approach is fully data-driven. Moreover, their goal is to generate the reach-and-grasp movements rather than stable grasp configuration as they do not take into account the metric of stability.

To find grasps for a specific goal the task can be also accounted during the grasp generation process. Early works consider task aspect in grasping in the force domain. Thus, Li and Sastry in  [5] describe the task oriented quality metric, which is based on the procedure of modeling tasks as ellipsoids in the wrench space of the object. More recently, Boutselis et al. in  [6] propose the methodology for deriving task-specific force closure grasps for multifingered robot hands given a finite set of external disturbances representing the task to be executed using the concept of Q distance. Li et al. in  [7] describe a data-driven shape matching algorithm for synthesizing humanlike enveloping grasps making use of shape features that contain contact normal information. To obtain only one stable resulting grasp they perform task-based pruning using the developed anatomically-based grasp quality measure. This approach is dedicated only for humanlike hands in virtual environments and is not tested on real settings.

Usually, both category of the object and the task should be accounted to find a useful grasp. Song et al. in  [8,9] consider object category together with task constraints as variables in the Bayesian network, from which full hand configuration can be derived. All experiments are done in simulation with human hand model only. Another approach is proposed by Dang and Allen  [10,11]. They introduce an example-based framework to generate functionally stable grasps for specific manipulation tasks. They introduce a semantic affordance map, which relates local geometry to a set of predefined semantic grasps designed for different tasks. Given an affordance map, an ideal approach direction of the hand can be estimated. After that, a final grasp with appropriate stability, tactile contacts and hand kinematics along approach direction are achieved using Eigengrasp planner  [12]. The experiments are done both in simulation and on a physical robot. To build a semantic affordance map only one representative object from each class is used, so that the generated grasps do not account for the shape variability inside the category. The main difference to our approach is that it requires full 3-D object models.

In case when only partial sensor data is available the full shape can be estimated from partial or multiple observations. Additionally, experience databases can be built offline using only little labeling. For instance, Goldfeder and Allen  [13] construct their database with only synthetic data using Eigengrasp planner for grasp generation. However, as in our approach they use observations from real sensors for new objects to search for the most similar grasp in the database. The benefit of our approach is that it is not fully data-driven and does not require the construction of large database of models and grasps to generalize for novel objects. Some approaches combine partial 3D data with RGB images (2D). Such methods are described in  [14,15]. They all account for object category and given tasks, but the grasps are generated only for objects, which are already contained in the database. Bohg et al. in  [16] also use the combination of 2D and 3D approaches. To predict the grasp they use the Bayesian network, which takes the object pose and category and infers a ranked list of grasps according to a specific task. Thus, their work also has a generalization potential for new objects in the category. Nevertheless, unlike our approach for the prediction they use only the most similar object model from the database, which can decrease the scales of generalization. Marton et al.  [17] also combine 2D and 3D descriptors, but they do not use the categories directly to find a suitable grasp. They look at the specific object instance by applying visual descriptors.

Suitable object/grasp representation can allow the robot to reason about the grasps and transfer them between similar objects. Recently, Pokorny et al. in  [18,19] present an infinite dimensional space—the Grasp Moduli Space, which combines grasps and objects parametrized by smooth differentiable functions. In this space various surface/grasp configurations can be continuously deformed in order to synthesize force closed grasps on novel objects. However, smooth parametrization deteriorates when only partial point cloud data is available. Moreover, the method is applicable only for objects, which can be represented by genus zero surfaces (objects without holes). Our approach copes with this problem and produces grasps for objects with holes. Detry et al.  [20,21] construct a low-dimensional space, in which similarly shaped object parts are close to each other. They do not consider object categories and overall object shape similarities. Similarly, Hjelm et al. in  [22] address the problem of transferring grasp knowledge across different objects and tasks. For grasp execution, they combine a part-based grasp planner with a model of task constraints.

In order to robustly handle uncertainty in object pose and shape as well as robot motion error, multiple sources of information can be used. Hsiao et al.  [23] propose a Bayesian framework for grasp planning, which uses the results from multiple object detectors and different grasp planners and attempts to find a consensus among them in a sense that resulting grasps are stable to errors in both perception and grasp execution. Because of its probabilistic nature, the method allows to find grasps not only for objects in the database, but also for similar-looking objects. However, they have models for all test objects in the database. Our method, in contrast, can generalize to novel objects for which full models are not available. Collaborative approach for grasp planning using different types of sensory data and different approaches for grasp planning is presented by Brook et al. in  [24]. Nevertheless, they also test their method only on objects from the constructed database.

The general methodology of maximizing grasp stability under uncertainty was presented in our previous work  [25–27]. We developed a probabilistic framework to use on-line sensory information for grasp planning, which allows to refine object’s pose based on tactile feedback and modify the grasp accordingly. Nevertheless, the earlier work considered uncertainty in object’s pose instead of the shape and the realization of the concept was completely different from our current work.

We begin by describing the framework informally to give an intuitive understanding of the approach. It is assumed that the category to be grasped is known and that several 3-D models belonging to that category are available. For each of these training models, one or more task specific grasp examples are known. Our framework (see Fig. 1
                     ) then attempts to generalize from this information to generate the corresponding grasp for a new object that is not included in the training data. The generalization is obtained by considering a probabilistic procedure that determines the grasp which is maximally likely to be stable and consistent with the task taking into account differences in shape and possible variability in grasp location.

The framework in Fig. 1 consists of offline and online parts. During the offline operation, the first step is to choose the training set of models. The training set should express shape variability to better generalize for novel objects. After that, the task specific grasps for each training object are obtained (e.g. through user interaction) and their relative poses with corresponding stability metrics are stored. This concludes the offline phase. In the online part, when a new object needs to be grasped the partial point cloud obtained from a single RGB-D image is first registered against each training model. As a result fitting scores are obtained, which describe the similarity of the target object to the model objects. These are then used as an input for an optimization process which determines the grasp that has maximal expected stability and is consistent with the training grasps.

The main idea of the general model is to find the best grasp pose over unknown object shape. Each grasp is parametrized by 6DOF pose 
                           X
                           =
                           
                              [
                              x
                              ,
                              y
                              ,
                              z
                              ,
                              
                                 
                                    α
                                 
                                 
                                    x
                                 
                              
                              ,
                              
                                 
                                    α
                                 
                                 
                                    y
                                 
                              
                              ,
                              
                                 
                                    α
                                 
                                 
                                    z
                                 
                              
                              ]
                           
                        , where 
                           x
                           ,
                           y
                           ,
                           z
                         are Cartesian coordinates and 
                           
                              
                                 α
                              
                              
                                 x
                              
                           
                           ,
                           
                              
                                 α
                              
                              
                                 y
                              
                           
                           ,
                           
                              
                                 α
                              
                              
                                 z
                              
                           
                         are rotation angles around the coordinate axes, which define the pose of the robot hand with respect to the object (pre-shape location).

The optimal grasp can then be found as the maximum of the expected stability and task compatibility over shape variability described as 
                           
                              (1)
                              
                                 E
                                 
                                    [
                                    S
                                    ∧
                                    T
                                    |
                                    X
                                    ,
                                    ϵ
                                    ]
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          T
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    |
                                    X
                                    ,
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    |
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          ϵ
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                         where 
                           S
                         denotes stability, 
                           T
                         task compatibility, 
                           P
                           
                              (
                              
                                 
                                    O
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    ϵ
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           ≡
                           ϕ
                           
                              (
                              
                                 
                                    ϵ
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         denotes the probability (weight) that object model 
                           i
                         can be used to generate grasps for the target object with fitting error 
                           
                              
                                 ϵ
                              
                              
                                 i
                              
                           
                         obtained from registration for the 
                           i
                        th training object. 
                           P
                           
                              (
                              
                                 
                                    S
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              |
                              
                                 
                                    O
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           ≡
                           ψ
                           
                              (
                              
                                 
                                    q
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         denotes the probability (weight) that the training grasp 
                           k
                         for model 
                           i
                         is stable as a function of the grasp quality metric 
                           
                              
                                 q
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                        . Thus, task-specific grasps for all objects are used in the optimization process, but their importance is modulated by the weights (grasps with bigger weights have greater influence). 
                           P
                           
                              (
                              
                                 
                                    T
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              |
                              X
                              ,
                              
                                 
                                    O
                                 
                                 
                                    i
                                 
                              
                              ;
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         is the probability that a grasp at location 
                           X
                         is task compatible, given model grasp location 
                           
                              
                                 θ
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                        .

The choice of grasp is then performed by maximizing (1) over 
                           X
                         as 
                           
                              (2)
                              
                                 arg
                                 
                                    
                                       max
                                    
                                    
                                       X
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          T
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    |
                                    X
                                    ,
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    |
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          ϵ
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 =
                                 arg
                                 
                                    
                                       max
                                    
                                    
                                       X
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 P
                                 
                                    (
                                    X
                                    |
                                    
                                       
                                          T
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    ,
                                    
                                       
                                          O
                                       
                                       
                                          i
                                       
                                    
                                    ;
                                    
                                       
                                          θ
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    )
                                 
                                 ψ
                                 
                                    (
                                    
                                       
                                          q
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    )
                                 
                                 ϕ
                                 
                                    (
                                    
                                       
                                          ϵ
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                         where Bayes formula with uniform prior is used for the first term and normalization terms can be ignored because of the maximization.

To implement the model, the particular distribution types have to be chosen. We model the stability weight 
                           ψ
                           
                              (
                              
                                 
                                    q
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         using a negative exponential function according to 
                           
                              (3)
                              
                                 ψ
                                 
                                    (
                                    
                                       
                                          q
                                       
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    )
                                 
                                 =
                                 1
                                 −
                                 
                                    
                                       ϵ
                                    
                                    
                                       −
                                       
                                          
                                             λ
                                          
                                          
                                             ψ
                                          
                                       
                                       
                                          
                                             q
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 λ
                              
                              
                                 ψ
                              
                           
                         is a damping coefficient that affects the rate of exponential decrease, and 
                           q
                           >
                           0
                         is a grasp quality measure, where 
                           q
                           =
                           0
                         indicates an unstable grasp and higher values indicate more likely stable grasps.

The goodness-of-fit weight 
                           ϕ
                           
                              (
                              
                                 
                                    ϵ
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         indicates the probability that object model 
                           i
                         can be used to generate grasps for the target object. We study two models, both using a negative exponential function. In the first model, (4a), the Euclidean fitting score 
                           
                              
                                 ϵ
                              
                              
                                 i
                              
                           
                        , equal to sum of squared distances between points in registered model 
                           i
                         and target point clouds, is used directly. To increase robustness for partial point clouds, the second model uses standard deviation of squared distances 
                           
                              
                                 σ
                              
                              
                                 i
                              
                           
                        , which penalizes large fitting errors, in addition to 
                           
                              
                                 ϵ
                              
                              
                                 i
                              
                           
                         as described in (4b). 
                           
                              
                                 (4a)
                                 
                                    ϕ
                                    
                                       (
                                       
                                          
                                             ϵ
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          ϵ
                                       
                                       
                                          −
                                          
                                             
                                                λ
                                             
                                             
                                                
                                                   eps
                                                
                                             
                                          
                                          
                                             
                                                ϵ
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                              
                                 (4b)
                                 
                                    ϕ
                                    
                                       (
                                       
                                          
                                             ϵ
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             σ
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          ϵ
                                       
                                       
                                          −
                                          
                                             
                                                λ
                                             
                                             
                                                
                                                   eps
                                                
                                             
                                          
                                          
                                             (
                                             
                                                
                                                   ϵ
                                                
                                                
                                                   i
                                                
                                             
                                             +
                                             
                                                
                                                   σ
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                         where 
                           
                              
                                 λ
                              
                              
                                 
                                    eps
                                 
                              
                           
                         controls the rate of exponential function decay.

For the density function 
                           P
                           
                              (
                              X
                              |
                              
                                 
                                    T
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              ,
                              
                                 
                                    O
                                 
                                 
                                    i
                                 
                              
                              ;
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                           ≡
                           P
                           
                              (
                              X
                              ;
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         (for brevity) we study two options. First, multivariate Gaussian distribution centered at each model grasp 
                           
                              
                                 θ
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                         with covariance matrix 
                           
                              
                                 Σ
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                         is presented in Eq. (5a).
                           
                              
                                 (5a)
                                 
                                    P
                                    
                                       (
                                       X
                                       ;
                                       
                                          
                                             θ
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             Σ
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         (
                                                         2
                                                         π
                                                         )
                                                      
                                                   
                                                   
                                                      n
                                                   
                                                
                                                
                                                   |
                                                   
                                                      
                                                         Σ
                                                      
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                   
                                                   |
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          ϵ
                                       
                                       
                                          −
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                
                                                   (
                                                   x
                                                   −
                                                   
                                                      
                                                         θ
                                                      
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                T
                                             
                                          
                                          
                                             
                                                Σ
                                             
                                             
                                                i
                                                ,
                                                k
                                             
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             x
                                             −
                                             
                                                
                                                   θ
                                                
                                                
                                                   i
                                                   ,
                                                   k
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                              
                                 (5b)
                                 
                                    P
                                    
                                       (
                                       X
                                       ;
                                       
                                          
                                             θ
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             Σ
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       s
                                       )
                                    
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         (
                                                         2
                                                         π
                                                         )
                                                      
                                                   
                                                   
                                                      n
                                                   
                                                
                                                
                                                   |
                                                   
                                                      
                                                         Σ
                                                      
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                   
                                                   +
                                                   s
                                                   I
                                                   |
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          ϵ
                                       
                                       
                                          −
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                
                                                   (
                                                   x
                                                   −
                                                   
                                                      
                                                         θ
                                                      
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                T
                                             
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         Σ
                                                      
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                   
                                                   +
                                                   s
                                                   I
                                                   )
                                                
                                             
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             x
                                             −
                                             
                                                
                                                   θ
                                                
                                                
                                                   i
                                                   ,
                                                   k
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                              
                                 (5c)
                                 
                                    P
                                    
                                       (
                                       X
                                       ;
                                       
                                          
                                             θ
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       b
                                       )
                                    
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          2
                                          b
                                       
                                    
                                    
                                       
                                          ϵ
                                       
                                       
                                          
                                             (
                                             −
                                             
                                                
                                                   
                                                      |
                                                      x
                                                      −
                                                      
                                                         
                                                            θ
                                                         
                                                         
                                                            i
                                                            ,
                                                            k
                                                         
                                                      
                                                      |
                                                   
                                                
                                                
                                                   b
                                                
                                             
                                             )
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

To estimate covariance matrices for the model grasps we explored the neighborhood of the grasps in all directions independently, performed the grasps in simulation and calculated the stability quality metrics. For each degree of freedom the process continued until the grasp became unstable and restarted in the opposite direction. Then, for each DOF we calculated the differences 
                           
                              
                                 Δ
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 Δ
                              
                              
                                 2
                              
                           
                         between the model grasp pose and the last stable grasp poses in both directions and took their average 
                           Δ
                           =
                           
                              
                                 
                                    
                                       Δ
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       Δ
                                    
                                    
                                       2
                                    
                                 
                              
                              
                                 2
                              
                           
                           =
                           c
                           σ
                        , which is proportional to a standard deviation value. We chose the coefficient 
                           c
                           =
                           3
                         after the three-sigma rule, which expresses a conventional heuristic that 99.7% of values are taken to lie within three standard deviations of the mean. The diagonal covariance matrix for 
                           i
                        th model grasp is then described by
                           
                              (6)
                              
                                 
                                    
                                       Σ
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               
                                                                  Δ
                                                               
                                                               
                                                                  i
                                                                  ,
                                                                  1
                                                               
                                                            
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      )
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             0
                                          
                                          
                                             ⋯
                                          
                                          
                                             0
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               
                                                                  Δ
                                                               
                                                               
                                                                  i
                                                                  ,
                                                                  2
                                                               
                                                            
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      )
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             ⋯
                                          
                                          
                                             0
                                          
                                       
                                       
                                          
                                             …
                                          
                                          
                                             ⋯
                                          
                                          
                                             ⋯
                                          
                                          
                                             ⋯
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             ⋯
                                          
                                          
                                             0
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               
                                                                  Δ
                                                               
                                                               
                                                                  i
                                                                  ,
                                                                  6
                                                               
                                                            
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      )
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    ]
                                 
                                 .
                              
                           
                         To avoid the problem of getting stuck in local optima we added to the estimated covariance the term 
                           s
                           I
                        , where the weight 
                           s
                         is a regularizer, which in our case was chosen manually, and 
                           I
                         is an identity matrix. The regularized form of Gaussian distribution is presented in Eq. (5b).

The second studied option is Laplace (double exponential) distribution described by Eq. (5c), where 
                           b
                         is diversity, a scale parameter proportional to the standard deviation. The parameter value was determined experimentally based on the assumption that there should be enough deviation from the mean values and further optimization does not get stuck in local optimum. The difference between the Laplace and the normal distribution is that the Laplace distribution has fatter tails. Thereby, the Laplace distribution allows larger deviations for the model grasps from the task compatibility viewpoint.

It is useful to note that the covariance estimation process has the effect that if two grasps have been demonstrated close to each other and their stable areas overlap significantly, the optimization of grasp quality in (2) will effectively merge those demonstrations while if the stable areas do not overlap, the grasps remain separate.

To find a stable task-specific grasp for a new object in the category we apply a numerical optimization approach. As the work environment can contain obstacles or can be limited by surfaces like walls or table, we deal with a constrained optimization problem. In our approach we treat rotational angles, which parametrized the grasp as Euler angles. Thus, we should take care of discontinuity problem. In our case we consider the difference between the model and optimized angles and manually insure that result angles belong to the interval 
                           
                              [
                              −
                              π
                              
                              π
                              ]
                           
                        . We repeat the optimization procedure the number of times equal to the number of database objects in the category. The process starts each time from the locally optimal grasp configuration for the current object model. Thus, we ensure that the final grasp will be in the neighborhood of the grasp for the similar object in the database. After that, we choose the result, which corresponds to the maximum objective function value.

In order to obtain fitting weights we performed a registration procedure. First, we captured an RGB-D snapshot using Kinect sensor. After that the object was segmented from the background using a planar supporting surface heuristic. Initial alignment was determined by matching local key point descriptors (Fast Point Feature Histogram FPFH  [28]). The alignment was then refined using Iterative Closest Point (ICP) algorithm. The initial alignment using local features was used because ICP is sensitive to the initialization. As our models are not identical to the target object, outlier rejection was used in ICP so that only points with relatively close correspondences were used in the iterative refinement. The reader can find detailed descriptions of the algorithms in  [29]. The use of ICP could be questioned because the models do not correspond perfectly to the target object, however, experimentally we found out that ICP provides a minor but noticeable improvement. Finally, it is important to note that the role of registration in the method is not to provide accurate pose estimation but to provide reasonably good fits with several candidate models so that the statistics of good grasps over the models allow grasping a novel object from the same category, even with only a partial (front-side) 3-D measurement.

First, we performed experiments in simulation environment to test the hypothesis that the use of several models in order to generate single stable grasp has benefits compared to the use of only one best match object. We also simulate multiple task-specific grasps to see how well our approach generalizes over different categories and several tasks.

Columbia Grasp Database (CGDB)  [30] is used as a source for category models. We use these models both for training and testing. GraspIt! simulator  [31] is chosen as a simulation environment. The main optimization part is done in Matlab environment. The object models in the CGDB are from Princeton Shape Benchmark  [32]. PSB consists of models of everyday objects. To see how well the proposed approach works for the objects with shape variability within a category we performed leave-one-out cross-validation for 2 categories: mugs and bottles. The set of mugs consists of all 7 models in the liquid container class from CGDB. The set of bottles includes 11 models from the bottle class of CGDB. The object models are shown in Figs. 2 and 3
                        
                        .

For each mug we manually chose 3 task-specific grasp configurations: from the top (top), from the side opposite to the mug handle (side) grasps for different transportation tasks and from the side, where the handle is located (handle) grasps for drinking or pouring. For each bottle we generate 1 configuration from the side (side), which can be associated with several tasks like pouring or transportation. Examples of training grasps for one of the mugs and one bottle are visualized in Fig. 4
                        . For each generated grasp we stored both object and robot locations as well as epsilon Quality Measures (QM), which are automatically calculated in GraspIt!.

Besides our approach, we found for each object and task grasp the best single grasp. It is a grasp configuration for the object in the training dataset, which is the closest to the testing object based on the fitting score values (an object with maximum fitting score). This approach is a benchmark to which we compare our technique.

@&#IMPLEMENTATION@&#

Additionally to the GraspIt!-Matlab part, we transformed each mesh representing our objects into a complete point cloud. After that, we run registration procedure using Point Cloud Library (PCL) to calculate fitting scores. The obtained fitting scores were used to calculate fitting weights in our approach according to Eq. (4a).

The algorithmic part described in Section  3.1 is implemented in Matlab. All three distributions: Gaussian, regularized Gaussian with regularizer 
                           s
                           =
                           50
                         (Gaussian-R) and Laplace with diversity 
                           b
                           =
                           50
                        , described in Eq. (5), were used as a probability density function 
                           P
                           
                              (
                              X
                              |
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         for the mugs category. Basic Gaussian distribution was not used for the bottles category as it showed the worst results in experiments with mugs. In case of simulation we do not use any limitations in the workspace. So, the standard Matlab unconstrained nonlinear optimization derivative-free approach (function fminsearch), based on the simplex search method of Lagarias et al.  [33], was applied to find the resulting grasp configuration.

In experiments we applied both, the grasp resulting from our models of the method and the best single grasp and calculated QM for them. Thus, we performed totally 21 experiments for all 3 types of grasps for the mug category and 11 experiments for the bottle category. The percentage of the grasps resulted from our algorithm, which were better, equally good and worse than the baseline approach in a sense of their stability for all objects within the category and all task types are shown in Fig. 5
                         for mugs and in Fig. 6
                         for bottles.

As can be seen from the diagrams, the Laplace approach was the most successful for both categories. It slightly outperforms the baseline technique for mugs and performs much better in the experiment with bottles. The Gaussian-R performs equally well for mugs and slightly better for bottles. In experiments with mugs the basic Gaussian fails more frequently. The possible reason is that the optimization gets stuck in local optima, that is why the results for regularized Gaussian are much better.

Although the Laplace approach performs the best for both testing categories the results can be treated as inconsistent and to show what are the advantages of the use of our approach real experiments need to be done. Moreover, as we used the complete models of the target objects, there can be a bias in the results. However, if we look at the reasons of grasp failures, we can admit that the best single approach either collides with an object during grasping or does not touch the object after performing the grasp, see Fig. 7
                        .

Gaussian approach most often fails because of the initial collisions with an object. As this approach showed the worst results, we did not use it later in real experiments. The regularized Gaussian was able to overcome the problem when the hand hits the object before grasping. The main reason for Gaussian-R and Laplace models failures is the lack of precision. Thus, the handle grasp is the most difficult in a sense that even small disturbances in several directions can make grasp unstable. Our approaches resulted in grasps which do not fully cover the mug or its handle. This situation is illustrated in Fig. 8
                        . The similar situation is for the side grasps of bottles. Gaussian-R failed to find stable grasps. The resulting configurations are shown in Fig. 9
                        . However, in these cases small perturbations of grasp locations can easily make such grasps stable.

The goal of this experiment is to study if the proposed approach can generate stable grasps not only for the new objects inside one category, but also for the objects of the other categories, which share shape similarities with models in the training dataset. To accomplish this, we chose the subset of object models in CGDB class tool. More concretely, we consider models from subclasses hammer and knife. 4 hammers were used as a training data, see Fig. 10
                     , and 2 knives were chosen for testing, see Fig. 11
                     . However, the objects are from different subclasses, and they are similar. All models have elongated shape and can be schematically divided into handle and working parts.

For each hammer we simulated a grasp from the handle, which can be associated with a task use. One of the model grasps is shown in Fig. 12
                     . Analogically to the training set of mugs, we generated 4 model grasps, calculated their quality measures and stored the values. After that, we also transformed mesh models of training and testing objects into point clouds and run registration procedure to obtain fitting metrics. We, then, run our approach on a testing set. The experimental results are collected in Table 1
                     .

The QM −1 in the table means that the grasp is unstable. The results for 2 knives shown in Fig. 13
                      demonstrate the ability of the new approach to generate stable grasps for the objects from the other class, which are similar to the models in the database. For these 2 models our method outperformed the traditional approach.

This section describes experiments on a real platform we performed to validate our approach. Experimental results show that the proposed technique outperforms the baseline best single grasp approach on objects that have never been seen by the system before.

The proposed approach was tested on a KUKA LBR4+ robotic arm with 3-fingered Barrett BH8-282 hand, the same hand that was used in simulation. We assumed a table-top grasping scenario, where the test objects are located on a flat surface. We chose the top grasp configuration because more demonstrated grasps respect the collision constraints in this configuration compared to the side and handle grasps, therefore less data providing more evidence. We considered the mug category and composed a test set consisting of six mugs varying in shape and size. The mugs used in experiments are illustrated in Fig. 14
                        . None of the objects are identical to any model in the training set used to learn grasps.

Each object was placed in five locations, differing in 
                           
                              (
                              x
                              ,
                              y
                              )
                           
                        -position and/or rotation around 
                           z
                        -axis (mug handle orientation). An exception is a mug without a handle, which is invariant to rotations and was placed only in 3 locations to avoid bias due to repeating the same case multiple times. For the registration, single snapshot views of partial 3D point clouds of objects were captured using Kinect. Hand–eye calibration was performed to allow transforming the registration results to the robot frame.

@&#IMPLEMENTATION@&#

The training stage is the same as in simulation experiments and done offline in GraspIt! simulator. As a training set we used the same set of 7 mugs from CGDB. After the collection of point cloud data we performed the registration procedure. As a result, we obtained fitting scores and final transformation matrices from camera to object frame. The fitting weights (probabilities) were then determined using Eq. (4b).

For optimization we followed the general procedure described in Eq. (1). To prevent collisions with the supporting table surface, the 
                           z
                         coordinate of the end-effector location was bounded below at 50 mm. The optimization problem becomes then constrained by this bound. To solve the constrained optimization problem, transformation methods were used to convert the bound constraint problem to an unconstrained one, which was then solved using standard simplex search. Matlab built-in implementation of the optimization was used  [34]. We did not consider other obstacles besides the table surface but they could be similarly implemented as constraints for the optimization.

The optimization results in a 6DOF optimal pose. After the optimization, the robot was moved to the optimal pose and the stability of the grasp was determined by human observation. The evaluation criteria for a grasping stability were as follows:


                        
                           
                              •
                              If the object falls on the table after lift up or manual disturbance, failure.

If the object moves a bit in a hand during lifting or manual disturbance, but does not fall at the end, partial success.

If the object stays stable in hand during the whole grasping process, success.

For the density function 
                           P
                           
                              (
                              X
                              |
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              )
                           
                         we studied two options: the regularized version of Gaussian distribution (Gaussian-R), given by Eq. (5b), with a regularizer 
                           s
                           =
                           700
                        , and Laplace distribution described by Eq. (5c) with scale parameter 
                           b
                           =
                           700
                        . In addition, best fitting single object was used as a baseline, similar to the simulation study.

@&#RESULTS@&#


                        Fig. 15
                         shows experimental results of the grasping performance using our grasping pipeline for three methods: baseline best single, regularized Gaussian (Gaussian-R) and Laplace models. The results demonstrate that the proposed approach outperformed the baseline method with both distribution types, with the Laplace method performing the best. The difference is statistically significant at 
                           p
                           <
                           0.0005
                         for Gaussian-R and 
                           p
                           <
                           0.00002
                         for Laplace model.
                           1
                        
                        
                           1
                           Failure was encoded with −1, partial success with 0 and success with 1. Sign-test was used to test against the null hypothesis that the median of difference between two methods does not differ from zero.
                         Thus, it is evident that regression over several models improves results over applying a single best fitting model.

Next, the nature of failures is analyzed. Table 2
                         summarizes the percentage of failures from total number of grasps for each approach according to their cause, categorized to reachability problems, registration (pose estimation) failures, failures due to shape dissimilarity and other reasons, for which the cause was difficult to point out. For the proposed approaches, the most common reason for a failure was the problem of reachability, that is, the robot did not find the Inverse Kinematics solution for the goal pose. This situation was equally difficult for all three cases including the baseline, as during experiments we did not take into account reachability constraints. The problem could be solved by including more constraints into optimization procedure.

For the baseline best single approach, the most common failure cause was the dissimilarity between the model and real objects. For example, in some cases the robot was not able to grasp an object because the resulting pose was too high above the object. In this case the grasp of the taller model was applied on the smaller object. Our approach allows to avoid this problem because it accounts not only the most similar model, but also all other models in the training set.

The third important reason for failures was a registration failure. In this situation the model and the object were badly aligned. Solving the problem is not in the scope of our work and probably could be solved by modifying the registration procedure, although the registration of objects without correct models is not trivial. It is useful to notice that the proposed approaches are less prone to registration failures because they use several registered models instead of only a single best one.


                        Fig. 16
                         shows as an example three resulting grasps for best single and Laplace approaches for cases where the best single baseline approach fails to generate a stable grasp. It can be seen that the proposed approach was able to find at least a partly stable grasp in these cases. For the blue and yellow mugs the baseline approach fails because of incorrect choice of the most similar object in the database. At the same time our approach was able to result in 3-fingered stable grasps. For the green mug Laplace method generates only a partly stable grasp, but the best single method totally fails because of the imprecise registration.

To analyze the proposed approaches further, we studied how the use of several models changes the grasps. The analysis was performed by registering real object point clouds with the models, then optimizing the grasp as above, and finally projecting the resulting grasp back to the models using the corresponding registration result. These results were then analyzed to see how the resulting grasp differs from the model grasps.


                        Fig. 17
                         visualizes grasps generated for three testing mugs (white mug, green mug and small white mug) projected back to model objects. The three columns in each subfigure correspond to model grasp (left), regularized Gaussian (center) and Laplace models (right). Also the fitting probabilities (weights) are given in the figure. Firstly, it can be observed that the resulting grasps differ from model grasps, typically quite slightly for the best fitting models, but nevertheless the conclusion is that the approach interpolates over several models and thus provides a degree of generalization. Secondly, for single object models the registration can fail in a way that the fitting score fails to capture (see for example Model 3 in Fig. 17(a) where the object was registered upside down). However, these cases are in the end grasped successfully in the system due to the use of several models. This provides us additional evidence that the use of multiple models improves robustness of the overall system. Finally, poorly fitting models often indicate gross registration failures (e.g. Model 4 in Fig. 17(a) and (b)) but even though these are not completely excluded from the optimization procedure, their low probabilities decrease their effect on the final grasp so that the optimized grasp will be successful.

@&#DISCUSSION@&#

Experimental results showed that by combining information over multiple grasps and multiple objects, the proposed approach results in more stable grasps over the classical approach of using the most similar model’s grasp. This finding suggests that the data-driven statistical approach is able to generalize from individual examples. This is complementary to other approaches which usually perform some kind of deformable shape alignment or grasp adjustment to achieve generalization. Such deformable alignment may, however, be difficult to achieve from only a partial view of the target, which can be seen as one advantage of the statistical approach.

There are still some open problems. Firstly, the reachability problem could be solved as outlined above. Moreover, the registration could be improved to better account for the case when the models do not correspond perfectly to the target objects. The hand poses that resulted in partial success present an opportunity for grasp refinement, that is, they could be further adjusted to get more stable grasps. One possible way and our future research direction is to collect additional information about the object, for example, using tactile sensors and use this feedback to perform regrasping. We believe this will be a fruitful direction since the benefits of using tactile feedback to achieve better stability of the grasp have been demonstrated for example by Dang and Allen in  [35] and in our previous work  [27]. In physical experiments only one object category was used. Experimental validation on other categories would be useful to study the generality of the approach.

@&#CONCLUSION@&#

In this paper, we presented an approach for task-specific stable grasping of objects with shape variations inside a category. The proposed method accounts for all training objects in the category during an optimization process, which allows to better generalize for new objects and to handle larger shape variability. The proposed method is close to data-driven approaches during the model building stage, but it does not require a construction of a large training dataset (a single task-specific stable grasp per object can be used). The general model to find an optimal grasp for a new object inside the category has probabilistic nature and is based on finding the grasp which is most likely to be both stable and task consistent taking into account shape uncertainty. The simulation experiments with tools showed that the method is able to generalize to objects from other categories that are similar in shape. The experimental results indicated that the approach outperforms the use of only the single best matching model, which is often used in category-based grasp generation.

@&#ACKNOWLEDGMENT@&#

The work was financially supported by Academy of Finland grant 264239.

@&#REFERENCES@&#

