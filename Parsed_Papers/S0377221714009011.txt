@&#MAIN-TITLE@&#Anytime Pareto local search

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New variants of Pareto local search (PLS) with much better anytime behavior.


                        
                        
                           
                           A study of impact of PLS components on anytime behavior.


                        
                        
                           
                           A new dynamic grid-epsilon method (Dynagrid) for improving anytime behavior.


                        
                        
                           
                           Experimental results on bi-objective TSP and bi-objective QAP.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Pareto local search

Anytime optimization

Multi-objective optimization

Traveling salesman problem

Quadratic assignment problem

@&#ABSTRACT@&#


               
               
                  Pareto Local Search (PLS) is a simple and effective local search method for tackling multi-objective combinatorial optimization problems. It is also a crucial component of many state-of-the-art algorithms for such problems. However, PLS may be not very effective when terminated before completion. In other words, PLS has poor anytime behavior. In this paper, we study the effect that various PLS algorithmic components have on its anytime behavior. We show that the anytime behavior of PLS can be greatly improved by using alternative algorithmic components. We also propose Dynagrid, a dynamic discretization of the objective space that helps PLS to converge faster to a good approximation of the Pareto front and continue to improve it if more time is available. We perform a detailed empirical evaluation of the new proposals on the bi-objective traveling salesman problem and the bi-objective quadratic assignment problem. Our results demonstrate that the new PLS variants not only have significantly better anytime behavior than the original PLS, but also may obtain better results for longer computation time or upon completion.
               
            

@&#INTRODUCTION@&#

Optimization problems are ubiquitous in our society and of crucial importance in numerous fields of high social, environmental or economic relevance. In particular, many relevant situations involve problems that are evaluated according to several criteria. These criteria are often conflicting and there is no solution that is best for all of them at the same time. In this paper, we consider problems where no information is given about the decision maker’s preferences. In this case, it is common to evaluate solutions by means of Pareto dominance. The goal is to find the set of Pareto optimal solutions (those not dominated by any other feasible solution), or at least a close approximation to it. The decision maker can then choose a posteriori the preferred one.

We focus on algorithms to tackle multi-objective combinatorial optimization problems (MCOPs), many of which are problems computationally intractable or, more formally, 
                        NP
                     -hard (Garey and Johnson, 1979). Pareto Local Search (PLS) (Paquete, Chiarandini, and Stützle, 2004) is a heuristic algorithm for tackling 
                        NP
                     -hard MCOPs in the Pareto sense. It is an extension of iterative improvement algorithms for single-objective problems (Hoos and Stützle, 2005) to the multi-objective case with the goal to approximate the Pareto-optimal set. PLS can produce, upon completion, high-quality approximations when used as a stand-alone algorithm (Paquete et al., 2004; Paquete and Stützle, 2006). PLS is also a crucial component of hybrid algorithms, where PLS is used to improve upon a set of good solutions that have been obtained by approaches, for example, based on scalarizations. Examples of such hybrid algorithms can be found for the multi-objective traveling salesman problem (Lust and Teghem, 2010a; 2010b) with two and three objectives, various bi-objective permutation flowshop problems (Dubois-Lacoste, López-Ibáñez, and Stützle, 2011b), and the bi-objective multi-dimensional knapsack problem (Lust and Teghem, 2012).

A disadvantage of PLS and, by extension, a limitation of these hybrid algorithms, is that it requires a possibly long time to reach high-quality approximations to the Pareto front (e.g., several hours for large biobjective traveling salesman problem (bTSP) instances tackled in the literature (Lust and Teghem, 2010b)). Moreover, if stopped early, PLS may produce a poor approximation when compared to the final approximation reached upon completion. For this reason, we say that PLS has a poor anytime behavior. By contrast, an algorithm with good anytime behavior aims to deliver the best possible result at any time during its execution by quickly reaching high-quality solutions and by continuously improving them (López-Ibáñez and Stützle, 2014; Zilberstein, 1996).

Our goal in this paper is to study and improve the anytime behavior of PLS. In a preliminary work (Dubois-Lacoste, López-Ibáñez, and Stützle, 2012), we empirically examined the impact that algorithmic components of PLS have on its anytime behavior, and proposed alternative variants that improve its anytime behavior for the bTSP. In this paper, we extend that preliminary work in four ways. First, we repeat the experiments reported in our preliminary study but considering longer computation time limits, which allows us to study the potential final quality reached by standard PLS versus the anytime PLS variants. Second, our preliminary work used only the bTSP as a benchmark problem. In this paper, we also consider the bi-objective quadratic assignment problem (bQAP). The bTSP and the bQAP are both fundamental problems that arise in a number of real-world situations. They are also among the most studied MCOPs in meta-heuristics research (Drugan and Thierens, 2010; 2012; Ehrgott and Gandibleux, 2008; Knowles and Corne, 2003; López-Ibáñez, Paquete, and Stützle, 2006; Lust and Teghem, 2010a; Paquete and Stützle, 2009). Third, we propose a dynamic grid mechanism (Dynagrid) that dynamically limits the number of unexplored solutions accepted by PLS. Dynagrid extends a previous static epsilon-grid mechanism (Angel, Bampis, and Gourvés, 2004) by discretizing the objective space using a decrease of epsilon at run-time. This allows PLS to converge faster to a well-spread Pareto-front approximation, while avoiding premature convergence if the initial discretization was excessively coarse. Dynagrid improves both the anytime behavior and the final quality achieved by PLS. Finally, we dedicate Section 7 to a survey of algorithmic components from the literature that are related to those proposed by us in this paper, and we discuss in detail the similarities and differences between the various proposals.

Our experimental analysis examines scenarios when PLS is used as a stand-alone algorithm and when PLS is part of a hybrid algorithm. Therefore, we are certain that the proposed anytime variants of PLS further improve the state-of-the-art local search algorithm for the bTSP (Lust and Teghem, 2010b), not only in terms of anytime behavior but also on final quality after completion. Moreover, our proposals can be applied to any bi-objective combinatorial problem and they may also turn out to be useful for other algorithms than PLS.

This paper is organized as follows. In Section 2, we first define multi-objective optimization and related concepts, and then we present the original PLS algorithm and its decomposition into distinct algorithmic components. In Section 3, we discuss the poor anytime behavior of the original PLS algorithm. Section 4 recalls the alternative algorithmic components proposed in a preliminary work (Dubois-Lacoste et al., 2012) and presents new results that further confirm the improvements in anytime behavior reported earlier. Section 5 proposes Dynagrid, a dynamic discretization of the objective space that further improves the anytime behavior of PLS. In Section 6, we compare the original PLS with the best PLS variants obtained from the alternative algorithmic components and the objective space discretization. We deliberately chose to review the literature that is relevant to our study at the end of the paper (Section 7), since this allows us to discuss in more detail the similarities and differences between our proposals and previous ones. Finally, we conclude in Section 8 and highlight promising directions for future research.

In this section, we first introduce basic concepts of multi-objective optimization. Next, we explain the original PLS algorithm and how we decompose it into different algorithmic components.

Many real-world problems require optimizing more than one objective. Often, these objectives are conflicting and, therefore, there exists no solution that is optimal for all objectives at the same time. If no a priori assumptions upon the decision maker’s preferences can be made, the goal typically becomes to find a set of solutions that are optimal in the sense of Pareto optimality.

More formally, candidate solutions are evaluated according to an objective function vector 
                           
                              
                                 f
                                 →
                              
                              =
                              
                                 (
                                 
                                    f
                                    1
                                 
                                 ,
                                 …
                                 
                                 ,
                                 
                                    f
                                    d
                                 
                                 )
                              
                           
                         with d objectives. Pareto dominance defines a partial order on the set of feasible solutions. Without loss of generality, we consider here only problems where all objectives are to be minimized. If 
                           
                              u
                              →
                           
                         and 
                           
                              v
                              →
                           
                         are vectors in 
                           
                              
                                 R
                                 d
                              
                              ,
                           
                        
                        
                           
                              u
                              →
                           
                         is said to dominate
                        
                           
                              v
                              →
                           
                         (
                           
                              
                                 u
                                 →
                              
                              ≺
                              
                                 v
                                 →
                              
                           
                        ) iff 
                           
                              
                                 u
                                 →
                              
                              ≠
                              
                                 v
                                 →
                              
                           
                         and ui
                         ≤ vi
                        , i = 1, … , d. 
                           
                              u
                              →
                           
                         and 
                           
                              v
                              →
                           
                         are said to be mutually non-dominated iff 
                           
                              
                                 u
                                 →
                              
                              ⊀
                              
                                 v
                                 →
                              
                              ,
                           
                        
                        
                           
                              
                                 v
                                 →
                              
                              ⊀
                              
                                 u
                                 →
                              
                           
                         and 
                           
                              
                                 u
                                 →
                              
                              ≠
                              
                                 v
                                 →
                              
                           
                        . For simplicity, we extend the notion of dominance to solutions and we say that a solution s dominates another one s′ iff 
                           
                              
                                 f
                                 →
                              
                              
                                 (
                                 s
                                 )
                              
                              ≺
                              
                                 f
                                 →
                              
                              
                                 (
                                 
                                    s
                                    ′
                                 
                                 )
                              
                           
                        . If a set 
                           A
                         does not contain any solution that dominates a solution s, and does not contain any solution s′ with 
                           
                              
                                 f
                                 →
                              
                              
                                 (
                                 
                                    s
                                    ′
                                 
                                 )
                              
                              =
                              
                                 f
                                 →
                              
                              
                                 (
                                 s
                                 )
                              
                              ,
                           
                         we write 
                           
                              A
                              ⊀
                              s
                           
                        .

If no s′ exists such that 
                           
                              
                                 f
                                 →
                              
                              
                                 (
                                 
                                    s
                                    ′
                                 
                                 )
                              
                              ≺
                              
                                 f
                                 →
                              
                              
                                 (
                                 s
                                 )
                              
                              ,
                           
                         
                        s is called Pareto optimal. The goal when tackling MCOPs in the Pareto sense is to find the set of Pareto-optimal solutions. Their image in the objective space is called the Pareto front. Since this goal is in many cases computationally intractable, heuristic algorithms are used to find an as good as possible approximation to the Pareto front (Ehrgott and Gandibleux, 2004).

PLS is a direct extension of the iterative improvement algorithm from single-objective problems to the multi-objective case. PLS explores the neighborhood of solutions in its archive, inserts new solutions in the archive that are non-dominated, and filters the archive to remove dominated solutions. PLS was originally proposed by Paquete et al. (2004); independently, a similar algorithm was proposed by Angel et al. (2004).


                        Algorithm 1
                         illustrates the PLS framework. The input to PLS is an initial set of solutions 
                           
                              A
                              0
                           
                         that are mutually non-dominated. The solutions in 
                           
                              A
                              0
                           
                         are initially marked as unexplored (line 2). PLS updates an archive of nondominated solutions 
                           
                              A
                              ,
                           
                         which is initially equal to 
                           
                              
                                 A
                                 0
                              
                              ,
                           
                         by applying the following steps. First, a solution s is chosen randomly among all unexplored ones (selection step on line 5) and its neighborhood, 
                           
                              N
                              (
                              s
                              )
                              ,
                           
                         is fully explored (line 6). All neighbors that are non-dominated with respect to the solutions in 
                           A
                         (line 7) are considered for addition to the archive 
                           A
                        . The procedure 
                           Update
                         (line 9) adds a candidate solution 
                           
                              
                                 s
                                 ′
                              
                              ∈
                              N
                              
                                 (
                                 s
                                 )
                              
                           
                         to the archive if s′ is not dominated by any solution in the archive and removes all solutions from the archive that become dominated by s′. Once the neighborhood of s has been fully explored, s is marked as explored (line 12). When 
                           A
                         contains only solutions that have been fully explored, the algorithm stops in a Pareto local optimum (Paquete, Schiavinotto, and Stützle, 2007), that is, a set of nondominated solutions for which any neighbor solution is dominated or equal to a solution in the set.

We decompose PLS into three main algorithmic components for which we will later describe and test alternative variants. We explain these components in detail below:

                           
                              
                                 Selection step. This component determines how to select the next solution for neighborhood exploration. In the original PLS, this solution is selected uniformly at random among the unexplored ones.


                                 Acceptance criterion. This component describes the conditions under which a new solution enters the archive. The original PLS accepts all solutions identified in the neighborhood exploration that are non-dominated.


                                 Neighborhood exploration. This component performs the neighborhood exploration of the selected solution. In particular, it defines the part of the neighborhood that will be explored before switching to a different solution. The original PLS algorithm always explores the entire neighborhood of a solution.

In the next section, we focus on the algorithmic components of PLS, test possible variants of them and examine their impact on the anytime behavior of the resulting algorithms.

PLS has a natural stopping criterion, that is, it stops when all solutions in the archive have been fully explored. Previous works have shown that PLS can reach a high-quality approximation of the Pareto front in many combinatorial problems if it runs until completion (Lust and Teghem, 2010b; Paquete, 2005). However, PLS may take a long time to stop. In the worst case, it may take an exponential time to reach completion, since for some problems the Pareto front may contain an exponential number of solutions and, in the original PLS, the archive size is unlimited. In practical problems, runtimes of hours for typical instance sizes have been reported (Lust and Teghem, 2010b). Therefore, it is desirable in some situations to stop PLS before completion, but still return an as high-quality approximation of the Pareto front as possible. An anytime algorithm aims to obtain as high-quality results as possible at any time during its execution and continuously improves the quality of the result as computation time increases (López-Ibáñez and Stützle, 2014; Zilberstein, 1996). Similarly, an algorithm that produces better results than another for any termination criterion of practical interest is said to have a better anytime behavior.

The original PLS does not make any attempt to quickly obtain a high-quality approximation of the Pareto front and, hence, if stopped early, the approximation of the Pareto front may be poor (see Fig. 1
                     ). Thus, we can say that PLS, as originally proposed, is not an anytime algorithm in the sense that it does not show a good anytime behavior.

As in previous work (Dubois-Lacoste, López-Ibáñez, and Stützle, 2011a; 2012), in this paper we use the hypervolume indicator (Zitzler, Thiele, Laumanns, Fonseca, and Grunert da Fonseca, 2003) to compare the anytime behavior of multi-objective optimizers by graphically plotting the evolution of the hypervolume over time. The hypervolume computes the size of the objective space dominated by a given non-dominated set and, thus, higher hypervolume corresponds to better quality. In the case of PLS, we compute the hypervolume of the current archive 
                        A
                      of non-dominated solutions. Fig. 2
                      illustrates this analysis; it shows the development of the obtained hypervolume over time for two algorithms. The plain line shows an algorithm with good anytime behavior; the algorithm produces a quick increase of the quality at the beginning, and then continuously improves until the end of the execution. The dotted line shows an algorithm with a poor anytime behavior; its quality improves slowly and it is worse than the quality of the other algorithm at any time.

In the following sections, we examine how the different components of PLS affect its anytime behavior. In addition, we propose variants of PLS that greatly improve its anytime behavior. These new variants allow stopping PLS in times shorter by several orders of magnitude than its natural completion time and obtain much better approximations to the Pareto front (Fig. 1 is a typical example).

We have recently shown (Dubois-Lacoste et al., 2012) that the anytime behavior of PLS can be largely improved by using alternative variants for each of its algorithmic components. In particular, we proposed the optimistic hypervolume improvement (OHI) as an alternative to random selection; and alternative variants for the acceptance criterion and neighborhood exploration. In this section, we first recall these proposals in detail, since we will use these concepts throughout the paper. Next, we report new experimental results. In particular, we consider longer computation time limits than those considered in our preliminary study (Dubois-Lacoste et al., 2012), which gives a more accurate notion of the potential final quality reached by standard PLS versus the new anytime PLS variants. Moreover, we include the bQAP as an additional benchmark problem.

                        
                           
                              Alternative for selection step. PLS does not make use of any information on the current state of the archive in the selection step but uses a simple random choice. An alternative approach is to select solutions whose exploration may have the largest potential to improve the current archive. Given two solutions s and s′ (in the biobjective case), we define the optimistic hypervolume contribution (ohvc) as the potential contribution to the hypervolume of the archive by the local ideal point defined by s and s′ in the objective space. In the bi-objective space, we can define it as:

                                 
                                    (1)
                                    
                                       
                                          ohvc
                                          
                                             (
                                             s
                                             ,
                                             
                                                s
                                                ′
                                             
                                             )
                                          
                                          =
                                          
                                             (
                                             
                                                f
                                                1
                                             
                                             
                                                (
                                                s
                                                )
                                             
                                             −
                                             
                                                f
                                                1
                                             
                                             
                                                (
                                                
                                                   s
                                                   ′
                                                
                                                )
                                             
                                             )
                                          
                                          ·
                                          
                                             (
                                             
                                                f
                                                2
                                             
                                             
                                                (
                                                
                                                   s
                                                   ′
                                                
                                                )
                                             
                                             −
                                             
                                                f
                                                2
                                             
                                             
                                                (
                                                s
                                                )
                                             
                                             )
                                          
                                          .
                                       
                                    
                                 
                              The ohvc is based on the assumption that solutions that are close in the solution space are close in the objective space. This common assumption is known to often hold in the single objective case. Intuitively, if this is true for each objective of a multi-objective problem, it will be true for the multi-objective problem itself. This assumption in the multi-objective case is supported empirically by some studies (Dubois-Lacoste et al., 2011a; Garrett and Dasgupta, 2008; Jaszkiewicz, Ishibuchi, and Zhang, 2012; Paquete and Stützle, 2003; Verel, Liefooghe, Jourdan, and Dhaenens, 2013), and to some extent by the results of this paper.

Hence, by exploring the neighborhood of a given solution, one can expect to find new non-dominated solutions in the region between the current solution and its closest neighbors in the objective space. The ohvc indicator can be used to select a pair of adjacent solutions. In the case of PLS, we define an additional indicator for the selection of a single solution s, called Optimistic Hypervolume Improvement (OHI), as follows:

                                 
                                    (2)
                                    
                                       
                                          OHI
                                          
                                             (
                                             s
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         2
                                                         ·
                                                         ohvc
                                                         
                                                         (
                                                         
                                                            s
                                                            sup
                                                         
                                                         ,
                                                         s
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         ∄
                                                         
                                                            s
                                                            inf
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         2
                                                         ·
                                                         ohvc
                                                         
                                                         (
                                                         s
                                                         ,
                                                         
                                                            s
                                                            inf
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         ∄
                                                         
                                                            s
                                                            sup
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         ohvc
                                                         
                                                         
                                                            (
                                                            
                                                               s
                                                               sup
                                                            
                                                            ,
                                                            s
                                                            )
                                                         
                                                         +
                                                         ohvc
                                                         
                                                         
                                                            (
                                                            s
                                                            ,
                                                            
                                                               s
                                                               inf
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                   
                                                      otherwise,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              where 
                                 
                                    s
                                    sup
                                 
                               and 
                                 
                                    s
                                    inf
                                 
                               are the closest neighbors of s in the bi-objective space from the current archive 
                                 A
                               defined as

                                 
                                    
                                       
                                          
                                             
                                                
                                                   s
                                                   sup
                                                
                                             
                                             
                                                =
                                             
                                             
                                                
                                                   
                                                      arg min
                                                      
                                                         
                                                            s
                                                            i
                                                         
                                                         ∈
                                                         A
                                                      
                                                   
                                                   
                                                      {
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         
                                                            s
                                                            i
                                                         
                                                         )
                                                      
                                                      ∣
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         
                                                            s
                                                            i
                                                         
                                                         )
                                                      
                                                      >
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         s
                                                         )
                                                      
                                                      }
                                                   
                                                   
                                                   and
                                                
                                             
                                          
                                          
                                             
                                                
                                                   s
                                                   inf
                                                
                                             
                                             
                                                =
                                             
                                             
                                                
                                                   
                                                      arg max
                                                      
                                                         
                                                            s
                                                            i
                                                         
                                                         ∈
                                                         A
                                                      
                                                   
                                                   
                                                      {
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         
                                                            s
                                                            i
                                                         
                                                         )
                                                      
                                                      ∣
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         
                                                            s
                                                            i
                                                         
                                                         )
                                                      
                                                      <
                                                      
                                                         f
                                                         2
                                                      
                                                      
                                                         (
                                                         s
                                                         )
                                                      
                                                      }
                                                   
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Either 
                                 
                                    s
                                    sup
                                 
                               or 
                                 
                                    s
                                    inf
                                 
                               may not exist if s is the best solution for f
                              1 or f
                              2, respectively (often called extreme solution). In such a case, we define the OHI to be two times the optimistic hypervolume contribution of the existing solution in order to avoid a strong bias against extreme solutions. Fig. 3
                               shows a graphical representation of the OHI indicator. The OHI value is a heuristic to measure the “gap” around solutions in the objective space, in order to select for exploration a solution that has the highest potential of increasing the hypervolume. This is different from measuring the actual hypervolume contribution of the solution (Beume, Naujoks, and Emmerich, 2007; Knowles, Corne, and Fleischer, 2003). Computing the OHI of a set of solutions in the bi-objective space can be done in linear time, if the set is sorted with respect to one objective. For this reason, when adding or removing solutions, we always keep the set sorted. The OHI could be applied to more than two objectives, but an efficient implementation would require a data structure to find efficiently the nearest solutions to a given one. We leave this extension to future work.

As an alternative to the random selection in the original PLS, denoted by 
                                 
                                    〈
                                    RND
                                    〉
                                    ,
                                 
                               the OHI selection, denoted by 
                                 
                                    〈
                                    OHI
                                    〉
                                    ,
                                 
                               selects the unexplored solution with the highest OHI value.


                              Alternatives for acceptance criterion. The original PLS algorithm accepts any non-dominated solution for inclusion in the archive. We call this component 〈⊀〉 for “non-dominated”. However, different criteria have been used in the literature, particularly more restrictive ones that avoid a large number of solutions in the archive (Liefooghe, Humeau, Mesmoudi, Jourdan, and Talbi, 2011) (a detailed discussion of how our proposals relate to the existing literature is given in Section 7). In particular, accepting only neighbors that dominate the current solution may allow a quick convergence to the Pareto front at the price of a possible loss of quality. We call this component 〈≻〉 for “dominating”. We can also switch from one rule to another: if a solution that dominates the current one is found, only such solution is accepted, and if no dominating solution can be found, the acceptance criterion switches to accepting solutions that are non-dominated. We call this component 〈≻⊀〉.


                              Alternatives for neighborhood exploration. PLS explores in its original version all neighboring solutions. This is also done in iterative improvement algorithms that use a best-improvement
pivoting rule and, hence, we refer to this way of neighborhood exploration in PLS also as best-improvement
and refer to it as component 〈*〉. In single-objective local search, a first-improvement neighborhood exploration often leads faster to local optima (Hoos and Stützle, 2005). In the multi-objective case, first-improvement corresponds to stopping the neighborhood exploration as soon as one neighboring solution can be accepted. We refer to this alternative as 〈1〉. In PLS with first-improvement neighborhood exploration a solution is marked as explored when a neighbor is accepted into the archive even if there could be more acceptable neighbors if the full neighborhood were explored. We also proposed switching from one alternative to the other in the following way: when all solutions in the archive have been marked as explored using the first-improvement rule, the algorithm will mark all solutions as unexplored and explore them again using the best-improvement rule. Ideally, the first-improvement phase will quickly converge to a good approximation of the Pareto front, while the best-improvement phase will add any remaining neighbors to the archive and, thus, further improve its quality. We denote this alternative with 〈1*〉.

In what follows, we denote each variant of the original PLS algorithm by specifying which alternative components it is using. For instance, PLS
                        
                           〈
                           OHI
                           ,
                           ≻
                           ⊀
                           ,
                           1
                           *
                           〉
                        
                      denotes the variant that

                        
                           •
                           uses OHI for the selection step;

uses a rule for the acceptance criterion that switches from dominating to non-dominated;

uses a rule for the neighborhood exploration that switches from stopping after the first accepted neighbor to stopping only after considering all accepted neighbors.

Following this notation, the original PLS is denoted by PLS
                        
                           〈
                           RND
                           ,
                           ⊀
                           ,
                           *
                           〉
                        
                     .

In our experimental analysis, we cover possible uses of PLS by using three different initial conditions, that is, sets of solutions that PLS starts from.

                              
                                 •
                                 
                                    High-quality sets (
                                    
                                       HQS
                                    
                                    ). State-of-the-art algorithms for several problems (Dubois-Lacoste et al., 2011b; 2013b; Lust and Teghem, 2010a; 2010b) use PLS in a second phase to refine a set of high-quality solutions obtained from a first phase, which often is based on scalarizations of the problem. To cover this usage of PLS, we consider an initial set composed of five high-quality solutions, that is, solutions very close to the Pareto-optimal front. These five solutions are also well-spread over the objective space, since they are obtained by an algorithm based on scalarizations that tends to distribute solutions as evenly as possible in terms of the hypervolume of the set (Dubois-Lacoste et al., 2011a). We chose five in order to have one very good solution for each objective (on the extremes of the Pareto front), one solution that is an equal trade-off between the two extremes, and two solutions that represent unequal trade-offs between the two extremes. Since the initial solutions are nearly-optimal and well-spread, the task of PLS becomes to fill the gaps between these solutions. A higher number of initial solutions would make this task easier, but it would make harder to assess the anytime behavior since the difference in terms of hypervolume between the initial set and the final one would be small. Another drawback of starting from more solutions is that they take time to be generated (since a single-objective algorithm is launched to tackle each scalarization one by one), during which the anytime behavior would be rather poor: stopping during that phase would bring few solutions. In some preliminary experiments, we observed that the anytime behavior of different PLS variants was relatively similar, even if the absolute values are different (since the initial set has a higher hypervolume).


                                    Two high-quality solutions (
                                    
                                       TS
                                    
                                    ). It is possible that there is no algorithm available to solve the scalarized problems, but an algorithm is available to solve the two individual objectives of the bi-objective problem. In this case, PLS starts from one nearly-optimal solution for each objective. These two initial solutions are on the extremes of the Pareto front, and, hence, the main task of PLS is to quickly reach the center of the Pareto front.


                                    Random solution (
                                    
                                       RS
                                    
                                    ). Finally, it is possible that no algorithm is available to solve any single-objective version of the problem, i.e., one must rely only on PLS to tackle the problem. In this case, PLS starts from a random initial solution, which is likely to be far away from the Pareto front. Thus, the main task of PLS is to quickly reach the Pareto front, while keeping a wide spread set of solutions.

Similarly to solutions that can be mutually non-dominated, different approximations to the Pareto front can be incomparable. In fact, this is often the case when comparing the output of different algorithms. It is therefore common to use indicators to measure the quality of these approximations. In this paper, we use the hypervolume (
                              HV
                           ) indicator, a widely-used unary indicator that is consistent with the Pareto optimality principle (Zitzler et al., 2003). In the bi-objective space, the hypervolume measures the area of the objective space that is weakly dominated by (i.e., dominated by or equal to) the image of the solutions in a non-dominated set. This area is bounded by a reference point that is worse in all objectives than all points in all non-dominated sets. The larger is this area, the better is a non-dominated set.

Computing the hypervolume of non-dominated sets requires to normalize the objective values of the solutions in them, to avoid favoring one objective over another if the objectives do not have the same range. For the bTSP, we found the lower bound for normalization using the exact Concorde solver (Applegate, Bixby, Chvátal, and Cook, 2014), release 03.12.19, and the upper bound for normalization by taking the worst solution value of 100 000 solutions that are sampled uniformly at random. For the bQAP, we do not use the same procedure since no exact solver is available that solves our instances within reasonable computation time. Therefore, we ran the original PLS algorithm three times, using all initial conditions, and we record the best and the worst value obtained over all results. We then define the lower bound as being the best value multiplied by 0.95, and the upper bound as being the worst value multiplied by 1.05. We check during the experimental analysis that the bounds are never exceeded by any result we obtained. All objective values are then normalized into the range [1, 2], and we use the coordinates (2.1, 2.1) as the reference point for computing the hypervolume of the normalized sets.

We assess graphically the anytime behavior by plotting the average hypervolume (over 25 runs) of the normalized sets over computation time. To do so, we define a priori a sequence of time steps, at which we normalize the current non-dominated set obtained so far by the algorithm, we compute its hypervolume and we record it. The computation time required to perform these steps is not counted in the overall computation time that is measured and reported in our results, since these steps are required to observe the behavior of the algorithms but are not actually part of the algorithms. By using an exponential scale for the sequence of time steps (and for the plot) we can observe the behavior of the algorithms both after short periods of time and at larger scales. More precisely, we use 100 time steps, computed as 
                              
                                 
                                    t
                                    i
                                 
                                 =
                                 
                                    
                                       (
                                       
                                          cutoff
                                          _
                                          time
                                       
                                       +
                                       1
                                       )
                                    
                                    
                                       (
                                       i
                                       /
                                       100
                                       )
                                    
                                 
                                 −
                                 1
                                 ,
                                 
                                 i
                                 ∈
                                 1
                                 ,
                                 …
                                 
                                 ,
                                 100
                                 ,
                              
                            where cutoff_time is a cut-off time (see Table 1
                           ), determined from preliminary runs of the algorithms. In the case of the bTSP, we use a cut-off time ten times longer than the one used in our preliminary study (Dubois-Lacoste et al., 2012). We also show graphically the variance of each algorithm across the multiple runs by plotting in gray the confidence intervals corresponding to each curve.

For the bTSP, we generated three instances with 500 cities. The two distance matrices of each instance are generated independently of each other and correspond to those of symmetric, Euclidean TSP instances (Dubois-Lacoste et al., 2011a; Paquete and Stützle, 2009). For the bQAP, we used the instance generator proposed in  Knowles and Corne (2003). We generated three instances with correlations between the flow matrices in { − 0.75, −0.5, 0, 0.5, 0.75}. The lower the correlation, the higher are the run times of PLS to reach completion, since the number of non-dominated solutions increases strongly with negative correlation (Paquete and Stützle, 2006). On the other hand, PLS requires a very short time to terminate for instances with correlation zero or larger. Hence, these instances are not useful for illustrating improvements in anytime behavior, and we only present in this paper results with correlation − 0.75 and − 0.5.

The algorithms are implemented in C++, compiled with gcc 4.4.6, and the experiments were run on a single core of AMD Opteron 6272 CPUs, running at 2.1 gigahertz with a 16 megabytes cache under Cluster Rocks Linux version 6/CentOS 6.3, 64 bits.

For the bTSP, we use a neighborhood operator based on 2-exchange moves, and we use delta-evaluations to compute the objective value of new candidate solutions faster (Hoos and Stützle, 2005). For the bQAP, we use a neighborhood operator based on exchanging two components (Hoos and Stützle, 2005). The initial solutions, when starting from two or more high-quality solutions are obtained solving scalarized problems (see Section 4.1.1). For the bTSP, the single-objective algorithm used to tackle these problems is an Iterated Local Search algorithm based on 3-opt moves (Hoos and Stützle, 2005). For the bQAP, we use a Simulated Annealing algorithm (Hussin and Stützle, 2014). For both problems, the single-objective algorithms were given 2 seconds for each scalarization.

We now present the experimental evaluation of the anytime behavior of the PLS variants. To make the presentation concise, we present in this paper plots for only one bTSP instance, one bQAP instance with correlation − 0.5 and another bQAP instance with correlation − 0.75. Other instances show remarkably similar results, and the conclusions drawn in the paper are true for all instances we tested. The plots for all additional instances are available on-line as supplementary material (Dubois-Lacoste, López-Ibáñez, and Stützle, 2013a).

We present in Fig. 4
                            the evaluation of the selection component that uses the optimistic hypervolume improvement (OHI) against the original random selection (
                              RND
                           ). The plots on each row show the results obtained with different instances: one bTSP instance (top) and two bQAP instances with correlation − 0.75 (middle) and correlation − 0.5 (bottom). Each column of plots corresponds to a different initial scenario, that is, starting with a random solution (left), two high-quality solutions (middle) and a set of high-quality solutions (right). In most plots, PLS
                              
                                 〈
                                 OHI
                                 〉
                              
                            outperforms PLS
                              
                                 〈
                                 RND
                                 〉
                              
                            at any moment of the search, sometimes by a large gap. This result indicates that the selection of the most promising objective regions for further improvement actually helps reaching better results in less computation time. On the other hand, both strategies obtain similar results on a few cases, such as the top-left plot that presents results for a bTSP instance when starting from a random solution. This configuration is the only one where OHI is slightly worse for a short period of time (between 1 and 100 seconds), likely due to the overhead of computation time required to perform the selection using OHI.

Nonetheless, the selection based on OHI is, overall, a clear improvement over the original component. For this reason, we use OHI instead of 
                              RND
                            for all the experiments in the rest of this section. Hence, we test whether we can improve the anytime behavior even further by using the alternative variants for the other components.


                           Fig. 5
                            presents a comparison of the various alternative acceptance criteria proposed in Section 4. The variants PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ,
                                 *
                                 〉
                              
                            and PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            behave exactly the same as long as at least one neighbor dominates the current solution. This clearly happens in the initial phases of the search when starting from a random solution (left column). However, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ,
                                 *
                                 〉
                              
                            quickly reaches completion since it cannot find any new dominating solutions, whereas PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            switches strategy and matches the final quality of PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                           . When the initial set is close to the Pareto front (middle and right columns), no solution can be found that dominates any of the initial ones and, thus, the hypervolume curve is entirely flat for PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ,
                                 *
                                 〉
                              
                           . However, as the switch from accepting only dominating neighbors to accepting also nondominated neighbors occurs for each new solution explored, there is still an observable difference between PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            and PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                           . In fact, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            compares very positively to PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                           : in many cases the former shows a large improvement of quality over the latter at any time of the execution, for instance, in the plots for bTSP starting from RS (top-left) or TS (top-middle). In the case of HQS (right column), and specially for the bQAP (middle-right and bottom-right), the differences are smaller or not statistically significant, due to the fact that dominating solutions are very rarely found and the two variants are essentially equivalent. There is no case showing PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            better than PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            and, overall, the switching component of PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            yields a better anytime behavior than the original one.


                           Fig. 6
                            reports a comparison of the different alternatives for the neighborhood exploration. It shows the anytime behavior of three PLS variants: PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 〉
                                 ,
                              
                            which stops the exploration of the neighborhood after accepting one solution, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                                 ,
                              
                            which explores the full neighborhood, and PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                                 ,
                              
                            which switches from the first to the second rule. The behavior of PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            before the switch is exactly the same as PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 〉
                                 ,
                              
                            therefore the two curves coincide until the point where PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 〉
                              
                            stagnates due to the limited neighborhood exploration. It is clear, therefore, that PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            should be preferred over PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 〉
                              
                            in every situation.

For the bTSP, when the initial set is either RS or TS, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            shows a much better anytime behavior than the original component used by PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                           . However, for the bTSP when the initial set is HQS and for the bQAP in all cases, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            has better anytime behavior than PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                           . Therefore, the best alternative for this component is dependent of the situation.

Since no strategy outperforms the other in every case, it could be interesting to test different trade-offs between PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            and PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                                 ,
                              
                            for example, by accepting more than one solution and switching to a full neighborhood exploration later. However, it is likely that the best number of solutions to accept is strongly problem-dependent. Hence, we leave further exploration of this direction for future research.

We have shown that switching the acceptance criterion during execution improves significantly the anytime behavior over the original acceptance criterion in most of the cases. We also have shown that switching from first-improvement to best-improvement can be helpful, but not in all cases. As a last step, we explore whether even better anytime behavior can be obtained by combining these two components in PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                           . Fig. 7
                            compares PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            with the strategies evaluated in the previous two sections. The plots show that in none of the cases, PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            improves over its two competitors. Hence, there are interactions between the components that prevent their respective advantages to combine together. We conjecture that this is because PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ≻
                                 ⊀
                                 ,
                                 *
                                 〉
                              
                            and PLS
                              
                                 〈
                                 OHI
                                 ,
                                 ⊀
                                 ,
                                 1
                                 *
                                 〉
                              
                            restrict in two different ways the number of solutions that are considered for inclusion in the archive and that probably the restriction incurred by their combination is too strong.

The best performing PLS variants for neighborhood exploration and acceptance criterion have in common that they restrict the number of non-dominated solutions added to the archive. In particular, such a restriction improves the anytime behavior in the early phases of the search by driving PLS toward regions in the objective space close to the Pareto front. This pressure is exerted by avoiding the acceptance of too many non-dominated solutions into the archive.

In this section, we exploit further this observation. We explicitly limit the potential number of non-dominated solutions to enter the archive by incorporating an epsilon-grid mechanism. We first explain the static version of the epsilon-grid mechanism, which was proposed by Angel et al. (2004). Later, we propose a dynamic adaptation of the grid, which we call Dynagrid. Finally, we show that Dynagrid, and by extension the anytime PLS, can be further improved by taking into account the hypervolume contribution of each point in the grid. The selection criterion based on the OHI was shown to be consistently better than the random version, therefore we use it for all variants designed in this section.

The epsilon-grid mechanism proposed by Angel et al. (2004) discretizes the objective space into a grid of boxes whose size increases with the distance to the axis; in this way, more solutions can be accepted in the center of the Pareto front than in the extremes. The size of the boxes is defined by a parameter ε: given ε > 1, for each objective d, normalized such the minimum value is 1, the bounds of boxes i = 0, 1, 2, …  are computed as

                           
                              (3)
                              
                                 
                                    
                                       B
                                       i
                                       d
                                    
                                    =
                                    
                                       [
                                       
                                          ϵ
                                          i
                                       
                                       ,
                                       
                                          ϵ
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       [
                                    
                                 
                              
                           
                        
                     


                        Fig. 8
                         shows graphically this epsilon-grid mechanism. We can determine directly the box corresponding to solution s for objective d by:

                           
                              (4)
                              
                                 
                                    
                                       B
                                       d
                                    
                                    
                                       (
                                       s
                                       )
                                    
                                    =
                                    
                                       B
                                       
                                          ⌊
                                          log
                                          
                                             (
                                             norm
                                             
                                                (
                                                
                                                   f
                                                   d
                                                
                                                
                                                   (
                                                   s
                                                   )
                                                
                                                )
                                             
                                             )
                                          
                                          /
                                          log
                                          
                                             (
                                             ϵ
                                             )
                                          
                                          ⌋
                                       
                                       d
                                    
                                 
                              
                           
                        
                     

The norm() function gives the normalized value for a given objective. In this paper, we use a mapping of the objectives such that the lower bound provided for a given objective (see Section 4.1.2) is mapped to 1, the upper bound to 100 000, and any value in between is mapped linearly to the range [1, 100 000]. Using a normalization mechanism whenever a decision must be taken based on objective values is important to not emphasize one objective over another when their ranges differ. It also allows applying the same algorithm to problems with objectives having different scales.

The main drawback of the epsilon-grid mechanism is that the parameter ε (Eqs. (3) and (4)) must be defined carefully before solving a problem. Therefore, it cannot be applied without previous knowledge of the problem (and even instance) to be tackled (Paquete, 2005).

Here, we propose Dynagrid, a new variant of the epsilon-grid mechanism that dynamically adapts the value of ε and, hence, the grid size, within the PLS algorithm. The aim of this mechanism is threefold. First, it allows the application of this method without any previous knowledge on the problem or the instance to be tackled. Second, it improves the anytime behavior of PLS, as we show later. Third, it can be applied directly to other MCOPs and, possibly also, to other algorithms for MCOPs.

The dynamic adaptation of ε is triggered by the convergence of PLS. Each time PLS using a fixed epsilon-grid terminates, that is, all solutions are marked as explored, the value of ε is reduced by a fixed factor. This mechanism is described in pseudo-code in Algorithm 2
                        . A PLS algorithm using the grid defined by ε (denoted by 
                           
                              
                                 PLS
                                 Grid
                              
                              ,
                           
                         line 7 of the pseudo-code) starts from the current solution archive 
                           A
                        . When 
                           
                              PLS
                              Grid
                           
                         reaches completion and all solutions in the archive are marked as explored, the value of ε is decreased according to a parameter r < 1 (line 8), and the solutions are marked again as unexplored. Then 
                           
                              PLS
                              Grid
                           
                         is re-started using the grid defined by the updated ε value (line 9). This process (lines 6–10) is repeated until a given termination criterion is met.

After a change of the value of ε, the grid changes and, as a result, there may be boxes that contain more than one solution. We do not remove these extra solutions, since the quality of the archive will decrease and removing these solutions would incur a computational overhead.

The rationale behind Dynagrid is to obtain quickly well-distributed solutions in the objective space, thus reaching quickly a good Pareto front approximation in terms of hypervolume, using large initial values for ε, and then reducing the value of ε to refine the grid and add more solutions only when PLS actually needs them to improve the quality of the results.

In our experimental analysis, we set the initial value of ε to 5. This is a rather large value (recall that ε has an exponential effect on the boxes size), which makes unlikely even the acceptance of one new solution when starting from the initial set. This is done on purpose to avoid the usage of problem-specific knowledge as much as possible. For the value of parameter r, we tested values in {0.9, 0.7, 0.5, 0.3, 0.1} during preliminary experiments. The differences due to different values of the parameter r were minor, resulting in rather similar curves of the development of the hypervolume; we provide the plots for this comparison as supplementary material (Dubois-Lacoste et al., 2013a). For the following experiments, we chose a setting of r = 0.5.


                        Fig. 9
                         compares the Dynagrid algorithm against variants that use different static grids, that is, they use different fixed values for ε. We tested values of ε ∈ {1.5, 1.05, 1.005}, but for the sake of clarity we show here only those for value 1.5 and 1.005; the results for 1.05 are a trade-off between the results obtained by the two extreme values. Clearly, the larger ε, the faster is the quality improvement in short computation time, but also the earlier PLS stagnates, as visible by the fact that curves become flat (that is, the hypervolume does not increase anymore), indicating that PLS actually stops.

For the bTSP with initial conditions RS and TS, the adaptive mechanism is able to improve the quality of the archive as quickly as the coarse static grid (ε = 1.5) does it. Moreover, it outperforms the fine static grid (ε = 1.005) at any time. Starting from HQS (top-right plot in Fig. 9), it gives slightly worse solution quality than the fine grid until roughly 200 seconds, but it is better for larger computation time. For the bQAP, the results obtained by the dynamic grid are clearly better than those for fixed values of ε. The dynamic grid improves quality quickly and reaches higher quality results than the fine grid at any time for all initial conditions.

Overall, the good performance of the dynamic grid is remarkable because it does not require preliminary knowledge of an appropriate setting of ε when being applied.

In the original epsilon-grid method (Angel et al., 2004), a new candidate solution s′ that falls into the same box as an already existing solution s in the archive only replaces s if s′ dominates s. Therefore, solutions that enter the archive earlier are preferred over more recent candidate solutions for the sole reason that they were encountered earlier. However, since our goal is to obtain a set of non-dominated solutions with the highest possible quality at any time, it may be preferable to relax this condition if the new candidate solution improves the quality measure over the existing one. More precisely, since we measure quality in terms of hypervolume (see Section 2.1), we extend our dynamic epsilon-grid (see Section 5.2) to optimize this indicator. In particular, we allow a solution s′ to replace a solution s if the hypervolume of the archive increases. More formally, given a new solution s′ that falls into the same box as another solution 
                           
                              s
                              ∈
                              A
                              ,
                           
                         where 
                           A
                         is the current archive, s′ replaces s if s′≺s or 
                           
                              HV
                              
                                 (
                                 A
                                 /
                                 
                                    {
                                    s
                                    }
                                 
                                 ∪
                                 
                                    {
                                    
                                       s
                                       ′
                                    
                                    }
                                 
                                 )
                              
                              >
                              HV
                              
                                 (
                                 A
                                 )
                              
                           
                        . Note that if s′≺s, due to the properties of the hypervolume indicator (Zitzler et al., 2003), the hypervolume of the archive resulting from the removal of s and the addition of s′ can only increase. Therefore, the dynamic grid considering hypervolume contribution aims explicitly at optimizing the hypervolume of the current archive at any time.

If there are several solutions in the box, then solution s above corresponds to the one with the least hypervolume contribution. The computation of the least hypervolume contribution is computationally cheap in two and three objectives: Computing all hypervolume contributions of a set of n points requires O(nlog n) (Emmerich and Fonseca, 2011). In our case, we do it in linear time since the set is kept sorted (according to one objective). For a higher number of objectives, it is unclear if the improvement in terms of quality would compensate the computational overhead; we leave this for future research.

In Fig. 10
                        , we compare the performance, in terms of anytime behavior, of Dynagrid when considering hypervolume contributions, called Dynagrid-HV, versus the basic Dynagrid algorithm, which was shown to outperform the static grid in the previous section. For the bTSP, with initial conditions RS, considering the hypervolume contribution slows down the initial increase of the solution quality between roughly 2 and 20 seconds. This is probably explained by the fact that the grid size is updated later with the hypervolume enhancement than without, as several solutions can successively enter in the box(es), postponing the decrease of epsilon. For longer computation time, however, Dynagrid-HV clearly improves over the Dynagrid algorithm. For the initial conditions TS and HQS, the improvement is very large: Dynagrid-HV reaches the same quality than the Dynagrid algorithm in about one order of magnitude shorter computation time. For the bQAP, Dynagrid-HV shows, for any given computation time, the same or better average quality than the Dynagrid algorithm, although the improvement is typically smaller than in the bTSP case. The improvements are clear for RS and TS initial sets; when starting from HQS, both alternatives bring similar results.

In summary, Dynagrid-HV improves further the anytime behavior of PLS. Since in the majority of cases and termination criteria, Dynagrid-HV is clearly better than the basic Dynagrid algorithm, we would recommend its use when tackling bi-objective problems with similar characteristics as the ones we tackle here.

In previous sections, we designed variants of PLS with better anytime behavior by exploring two fundamentally different directions. Here, we compare these two approaches. Fig. 11
                      presents a comparison of the best algorithms obtained from each of the two alternatives. Additionally, to highlight the improvement obtained by these new PLS variants over the original PLS algorithm, we include also the original PLS in this comparison. For the bTSP, PLS
                        
                           〈
                           OHI
                           ,
                           ⊀
                           ,
                           1
                           *
                           〉
                        
                      dominates completely the original PLS algorithm. It also performs better than Dynagrid-HV up to roughly 20 seconds, when the hypervolume-over-time curves of the two algorithms cross. This crossing may be explained by the fact that Dynagrid-HV requires some time to adapt the discretization, which penalizes it for very short runtimes. For the bQAP, PLS
                        
                           〈
                           OHI
                           ,
                           ≻
                           ⊀
                           ,
                           *
                           〉
                        
                      consistently and completely surpasses the original PLS algorithm, but it is itself mostly outperformed by Dynagrid-HV.

To determine whether our conclusions are consistent across different instance sizes, we analyze how the experimental results scale when tackling larger instances. To do so, we generated larger instances of size 1000 for the bTSP and size 150 for the bQAP, following the same setup used for the other instances (see Section 4.1). Table 2
                         presents the cut-off times for these instances for each problem.

We present a comparison of the same algorithms on these larger instances in Fig. 12
                        . All the trends observed for smaller instances not only remain true, but are strengthened. In fact, the gap between the original PLS algorithm and the two new anytime PLS variants widens, as it is most clearly visible on the bTSP. Hence, the performance improvements introduced by the proposed anytime PLS algorithms over the original PLS are particularly important when tackling large-scale bi-objective problems.

We perform a statistical comparison of the anytime PLS algorithms that were previously evaluated in this section. For the statistical tests, we focus on specific snapshots in time that are at a 1000th, a 100th, and a 10th of the cut-off time, and the cut-off time itself. Since the time steps that we use increase exponentially (see Section 4.1), they do not necessarily correspond exactly to these selected times: in this case we use the closest ones.

We use the Friedman test to assess the significance of the differences in terms of hypervolume, with a standard confidence level of 0.95 (thus, a 
                           
                              
                                 p
                                 −
                                 v
                                 a
                                 l
                                 u
                                 e
                              
                              <
                              0.05
                           
                         indicates that the null hypothesis is to be rejected). In the Friedman test, each instance and run is considered as a different block. Table 3
                        
                         presents this comparison for both problems. These results confirm (i) the improvement of the proposed anytime PLS variants over the original PLS algorithm, and (ii) that Dynagrid-HV is almost always statistically significantly better than other strategies.

Many previous works are based on the original PLS algorithm, here we only mention those that are closer to our work. A more complete list of references can be found in a recent overview (Dubois-Lacoste, López-Ibáñez, and Stützle, 2013b).


                     Liefooghe, Mesmoudi, Humeau, Jourdan, and Talbi (2009) and Liefooghe et al. (2011) also decompose the PLS algorithm into different components and study the performance of some of their variants. Nonetheless, there are significant differences between their study and our proposals here. First, they do not distinguish between acceptance criterion and neighborhood exploration, and they do not consider variants that switch strategies during a single run of PLS, such as the ones studied here (Section 4). Thus, we explore a more refined decomposition of PLS and therefore also test more combinations. Second, their goal is to compare the results obtained after a given computation time. More precisely, in their experimental setup, they choose the same, predefined computation time limit for all variants, and variants that would finish before this computation time limit are restarted from scratch. A variant is then judged by the final aggregated non-dominated set found across the multiple restarts. Here, we focus on the anytime behavior of the resulting algorithms, making our study rather different.

PLS (Paquete et al., 2004) and similar algorithms (Angel et al., 2004) are used as either stand-alone algorithms (Paquete et al., 2004; Paquete and Stützle, 2006) or as components of hybrid algorithms (Dubois-Lacoste et al., 2011b; Lust and Teghem, 2010a; 2010b). When tackling large instances, these algorithms may require a long time to reach completion. One solution is to stop the algorithm before completion (Dubois-Lacoste et al., 2011b). In this case, our proposed anytime PLS variants will produce much better results. An alternative solution is to reduce the completion time by using problem-specific speed-up techniques to avoid exploring the whole neighborhood of each solution (Lust and Teghem, 2010a). Our proposed variants can be combined with these problem-specific techniques in order to also improve the anytime behavior.


                     Drugan and Thierens (2010); 2012) focus on PLS-based algorithms that can successfully handle the situation where PLS reaches completion and still additional computation time is available. They show that promising results can be attained when restarting PLS from new solutions on a “path” between two solutions in the Pareto local optimum set (in a manner similar to the path-relinking Glover, 1998 mechanism). A different approach to handle the same situation can be found in Geiger (2011), where the author proposes to apply a different neighborhood operator when PLS converges to a Pareto local optimum: this idea can be seen as an adaptation of variable neighborhood descent (Hansen and Mladenovic, 2001) to PLS. Despite the fact that their goal is different from ours, these studies can be seen as complementary to this paper: they focus on time scales that are larger than the time required by PLS to terminate, while we focus here on computation times that are shorter or roughly similar to the time required by the original PLS to reach completion.

The Dynagrid mechanism proposed here is related to the concept of bounded archiving, that is, limiting the size of an archive of non-dominated solutions. In particular, the idea of using a hyper-grid on the objective space to limit the number of solutions in a nondominated archive has been used extensively in the bounded archiving literature (López-Ibáñez, Knowles, and Laumanns, 2011). The Pareto archived evolution strategy (PAES) (Knowles and Corne, 2000) can be understood as a random mutation hill-climber that uses a discrete grid to limit the size of its archive of solutions. One difference between PAES and PLS is that PAES uses a random exploration of neighborhoods while PLS uses a systematic one analogous to iterative improvement algorithms. The adaptive grid mechanism of PAES is quite different from Dynagrid, since the former allows a new solution to enter an already populated box as long as the maximum archive size has not been reached. By contrast, Dynagrid does not take into account a maximum archive size, and new solutions can only enter an already populated box by replacing one of the solutions already in the box. Moreover, the grid mechanism in PAES is adaptive because the grid is recomputed when the ranges in the archive change, but the number of subdivisions is static. By contrast, Dynagrid increases the number of subdivisions over time in order to refine the current approximation to the Pareto front. The ε-Pareto archiving algorithm (Laumanns, Thiele, Deb, and Zitzler, 2002) also uses an epsilon-grid in the objective space, but the acceptance criterion is slightly different from the static epsilon-grid mechanism (Angel et al., 2004) (and by extension from Dynagrid). In ε-Pareto archiving, dominance is first tested with respect to the boxes in the grid, whereas epsilon-grid always considers dominance among solutions. The dynamic version of ε-Pareto archiving starts from a small ε and increases it every time the archive
 size exceeds a predefined maximum size. Its goal is to maintain a fixed-size archive with minimal ε. The multi-level grid archiving algorithm (Laumanns and Zenklusen, 2011) does not actually use an explicit ε value but instead considers a succession of coarse-grained boxes when deciding whether to accept each individual solution. The goal is again to maintain a fixed-size archive with a good approximation quality. The dynamic adaptation of ε in Dynagrid is fundamentally different. It starts with a large ε and decreases it every time PLS converges to a Pareto local optimum with respect to the current value of ε. It allows PLS to quickly converge to a well-spread approximation set and, once PLS converges, it allows PLS to continue the search by refining the grid.

Although there has been some work on anytime algorithms for single-objective optimization problems (e.g., López-Ibáñez and Stützle, 2014; Loudni and Boizumault, 2008; Zilberstein, 1996), the anytime behavior of multi-objective optimization algorithms is rarely considered. With respect to evolutionary multi-objective algorithms, some preliminary work has shown that the anytime behavior of some popular algorithms is rather poor when using their default settings (Radulescu, López-Ibáñez, and Stützle, 2013). A good anytime behavior is specially crucial for algorithms that have a natural stopping criterion but are often stopped earlier in practice, such as PLS. In a previous work, we have studied the anytime behavior of Two-Phase Local Search (TPLS) (Dubois-Lacoste et al., 2011a), which is a different local search algorithm for multi-objective combinatorial optimization. Our work here shares a similar goal, that is, to improve the anytime behavior of an existing local search algorithm. Nonetheless, the improvements proposed to achieve such a goal are fundamentally different because TPLS and PLS follow completely different search paradigms: TPLS is based on scalarizations, whereas PLS is based on dominance (Paquete and Stützle, 2007).

Finally, recent studies (López-Ibáñez and Stützle, 2014; Radulescu et al., 2013) have applied automatic configuration tools, also called tuners, to automatically select and tune the algorithmic components and parameters of optimization algorithms to obtain a good anytime behavior. This approach can only select among the components provided and not devise new ones as we have done here. Applying automatic configuration to the original PLS in order to improve its anytime behavior would not bring much improvement, since its components do not provide a good anytime behavior. On the other hand, the diversity of behaviors demonstrated by the anytime PLS variants proposed here, where particular variants are better for certain problem characteristics, suggests that automatic configuration can be applied to select the appropriate variant when tackling a new problem.

@&#CONCLUSION@&#

To the best of our knowledge, our present work and our preliminary study (Dubois-Lacoste et al., 2012) are the first to analyze and improve the anytime behavior of PLS, a high-performing multi-objective local search algorithm, and an important component of state-of-the art algorithms for several well-known MCOPs (Dubois-Lacoste et al., 2011b; Lust and Teghem, 2010a; 2010b; 2012).

The experimental analysis presented in this work studied the impact of various alternatives for the algorithmic components of PLS. In particular, we considered different algorithm components for the selection of the solutions to be explored, the type of neighborhood exploration and the acceptance criteria for new solutions. We also analyzed PLS variants that switch from one alternative to a different one during a single run of PLS. Our results show that such “switching” variants of PLS improve significantly the anytime behavior over the original PLS. However, we found that the best variants are different for the bTSP and the bQAP, and, thus, the best variant depends on the problem being tackled.

In addition, we proposed a radically different anytime PLS algorithm based on a dynamic discretization of the objective space, where the objective space is divided into a grid. Our results clearly showed that the dynamic adaptation of the grid size outperforms any static value in terms of anytime behavior. Moreover, we found that results could be further improved by taking into account the hypervolume contribution when deciding whether to add a new solution to an already populated box of the grid. The resulting PLS variant, which we call Dynagrid-HV, is consistently better than the other anytime PLS variants examined in this paper and completely outperforms the original PLS for any given termination time.

Since our experimental study considered three different scenarios that include starting PLS from random solutions of typically poor quality and also from nearly-Pareto-optimal solutions, we are certain that our conclusions are useful for applications of PLS as a stand-alone algorithm and also for hybrid algorithms where PLS is a major component. In particular, by replacing the original PLS with the proposed anytime PLS variants, we expect significant improvements in the results obtained by the current state-of-the-art algorithms for the multi-objective traveling salesman problem (Lust and Teghem, 2010b), various bi-objective permutation flowshop problems (Dubois-Lacoste et al., 2011b), and the bi-objective multi-dimensional knapsack problem (Lust and Teghem, 2010a).

Moreover, a combination of the variants proposed in this paper with the mechanisms that were proposed to restart PLS (Drugan and Thierens, 2010; 2012) once it has reached a Pareto local optimum (Paquete et al., 2007) is also promising. Such a combination will make the resulting algorithm applicable to a very wide range of computation times and, thus, real-world situations.

Our study has considered the standard neighborhood operators for the benchmark problems tackled. However, the choice of neighborhood operators has a strong influence on the number and quality of non-dominated solutions found and, thus, it impacts the anytime behavior of PLS. A possible direction of future research is to study the influence of different neighborhoods on the anytime behavior of PLS.

Finally, our work has focused on bi-objective problems. We plan to extend our analysis to three and more objectives. The number of nondominated solutions and the complexity of some algorithmic components increase exponentially with the number of objectives. Thus, such problems pose different computational challenges that may require different algorithmic components to design PLS algorithms with good anytime behavior.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the META-X project, an Action de Recherche Concertée funded by the Scientific Research Directorate of the French Community of Belgium, the COMEX project within the Interuniversity Attraction Poles Programme of the Belgian Science Policy Office, and by the MIBISOC network, an Initial Training Network funded by the European Commission, grant number PITN-GA-2009-238819. Manuel López-Ibáñez and Thomas Stützle acknowledge support from the Belgian F.R.S.-FNRS, of which they are a postdoctoral researcher and a senior research associate, respectively. The authors thank Mohamed S. bin Hussin for providing his Simulated Annealing implementation for single-objective QAP instances.

@&#REFERENCES@&#

