@&#MAIN-TITLE@&#NESTOR: A formal model for digital archives

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A set-theoretical formal model for digital archives is presented.


                        
                        
                           
                           The 5S model is extended for digital archives and concrete applications are given.


                        
                        
                           
                           Address EAD issues in the Web and with (compound) digital objects.


                        
                        
                           
                           Use cases based on OAI-PMH, OAI-ORE and annotation frameworks for digital archives.


                        
                        
                           
                           Properties and mappings between the tree and NESTOR are formally proved.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Foundation

Digital archive

Digital library

Hierarchy

Set-based model

Application

@&#ABSTRACT@&#


               
               
                  Archives are an extremely valuable part of our cultural heritage since they represent the trace of the activities of a physical or juridical person in the course of their business. Despite their importance, the models and technologies that have been developed over the past two decades in the Digital Library (DL) field have not been specifically tailored to archives. This is especially true when it comes to formal and foundational frameworks, as the Streams, Structures, Spaces, Scenarios, Societies (5S) model is.
                  Therefore, we propose an innovative formal model, called NEsted SeTs for Object hieRarchies (NESTOR), for archives, explicitly built around the concepts of context and hierarchy which play a central role in the archival realm. NESTOR is composed of two set-based data models: the Nested Sets Model (NS-M) and the Inverse Nested Sets Model (INS-M) that express the hierarchical relationships between objects through the inclusion property between sets. We formally study the properties of these models and prove their equivalence with the notion of hierarchy entailed by archives.
                  We then use NESTOR to extend the 5S model in order to take into account the specific features of archives and to tailor the notion of digital library accordingly. This offers the possibility of opening up the full wealth of DL methods and technologies to archives. We demonstrate the impact of NESTOR on this problem through three example use cases.
               
            

@&#INTRODUCTION@&#

Over the past two decades, digital libraries have been steadily evolving and shaping the way people and institutions access and interact with our cultural heritage, study and learn (Borgman, 1999, 2003; Fox et al., 1993; Fox et al., 1995; Fox et al., 2012; Lesk, 1997; Marchionini and Maurer, 1995; Witten and Bainbridge, 2003). Nowadays, the reach of digital libraries goes far beyond the realm of traditional libraries and also encompasses other kinds of cultural heritage institutions, such as archives and museums. Nevertheless, these institutions are quite different from several points-of-view: they have different internal organizations and traditions; their resources are different in nature, structure, and descriptions; and their users have different information needs which call for different methods for accessing resources.

Archives are not simply constituted by a series of objects that have been accumulated and filed with the passing of time – as usually happens with libraries that collect, for example, individual published books, journals, and serials. Instead, archives represent the trace of the activities of a physical or juridical person in the course of their business which is preserved because of their continued value.

To this end, archives keep the context in which their records have been created and the network of relationships between them in order to preserve their informative content and provide understandable and useful information over time (Gilliland-Swetland, 2000). The fundamental characteristic of archives resides in their hierarchical organization. This expresses the context – i.e. the relationships and dependencies between the records of the archive – by using what is called the archival bond and it distinguishes archives from other objects in the realm of cultural heritage – e.g. books – which in general are perceived as individual, repeatable and unrelated entities (Vitali, 2010). Archives are in fact made up of series which, in turn, can be organized in sub-series formed of archival units, such as files, registers and so on. These archival units have a homogeneous nature and can, in turn, be divided into subunits containing items such as letters, reports, contracts, testaments, photographs, and drawings (International Council on Archives, 1999).

Digital libraries benefit from the existence of sophisticated formal models, such as the Structures, Spaces, Scenarios, Societies (5S) model (Fox et al., 2012; Gonçalves, Fox, et al., 2004; Gonçalves et al., 2008), which allow us to formally describe them and to prove their properties and features. Despite the importance of archives, so far there has been no attempt to develop a dedicated formal model, built around their peculiar constituents, such as the notion of archival bond. Nor can we exploit the 5S model as it is for archives because, as we will discuss later on, it needs to be extended and adapted to archives.

In this article we highlight the central role of formal models for the digital library, because integration and cooperation between these models can enhance the interoperability between the different facets of DL, including their community, methodology and technology. In this context a model for archives is sorely needed to formally define their characteristics and to prove that general digital library methods and technologies can be embodied in this field and respect archival practice.

Therefore, we propose an innovative formal model for archives built around the notions of archival bond and hierarchy. The proposed model, called NEsted SeTs for Object hieRarchies (NESTOR), is based on the idea of expressing the hierarchical relationships between objects through the inclusion property between sets, in contrast to the binary relation between nodes exploited by the tree (Aho and Ullman, 1992).

Then we exploit NESTOR to formally extend the 5S model to define a digital archive as a specific case of digital library able to take into consideration the peculiar features of archives. This defines an actual bridge between these two formal models which: (i) allows archives to exist and interact with other realities (i.e. libraries and museums); (ii) provides archives the possibility of exploiting the full wealth of digital library technologies and methods; and (iii) enables integrated access to heterogeneous contents.

As concrete accounts of this and as substantial examples of their application, we apply NESTOR and the extended 5S model to three typical scenarios for digital archives and overcome well-known issues in the field. The first is called “detaching the archives” which is the case of interoperability between digital archives where we formally exploit the Open Archives Initiative Protocol for Metadata Harvesting (OAI-PMH) to demonstrate how digital library technologies can be adopted with archives. The second scenario is called “unchaining the archives” which shows how archives modeled with NESTOR can form compound digital objects made available as Linked Open Data (LOD) (Heath and Bizer, 2011) on the Web adopting Open Archives Initiative Object Reuse and Exchange (OAI-ORE) as a working framework. Finally, the third scenario is called “socializing the archives” which describes how NESTOR together with the Flexible Annotation Semantic Tool (FAST) (Agosti and Ferro, 2008) can enhance the role of annotations in archives by helping both archivists and end-users in the description and interpretation of archival resources.

The paper is organized as follows. Section 2 provides an intuitive overview of the principles underlying the two set data models composing NESTOR (i.e. the NS-M and INS-M) and a presentation of the main contributions of this work. In Section 3 we provide some background on archives, formal models for digital libraries and discuss the related work about nested sets methodologies. In Section 4 we formally present NESTOR along with its properties. Section 5 shows the equivalence between NESTOR and the archival trees. In Section 6 we introduce our extension to the 5S model via NESTOR and in Sections 7–9 we apply NESTOR and this extension to three case studies. We draw conclusions and point to future work in Section 10. In Appendix A we report all the proofs of the properties and theorems presented in Sections 4 and 5.

The set data models composing NESTOR are well-suited for archival practice; indeed, the idea of “set” shapes the concept of archival division which is a “container” comprising distinct elements that have some properties in common. If we consider the Chinese boxes metaphor, a hierarchy is composed of a sequence of boxes contained one inside the other; if we look at an archive from the physical point-of-view, we can see that it resembles the Chinese boxes structure as there are boxes, folders, sheets, etc. contained one inside the other.

Nested sets are closer to this view of reality than trees are. Indeed, although archival practice commonly considers archives as trees, a tree is actually a higher level abstraction than the nested sets as it only focuses on structural relationships. Indeed, NESTOR comprises both the structure and the content of the archive, where the inclusion relationships represent the structure and the elements belonging to the sets represent the content.

To illustrate the basic ideas behind NESTOR, let us consider an archive composed of six divisions: a fonds, two sub-fonds, and three series.

As shown in Fig. 1
                        , the first model composing NESTOR – i.e. the Nested Sets Model (NS-M) – adopts a bottom-up approach: (i) each set corresponds to an archival division; (ii) the innermost sets are the leaves of the hierarchy, e.g. the series; and (iii) you create supersets as you climb up the hierarchy, e.g. the sub-fonds and fonds. In general, in Fig. 1 we can see that each node of the archival tree is mapped into a set, where child nodes become proper subsets of the set created from the parent node. Every set is a subset of at least one set; the set corresponding to the tree root is the only set without any supersets and every set in the hierarchy is a subset of the root set. The leaves are sets with no subsets. The tree structure is maintained thanks to the nested organization and the relationships between the sets are expressed by the set inclusion order. Even the disjunction between two sets brings information; indeed, the disjunction of two sets means that these belong to two different branches of the same archival hierarchy.

As shown in Fig. 2
                        , the second model composing NESTOR – i.e. Inverse Nested Sets Model (INS-M) – adopts a top-down approach: (i) each set corresponds to an archival division; (ii) the innermost set is the root of the hierarchy, i.e. the fonds; and (iii) you create supersets as you climb down the hierarchy, e.g. sub-fonds and then series. We can say that a tree is mapped into the INS-M by transforming each node into a set, where each parent node becomes a subset of the sets created from its children. The set created from the tree’s root is the only set with no subsets and the root set is a proper subset of all the sets in the hierarchy. The leaves are the sets with no supersets and they are sets containing all the sets created from the nodes composing the tree path from a leaf to the root. An important aspect of INS-M is that the intersection of every couple of sets obtained from two nodes is always a set representing a node in the tree. The intersection of all the sets in the INS-M is the set mapped from the root of the tree.

Unfortunately, the representation of the INS-M by means of the Euler-Venn diagrams (adopted for the NS-M) is not very expressive and can be confusing for the reader (Agosti, Ferro, et al., 2009) – see Fig. 2. Nevertheless, we can exploit the “DocBall representation” (Crestani et al., 2004) – see bottom of Fig. 2 – which is composed of a set of circular sectors arranged in concentric rings. In the context of NESTOR a circular ring has to be seen as a set containing objects, where the outer rings are supersets of the inner rings. Each ring represents a level of the hierarchy, with the center (level 0) representing the root. In a ring, the circular sectors represent the nodes in the corresponding level. Therefore, the fonds is represented by the inner ring at level 0 of the DocBall. At level 1 we find the direct supersets of the fonds which are the sub-fonds; both these sets are represented as circular sectors comprising the inner circle. With this representation a subset is presented in a ring within the set including it. Indeed, we can see that the fonds is included by all the other sets. If the intersection of two or more sets is empty, then these sets have no common circular sector in the inner rings of the DocBall.

From this description we can see that the INS-M can be associated to the top-down descriptive activity and the NS-M to the bottom-up one. The top-down descriptive activity is followed by the archivist when s/he has to describe an archive for which s/he knows the structure in advance. For instance, the archivist knows that there is a fonds divided into three sub-fonds and so on; in this case the activity is to describe these archival divisions and the documents they contain. We call this top-down because in this case the archivist knows a priori how to divide the documents (i.e. elements) into the archival divisions (i.e. sets). The bottom-up description activity works the other way around; the archivist starts to study the documents and s/he decides how to put them together in order to form an archival division, thus the archival hierarchy is built from the bottom. We call bottom-up approach because in this case dividing the documents into archival divisions is an iterative process: the archivist starts from the whole set of documents (i.e. the fonds) and s/he defines the subsets (i.e. subfonds, series, etc.) by construction, analysing the documents one by one.

In the context of Libraries, Archives, and Museums (LAM) unifying a variety of organizational settings and providing more integrated access to their contents is an aspect of utmost importance. Indeed, LAM collect, manage and share digital contents; although the type of materials may differ and professional practices vary, LAM share an overlapping set of functions. Fulfilling these functions in “collaboration rather than isolation creates a win–win for users and institutions” (Zorich et al., 2008). Although the convergence between libraries, archives and museums has been a topic of much discussion in the digital library community, the emerging similarities between these three types of cultural heritage institutions are not yet evident in the proposed formal models, developed systems, and education of professionals (Trant, 2009; Timms and Fall, 2009).

In particular, there are no state-of-the-art formal models for archives and this has prevented them from being fully integrated in digital library communities, methodologies and technologies. The definition of the set data models and their properties we give in Section 4 proves that the nested sets idea can be formalized as a proper data model which can be exploited to represent and manage archival hierarchies. Indeed, we show that it is possible to represent a hierarchical organization by means of the sets and then represent the objects belonging to the sets and formally establish relations between them.

The formalization of NESTOR settles a common ground for dealing with hierarchies open to existing models, solutions and technologies; it exploits and enhances the state of the art in the fields of digital library, thus providing a further level of expressiveness and a theoretical environment that can be exploited for the definition of innovative systems, functionalities and services. Furthermore, as will also emerge later on, the nested sets models have several advantages over trees while remaining semantically equivalent, and even though they are well known in the field from an intuitive point-of-view, they have not been formalized before.

We exploit the formal basis provided by NESTOR to extend the widely-known 5S Model (Gonçalves, Fox, et al., 2004) in order to explicitly enclose archives and their constraints in the reality it intends to model. Afterwards, we exploit a main feature of NESTOR which is the separation between the structural and the content aspects of the entities represented within the set data models to address concrete issues in the field of digital libraries. Specifically, in the field of archives the formalization of NESTOR allows us to address some known problems and, at the same time, to push the boundaries of the discipline. To this purpose we present three use cases. The first is called “detaching the archives”, the goal of which is to allow variable granularity sharing of archival metadata in a distributed environment; the aim is to free and exchange a specific archival description (or a set of descriptions) independently from the whole archive, since in any moment the context of this description can be reconstructed. This use case shows how NESTOR can address known problems regarding the state-of-the-art of digital archives; we consider the issues regarding interoperability between digital archives and metadata exchange. The 5S model has been used for modeling the Open Archives Initiative Protocol for Metadata Harvesting (OAI-PMH) (Van de Sompel et al., 2003), which is the de facto standard for metadata sharing between digital libraries in distributed environments. The formal definition of NESTOR allows us to exploit the theoretical common ground with the 5S model to extend OAI-PMH and allow it to manage and exchange complex hierarchical data structure in a flexible way, thus overcoming a well-known problem affecting the current archival description standard. The extension of OAI-PMH will make possible the exchange of data belonging to a hierarchy with a variable granularity without losing the relationships between the other data in the hierarchy.

The second use case is called “unchaining the archives”, the goal of which is to open up archival data in the Web by exploiting the potentialities of the Linked Open Data (LOD) (Heath and Bizer, 2011) paradigm and to enrich the archival descriptions with related digital objects. This use case shows how NESTOR helps to push the boundaries of the discipline by creating new possibilities for archives. Indeed, the reality of modern archival records creation is that documents may exist in “multiple contexts and have multiple and complex relationships that describe their significance and value” (Kaplan et al., 2010). Furthermore, new archival trends encourage the adoption of a “plural, provisional and interpretative perspective” (Light and Hyry, 2002) in the description of archives. This vision leads to the creation of multiple connected hierarchies of entities that must respect the archival rules and NESTOR, along with its relationships with the 5S model, addresses this aspect in a formal way with tangible outcomes. Furthermore, archival practice is experiencing a transformation process which promotes the definition of complex relationships between the resources of interest and the constitution of compound digital objects (Kaplan et al., 2010). For similar reasons, in the wider context of digital libraries we are experiencing a wide-ranging diffusion of the Open Archives Initiative Object Reuse and Exchange (OAI-ORE).
                           1
                           
                              http://www.openarchives.org/ore/.
                        
                        
                           1
                        
                     

Archives as a meaningful part of digital libraries can take advantage of using the LOD approach instantiated by means of OAI-ORE (Kaplan et al., 2010); indeed, a methodology for representing archives in OAI-ORE would allow richer methods for modeling archival descriptions and can also provide additional and flexible visualizations of the documents that would not be restricted to the “old linear view inspired by the paper tradition” (Kaplan et al., 2010). At the same time, it is commonly agreed (Kaplan et al., 2010; Light and Hyry, 2002; Ross, 2007) that new approaches, such as the adoption of the OAI-ORE model, should add to, but not undermine, fundamental archival theory.

The formal basis we define allows us to model an archive as an OAI-ORE instance while retaining its hierarchical structure and the archival bond (Ferro and Silvello, 2013b), and to propose a methodology to map archival descriptions into OAI-ORE by showing how it enables both the preservation of their original order and the definition of new types of relationships.

The third use case is called “socializing the archives”, the goal of which is to assist archivists and general users in enriching, consulting, and understanding archives by means of annotations. This use case shows how NESTOR allows us to transform archives into a new type of information infrastructure that can be user-centered and is able to support content management tasks together with tasks devoted to communication and cooperation (Kani-Zabihi et al., 2010). The main way of reaching this goal is to support archivists by considering the way in which they work (Pearson et al., 2009; Siemens et al., 2011) and, as a consequence, by enriching archives through digital annotations. Indeed, annotations foster collaboration between archivists, researchers and general users by playing a central role both in the phase of creation and in the phase of consultation of archival metadata. In the creation phase archivists have to select and describe the archival material and annotations allow them to explain and discuss their choices, thus enabling users to properly access and consult the archival metadata. In the consultation phase, annotations are exploited to find relationships between different parts of an archive or between different archives; for instance, users can exploit annotations to move from one archive to another guided by the expertise of the archivists that annotated them.

The archival community has developed “content and data structure standards” (Prom et al., 2007) to facilitate the description, management and access to the archival resources; however, these standards can be difficult for archivists to use (Discovery et al., 2007) and are often implemented in ways that can negatively affect their description activity (Yako, 2008). Therefore, there has been a proliferation of digital archival systems based on diversified descriptive methodologies and metadata; also from the annotation point-of-view a lot of research has been done that has led to the design and development of variegated annotation systems (Agosti and Ferro, 2008).

This heterogeneity turns into an interoperability problem when we need to access and consult archival metadata managed by different digital archive systems and annotations created and handled by different systems. Moreover, annotations under certain conditions as well as archives can be opportunely organized in a hierarchical way. The 5S model extended through NESTOR allows for the formal modeling and managing of multiple hierarchies which are exploited to create a common basis between archives through the NESTOR model and annotations through the FAST formal model (Agosti and Ferro, 2008; Ferro and Silvello, 2013a).

@&#RELATED WORK@&#

Archival description is defined in Pearce-Moses (2005) as “the process of analyzing, organizing, and recording details about the formal elements of a record or collection of records, to facilitate the work’s identification, management, and understanding”; archival descriptions have to reflect the peculiarities of the archive, retain all the informative power of a record, and keep trace of the provenance and original order in which resources have been collected and filed by archival institutions (Gilliland-Swetland, 2000). This is emphasized by the central concept of fonds,
                           2
                           The term fonds is not a commonly used English word. It is derived from the French (Hayworth, 1993) and in the archival context it is used both for the singular and plural form of the noun.
                        
                        
                           2
                         which should be viewed primarily as an “intellectual construct”, the conceptual “whole” that reflects an organic process in which a records creator produces or accumulates series of records (Cook, 1993). In this context, provenance becomes a fundamental principle of archives often referred to as “respect des fonds” which dictates that resources of different origins be kept separate to preserve their context (Duranti, 1998; Gilliland-Swetland, 2000).


                        Duranti (1998) highlights that maintaining provenance leads archivists to evaluate records on the basis of the importance of the creator’s mandate and functions, and fosters the use of a hierarchical method. The hierarchical structure of the archive expresses the relationships and dependency links between the records of the archive by using what is called the archival bond defined as “the interrelationships between a record and other records resulting from the same activity” (Pearce-Moses, 2005). Archival bonds, and thus relationships, are constitutive parts of an archival record: if a record is taken out from its context and has lost its relationships, its informative power would also be considerably affected. Therefore, archival descriptions need to be able to express and maintain such structure and relationships in order to preserve the context of a record.

Archival description proceeds from the general to the specific as a consequence of the provenance principle and has to show, for every unit of description, its relationships and links with other units and to the general fonds. Therefore, archival descriptions produced according to the International Standard for Archival Description (General) (ISAD (G)) (International Council on Archives, 1999) take the form of a tree. In Fig. 3
                         we can see the ISAD (G) hierarchical model: any number of intermediate levels are possible between any shown in the model. Entities are in a vertical relationship of subordination with the entity they belong to; the hierarchical representation is further complicated by the fact that the entities which belong to the same father have a “horizontal-type” relationship – they need to be represented according to a significant sequence which reflects the position that they have in the logical and/or the material order of the archive.

The principles of ISAD (G) are put into action by the Encoded Archival Description (EAD) standard (Society of American Archivists, 2003; Pitti, 1999) for encoding archival descriptions. EAD is based on eXtensible Markup Language (XML) (W3C, 2006) and it succeeded because “for the first time archivists have been offered a data structure standard that accommodates a hierarchical structure for the presentation of a variety of descriptions” (Haworth, 2001) and it enables archivists to be software independent.

EAD is composed of three high-level components: 〈eadheader〉, 〈frontmatter〉, and 〈archdesc〉. The 〈eadheader〉 contains metadata about the archival descriptions and includes information about them such as title, author and date of creation. The 〈frontmatter〉 supplies publishing information and is an optional element, while the 〈archdesc〉 contains the archival description itself and constitutes the core of EAD. The 〈archdesc〉 may include many high-level sub-elements, most of which are repeatable. The most important element is the 〈did〉 or descriptive identification which describes the collection as a whole. The 〈did〉 element is composed of numerous sub-elements intended for brief, clearly designated statements of information and they are available at every level of description. Finally, the 〈archdesc〉 contains an element that facilitates a detailed analysis of the components of a fonds, the 〈dsc〉 or description subordinate components. The 〈dsc〉 contains a repeatable recursive element, called 〈c〉 or component. A component may be an easily recognizable archival entity such as series, subseries or items. Components are not only nested under the 〈archdesc〉 element, they are also usually nested inside one another. Components usually are indicated with 〈cN〉 tag, where N
                        ∈{01,02,…,12}.

EAD reflects the archival structure and holds relationships between entities in an archive. In addition, EAD encourages archivists to use collective and multilevel description, and because of its flexible structure and broad applicability, it has been embraced by many repositories (Kiesling, 2001).

Nonetheless, EAD allows for several degrees of freedom in tagging practice, which may turn out to be problematic in the automatic processing of EAD files, since it is difficult to know in advance how an institution will use the hierarchical elements. The EAD permissive data model may undermine the very interoperability it is intended to foster. Indeed, it has been underlined that only EAD files meeting stringent best practice guidelines are shareable and searchable (Prom et al., 2007). Moreover, there is also a second relevant problem related to the level of material that is being described. Unfortunately, the EAD schema rarely requires a standardized description of the level of the materials being described, since the 〈level〉 attribute is required only in the 〈archdesc〉 tag, while it is optional in 〈cN〉 components and in very few EAD files this possibility is used, as pointed out by Prom (2002). As a consequence, the level of description of the lower components in the hierarchy needs to be inferred by navigating the upper components, even as far as up to the 〈archdesc〉, where the presence of the 〈level〉 attribute is mandatory. Therefore, access to individual items might be difficult without taking into consideration the whole hierarchy.

We highlight this fact in Fig. 4
                         where we present the structure of an EAD file. In this example we can see the top-level components 〈eadheader〉 and 〈archdesc〉 and the hierarchical part represented by the 〈dsc〉 component; the 〈level〉 attribute is specified only in the 〈archdesc〉 component. Therefore, the archival levels described by the components of the 〈dsc〉 can be inferred only by navigating the whole hierarchy. Moreover, sharing and searching archival description might be made difficult by the typical size of EAD files with a very deep hierarchical structure. Indeed, each EAD file is a description of a whole collection of items rather than the description of an individual item. On the other hand, users are often interested in the information described at the item level, which is typically buried very deeply in the hierarchy and might be difficult to reach (Shreeves et al., 2003).

EAD presents some difficulties both for the expert user (i.e. archivists who find the “complexity of EAD itself to be a deterrent to implementation” (Yako, 2008)) and the general user who has to consult and interpret the archival data without specific knowledge of archival theory and practice. One difficulty is related to the reconstruction of the archival context starting from an element buried in the hierarchy; this difficulty related to the data/system model on which EAD is based may be reflected in a similar difficulty and disorientation for the user in the perception of the context which supplies the information needed to satisfy her/his information requirements. Another concern is that in some cases EAD makes searches more complicated for users (Yako, 2008).

These problems are also enhanced by the lack of a systematic user study about the perception and usefulness of EAD for the end-user. Note that in the recent past few institutions have developed formal evaluations for monitoring the effectiveness of EAD. Archivists base their perceptions regarding end-user utilization of EAD on very little quantitative or systematic qualitative data (Roth, 2001), so it is not easy to measure the end-user’s level of engagement (O’Brien and Toms, 2010) with the archival data. One of the goals of NESTOR is to provide a flexible model to handle archival data in order to facilitate the interpretation, utilization, sharing and also visualizations of archival resources; the importance of these aspects are assessed by several studies about the functionality and the usability of electronic resources (Makri et al., 2011) and we take them into account in the use cases presented in Sections 7 and 9.

When we need to relate one or more digital objects to their archival descriptions represented as metadata, EAD introduces some more limitations. Indeed, each 〈cN〉 tag of the EAD may contain a description of a digital object or a bunch of digital objects. These objects are usually reachable by means of a Uniform Resource Identifier (URI); the link from EAD to a digital object or group of objects can be made at any level, but “it should be made at the level where the object(s) is described or implied in EAD” (OAC Working Group, 2005). To this end EAD provides a 〈dao〉 tag which allows us to specify a URI to an external digital object which is part of the described material (see Fig. 5
                        a); furthermore, EAD also provides an 〈extptr〉 element to point to a digital object that is not part of the described materials (OAC Working Group, 2005). By means of these tags we can link one external digital object to each archival division, but we cannot link more than one digital object to a specific division. The current solution to this problem exploits third-party components – i.e. “digital wrappers”
                           3
                           Digital wrappers “are pieces of software for binding digital content files and their metadata together and for specifying the logical relationships among the content files” (GDO, 2011).
                        
                        
                           3
                        ; a relevant example is the Metadata Encoding and Transmission Standard (METS) metadata that is used as an in-between component for relating a bunch of digital objects to an EAD component (Sugimoto and van Dongen, 2009; GDO, 2011) – see Fig. 5b. NESTOR in conjunction with the LOD paradigm enables the definition of a more flexible solution to the problem. This solution, presented in Section 8 in the “detaching the archives” use-case, exploits the clear distinction between structure and content enabled by NESTOR to instantiate an archive as an OAI-ORE instance which exposes archives as compound digital objects in the Web.

In order to settle a theoretical common ground where it is possible to establish relationships between NESTOR and the different models proposed in the field of digital libraries, we describe and discuss the following state-of-the-art models: (i) the 5S formal model, (ii) the DELOS reference model, and (iii) the Europeana Data Model (EDM). These models are different in the scope they pursue and in the way they are defined, but they all aim at providing a means to model data, services, or applications in the digital libraries realm.

The Structures, Spaces, Scenarios, Societies (5S) (Fox et al., 2012; Gonçalves, Fox, et al., 2004; Gonçalves et al., 2008) is a formal model which draws upon the broad digital library literature to produce a comprehensive base of support. It was developed largely bottom up, starting with key definitions and elucidation of digital library concepts from a minimalist approach. It is built around five main concepts: (i) streams are sequences of elements of an arbitrary type, e.g. bits, characters, images, and so on; (ii) structures specify the way in which parts of a whole are arranged or organized, e.g. hypertexts, taxonomies, and so on; (iii) spaces are sets of objects together with operations on those objects that obey certain constraints, e.g. vector spaces, probabilistic spaces, and so on; (iv) scenarios are sequences of related transition events, for instance, a story that describes possible ways to use a system to accomplish some functions that a user desires; and (v) societies are sets of entities and relationships between them, e.g. humans, hardware and software components, and so on.

Starting from these five main concepts, the model provides a definition for a minimal digital library which is constituted by: (i) a repository of digital objects; (ii) a set of metadata catalogs containing metadata specifications for those digital objects; (iii) a set of services containing at least services for indexing, searching, and browsing; and (iv) a society.

While these broad concepts can also be common to archives, when you look at the specific way in which they are formally defined, you realize that the definitions cannot be straightforwardly applied to the case of archives without at least some extension. We will discuss this in further detail with the presentation of an extension of 5S via NESTOR in Section 6.

The DELOS Reference Model (Candela et al, 2007) is a high-level conceptual framework that aims at capturing significant entities and their relationships with the digital library universe with the goal of developing more robust models of it. The DELOS Reference Model and the 5S model address a similar problem with different approaches; the former does not provide formal definitions, but it does provide a way to model and manage the resources of the digital library realm. The 5S on the other hand is a formal model providing mathematical definitions of the digital library entities that can be used to prove properties, theorems and propositions like in Gonçalves, Watson, et al. (2004), Gonçalves et al. (2008).

So the DELOS Reference Model is similar to the 5S model in its broader goal, but instead of using a mathematical formalism, it relies on concept maps (Novak, 1990; Novak and Cañas, 2008) because of their simplicity and immediacy and it highlights six main domains in the digital library universe: (i) content: the data and information that digital libraries handle and make available to their users; (ii) user: the actors (whether human or not) entitled to interact with digital libraries; (iii) functionality: the services that digital libraries offer to their users; (iv) quality: the parameters that can be used to characterize and evaluate the content and behavior of digital libraries; (v) policy: a set of rules that govern the interaction between users and digital libraries; and (vi) architecture: a mapping of the functionality and content offered by a digital library onto hardware and software components.

These six main domains represent the high level containers that help organize the DELOS Reference Model. For each of these domains, the fundamental entities and their relationships are clearly defined. Even though the 5S model and the DELOS Reference Model are at two different levels of abstractions and make use of different languages and formalisms to represent the digital library universe, it is possible to make bridges and mappings between the two, as for example has been done for the quality domain (Agosti, Ferro, et al., 2007).

It is possible to express the high-level entities and the relationships grasped by NESTOR throughout the concepts defined in the DELOS Reference Model with little or no extension to the model, but it would be very difficult to express in the DELOS Reference Model the constraints that are present in NESTOR. Moreover, the DELOS Reference Model is not a formal model and thus it would not be possible to formally prove the properties of the modeled reality of interest.

We can consider the EDM (Doerr et al., 2011; Europeana, 2011; Europeana, 2012) at a different level and without the ambition of modeling the whole digital library universe. The EDM aims at structuring the data managed by Europeana,
                           4
                           
                              http://www.europeana.eu/.
                        
                        
                           4
                         a major effort of the European Union to create a digital library containing the cultural heritage of Europe. EDM adheres to the modeling principles that underpin the approach of the Web of Data (“Semantic Web”) (Bizer et al., 2009; Heath and Bizer, 2011). A common model like EDM can instead be seen as an anchor to which various finer-grained models can be attached, making them at least partly interoperable at the semantic level, while the data retain their original expressivity and richness. It is thus possible to convert EAD concepts to and represent them in EDM (Hennicke et al., 2011; Casarosa et al., 2013). The same holds true in the case of NESTOR (Ferro and Silvello, 2013b), which pass through OAI-ORE (Lagoze et al., 2008a), with the additional benefit of exploiting the formal model to precisely define these mappings, constraining the mappings, and proving their properties as we show in Section 8.

NESTOR, along with all the models presented here, can be employed by general-purpose digital library architectures, such as Greenstone (Witten et al., 2009), and Fedora Commons,
                           5
                           
                              http://fedora-commons.org/.
                        
                        
                           5
                         in order to provide support for modeling data and resources and to enhance their applications and services. These initiatives aim at providing a common architectural and software platform that can be exploited to build a digital library; therefore, they address a different set of problems from NESTOR, the 5S model, the DELOS reference model, and EDM.

The intuitive idea of nested sets was proposed by Knuth (1997) without any formal definition and it has been mainly exploited in the field of relational databases as an alternative approach for implementing some integer encodings to efficiently solve recursive queries in Structured Query Language (SQL) (Celko, 2000; Kamfonas, 1992; Na and Lee, 2006; Tropashko, 2005).

In Fig. 6
                         we report the original representation of nested sets proposed by Knuth. Fig. 6a represents an instance of the general idea of nested sets: “A collection of sets in which any pair of sets is either disjoint or one contains the other” (Knuth, 1997). Fig. 6b represents a linear nested sets view. Matching parentheses can be seen as delimiting a set, contained in the sets delimited by more external matching parentheses. The parent–child relationships are retained by the nesting inside the parentheses. The representation of the tree in Fig. 6c works in the same way by exploiting the idea of indentation.

We exploited this idea in the field of digital libraries by proposing some applications to the realm of archives; indeed, in Ferro and Silvello (2008b) the idea of using a nested organization of subsets has been exploited to allow the exchange of archival metadata between distributed digital libraries. An initial formulation of the first model composing NESTOR which is the Nested Sets Model (NS-M) was presented in Ferro and Silvello (2009) and then it was improved in Agosti et al. (2010b). In Ferro and Silvello (2009) the second model called Inverse Nested Sets Model (INS-M) was introduced and applied to represent, manage and exchange archival data between distributed digital libraries. However, in this paper, we have completely reworked the formal definitions of NESTOR and propose a brand new formalism which also allows us to better express the properties of the model. This work has been reviewed and extended in Agosti et al. (2011), where a mapping between the two newly defined set data models is proposed along with a preliminary definition of an algebra to operate on NESTOR (this aspect is not discussed in this article). In Ferro and Silvello (2011) the INS-M was exploited to define an algorithm to find the lowest common ancestor between two objects in a hierarchy. To the best of our knowledge, the INS-M has not been addressed before in the literature and both models, NS-M and INS-M, are defined here from a formal point of view.

NESTOR defines two set-based data models: The Nested Sets Model (NS-M) and the Inverse Nested Sets Model (INS-M). They are both formally defined in the context of set theory (Halmos, 1960; Jech, 2003). We present the NS-M and then the INS-M. We will maintain this order in the whole presentation of NESTOR. We define both NS-M and INS-M as a collection of subsets where specific conditions must hold. Note that for the sake of readability all the proofs are gathered and reported in Appendix A.

The first definition regards the NS-M; basically, we define a collection of subsets (i.e. 
                        
                           C
                        
                     ) of a set (i.e. A) and then we impose some constraints on the subsets of A (i.e. H,
                     K
                     ⊂
                     A) which belongs to 
                        
                           C
                        
                     . NS-M is defined as a Nested Sets Collection (NS-C) which is a collection of subsets where two conditions must hold. In the following definition, the first condition (4.1) states that set A which contains all the subsets of the collection must belong to the NS-C itself. The second condition states that the intersection of every couple of sets in the NS-C is not the empty-set only if one set is a proper subset of the other.
                        Definition 1
                        Let A be a set and let 
                              
                                 C
                              
                            be a collection of subsets of A. Then 
                              
                                 C
                              
                            is a Nested Sets Collection (NS-C) if:
                              
                                 (4.1)
                                 
                                    A
                                    ∈
                                    C
                                    ,
                                 
                              
                           
                           
                              
                                 (4.2)
                                 
                                    ∀
                                    H
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    H
                                    ∩
                                    K
                                    
                                    ≠
                                    
                                    ∅
                                    ⇒
                                    H
                                    ⊆
                                    K
                                    ∨
                                    K
                                    ⊆
                                    H
                                    .
                                 
                              
                           
                        

This definition formally defines how an archive can be modeled by means of the NS-M as shown in Fig. 1. The collection of subsets 
                        
                           C
                        
                      is the considered archive; the first condition says that there is a set – i.e. the “fonds” – which contains all the subsets – i.e. “subfonds”, “series”, etc. – of the archive. The second condition says that two subsets such as two “series” cannot have common elements, thus their intersection is always empty.

Now, we can introduce the Inverse Nested Sets Collection (INS-C) which defines the INS-M. We define an INS-C as a collection of subsets where two conditions must hold. The first condition (4.3) states that 
                        
                           C
                        
                      must contain the bottom set (i.e. the common subset of all the sets in 
                        
                           C
                        
                     ), call it B, which is the common subset of all the sets in 
                        
                           C
                        
                     . The second condition (4.4) states that if we consider three sets K, H and L in 
                        
                           C
                        
                      such that H is a subset of K and K is not equal to L, then the intersection between L and K is not the same as the intersection between H and L or H is not a subset of L and vice versa.
                        Definition 2
                        Let A be a set and let 
                              
                                 C
                              
                            be a collection. Then, 
                              
                                 C
                              
                            is an Inverse Nested Sets Collection (INS-C) if:
                              
                                 (4.3)
                                 
                                    ∃
                                    !
                                    B
                                    ∈
                                    C
                                    |
                                    ∀
                                    K
                                    ∈
                                    C
                                    ,
                                    B
                                    ⊆
                                    K
                                    ,
                                 
                              
                           
                           
                              
                                 (4.4)
                                 
                                    ∀
                                    H
                                    ,
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                    |
                                    H
                                    ⊆
                                    K
                                    ,
                                    L
                                    
                                    ≠
                                    
                                    K
                                    ⇒
                                    (
                                    L
                                    ∩
                                    K
                                    =
                                    H
                                    ∩
                                    L
                                    )
                                    ∨
                                    (
                                    H
                                    ⊆
                                    L
                                    )
                                    ∨
                                    (
                                    L
                                    ⊆
                                    H
                                    )
                                    .
                                 
                              
                           
                        

This definition can be further explained by taking into account the example from Fig. 7
                     a; let us consider the collection 
                        
                           E
                           =
                           {
                           B
                           ,
                           H
                           ,
                           K
                           ,
                           L
                           }
                        
                      represented on the left hand side of the figure, where B
                     ={a},
                     H
                     ={a,
                     b}, K
                     ={a,
                     b,
                     c,
                     d} and L
                     ={a,
                     c}. In this case, H
                     ⊆
                     K, L
                     ≠
                     K and H
                     ⊈
                     L
                     ∧
                     L
                     ⊈
                     H but L
                     ∩
                     K
                     ={a,
                     c}≠
                     H
                     ∩ 
                     L
                     ={a}; therefore, the collection represented in Fig. 7 is not an INS-C. If we consider the collection of subsets 
                        
                           G
                           =
                           {
                           B
                           ,
                           H
                           ,
                           K
                           ,
                           L
                           }
                        
                      represented in Fig. 7b, where B
                     ={a},
                     H
                     ={a,
                     c,
                     d}, K
                     ={a, d} and L
                     ={a,
                     b,
                     c}, we can see that K
                     ⊆
                     H and that 
                        
                           ∃
                           L
                           ∈
                           G
                           |
                           L
                           ⊈
                           K
                           ∧
                           K
                           ⊈
                           L
                        
                      but L
                     ∩
                     K
                     ={a}≠
                     H
                     ∩
                     L
                     ={a,
                     c}, thus 
                        
                           G
                        
                      is not an INS-C.

This definition formally defines how an archive can be modeled by means of the INS-M as shown in Fig. 2. If the collection 
                        
                           C
                        
                      is the archive we intend to model, the first condition says that there must exist an archival division which all other divisions share; this means that the “fonds” must be the archival division common to all the other divisions in the archive. Basically, this is another way of saying that all the archival divisions are dependant on the same “fonds”. The second condition extends this fact by saying that if two or more archival divisions, say “series”, belong to the same archival branch, then they must have in common the same “subfonds” and “fonds”.

In the context of information access systems it is important to separate between intensional and extensional aspects of information; for instance, in relational database management systems there exists the distinction between metadata (i.e. intensional level) and data (i.e. extensional level).

In NESTOR it is possible to delineate a clear distinction between intension and extension of a collection of sets and thus between structure and content; indeed, from the structural point-of-view, a collection of subsets is represented by the sets in the collection and their inclusion dependencies. A collection of subsets at the intensional level is defined by its structure. Let us consider an example based on the NS-M knowing that these considerations are also valid for the INS-M. We can say that 
                           
                              C
                              =
                              {
                              A
                              ,
                              B
                              ,
                              C
                              }
                           
                         where B
                        ⊆
                        A, C 
                        ⊆
                        A and B
                        ⊈
                        C
                        ∧
                        C
                        ⊈
                        B is a NS-C because it respects conditions (4.1) and (4.2) of Definition 1. In this way, we know the structure of the collection and we know which relationships hold between the sets. From the archival point-of-view, this means that we can model an archive just by considering its archival divisions and by defining the relationships between them without taking into account their actual content.

When we consider a collection of subsets 
                           
                              C
                           
                         from the content point-of-view, it means that we refer to its extensional level. In this case a collection of subsets 
                           
                              C
                           
                         is represented by the extension of the sets composing it; the properties of the sets are then verified by inspecting the sets and verifying the elements that they contain. In this case, we say that the content of a collection of subsets defines the extension of such a collection. From the archival point-of-view, this means that we can model an archive just by considering the actual content of its archival divisions without explicitly defining the relationships between them. Therefore, we can say that 
                           
                              C
                              =
                              {
                              A
                              ,
                              B
                              ,
                              C
                              }
                           
                         where A
                        ={a,
                        b,
                        c,
                        d}, B
                        = {b} and C
                        ={c,
                        d} is the extension of a NS-C. In the next example we can see a NS-C defined at the intensional level which is instantiated by two different NS-C specified at the extensional level.
                           Example 1
                           Let us consider the following NS-C defined at the intensional level: 
                                 
                                    C
                                    =
                                    {
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    ,
                                    D
                                    }
                                 
                               where B
                              ⊆
                              A, C
                              ⊆
                              A, D
                              ⊆
                              C and B
                              ⊈
                              C
                              ∧
                              C
                              ⊈
                              B. Then, A
                              ={a,
                              b,
                              c,
                              d,
                              e}, B
                              ={b}, C
                              ={c,
                              d,
                              e}, D
                              ={d,
                              e} – represented in Fig. 8
                              a – is a valid instance for 
                                 
                                    C
                                 
                              , as well as A
                              ={a,
                              b,
                              c,
                              d,
                              e,
                              f}, B
                              ={c,
                              d}, C
                              ={b,
                              e,
                              f} and D
                              ={f} – represented in Fig. 8b; indeed, they both satisfy the specified structural conditions.

This very example can be described in the context of archives by exploiting the very simple archive modeled by means of the NS-M shown in Fig. 9
                        ; it allows us to see how it is possible to define the intension and the extension of an archive thanks to NESTOR.
                           Example 2
                           Let us consider the archive represented by the NS-M in Fig. 9. At the intensional level, the archive can be modeled as follows: 
                                 
                                    C
                                    =
                                    {
                                    fonds
                                    ,
                                    subfondsA
                                    ,
                                    subfondsB
                                    ,
                                    seriesA
                                    }
                                 
                               where subfondsA
                              ⊆
                              fonds, subfondsB
                              ⊆
                              fonds, serieA 
                              ⊆
                              subfondsB, subfondsA
                              ⊈
                              subfondsB and subfondsB
                              ⊈
                              subfondsA.

Then, fonds
                              ={summary,letterA,
                              letterB,
                              letterC}, subfondsA
                              ={letterA}, subfondsB
                              ={letterB,
                              letterC}, seriesA
                              ={letterD} is a valid instance for 
                                 
                                    C
                                 
                              ; it describes the extension of the archive.

Both the structural and the content aspects are important for the treatment of the NESTOR model. We exploit the structure defined at the intensional level to define the properties of NESTOR, whereas we exploit the extensional level to perform set operations which manipulate the content of the subsets composing the collections.

In the following we make extensive use of the concepts of collection of proper subsets and supersets and of direct subsets and supersets. Let 
                           
                              C
                           
                         be a collection of sets and 
                           
                              A
                              ∈
                              C
                           
                         be a set, we define:
                           
                              •
                              
                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             -
                                          
                                       
                                       (
                                       A
                                       )
                                       =
                                       {
                                       B
                                       ∈
                                       C
                                       :
                                       A
                                       ⊂
                                       B
                                       }
                                    
                                  to be the collection of proper supersets of A in 
                                    
                                       C
                                    
                                 ;


                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                       (
                                       A
                                       )
                                       =
                                       {
                                       B
                                       ∈
                                       C
                                       :
                                       B
                                       ⊂
                                       A
                                       }
                                    
                                  to be the collection of proper subsets of A in 
                                    
                                       C
                                    
                                 .


                                 
                                    
                                       
                                          
                                             D
                                          
                                          
                                             -
                                          
                                       
                                       (
                                       A
                                       )
                                       =
                                       {
                                       B
                                       ∈
                                       C
                                       :
                                       (
                                       (
                                       A
                                       ⊂
                                       B
                                       )
                                       ∧
                                       (
                                       ∄
                                       E
                                       ∈
                                       C
                                       |
                                       A
                                       ⊂
                                       E
                                       ⊂
                                       B
                                       )
                                       )
                                       }
                                    
                                  to be the collection of direct supersets of A in 
                                    
                                       C
                                    
                                 .


                                 
                                    
                                       
                                          
                                             D
                                          
                                          
                                             +
                                          
                                       
                                       (
                                       A
                                       )
                                       =
                                       {
                                       B
                                       ∈
                                       C
                                       :
                                       (
                                       (
                                       B
                                       ⊂
                                       A
                                       )
                                       ∧
                                       (
                                       ∄
                                       E
                                       ∈
                                       C
                                       |
                                       B
                                       ⊂
                                       E
                                       ⊂
                                       A
                                       )
                                       )
                                       }
                                    
                                  to be the collection of direct subsets of A in 
                                    
                                       C
                                    
                                 .

Many properties of the NS-M are derived from the straightforward application of set theory as we show in the following example which takes into account the intensional level of the NS-M.
                           Example 3
                           Let 
                                 
                                    C
                                 
                               be a NS-C. For all 
                                 
                                    H
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    H
                                    ⊆
                                    K
                                 
                               we can easily derive that H
                              ∪
                              K
                              =
                              K and H
                              ∩
                              K
                              =
                              H. As well we can say that for all 
                                 
                                    H
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    H
                                    ⊈
                                    K
                                    ∧
                                    K
                                    ⊈
                                    H
                                    ⇒
                                    H
                                    ⧹
                                    K
                                    =
                                    H
                                    ∧
                                    K
                                    ⧹
                                    H
                                    =
                                    K
                                 
                              .

In this example we see that the sets in a NS-C behave exactly as one would expect under the operations of union, intersection and set difference. Let us see an example which shows how these operations behave at the extensional level.
                           Example 4
                           Let 
                                 
                                    C
                                    =
                                    {
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    }
                                 
                               be a NS-C, where B
                              ⊆
                              A and C
                              ⊆
                              B. Then let us consider the following instance: A
                              ={a,
                              b,
                              c,
                              d,
                              e}, B
                              ={c,
                              d,
                              e} and C
                              ={e}. Then, B
                              ∪C
                              ={c,
                              d,
                              e}=
                              B and B
                              ∩
                              C
                              ={e}=
                              C.

Let us consider a NS-C 
                           
                              C
                           
                        ; the next proposition shows that for all 
                           
                              H
                              ∈
                              C
                           
                        , H has at most one direct superset.
                           Proposition 1
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be a NS-C. Then, 
                              
                                 
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    ⩽
                                    1
                                 
                              
                              .
                           

The following corollary to this proposition shows that the set with minimum cardinality in the collection of supersets of H is its direct superset.
                           Corollary 2
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be a NS-C, 
                              
                                 
                                    H
                                    ∈
                                    C
                                 
                               
                              be a set, 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                 
                               
                              be the collection of proper supersets of H and 
                              
                                 
                                    K
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                 
                               
                              where 
                              
                                 
                                    ∀
                                    L
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    |
                                    K
                                    |
                                    ⩽
                                    |
                                    L
                                    |
                                 
                               
                              be the subset with minimum cardinality in 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                 
                              
                              . Then, 
                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    =
                                    K
                                 
                              
                              .
                           

Finally, the next proposition proves that the direct subsets of H are always disjoints.
                           Proposition 3
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be a NS-C and 
                              
                                 
                                    H
                                    ∈
                                    C
                                 
                               
                              be a set, then 
                              
                                 
                                    ∀
                                    K
                                    ,
                                    L
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    K
                                    ∩
                                    L
                                    =
                                    ∅
                                 
                              
                              .
                           

The following proposition shows the behavior of union and set difference in the INS-M under specific conditions. Property 4.5 shows that, given an INS-C, the union of two disjoint sets is a set which does not belong to the INS-C; whereas, Property 4.6 shows that the difference between two sets in the given INS-C is a set not belonging to the INS-C.
                           Proposition 4
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C and 
                              
                                 
                                    {
                                    H
                                    ,
                                    K
                                    }
                                    ∈
                                    C
                                 
                               
                              two sets where H
                              ≠
                              K. Then,
                              
                                 
                                    (4.5)
                                    
                                       (
                                       (
                                       H
                                       ⊈
                                       K
                                       )
                                       ∧
                                       (
                                       K
                                       ⊈
                                       H
                                       )
                                       )
                                       ⇔
                                       H
                                       ∪
                                       K
                                       =
                                       L
                                       
                                       ∉
                                       
                                       C
                                    
                                 
                              
                              
                                 
                                    (4.6)
                                    
                                       H
                                       ⧹
                                       K
                                       =
                                       L
                                       
                                       ∉
                                       
                                       C
                                       .
                                    
                                 
                              
                           

Let us consider an INS-C 
                           
                              C
                           
                        , then for all 
                           
                              H
                              ∈
                              C
                           
                        , H has at most one direct subset.
                           Proposition 5
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C. Then, 
                              
                                 
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    ⩽
                                    1
                                 
                              
                              .
                           

The following corollary to this proposition proves that for all 
                           
                              H
                              ∈
                              C
                           
                        , the set with maximum cardinality in the collection of subsets of H is its direct subset.
                           Corollary 6
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C, 
                              
                                 
                                    H
                                    ∈
                                    C
                                 
                               
                              be a set, 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                 
                               
                              be the collection of proper subsets of H and 
                              
                                 
                                    K
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                 
                               
                              where 
                              
                                 
                                    ∀
                                    L
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    |
                                    K
                                    |
                                    ⩾
                                    |
                                    L
                                    |
                                 
                               
                              be the subset with higher cardinality in 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                 
                              
                              . Then, 
                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    =
                                    K
                                 
                              
                              .
                           

We know that for all 
                           
                              H
                              ,
                              K
                              ∈
                              C
                           
                         where 
                           
                              C
                           
                         is an INS-M, the intersection between them is never empty, otherwise Condition (4.3) of Definition 2 does not hold. The next proposition proves that the intersection between H and K is the set with maximum cardinality among all of their common subsets.
                           Proposition 7
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C and 
                              
                                 
                                    H
                                    ,
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                 
                               
                              be three sets such that H
                              ∩
                              K
                              
                              =
                              
                              L, then 
                              
                                 
                                    ∀
                                    W
                                    ∈
                                    (
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ∩
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    K
                                    )
                                    )
                                    ,
                                    W
                                    
                                    ≠
                                    
                                    L
                                    ⇒
                                    |
                                    L
                                    |
                                    >
                                    |
                                    W
                                    |
                                 
                              
                              .
                           

In the following we prove the equivalence between the two proposed set data models by presenting two functions ζ and ξ which allow us to go from a NS-C to an INS-C and vice versa. The possibility of mapping between one model and the other allows us to model an archive by means of both the models presented, thus exploiting the properties that are better suited for the needs we may have.
                           Definition 3
                           Let A be a set and 
                                 
                                    C
                                 
                               and 
                                 
                                    E
                                 
                               be two collections of subsets of A. We define 
                                 
                                    ζ
                                    :
                                    C
                                    →
                                    E
                                 
                               to be a function such that for all 
                                 
                                    H
                                    ∈
                                    C
                                 
                               there exists 
                                 
                                    K
                                    ∈
                                    E
                                 
                               such that:
                                 
                                    (4.7)
                                    
                                       K
                                       =
                                       
                                          
                                             
                                                ⋃
                                             
                                             
                                                L
                                                ∈
                                                {
                                                H
                                                ∪
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                H
                                                )
                                                }
                                             
                                          
                                       
                                       
                                          
                                             
                                                L
                                                ⧹
                                                
                                                   
                                                      
                                                         ⋃
                                                      
                                                      
                                                         W
                                                         ∈
                                                         
                                                            
                                                               D
                                                            
                                                            
                                                               +
                                                            
                                                         
                                                         (
                                                         L
                                                         )
                                                      
                                                   
                                                
                                                W
                                             
                                          
                                       
                                    
                                 
                              
                           

For every set 
                           
                              H
                              ∈
                              C
                           
                        , the ζ function takes into account all its supersets – i.e. 
                           
                              H
                              ∪
                              
                                 
                                    S
                                 
                                 
                                    -
                                 
                              
                              (
                              H
                              )
                           
                        ; for each one, say L, of these supersets, ζ retains all the elements that exclusively belong to L – i.e. 
                           
                              L
                              ⧹
                              ⋃
                              
                                 
                                    D
                                 
                                 
                                    +
                                 
                              
                              (
                              L
                              )
                           
                        , the elements which are in L and do not belong to any other direct subset of L. Then, the set K
                        =
                        ζ(H) contains the union of all the elements of all the considered sets.
                           Definition 4
                           Let 
                                 
                                    C
                                 
                               and 
                                 
                                    E
                                 
                               be two collections of subsets. We define 
                                 
                                    ξ
                                    :
                                    C
                                    →
                                    E
                                 
                               to be a function such that for all 
                                 
                                    H
                                    ∈
                                    C
                                 
                               there exists 
                                 
                                    K
                                    ∈
                                    E
                                 
                               such that:
                                 
                                    (4.8)
                                    
                                       K
                                       =
                                       
                                          
                                             
                                                H
                                                ∪
                                                
                                                   
                                                      
                                                         ⋃
                                                      
                                                      
                                                         L
                                                         ∈
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               -
                                                            
                                                         
                                                         (
                                                         H
                                                         )
                                                      
                                                   
                                                
                                                L
                                             
                                          
                                       
                                       ⧹
                                       
                                          
                                             
                                                ⋃
                                             
                                             
                                                L
                                                ∈
                                                
                                                   
                                                      D
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                H
                                                )
                                             
                                          
                                       
                                       L
                                    
                                 
                              
                           

The ξ function maps every set 
                           
                              H
                              ∈
                              C
                           
                         into another set, call it 
                           
                              K
                              ∈
                              E
                           
                        . K is defined by the union of all the elements belonging to H and to its supersets minus all the elements belonging to the subsets of H itself.

The next theorem shows that NS-M and INS-M have the same expressive power by proving that if we apply the function ζ to a NS-C we obtain an INS-C as output.
                           Theorem 8
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be a NS-C then 
                              
                                 
                                    ζ
                                    (
                                    C
                                    )
                                    =
                                    E
                                 
                               
                              is an INS-C.
                           

Now, let us see how the ξ function allows us to map an INS-C into a NS-C.
                           Theorem 9
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C then 
                              
                                 
                                    ξ
                                    (
                                    C
                                    )
                                    =
                                    E
                                 
                               
                              is a NS-C.
                           

In Fig. 10
                         we can see the mapping between the two set data models through the ζ and ξ functions.

Archivists use the tree as the model of an archive because it expresses the multileveled and hierarchical nature of the relationships between the archival divisions (International Council on Archives, 1999). As discussed in the previous sections, NESTOR instead adopts an approach based on set inclusion relationships and we have intuitively shown that it is suitable for modeling an archive.

The formal definition of the set data models and their properties we gave in Section 4 prove that the nested sets idea is not just an alternative graphical representation of the tree, but a proper data model that can be exploited to represent and manage hierarchies. In order to exploit this model in the archival context it is necessary to prove that these newly defined set data models are as expressive as the tree and that they can model all the facets of archival reality. We prove that the expressive power of the set data models and the tree are formally comparable and that the set data models allow us to explicitly represent aspects of the reality of interest that are problematic to capture with the tree. The major concern of the tree is on the hierarchical structure defined between the entities represented by means of it; the set data models allow us to do the same by means of collections of sets and at the same time to add a further expressive dimension represented by the elements belonging to the sets.

In this section, we formally prove that modeling an archive by means of a tree is equivalent to modeling it with the set-based approach adopted in NESTOR. To this end, we present two formal mappings from the tree to the NS-M and INS-M models and vice versa, thus verifying their equivalence.

First of all, we present the formal mapping between the tree and the NS-M. The mapping procedure creates a set for each node of the tree and defines the inclusion order between the newly created sets using the information brought by the edges connecting the nodes of the tree. For instance, let T
                        =(V,
                        E) be a tree; if we consider an edge e
                        
                           j,k
                        
                        ∈
                        E, then we have to create two sets J and K corresponding to the nodes {v
                        
                           j
                        , v
                        
                           k
                        }∈
                        V such that K
                        ⊆
                        J; indeed, from e
                        
                           j,k
                         we know that v
                        
                           j
                         is the parent of v
                        
                           k
                         and so set J will be the superset of K. In order to properly understand the mappings, it is worthwhile introducing two concepts we will widely use in the following. We define with Γ
                        +(v
                        
                           i
                        ) the set of all the descendants of v
                        
                           i
                         in V (including v
                        
                           i
                         itself); vice versa Γ
                        −(v
                        
                           i
                        ) is the set of all the ancestors of v
                        
                           i
                         in V (including v
                        
                           i
                         itself).
                           Theorem 10
                           
                              Let T
                              
                              =
                              
                              (V,
                              
                              E) be a tree and let 
                              
                                 
                                    C
                                 
                               
                              be a collection of subsets where ∀v
                              
                                 i
                              
                              ∈
                              V, 
                              
                                 
                                    ∃
                                 
                              !
                                 
                                    H
                                    ∈
                                    C
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                              . Then 
                              
                                 
                                    C
                                 
                               
                              is a Nested Sets Collection.
                           

This theorem shows us that if we map a tree into a collection of subsets by following the described rules, we obtain a NS-C. In Fig. 11
                         we show how a tree can be mapped in a family of subsets 
                           
                              
                                 
                                    V
                                 
                                 
                                    V
                                 
                              
                           
                         as proved by Theorem 10.

The following theorem shows that a NS-C can be mapped into a tree by creating a node from every set in the NS-C. Two sets J and K in the NS-C correspond to two nodes v
                        
                           j
                         and v
                        
                           k
                         in the tree and the edge e
                        
                           j,k
                         between them is created if and only if J is the direct superset of K.
                           Theorem 11
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be a NS-C, V be a set of nodes and E be a set of edges where 
                              
                                 
                                    ∀
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ∈
                                    V
                                    ,
                                    ∃
                                    !
                                    J
                                    ∈
                                    C
                                    ∧
                                    ∀
                                    
                                       
                                          e
                                       
                                       
                                          j
                                          ,
                                          k
                                       
                                    
                                    ∈
                                    E
                                    ,
                                    ∃
                                    !
                                    J
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    K
                                    ⊆
                                    J
                                 
                              
                              . Then T
                              
                              =
                              
                              (V,
                              
                              E) is a tree.
                           

We have formally defined the relationships between a tree with the NS-M; we know that a tree can be mapped into a NS-C where every node of the tree is mapped into a set of the collection and vice versa.

Now we can present the corresponding theorems for the INS-M which show how a tree can be mapped into an INS-C and vice versa. Basically, every couple of nodes v
                        
                           j
                         and v
                        
                           k
                         is mapped into a couple of sets J and K. If there is an edge between v
                        
                           j
                         and v
                        
                           k
                        , say e
                        
                           j,k
                        , then the set J created from v
                        
                           j
                         is defined as a subset of the set K created from v
                        
                           k
                        . The mapping between a tree and an INS-C reverses the idea described for the mapping of a tree into a NS-C; if a node is a parent of another node in a tree, this is mapped into a set which is a subset of the set created from its child node.
                           Theorem 12
                           
                              Let T
                              
                              =
                              
                              (V,
                              
                              E) be a tree and let 
                              
                                 
                                    C
                                 
                               
                              be a collection of subsets where ∀v
                              
                                 i
                              
                              ∈
                              V, ∃!I
                              
                              =
                              
                              Γ
                              −
                              (v
                              
                                 i
                              
                              ). Then 
                              
                                 
                                    C
                                 
                               
                              is an INS-C.
                           

This theorem shows us that if we map a tree into a collection of subsets following the described rules, we obtain an INS-C. In Fig. 12
                         we show how a tree can be mapped in a family of subsets 
                           
                              
                                 
                                    V
                                 
                                 
                                    V
                                 
                              
                           
                         as shown by Theorem 12.

Now we can see how an INS-M 
                           
                              C
                           
                         is mapped into a tree T
                        =(V,
                        E); the following theorem shows that if we map every couple of sets 
                           
                              {
                              
                                 
                                    A
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    A
                                 
                                 
                                    k
                                 
                              
                              }
                              ∈
                              C
                           
                         into a couple of nodes {v
                        
                           j
                        ,
                        v
                        
                           k
                        }∈
                        V such that there is an edge e
                        
                           j,
                           k
                        
                        ∈
                        E if and only if A
                        
                           j
                         is a direct subset of A
                        
                           k
                        , then the graph defined by the nodes in V connected by the edges in E is a tree.
                           Theorem 13
                           
                              Let 
                              
                                 
                                    C
                                 
                               
                              be an INS-C, V be a set of nodes and E be a set of edges where 
                              
                                 
                                    ∀
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ∈
                                    V
                                    ,
                                    ∃
                                    !
                                    J
                                    ∈
                                    C
                                    ∧
                                    ∀
                                    
                                       
                                          e
                                       
                                       
                                          j
                                          ,
                                          k
                                       
                                    
                                    ∈
                                    E
                                    ,
                                    ∃
                                    !
                                    J
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    J
                                    ⊆
                                    K
                                 
                              
                              . Then T
                              
                              =
                              
                              (V,
                              
                              E) is a tree.
                           

As discussed in Sections 1 and 3, the 5S model needs to be extended and adapted to the specific case of archives.

The notion of descriptive metadata specification
                     
                        6
                        In this section, we use italics to highlight definitions taken from the 5S model.
                     
                     
                        6
                      (Definition 12 Gonçalves, Fox, et al., 2004[p. 292]) is suitable either for representing, for each archival division, a descriptive metadata – e.g. a metadata describing a series, a sub-fonds, or an archival unit – or for representing the archive as a whole, as in the case of EAD.

When it comes to the definition of metadata catalog (Definition 18 Gonçalves, Fox, et al., 2004[p. 295]), there is no means to impose a structure over the descriptive metadata in the catalog. Therefore, if you use separate descriptive metadata specifications for each archival division, as in the former case, this would prevent the possibility of expressing the relationships between these archival divisions, i.e. you would lose the possibility of retaining the archival bond. This means that an archive cannot be properly modeled throughout the 5S model without losing one of its main properties.

Moreover, in a metadata catalog, there is no means to associate (sub-) parts of the descriptive metadata specifications to the digital objects (Definition 16 Gonçalves, Fox, et al., 2004[p. 294]) that they describe, but you can only associate a whole descriptive metadata to a whole digital object.

Therefore, if you represent an archive as a whole with a single descriptive metadata specification, as in the latter case, it would not be possible to associate (sub-) parts of that descriptive metadata to the different digital objects corresponding to the various archival divisions; this does not allow the definition of compound digital objects and it is a barrier towards the adoption of the LOD paradigm in the archival context as we discuss in Section 8. Furthermore, this strongly limits the interoperability between digital archives and the possibility of sharing archival metadata with variable granularity.

Our extension to the 5S model is thus organized as follows:
                        
                           •
                           using the notion of structure (Definition 2 Gonçalves, Fox, et al., 2004[p. 288]), we introduce the notion of NESTOR structure, as a structure that complies with the constraints of NS-M or INS-M;

using the notion of metadata catalog, we introduce the notion of NESTOR metadata catalog, as a metadata catalog that exploits a NESTOR structure to retain the archival bonds;

using the notion of digital library (Definition 24 Gonçalves, Fox, et al., 2004 [p. 299]), we introduce the notion of digital archive, as a digital library where at least one of the metadata catalogs is a NESTOR metadata catalog.

Let 
                              
                                 C
                              
                            be a Nested Set Collection (NS-C) on a set A. A NS-M structure (
                           A
                           ) is a structure (NS−G, L, 
                           
                              
                                 F
                              
                           ), where L is a set of label values, 
                              
                                 F
                              
                            is a labeling function, and NS−G
                           =(V,
                           E) is a directed graph where 
                              
                                 ∀
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 V
                                 ,
                                 ∃
                                 !
                                 J
                                 ∈
                                 C
                                 ∧
                                 ∀
                                 
                                    
                                       e
                                    
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                                 ∈
                                 E
                                 ,
                                 ∃
                                 !
                                 J
                                 ,
                                 K
                                 ∈
                                 C
                                 |
                                 K
                                 ⊆
                                 J
                              
                           .

Let 
                              
                                 C
                              
                            be an Inverse Nested Set Collection (INS-C) on a set A. An INS-M structure (
                           A
                           ) is a structure (INS−G, L, 
                           
                              
                                 F
                              
                           ), where L is a set of label values, 
                              
                                 F
                              
                            is a labeling function, and INS−G
                           =(V,
                           E) is a directed graph where 
                              
                                 ∀
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 V
                                 ,
                                 ∃
                                 !
                                 J
                                 ∈
                                 C
                                 ∧
                                 ∀
                                 
                                    
                                       e
                                    
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                                 ∈
                                 E
                                 ,
                                 ∃
                                 !
                                 J
                                 ,
                                 K
                                 ∈
                                 C
                                 |
                                 J
                                 ⊆
                                 K
                              
                           .


                     Definition 5 applies Definition 1 and Theorem 11 to the definition of structure in the 5S model, ensuring that the resulting structure complies with the NS-M. Note that the set of label values L and the labeling function 
                        
                           F
                        
                      are not strictly needed for the NS-M, but they can be useful in the context of the 5S and this feature, in turn, may extend the NS-M with semantic possibilities. Similarly, Definition 6 applies Definition 2 and Theorem 13.
                        Definition 7
                        Given a set A, a NESTOR structure (
                           A
                           ) is either a NS-M structure (A) or an INS-M structure (A).

The definition of metadata catalog in the 5S model can be expressed as follows. Let H be a set of handles to digital objects and M a set of descriptive metadata specifications, then a metadata catalog is a function DM:H
                     ×2
                        M
                     .
                        Definition 8
                        Let H be a set of handles to digital objects and M a set of descriptive metadata specifications, a metadata catalog DM is a NESTOR metadata catalog if:
                              
                                 (6.1)
                                 
                                    ∀
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    ∈
                                    H
                                    |
                                    ∃
                                    
                                       
                                          M
                                       
                                       
                                          i
                                       
                                    
                                    ∈
                                    
                                       
                                          2
                                       
                                       
                                          M
                                       
                                    
                                    ∧
                                    DM
                                    (
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          M
                                       
                                       
                                          i
                                       
                                    
                                    ⇒
                                    |
                                    
                                       
                                          M
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    =
                                    1
                                 
                              
                           
                           
                              
                                 (6.2)
                                 
                                    ∃
                                    NESTOR
                                    
                                    structure
                                    (
                                    M
                                    )
                                 
                              
                           
                        

Condition (6.1) imposes that, if it exists, there is only one descriptive metadata specification for a given digital object because, in archival practice, every single metadata describes a unique archival division, being it a level in the archive or a digital object (International Council on Archives, 1999). Condition (6.2) ensures that the relationships between the different archival divisions are compliant with the descriptive metadata specifications in M.
                        Definition 9
                        A digital archive 
                           
                              
                                 (
                                 R
                                 ,
                                 DM
                                 ,
                                 Serv
                                 ,
                                 Soc
                                 )
                              
                            is a digital library where
                              
                                 •
                                 
                                    
                                       
                                          R
                                       
                                     is a repository;

at least one of the metadata catalogs in the set of metadata catalogs DM is a NESTOR metadata catalog;


                                    Serv is a set of services containing at least services for indexing, searching, and browsing;


                                    Soc is a society.


                     Definition 9 extends the definition of digital library in the 5S model requiring that at least one of the metadata catalogs is a NESTOR one, i.e. there exists at least one metadata catalog capable of retaining the archival bonds. This definition has several consequences. Firstly, more than one NESTOR metadata catalog can be present in the same digital archive, thus making it possible to express different archival descriptions over the same set of digital objects. This extends the current practice in which a system for managing an archive is usually capable of managing only one description of the archive, thus giving only one point-of-view on the material held (Light and Hyry, 2002; Discovery et al., 2007; Kaplan et al., 2011). Secondly, you can mix NESTOR and non-NESTOR metadata catalogs which allows for the seamless integration of different visions of the managed digital objects within the same digital archive. This opens up the possibility of exploiting the whole breadth of methodologies and tools available in the digital library field with archives.

Let us consider the sample archive shown in Fig. 13
                         where there are four archival divisions (i.e. a fonds, two series, and a unit) each one containing one or more digital objects representing the content of that archival division. In particular, the archival unit contains two digital objects (for instance, they could be the digitalization of two pages of a letter); as observed in Section 3.1, EAD cannot natively handle this case, whereas with NESTOR this is straightforward as we show in the following.

According to Definition 9, to model this digital archive throughout the extended 5S we need to define a repository 
                           
                              R
                           
                        , a NESTOR metadata catalog DM
                        
                           C
                        , a set of services Serv, and a society Soc. The 5S defines a repository (Definition 19 Gonçalves, Fox, et al., 2004[p. 295]) as a tuple 
                           
                              (
                              R
                              ,
                              get
                              ,
                              store
                              ,
                              del
                              )
                           
                         where 
                           
                              R
                              ⊂
                              
                                 
                                    2
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          do
                                       
                                    
                                 
                              
                           
                         and C
                        
                           do
                         is the considered collection of digital objects; in this example C
                        
                           do
                        
                        ={do
                        
                           A
                        ,
                        do
                        
                           B
                        ,
                        do
                        
                           C
                        ,
                        do
                        
                           D1,
                        do
                        
                           D2}.

A NESTOR metadata catalog 
                           
                              
                                 
                                    DM
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          do
                                       
                                    
                                 
                              
                           
                         is a set of pairs associating a handle (i.e. h
                        
                           i
                        
                        ∈
                        H) to a descriptive metadata specification (i.e. md
                        
                           i
                        ) and for which a NESTOR structure exists. So, 
                           
                              
                                 
                                    DM
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          do
                                       
                                    
                                 
                              
                              =
                              {
                              (
                              
                                 
                                    h
                                 
                                 
                                    A
                                 
                              
                              ,
                              {
                              
                                 
                                    md
                                 
                                 
                                    A
                                 
                              
                              }
                              )
                              ,
                              (
                              
                                 
                                    h
                                 
                                 
                                    B
                                 
                              
                              ,
                              {
                              
                                 
                                    md
                                 
                                 
                                    B
                                 
                              
                              }
                              )
                           
                        , (h
                        
                           C
                        , {md
                        
                           C
                        }), (h
                        
                           D1,{md
                        
                           D
                        }), (h
                        
                           D2,{md
                        
                           D
                        })}. Now, we need to build a NESTOR structure over this metadata catalog; as defined in Definition 7, a NESTOR structure can be either a NS-M structure or an INS-M structure. In this example we present only a NS-M structure because the INS-M structure can be derived following the same procedure. For the archive in Fig. 13 a NS-M structure is defined from the intensional point-of-view as 
                           
                              C
                              =
                              {
                              A
                              ,
                              B
                              ,
                              C
                              ,
                              D
                              }
                           
                         where B 
                        ⊆
                        A, C
                        ⊆
                        A, D
                        ⊆
                        C, C
                        ⊈
                        B, and B
                        ⊈
                        C; from the extensional point-of-view it is defined as A 
                        ={md
                        
                           A
                        ,
                        md
                        
                           B
                        ,
                        md
                        
                           C
                        ,
                        md
                        
                           D
                        },
                        B
                        ={md
                        
                           B
                        },
                        C
                        ={md
                        
                           C
                        ,
                        md
                        
                           D
                        },
                        D
                        = {md
                        
                           D
                        }. In this case we defined the NS-M structure in a set-based fashion, but by employing Theorem 11 it can be defined in a graph-based fashion (i.e. thus obtaining the graph NS-G) mapping the NS-C into a tree. A NS-M Structure also requires a set L of labels and a function 
                           
                              F
                           
                         mapping from the NS-G to L; so, 
                           
                              L
                              =
                              {
                              fonds
                              ,
                              
                              series
                              ,
                              
                              unit
                              }
                              ,
                              F
                              (
                              A
                              )
                              =
                              {
                              fonds
                              }
                              ,
                              F
                              (
                              B
                              )
                              =
                              {
                              series
                              }
                              ,
                              F
                              (
                              C
                              )
                              =
                              {
                              series
                              }
                           
                        , and 
                           
                              F
                              (
                              D
                              )
                              =
                              {
                              unit
                              }
                           
                        . Note that in this case, each of the presented descriptive metadata specifications (i.e. md
                        
                           A
                        , …,md
                        
                           D
                        ) describes one or more digital objects. Referring back to the archival state-of-the-art, each metadata could be seen as part of the EAD metadata standard; for instance, md
                        
                           A
                         describes a fonds, thus it can be represented by the c1 component in EAD – i.e. 〈c1 level
                        
                        =
                        
                        fonds〉.

To complete the definition of the digital archive we need to specify the set of services as they are defined by the 5S (Definition 7 Gonçalves, Fox, et al., 2004[p. 290]); for an archive a possible set of services can be Serv
                        ={browse,
                        
                        search, 
                        
                        describe, 
                        
                        update, store} which allows users to browse the archive, search for a specific piece of information, describe a new archival resource and update the existing resources. The users of the digital archives are defined by the 5S concept of society (Definition 10 Gonçalves, Fox, et al., 2004[p. 292]), which for an archive can be instantiated as Soc ={archivist,
                        student,
                        general public, historian}. In Fig. 14
                         we give a graphical representation of the sample archive of Fig. 13 represented via the extended 5S Model.

The extension of the 5S Model via NESTOR represents an actual bridge between these two formal models which allows for a realization of an integrated and inteoroperable environment for LAM. In particular, this explicit connection allows archives to live and cooperate with other methodologies initially not built for archives paving the road for an actual sharing of functionalities in the LAM context.

A meaningful example is OAI-PMH which is formally defined in the context of the 5S and can now be employed by archives without changing its internal functioning and broadening its functionalities (see Section 7). This theoretical framework is also employed for exposing archives through the LOD paradigm instantiated by OAI-ORE 8. Lastly, the very methodology adopted for extending the 5S model can be adapted for connecting NESTOR to the FAST formal model in order to enrich archives by means of collaboration tools such as digital annotations as we show in Section 9.

Modeling digital archives through the extended 5S model opens-up new ways of representing and handling archival resources. A relevant advancement resides in the possibility of adopting widely-used digital library technologies within archives without changing their inner functioning or modifying them while at the same time retaining all the archival fundamental characteristics – e.g. the context of resources and the archival bond.

The OAI-PMH
                        7
                        
                           http://www.openarchives.org/pmh/.
                     
                     
                        7
                      is the de facto standard for metadata exchange in digital libraries (Bell and Lewis, 2006; Foulonneau et al., 2005; Hagedorn, 2003; Lagoze, Van De Sompel, Nelson, et al., 2008; Shreeves et al., 2003) and it has also been modeled by the 5S model to allow for “the specification and automatic generation of digital library applications” (Gonçalves, Fox, et al., 2004).

OAI-PMH is open from an architectural point-of-view and a low-barrier mechanism for repository interoperability. It is based on Web standards such as HyperText Transfer Protocol (HTTP) (Fielding et al., 1999) and XML, and on two main components, Data Providers and Service Providers, where the former are repositories that export records in response to requests from a software service called harvester and the latter are those services that harvest records from Data Providers and provide added-value services built on top of the aggregated harvested metadata.

The protocol defines a harvesting procedure called selective harvesting which is of interest for our purposes. Selective harvesting is based on the concept of OAI-set, which enables logical data partitioning by defining groups of records (i.e. OAI-records), and permits the harvesting only of records owned by a specified OAI-set. An OAI-set is identified by a setSpec which is a mandatory and unique handle for a set within the repository. OAI-set organization may be flat or hierarchical, where hierarchy is expressed in the setSpec field by the use of a colon [:] separated list indicating the path from the root of the set hierarchy to the respective node. For example, if we define an OAI-set the setSpec of which is “A”, its sub-set “B” would have “A:B” as setSpec. In this case B is seen by the protocol as a proper sub-set of A, that is B ⊂ A. Harvesting from a set which has sub-sets will cause the repository to return metadata in the specified set and recursively to return metadata from all the sub-sets. In our example, if we harvest set A, we also obtain the items in sub-set B (Van de Sompel et al., 2002).

OAI-PMH is formally described by means of the 5S model. Data and Service providers are represented as (electronic) Societies; the communications between the Data and Service providers are Streams, whereas the sets, metadata and schemas are Structures (Gonçalves, Fox, et al., 2004[p. 283]).

When it comes to archives, as discussed in Section 3, EAD is the reference standard to be considered. It represents an archive as a monolith and every description is embedded in the archival structure (see Fig. 4). This means that content and structure are interlinked in the same XML file and they cannot be handled separately.

Several state-of-the-art mapping initiatives have tackled this problem; for instance, (Carini and Shepherd, 2004) described the possibility of mapping Machine Readable Cataloging (MARC) metadata into EAD but not vice versa because MARC does not allow for retaining the archival structure like EAD does. The problem of retaining the archival structure and at the same time being able to exchange metadata with variable granularity also affects many other mapping initiatives. Indeed, a common solution for exchanging archival metadata in distributed environments is to map EAD into a collection of lightweight metadata – i.e. Dublin Core (DC) metadata – that can be exchanged and accessed with a variable granularity (Prom, 2003; Prom and Habing, 2002; Ferros et al., 2008; Bountouri and Manolis, 2009). The main problem with these solutions is that the DC metadata cannot retain the archival structure by themselves. Instead they have to be related by means of several links to the EAD structure, thus they are not independent from the original EAD file. Several proposals solve the mapping problem from the content point-of-view, but they do not provide a way to retain the archival structure without referring to the original EAD file or to a relational database which is, by its nature, not easibly shareable with variable granularity while retaining the archival context (Combs et al., 2010).

There are services providing support for sharing archival metadata, such as the OCLCs ArchiveGrid,
                        8
                        
                           http://http://archivegrid.org/.
                     
                     
                        8
                      where “EAD-encoded findings aids are harvested by agreement between institutions and the ArchiveGrid service, and aggregated together with HTML-encoded inventories and collection-level descriptions” (Riley and Shepherd, 2009). The main criticism of these approaches is that they do not support the wide distribution of data “that is essential for archives to participate fully in a constantly changing information environment” (Riley and Shepherd, 2009) and that they do not provide for variable granularity access and exchange of them.

Other general-purpose digital library systems do not take into account the possibility of managing and sharing archival metadata like EAD. For instance, Greenstone
                        9
                        
                           http://www.greenstone.org/.
                     
                     
                        9
                      has an extensible mechanism for handling a wide variety of file formats through document plugins, but the best way to get EAD into Greenstone would be through an EAD-plugin written specifically for this because no mapping service is provided. Fedora Commons
                        10
                        
                           http://www.fedora-commons.org/.
                     
                     
                        10
                      provides support for ingesting and visualizing EAD files, but does not provide any solution for mapping or exchanging these files in a distributed environment.

Modeling an archive through a unique EAD file also limits the information access possibilities. Indeed, the unique entry point to access the information is the root of the file, which means we then have to navigate the hierarchy to access the information of interest. In order to overcome this issue we can define some superstructures to the EAD; for instance, we can settle some predefined entry points by the use of XPointers
                        11
                        
                           http://www.w3.org/TR/xptr-framework/.
                     
                     
                        11
                      pointing to specific elements of the XML or by using predefined paths driving the user through the hierarchical structure.

A direct consequence is that in a distributed environment where it is necessary to exchange data between repositories, we are forced to exchange the archive as a whole. Indeed, we cannot share a specific piece of information – e.g. the descriptions of the documents belonging to a specific series – without extracting it from the EAD file and thereby losing the structural information retained due to the nested tags in the EAD itself (Ferro and Silvello, 2008a; Prom and Habing, 2002; Yako, 2008). This leads to difficulties in fully exploiting OAI-PMH within archives. Indeed, OAI-PMH can be used only to exchange the whole archive as a monolithic unit, thus many of the useful functionalities of the protocol cannot be exploited.

To this end, we exploit NESTOR along with the extended 5S to propose a general solution for modeling archives, thus overcoming the presented limitations and enabling a full exploitation of standard digital library technologies within digital archives.

Let us consider a family of subsets 
                        
                           
                              
                                 F
                              
                              
                                 I
                              
                           
                        
                      on a NS-C indexed by a set I composed of 〈setspec〉 values. Elements of I must ensure that each 〈setspec〉 complies with the NS-M constraints, that is i
                     ∈
                     I
                     ={s
                     0:s
                     1:…:s
                     
                        j
                     } means that it exists an 
                        
                           
                              
                                 F
                              
                              
                                 j
                              
                           
                           ∈
                           
                              
                                 F
                              
                              
                                 I
                              
                           
                        
                      such that F
                     
                        j
                     
                     ⊂…⊂
                     F
                     1
                     ⊂
                     F
                     0. Every 
                        
                           
                              
                                 F
                              
                              
                                 j
                              
                           
                           ∈
                           
                              
                                 F
                              
                              
                                 I
                              
                           
                        
                      is an OAI-set identified by a setspec value in I.

The setspec values for each 
                        
                           
                              
                                 F
                              
                              
                                 k
                              
                           
                           ∈
                           
                              
                                 F
                              
                              
                                 I
                              
                           
                        
                      are built in such a way to maintain the inclusion order between the sets. If an F
                     
                        k
                      has no superset its setspec value is composed only of a single value (〈setspec〉s
                     
                        k
                     〈/setspec〉). Instead if a set F
                     
                        h
                      has supersets, e.g. F
                     
                        a
                      and F
                     
                        b
                      where F
                     
                        b
                      
                     ⊂
                     F
                     
                        a
                     , its setspec value must be the combination of the name of its supersets and itself separated by the colon [:] (e.g. 〈setspec〉s
                     
                        a
                     
                     
                     :
                     
                     s
                     
                        b
                     
                     
                     :
                     
                     s
                     
                        h
                     〈/setspec〉). Furthermore, let OAI
                     ={oai
                     0,…,oai
                     
                        n
                     } be a set of OAI-records, then each oai
                     
                        i
                     
                     ∈
                     F
                     
                        j
                      must contain the setspec of F
                     
                        j
                      in its header.

Let us consider the archive represented by the NS-C in Fig. 1. As we can see in Fig. 15
                     , each set composing this nested set structure is mapped into an OAI-Set with a proper setSpec; the set called “fonds” is mapped into an OAI-set with <setspec>
                     0001
                     </setspec>. This set has two subsets that are mapped into two OAI-sets: <setspec> 
                     0001:
                     
                     
                     0002
                     </setspec> and <setspec>0001
                     
                     :
                     
                     0003
                     </setspec> and so on for the other sets.

We can see that the hierarchical relationships and thus the inclusion order between the sets is maintained by the identifiers of the OAI-sets which are defined as materialized paths from the root to the identified set. Each single archival description is mapped into a metadata belonging to an OAI-set; the membership information is added to the header of these metadata that are seen as OAI-records. In this way each archival description can be encoded by a single metadata without any constraints on its format; indeed, an OAI-set can contain different kinds of metadata formats. With this model we do not impose any conditions on the archival descriptions, thus allowing the possibility of changing the metadata, updating the information or adding a new metadata format without affecting the structure of the archive and without changing the data model.

An important aspect that has to be highlighted is that this implementation also maintains the horizontal dimension of the archival hierarchy – i.e. the order between the subsets of a set. In Fig. 15 we can see that we can talk of the first sub-fonds of the fonds (we named it Sub-fondsA) or of the second series of sub-fonds. This is possible because the OAI setspecs define not only inclusion order between the OAI-sets but also a partial order between the OAI-sets which are common subsets of another OAI-set.

In the same way, we can use the INS-M with OAI-PMH. Let 
                        
                           G
                        
                      be an INS-C indexed by a set J (i.e. a family of subsets 
                        
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                        
                     ) composed by 〈setspec〉 values such that j
                     ∈
                     J
                     ={s
                     0:s
                     1: …:s
                     
                        k
                     } means that 
                        
                           ∃
                           
                              
                                 G
                              
                              
                                 k
                              
                           
                           ∈
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                           =
                           
                              
                                 G
                              
                              
                                 k
                              
                           
                           ⊂
                           …
                           ⊂
                           
                              
                                 G
                              
                              
                                 1
                              
                           
                           ⊂
                           
                              
                                 G
                              
                              
                                 0
                              
                           
                        
                     .

In 
                        
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                        
                     , unlike in 
                        
                           
                              
                                 F
                              
                              
                                 I
                              
                           
                        
                     , the following case may happen: Let 
                        
                           {
                           
                              
                                 G
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 G
                              
                              
                                 k
                              
                           
                           ,
                           
                              
                                 G
                              
                              
                                 w
                              
                           
                           }
                           ∈
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                        
                     , then it is possible that G
                     
                        w
                     
                     ⊂
                     G
                     
                        i
                      and G
                     
                        w
                     
                     ⊂ 
                     G
                     
                        k
                      but either G
                     
                        i
                     
                     ⊈
                     G
                     
                        k
                      and G
                     
                        k
                     
                     ⊈
                     G
                     
                        i
                     . If we consider 
                        
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                        
                      composed only of G
                     
                        i
                     ,
                     G
                     
                        k
                      and G
                     
                        w
                     , the identifier of G
                     
                        i
                      is <setspec>s
                     
                        i
                     </setspec> and the identifier of G
                     
                        k
                      is <setspec>s
                     
                        k
                     </setspec>. Instead, the identifier of G
                     
                        w
                      must be <setspec>s
                     
                        i
                     
                     :
                     s
                     
                        w
                     </setspec> and <setspec>s
                     
                        k
                     
                     :
                     s
                     
                        w
                     </setspec> at the same time; this means that in 
                        
                           
                              
                                 G
                              
                              
                                 J
                              
                           
                        
                      there are two distinct OAI-sets, one identified by <setspec>s
                     
                        i
                     
                     :
                     s
                     
                        w
                     </setspec> and the other identified by <setspec>s
                     
                        k
                     
                     :
                     s
                     
                        w
                     </setspec>. This is due to the fact that the intersection between OAI-sets in OAI-PMH is not set-theoretically defined (Van de Sompel et al., 2003); indeed, the only way to get an intersection of two OAI-sets is by enumerating the records. This means that we can know if an OAI-record belongs to two or more sets just by seeing whether there are two or more 〈setspec〉 entries in the header of the record. In this case the records belonging to G
                     
                        w
                      will contain two 〈setspec〉 entries in their header: <setspec>s
                     
                        i
                     
                     :
                     s
                     
                        w
                     </setspec> and <setspec>s
                     
                        k
                     
                     :
                     s
                     
                        w
                     </setspec>; note that only the <setspec> value is duplicated and not the records themselves.

Let us consider the sample archive represented by the INS-C in Fig. 2. In Fig. 16
                      we can see how the INS-C is mapped into a collection of OAI-sets and OAI-records. We obtain four sets from the common subset – i.e. the fonds of the sample archive – with four different identifiers: “0004:0001”, “0001:0001:0001”, “0002:0001:0001” and “0003:0001:0001”. The sets mapped from the children of the root are defined in the same way. The sets related to the series are identified by “0001”, “0002” and “0003”. We can see that the OAI-records belonging to the “fonds” have four setspecs in the header because the fonds in the INS-M representation is the common subset of four other sets, thus it has four different associated OAI-sets.

These instantiations of the set data models have three main relevant features which are also important aspects defining the flexibility and adaptability of NESTOR: (i) they clearly divide the structural elements (i.e. the sets) from the content elements (i.e. the archival descriptions); (ii) they do not bind the archival descriptions to a unique, fixed and predefined metadata format; and (iii) they exploit digital library technologies, like OAI-PMH, without any change in their internal functioning and without any extension.

We make available a variable granularity access to the structure and to the content of an archive. Indeed, each OAI-set is individually accessible as well as each single metadata. From an OAI-set we can easily reconstruct the relationships with the other OAI-sets by exploiting the setspec organization; from a metadata we can reconstruct the relationships with the other metadata thanks to the membership information contained in their header.

By means of OAI-PMH it is possible to exchange a specific part of the archive while at the same time maintaining the relationships with the other parts of it. The NS-M fosters the reconstruction of the lower levels of a hierarchy; thus, with the pair formed by NS-M and OAI-PMH applied to an archive, if a harvester asks for an OAI-Set representing for instance a sub-fonds, it recursively obtains all the OAI-subsets and items in the subtree rooted in the selected sub-fonds.

The INS-M fosters the reconstruction of the upper levels of a hierarchy which in the archival case often contain contextual information which permit the relationships of archival documents to be inferred with the other documents in the archive and with the production and preservation environment.

The choice between a NS-M or INS-M should be made on the basis of the application context. For instance, often the information required by a user is stored in the external nodes of the archival tree (Shreeves et al., 2003). If we model the archival tree by means of the INS-M, when a harvester requires an external node of the tree it will receive all the archival information contained in the nodes comprised in the path going from the required node up to the root of the archive. This means that a Service Provider can offer a potential user the required information stored in the external node and also all the information stored in its ancestor nodes and thus its context.

Furthermore, the possibility of going from one set data model to the other by means of the defined mapping functions is very useful in the archival context because we can address user requirements in the most effective way without being bound by the properties of a single model of choice.

Currently, archival practice is moving towards the definition of complex relationships between resources of interest as well as the constitution of compound digital objects. To this end archives can take advantage of using the LOD paradigm which eases access to the resources, enhances interoperability by moving the focus from the systems managing the data to the data themselves, and provides additional and flexible representations of archival resources. In the context of digital libraries, the LOD paradigm can be instantiated by means of Open Archives Initiative Object Reuse and Exchange (OAI-ORE) which has a precise focus in the representation and management of compound digital objects.

In this section we define a formal basis that provides a means for: (i) defining OAI-ORE instances consistent with the fundamental archival principles; and, (ii) overcoming the issues affecting state-of-the-art solutions in the field of digital libraries we presented in Section 3.1. In order to exploit OAI-ORE within archives there is the need to model the archival structure – which is the means to retaining all the archival characteristics such as the archival bond – into OAI-ORE. The 5S models OAI-ORE as a Structure (Kozievitch and Torres, 2010); this very model extended via NESTOR allows us to impose conditions on the 5S Structure – i.e. by defining it as a NESTOR Structure (Definition 7) – thus creating OAI-ORE instances according to archival practice.

The OAI-ORE defines a machine-readable and standard mechanism for defining aggregations of resources on the Web. By means of OAI-ORE we can identify a bunch of resources related to each other as a single entity enabling the access and exchange of them at an aggregation level of granularity. The OAI refers to these aggregations as “compound objects”. Compound units are aggregations of distinct information units that form a logical whole when combined. Some examples (Van de Sompel and Lagoze, 2007) of these are a digitized book that is an aggregation of chapters, where each chapter is an aggregation of scanned pages, and a scholarly publication that is an aggregation of text and supporting materials such as datasets, software tools, and video recordings of an experiment; archives can also be seen as aggregations of archival metadata describing archival objects which in turn can have a digital form.

The OAI-ORE data model is based on three main kinds of resources: Aggregation, Aggregated Resources and Resource Map. An Aggregation is defined as a resource representing a logical collection of other resources. An Aggregation is a logical construct and thus it has no representation; it is described by a Resource Map which can be seen as a materialization of the Aggregation. A Resource Map must describe a single Aggregation and must enumerate the constituent Aggregated Resources; a resource is an “Aggregated Resource” in an Aggregation only if it is asserted in a Resource Map. Each resource in the OAI-ORE data model is identified by a URI. The OAI-ORE data model is expressed by the Resource Description Framework (RDF),
                        12
                        
                           http://www.w3.org/RDF/.
                     
                     
                        12
                      so its instances are expressed as RDF graphs. An RDF graph is defined by a set of triples (s,
                     p,
                     o) expressing the relationship defined by a predicate p between a subject s and an object o; s and o may be a URI with an optional fragment identifier, a literal or a blank (having no separate form of identification). Properties p are URI references.
                        13
                        
                           http://www.w3.org/TR/rdf-concepts/.
                     
                     
                        13
                     
                  

In order to explain how an archive can be properly modeled as an instance of the OAI-ORE data model and thus be exposed as LOD, we have to consider that the issues of EAD determined by the lack of distinction between structure and content is emphasized when we take into account the digital objects. A single EAD metadata can directly point-to at most one digital object at the time and to overcome this problem an ad hoc solution which exploits METS as a meta-structure over EAD has been proposed (Sugimoto and van Dongen, 2009) with the limitations we discussed in Section 3 and depicted in Fig. 5.

In the previous section a methodology is described for mapping an EAD file into NESTOR which preserves the full informative power of the metadata. In this way, NESTOR can be used as a model to describe an archive from scratch as well as a mapping component that allows us to manipulate and transform the EAD files while respecting archival principles (FerroSilvello2009b). We exploit this very methodology to establish a direct and formal connection between OAI-ORE and NESTOR. In this use-case we present the mapping towards the NS-M; the mapping towards the INS-M can be derived symmetrically. This methodology allows for exposing EAD files as LOD in the Web; in the literature, to our knowledge, there are only two alternatives to this, but no one considers a mapping towards OAI-ORE. The first is an ontology-based metadata integration which maps EAD into the CIDOC Conceptual Reference Model (CRM) ontology (Stasinopoulou et al., 2007) in order to address heterogeneity between different metadata formats. This methodology does not provide a solution of creating compound digital objects and exposing them as LOD. The second alternative (Casarosa et al., 2013) maps EAD to EDM in order to provide access to archival data from many access points; in this case the problem of relating archival descriptions in EAD with several digital objects and expose them on the Web is not specifically addressed.

In order to exploit OAI-ORE in the context of archives we provide a compact formal definition of the framework that will be exploited for bridging with NESTOR. We indicate with UA
                     ⊂
                     U
                     ={ua
                     1, …,
                     ua
                     
                        k
                     ,…,
                     ua
                     
                        n
                     } the set of URI identifying the Aggregations and with η
                     
                        A
                     :UA
                     →
                     R the restriction of η (η∣
                        A
                     ) to UA; the image of η
                     
                        A
                      is the set of Aggregations A
                     ⊂
                     R
                     ={a
                     1,…,a
                     
                        k
                     ,…, a
                     
                        n
                     }. In the same way, we indicate with URM
                     ⊂
                     U the set of URI identifying the Resource Maps and we define η
                     
                        RM
                     :URM
                     →
                     R to be the restriction η∣
                        RM
                      where RM
                     ⊂
                     R is the set of Resource Maps. Finally, we indicate with UAR
                     ⊂
                     U the set of URI identifying the Aggregated Resources.
                        14
                        Please note that the definition of the sets UA,
                           URM, UAR is a mere convention to indicate URIs pointing to different kinds of resources in OAI-ORE and they do not stand for different kinds of URIs (Van de Sompel and Lagoze, 2007).
                     
                     
                        14
                      We define η
                     
                        AR
                     :UAR
                     →
                     R to be the restriction η∣
                        AR
                      where AR
                     ⊂
                     R is the set of Aggregated Resources. Every rm
                     
                        i
                     
                     ∈
                     RM must describe one and only one a
                     
                        j
                     
                     ∈
                     A, but a
                     
                        j
                      may be described by more than one Resource Map; thus, we indicate with φ
                     
                        RMA
                     : RM
                     →
                     A a function which maps a Resource Map to the Aggregation it materializes. Every ar
                     
                        i
                     
                     ∈
                     AR may be aggregated by more than one a
                     
                        j
                     
                     ∈
                     A.

OAI-ORE comes with other two important features: Proxy and Nested Aggregations. A Proxy is a resource that indicates an Aggregated Resource in the context of a specific Aggregation and it is associated with an Aggregated Resource via an assertion in a Resource Map describing the Aggregation that is the context of the Proxy (Lagoze et al., 2008b). We indicate with UP
                     ⊂
                     U
                     ={up
                     1, …,up
                     
                        k
                     ,…,up
                     
                        z
                     } the set of URI identifying the Proxies. We define η
                     
                        P
                     :UP
                     →
                     R to be the restriction η∣
                        P
                      where P
                     ⊂
                     R is the set of Proxies. Proxies allow us to define relationships between Aggregated Resources. We indicate with φ
                     
                        PAR
                     :P
                     →
                     AR a function which maps a Proxy to the Aggregated Resource for which it is a Proxy and with φ
                     
                        PA
                     :P
                     →
                     A a function which maps a Proxy to the Aggregation in which it is a Proxy.

The Nested Aggregations feature enables the definition of Aggregations of Aggregations; this is consistent in the OAI-ORE data model because an Aggregation is a Resource which can also be seen as an Aggregated Resource of another Aggregation. Thanks to this feature, an order exists between Aggregations, call it ≺
                        a
                     ; more formally: for all a
                     
                        i
                     ,
                     a
                     
                        j
                     
                     ∈
                     A we say that a
                     
                        i
                     
                     ≺
                     
                        a
                     
                     a
                     
                        j
                      if and only if the Aggregation a
                     
                        i
                      is aggregated by a
                     
                        j
                     . It is important to note that ≺
                        a
                      cannot define any orders between any OAI-ORE entities other than Aggregations; in fact, to define an order between Aggregated Resources we must use Proxies. Now, we can summarize the concept of the OAI-ORE Data Model thanks to the next definition.
                        Definition 10
                        Let 
                              
                                 E
                                 =
                                 {
                                 A
                                 ,
                                 R
                                 ,
                                 AR
                                 ,
                                 P
                                 ,
                                 UA
                                 ,
                                 UR
                                 ,
                                 UAR
                                 ,
                                 UP
                                 }
                              
                            be the collection of OAI-ORE entity sets and Φ
                           ={η
                           
                              A
                           ,
                           η
                           
                              RM
                           ,
                           η
                           
                              AR
                           , η
                           
                              P
                           ,
                           φ
                           
                              RMA
                           ,
                           φ
                           
                              PAR
                           ,
                           φ
                           
                              PA
                           } be the set of OAI-ORE functions. We define 
                              
                                 O
                                 =
                                 〈
                                 E
                                 ,
                                 Φ
                                 〉
                              
                            to be an OAI-ORE Data Model.

In order to model an archive by means of OAI-ORE we need a methodology to identify the archival resources and to express the relationships between them. We have seen that we can represent a tree by means of the NS-M and that an archive can be modeled by means of a tree as well as by a NS-C. Therefore, we can model an archive throughout OAI-ORE by starting from its representation in the NS-M. We need to define a mapping between a NS-C 
                        
                           C
                        
                      and an OAI-ORE model 
                        
                           O
                           =
                           〈
                           E
                           ,
                           Φ
                           〉
                        
                     ; in order to do this we have to take into account the two main entities of NESTOR which are: the sets and the elements (i.e. resources) belonging to them.

The intuitive idea is that every set 
                        
                           H
                           ∈
                           C
                        
                      becomes an Aggregation a
                     
                        h
                     
                     ∈
                     A and consequently, every resource r
                     
                        t
                     
                     ∈
                     R belonging to H becomes an aggregated resource ar
                     
                        t
                     
                     ∈
                     AR aggregated by a
                     
                        h
                     . Furthermore, for every pair of sets 
                        
                           {
                           H
                           ,
                           K
                           }
                           ∈
                           C
                           
                           such
                           
                           that
                           
                           H
                           ⊆
                           K
                        
                     , it is possible to create a pair of aggregations {a
                     
                        h
                     ,
                     a
                     
                        k
                     }∈
                     A such that a
                     
                        h
                      
                     ≺
                     
                        a
                     
                     a
                     
                        k
                      where ≺
                        a
                      is the order relation defined above.

Every set in a collection of subsets can be mapped into an Aggregation in the OAI-ORE model; the inclusion order between the sets is maintained by the relation defined between the Nested Aggregations of OAI-ORE. Then, by means of the function φ
                     
                        RMA
                      a Resource Map is associated with each Aggregation. Every resource belonging to a set H in the NS-C is mapped into Aggregated Resources belonging to the Aggregation mapped from H. Therefore, we can map a NS-C into a corresponding OAI-ORE model and be sure that the hierarchical dependencies are properly retained. This means that if we model an archive through a NS-C, then we define an OAI-ORE instance of the archive which retains the original hierarchical structure of the archive and the archival bond of archival resources.

The presented formal basis guarantees that an archive modeled by means of the NS-M can be mapped into an instance of the OAI-ORE Data Model, thus retaining the fundamental archival hierarchy. In this section we show how we can define different kinds of relationships between the resources; furthermore, we show how proper use of Proxies can preserve the order between the resources within the same archival division. It is worthwhile providing a concrete example of how this formal basis can be applied to a sample archive modeled by the NS-M by describing the mapping methodology step-by-step with the help of some mapping tables.

Let us take into account the sample archive represented in Fig. 17
                     ; this archive is composed of five archival divisions – i.e. one fonds, two sub-fonds and two series – each containing metadata and digital objects. In NS-M these divisions are represented by means of five sets and the hierarchical relationships are retained by means of the inclusion dependencies between the sets. In Table A we can see the mapping of the sets into the OAI-ORE Aggregations and in Table B we can see how the inclusion dependencies are mapped into Nested Aggregations. These two mappings show us how to represent the structure of a sample archive in an instance of the OAI-ORE data model.


                     
                        
                           
                        
                     
                  

Each set in the NS-C contains several elements which are metadata or digital objects. For instance, the set “fonds” contains two elements: a metadata (i.e m
                     1) and an associated digital object (i.e. do
                     1). The set “sub-fondsA” contains only a metadata (i.e. m
                     2), the set “seriesA” contains a metadata (i.e m
                     3) and an associated digital object (i.e. do
                     3), and so on. In Table C we can see how the elements are mapped into Aggregated Resources and in Table D how the Aggregated Resources are associated with the correct Aggregations. We can see that an element belonging to a set – e.g. m
                     2
                     ∈
                     subfondsA – is mapped into an Aggregated Resource – e.g. ar
                     
                        c
                      – aggregated by the Aggregation a
                     2 which corresponds to the set subfondsA. Table E and Table F show how we can use Proxies to associate the metadata with the digital objects they describe. OAI-ORE allows us to define different kinds of relationships between the Aggregated Resources using the Proxies. For instance, in Table F we can see that two Proxies p
                     
                        a
                      and p
                     
                        b
                      associated to ar
                     
                        a
                      and ar
                     
                        b
                      respectively are related by the relationship “isMetadataOf”; thus, throughout p
                     
                        a
                      and p
                     
                        b
                      we can say that the Aggregated Resource ar
                     
                        a
                      is a metadata describing the digital object ar
                     
                        b
                     . The relationships between the Aggregated Resources can reflect the order between the archival descriptions within a common archival division; in this way, we are sure that the OAI-ORE representation of the archive respects the original order principle. We can see that within this methodology it is quite simple to extend the range of the relationships connecting the Aggregated Resources and to define in this way new semantic associations between the archival resources.

In Fig. 18
                      we can see the RDF graph representing the OAI-ORE instance of the sample archive in Fig. 17. In this figure we represent the Aggregations, the Aggregated Resources and the Proxies associated to a
                     1; for readability we have omitted showing the other Proxies and the Resource Maps. This methodology makes it possible to model and describe archives from scratch by means of OAI-ORE while allowing archivists to easily express relationships between archival metadata and digital objects. Archival principles are preserved and still have primary importance for understanding archival resources; at the same time, OAI-ORE offers the possibility of defining new relationships between the resources, thus enabling the definition of new services over archives. This methodology provides a means to define archival compound objects that can be shared with the systems which already employ OAI-ORE and that can be exposed as LOD on the Web. Lastly, in Fig. 18 we can see an alternative to the state-of-the-art solutions depicted in Fig. 5 which overcome the presented issues and at the same time add more flexibility and expressive power to archives.

Furthermore, this methodology and the described formal basis guarantee the backward compatibility with other archival descriptive standards; for instance, a methodology to map the archival descriptions modeled by OAI-ORE into EAD can be easily defined. Indeed, we know how to map EAD into a NS-C and a NS-C into an instance of the OAI-ORE data model. In the same way, we can map the archival descriptions modeled by OAI-ORE into an EAD file by reversing the presented methodology.
                        15
                        Note that backward compatibility can be limited by the fact that the EAD expressive power is inferior to that of OAI-ORE.
                     
                     
                        15
                      In this context, the formal basis of NESTOR acts as an interoperability layer between EAD and OAI-ORE and guarantees the possibility of going from one model to the other.

Archives need to take into account the end-user who is going to consult them and who does not have the competencies or experience to properly interpret archival data or use finding aids. Annotations are a valuable and well-known means for collaboration which can help in socializing the archives by opening them up to the general public and by helping the interpretation of information (Agosti, Bonfiglio-Dosio, et al., 2007; Agosti and Ferro, 2003; Agosti et al., 2004). This is also in line with the current tendencies in Web 2.0, where available resources can be augmented with user-generated content which then provides alternative access points for searching and browsing resources.

The goal of this use case is to show how NESTOR can be employed as a bridge between archival theory and practice and the model used for annotations. NESTOR is exploited both for the theoretical basis it defines and for the alternative representations of archives it provides. Indeed, from the representation of the INS-M it is possible to generate original visualizations of archival data enriched with annotations and to exploit this to enrich user experience, e.g. when eliminating the results of a search involving annotations and archival data.

To this purpose we rely on NESTOR and the Flexible Annotation Semantic Tool (FAST) annotation model (Agosti and Ferro, 2008) for handling archival and annotation aspects and for showing how annotations can be enclosed in the “NESTOR view” of archives. The formal integration between NESTOR and FAST is described in Ferro and Silvello (2010) and it is not presented here, because on the one hand, it requires a deep understanding of the FAST model which is out of the scope of this article, and on the other hand, it follows a formal methodology close to the one presented in the previous section for relating NESTOR and OAI-ORE.

Beyond formally modeling what an annotation is, FAST introduces a full range of operators that allow users to either search and retrieve annotations on the basis of their content or to search and retrieve annotated resources on the basis of the annotations related to them (Agosti and Ferro, 2005; Agosti and Ferro, 2006; Ferro, 2009). To this end, FAST makes use of the extended boolean model (Salton et al., 1983) to allow for mixing exact and best match queries and explicitly takes into consideration the hypertext existing between annotations and annotated resources to modify the scores and rank annotations and/or annotated resources according to the paths connecting them. All the search operators and modifiers are exposed via a simple query language based on Contextual Query Language (CQL) (OASIS Search Web Services Technical Committee, 2012), developed and maintained by the Library of Congress in the context of the Z39.50 Next Generation (ZING) project and suitable to be embedded in HTTP requests and Web services.

For example, it is possible to express queries like the following one.
                        
                           
                              
                              
                                 
                                    
                                       fast.annotation.text =/thread
                                       
                                       =
                                       
                                       halfThread ‘‘illuminated manuscript"
                                    
                                 
                                 
                                    
                                       and/match
                                       
                                       =
                                       
                                       looseMatch
                                    
                                 
                                 
                                    
                                       fast.annotation.author.identifier =/thread
                                       
                                       =
                                       
                                       halfThread ferro
                                    
                                 
                              
                           
                        
                     which searches for annotations about illuminated manuscripts and authored by the user ferro, where the former is a best match (search engine-like) search clause while the latter is an exact match (database-like) search clause. The two clauses are mixed with a relaxed boolean operator (looseMatch modifier), meaning that annotations matching only one of them will be retrieved even if ranked lower than annotations matching both of them. Moreover, not only the content of the annotation is taken into account, but also the hypertext of annotations (halfThread modifier) contributes to the final result list, meaning that if, for example, an annotation a
                     
                        j
                      about illuminated manuscripts annotates another annotation a
                     
                        i
                     , also a
                     
                        i
                      will be part of the final result list, even if ranked lower. Similar mechanisms apply to search and retrieve annotated resources on the basis of their annotations.

Therefore, here we focus on how to exploit FAST and NESTOR to enhance the user experience when searching for annotations and annotated archival data and to lay the ground for modeling and studying the alternatives we can exploit to better access and visualize annotated archival resources.


                     Fig. 19
                      presents three possible scenarios; in this figure an archive is represented as a document tree where the nodes are named “d
                     1,
                     d
                     2, …” for convenience; for the same reasons annotations are indicated as “a
                     1, a
                     2,…”. In the first scenario we consider an archival tree where the node d
                     2, annotated by a
                     1, is the root of an annotation tree composed of three annotations. The second scenario shows that a
                     3, which is part of an annotation tree annotating d
                     2, is connected to a second archive by means of a “relate-to” link.
                        16
                        A “relate-to” link is different from the other links because it relates two different archival or annotation trees (Agosti and Ferro, 2008).
                     
                     
                        16
                      In the third scenario, we can see two archives connected by a relate-to link defined between two annotations – i.e. a relate-to link between a
                     3 and a
                     5.

Suppose now the user has issued a query which retrieves the following resources: a
                     2, d
                     9, and a
                     5. How can we better serve these results to the user in the three above scenarios in order to make him easily grasp their overall context? We present three possible scenarios showing how annotation trees can be attached to an archive and then we show how they can be modeled through the INS-M and represented by means of the DocBall, as shown in Fig. 20
                     .

In the first scenario we need to join an “archival DocBall” representing the archive and an “annotation DocBall” representing the annotation tree originally attached to node d
                     2 of the archive – see Fig. 19a. The resulting DocBall is shown in Fig. 20a, where a
                     1 is a superset of d
                     2. The second scenario presents the same annotated archive we have seen in the first scenario enriched by the relationship of annotation a
                     3 with the node d
                     9 of a second archive. In this case, we use a DocBall representing the first archive within its annotations – call it “DocBall A” (see Fig. 20a) – and a DocBall representing the second archive – call it “DocBall B”. In order to join these two DocBalls connected by annotation a
                     3, we add the inner sector of DocBall B – i.e. d
                     8 – to DocBall A as a superset of a
                     3. The resulting DocBall (see Fig. 20b) provides us with an integrated view of the two archives connected by the annotation tree rooted in a
                     1. The third scenario enhances this idea; indeed, in this case both “DocBall A” and “DocBall B” represent annotated archives that have to be joined together. We follow the methodology presented in scenario 2 by taking the inner sector of DocBall B – i.e. d
                     8 which represents the root of the second archive – and adding it to DocBall A as a superset of the annotation – in this case a
                     3 – which relates the two archives to each other. The general methodology of joining two DocBall can be summarized as follows; let D
                     
                        A
                      and D
                     
                        B
                      be two DocBall, where section s
                     
                        A
                      of D
                     
                        A
                      is related to section s
                     
                        B
                      of D
                     
                        B
                     . To join D
                     
                        A
                      with D
                     
                        B
                     , the inner section of D
                     
                        B
                      must be added to D
                     
                        A
                      as a superset of s
                     
                        A
                     .

We can use the alternative representations of Fig. 19 to devise different strategies to represent search results involving annotations and archival data in order to understand what is the most suitable according to the user needs, various user categories, and the performed tasks. In this context, the two models, NESTOR and FAST, provide a sound basis which ensure the presentation of alternative and equivalent representations to the end user, while at the same time keeping the overall coherence and possibility of passing from one to the other.

For example, Fig. 21
                      shows a possible prototype that can be exploited to compare alternative presentation strategies: (a) it provides a typical ranked list, in a Google-like fashion; (b) it presents a traditional tree-like view of the archival data; and (c) it exploits the DocBall visualization introduced above to give an overall view of the search results.

The DocBall is in the center of the canvas and when we move the pointer over a circular section a tooltip appears showing the content of this section; if we click on a section, the DocBall rotates and the selected section is highlighted. In this figure we selected section d
                     2, the content of which is shown in the right column and the tooltip shows the content of a
                     1. In this way the user can select an archival section, see its content in the right column and view the content of annotations or other archival divisions by means of the tooltip. We can see that archival documents and annotations are represented as circular sectors with different colors in the DocBall. The use of colors may be an effective way of distinguishing between the sectors which are documents and those which are annotations. However, the DocBall could become ineffective if there are many sectors that have to be represented. In this case an expand/compress strategy can be adopted in the same way it is used to show the branches of very large trees.

This use case enables a comprehensive view of archival structure and content together with its annotations; furthermore, it highlights the relationships between different archives and how it is possible to enhance the role of annotations in the archival context and the expertise of archivists in the description as well as in the search phase within archives. Finally, this use case is a first-step in the direction of providing users with alternative interactive means to access archives and it opens the way to further studies toward understanding what the user preferred interaction style is, which visualizations are most suitable for which tasks, and how these visualizations help the user in keeping the overall context of archival data and annotations.

Building foundations and a formal theory for digital libraries is a longstanding issue in the field, dating back to the mid-1960s (Licklider, 1965), and this challenge has been accepted only very recently, for example, by the 5S model (Gonçalves, Fox, et al., 2004) and the DELOS Reference model (Candela et al, 2007). Archives are a fundamental constituent of our cultural heritage and digital libraries are the natural choice for managing and providing access to their assets.

Nevertheless, the foundational models of digital libraries have been built around the most general concepts but without specifically dealing with the peculiar features of archives. This hampers the possibility of fully exploiting and applying them for defining a theory for digital archives, intended as digital libraries with specific characteristics that fit in the archival domain.

We think that the archival domain deserves a formal theory as well and that this theory has to be reconciled with the more general theories for digital libraries in order to provide archives with the full breadth of methodologies and technologies which have been developed over the last two decades in the digital library field.

To this end, we have introduced an original formal model, called NESTOR, which exploits the inclusion relationships among sets as a means of representing the notions of context and hierarchy which are central to archives. Then, we extended the 5S model to introduce the notion of digital archive as a specific case of digital library complying with archival constraints. Finally, we applied this extension to three concrete use cases: (i) “detaching the archives” which is the case of interoperability between digital archives giving a concrete account of how digital library technologies can be disclosed to archives; (ii) “unchaining the archives” which shows how archives modeled with NESTOR can form compound digital objects exposed as LOD in the Web; and, (iii) “socializing the archives” which describe how NESTOR can enhance the role of annotations in archives by helping both archivists and end-users in the description and interpretation of archival resources.

Future work will concern the formal definition of creation, deletion, update, and search operations on digital archives via NESTOR and the study of their properties.

This, in turn, will open up the possibility to further extend the 5S model. Indeed, according to this model, a minimal digital library has to offer indexing, searching and browsing services (Gonçalves, Fox, et al., 2004, p. 299). The formal definition of the query and update operations in NESTOR will thus allow us to precisely describe what these services are in the case of digital archives.

Moreover, the formal definition of the above mentioned operations will allow us to study their computational complexity, thus characterizing their definition with upper bounds for time and space costs. This will also represent a further addition to the 5S model since, not only we will be able to express what minimal digital library services are in the case of digital archives, but we will also be able to characterize them from a performance point of view.

Therefore, we also plan to carry out extensive experimentation to assess the scalability and actual execution times of the proposed operations on real and synthetic datasets, as we have just started to explore (Silvello, 2012). This will then complete the formal modeling and the extension of the 5S model with experimental data.

Finally, merging this modeling effort with other existing formal models, as we did in the case of annotation, will move digital archives to the next generation, making them not only browsing and consulting tools, but also active means where researchers, students, and practitioners can interact with and augment archival content with user-generated contents, tags, and annotations. This will require not only the design and development of services which exploit these joint formal models, but also the carrying out of detailed user studies to understand which solutions are best suited for supporting information access and use tasks of different user categories. Moreover, by relying exposing archives as LOD on the Web, as in the “unchaining the archives” use case, and their connections with annotations, as in the “socializing the archives” use case, it will be possible to readily integrate in digital archives recent activities such as the Open Annotation Model (Sanderson et al., 2013), currently discussed by the World Wide Web Consortium (W3C), which is easily representable by means of the FAST annotation model as well.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to express their deep gratitude to Maristella Agosti for her continued support and contributions to this work which benefited from her precious suggestions and valuable feedback. Sincere thanks are due to Floriana Esposito and Carlo Meghini for their comments on the main ideas of the model. We would like to thank Fausta Bressani and Andreina Rigon of the Cultural Heritage Directorate (Direzione Beni Culturali) of the Italian Veneto Region (Regione del Veneto) and Erilde Terenzoni and Cristina Tommasi of the Archival Supervising Office for the Italian Veneto Region (Soprintendenza Archivistica per il Veneto) of the Ministry of Cultural Heritage.

Last but not least, thanks and appreciation are due to the anonymous reviewers who really helped us in increasing the quality of the paper to make its contributions more exploitable in a multi-disciplinary context.

The work reported has been carried out in the context of an agreement between the Italian Veneto Region
                     17
                     
                        http://www.regione.veneto.it/.
                  
                  
                     17
                   and the University of Padua. The CULTURA
                     18
                     
                        http://www.cultura-strep.eu/.
                  
                  
                     18
                   (Contract No. 269973) and the PROMISE network of excellence
                     19
                     
                        http://www.promise-noe.eu/.
                  
                  
                     19
                   (Contract No. 258191) Projects, as part of the 7th Framework Program of the European Commission, have partially supported the reported work.

This appendix reports the proof of theorems and propositions presented in Section 4.

The following is the proof of Proposition 1 which proves that every set in a NS-C has at most one direct superset.
                           Proof
                           Ab absurdo suppose that 
                                 
                                    ∃
                                    H
                                    ∈
                                    C
                                    
                                    such
                                    
                                    that
                                    
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    >
                                    1
                                    ⇒
                                    ∃
                                    K
                                    ,
                                    L
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    H
                                    ⊆
                                    K
                                    ∧
                                    H
                                    ⊆
                                    L
                                    ∧
                                    L
                                    ⊈
                                    K
                                    ∧
                                    K
                                    ⊈
                                    L
                                    ⇒
                                    K
                                    ∩
                                    L
                                    =
                                    H
                                    ⇒
                                    C
                                 
                               is not a NS-C (condition (4.2) of Definition 1).□

The following is the proof of Corollary 2. This corollary proves that if we consider the collection of supersets of a set in a NS-C (say H), the set with minimum cardinality is the direct superset of H.
                           Proof
                           We know from Proposition 1 that 
                                 
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    ⩽
                                    1
                                 
                              . Then, ab absurdo suppose that 
                                 
                                    ∀
                                    L
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    |
                                    K
                                    |
                                    ⩽
                                    |
                                    L
                                    |
                                 
                               and that 
                                 
                                    ∃
                                    W
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    
                                       
                                          
                                             (
                                             |
                                             W
                                             |
                                             >
                                             |
                                             K
                                             |
                                             )
                                             ∧
                                             (
                                             
                                                
                                                   D
                                                
                                                
                                                   -
                                                
                                             
                                             (
                                             H
                                             )
                                             =
                                             W
                                             )
                                          
                                       
                                    
                                 
                              . This means that H
                              ⊆
                              W
                              ∧
                              H
                              ⊆
                              K and by definition of NS-M W
                              ⊆
                              K
                              ∨
                              K
                              ⊆
                              W. If W
                              ⊆
                              K
                              ⇒∣W∣<∣K∣; if K
                              ⊆
                              W
                              ⇒∣K∣<∣W∣. So if 
                                 
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    =
                                    W
                                    ⇒
                                    |
                                    W
                                    |
                                    <
                                    |
                                    K
                                    |
                                 
                              .□

The following is the proof of Proposition 3 which says that the direct subsets of a set in a NS-M are always disjoints.
                           Proof
                           Ab absurdo suppose that 
                                 
                                    K
                                    ∩
                                    L
                                    
                                    ≠
                                    
                                    ∅
                                    ⇒
                                    K
                                    ∩
                                    L
                                    =
                                    W
                                    
                                    such
                                    
                                    that
                                    
                                    |
                                    W
                                    |
                                    ⩾
                                    1
                                    ∧
                                    W
                                    ⊈
                                    K
                                    ∧
                                    W
                                    ⊈
                                    L
                                    ⇒
                                    C
                                 
                               is not a NS-C.□

The following is the proof of Proposition 4 showing the behavior of union and set difference in the INS-M under specific conditions.
                           Proof
                           
                              Let us prove 
                              
                                 Property 4.5
                              . (⇒). Ab absurdo suppose that 
                                 
                                    (
                                    (
                                    H
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    H
                                    )
                                    )
                                    ⇒
                                    H
                                    ∪
                                    K
                                    =
                                    L
                                    ∈
                                    C
                                 
                              . This means that H
                              ⊆
                              L
                              ∧
                              K
                              ⊆
                              L. Without any loss of generality, let us take into account H
                              ⊆
                              L; in this case 
                                 
                                    ∃
                                    K
                                    ∈
                                    C
                                    |
                                    (
                                    (
                                    H
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    H
                                    )
                                    )
                                 
                               but 
                                 
                                    L
                                    ∩
                                    K
                                    =
                                    K
                                    
                                    ≠
                                    
                                    H
                                    ∩
                                    K
                                    ⇒
                                    C
                                 
                               is not an INS-C.

(⇐). Ab absurdo suppose that 
                                 
                                    H
                                    ∪
                                    K
                                    =
                                    L
                                    
                                    ∉
                                    
                                    C
                                    ⇒
                                    H
                                    ⊆
                                    K
                                    ∨
                                    K
                                    ⊆
                                    H
                                 
                              . 
                                 
                                    H
                                    ⊆
                                    K
                                    ⇒
                                    H
                                    ∪
                                    K
                                    =
                                    K
                                    ∈
                                    C
                                    ∧
                                    K
                                    ⊆
                                    H
                                    ⇒
                                    K
                                    ∪
                                    H
                                    =
                                    H
                                    ∈
                                    C
                                 
                              .


                              Let us prove 
                              
                                 Property 4.6
                              . Ab absurdo suppose that 
                                 
                                    H
                                    ⧹
                                    K
                                    =
                                    L
                                    ∈
                                    C
                                 
                              .

If 
                                 
                                    (
                                    H
                                    ⧹
                                    K
                                    =
                                    L
                                    ∈
                                    C
                                    )
                                    ∧
                                    K
                                    ⊆
                                    H
                                    ⇒
                                    L
                                    ∩
                                    K
                                    =
                                    ∅
                                    ∧
                                    L
                                    ∩
                                    H
                                    =
                                    L
                                    ⇒
                                    (
                                    (
                                    L
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    L
                                    )
                                    )
                                    ⇒
                                    ∃
                                    H
                                    ,
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                    |
                                    K
                                    ⊆
                                    H
                                    ∧
                                    (
                                    (
                                    L
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    L
                                    )
                                    )
                                    ∧
                                    (
                                    K
                                    ∩
                                    L
                                    
                                    ≠
                                    
                                    L
                                    ∩
                                    H
                                    )
                                    ⇒
                                    C
                                 
                               is not an INS-C.

If 
                                 
                                    (
                                    H
                                    ⧹
                                    K
                                    =
                                    L
                                    ∈
                                    C
                                    )
                                    ∧
                                    (
                                    (
                                    H
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    H
                                    )
                                    )
                                    ⇒
                                    L
                                    ⊆
                                    H
                                    ∧
                                    (
                                    (
                                    L
                                    ⊈
                                    K
                                    )
                                    ∧
                                    (
                                    K
                                    ⊈
                                    L
                                    )
                                    )
                                    ⇒
                                    H
                                    ∩
                                    K
                                    
                                    ≠
                                    
                                    ∅
                                    
                                    ≠
                                    
                                    L
                                    ∩
                                    K
                                    =
                                    ∅
                                    ⇒
                                    C
                                 
                               is not an INS-C. □

The following proof shows that the sets in an INS-C verify the properties defined by Proposition 5.
                           Proof
                           Ab absurdo suppose that 
                                 
                                    ∃
                                    H
                                    ∈
                                    C
                                    
                                    such
                                    
                                    that
                                    
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    >
                                    1
                                    ⇒
                                    ∃
                                    K
                                    ,
                                    L
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    K
                                    
                                    ≠
                                    
                                    L
                                    |
                                    L
                                    ⊆
                                    H
                                    ∨
                                    K
                                    ⊆
                                    H
                                 
                              . This means that L
                              ⊈
                              K
                              ∧
                              K 
                              ⊈
                              L because 
                                 
                                    L
                                    ,
                                    K
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                 
                               and L
                              ∩
                              K
                              ≠
                              H
                              ∩
                              L thus 
                                 
                                    C
                                 
                               in not an INS-C because it violates condition (4.4) of Definition 2.□

The following proves Corollary 6 to the preceding proposition and shows that for all 
                           
                              H
                              ∈
                              C
                           
                        , the set with maximum cardinality in the collection of subsets of H is its direct subset.
                           Proof
                           We know from Proposition 5 that 
                                 
                                    |
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    |
                                    ⩽
                                    1
                                 
                              . Then, ab absurdo suppose that 
                                 
                                    ∀
                                    L
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ,
                                    |
                                    K
                                    |
                                    ⩾
                                    |
                                    L
                                    |
                                 
                               and that 
                                 
                                    ∃
                                    W
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    
                                    such
                                    
                                    that
                                    
                                    |
                                    W
                                    |
                                    <
                                    |
                                    K
                                    |
                                    ∧
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    =
                                    W
                                 
                              . This means that W⊂H
                              ∧
                              K
                              ⊂
                              H. If 
                                 
                                    |
                                    W
                                    |
                                    <
                                    |
                                    K
                                    |
                                    ⇒
                                    W
                                    ⊂
                                    K
                                    ⇒
                                    W
                                    ⊂
                                    K
                                    ⊂
                                    H
                                    ⇒
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    
                                    ≠
                                    
                                    W
                                 
                              .□

The next proof (Proposition 7) shows that the intersection between H and K is the set with maximum cardinality among all of their common subsets.
                           Proof
                           Ab absurdo suppose that H
                              ∩
                              K
                              =
                              L and that 
                                 
                                    ∃
                                    W
                                    ∈
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ∩
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    K
                                    )
                                    ,
                                    W
                                    
                                    ≠
                                    
                                    L
                                    ⇒
                                    |
                                    W
                                    |
                                    >
                                    |
                                    L
                                    |
                                    ⇒
                                    (
                                    W
                                    ⊆
                                    (
                                    H
                                    ∩
                                    K
                                    )
                                    )
                                    ∧
                                    (
                                    L
                                    ⊆
                                    (
                                    H
                                    ∩
                                    K
                                    )
                                    )
                                    ⇒
                                    L
                                    ⊆
                                    W
                                    ⇒
                                    H
                                    ∩
                                    K
                                    =
                                    W
                                 
                              .□

The following proof of Theorem 8 shows that NS-M and INS-M have the same expressive power by proving that if we apply the function ζ to a NS-C we obtain an INS-C as output.
                           Proof
                           To prove that 
                                 
                                    ζ
                                    (
                                    C
                                    )
                                    =
                                    E
                                 
                               is an INS-C we have to verify if it satisfies the two conditions of Definition 2.

Condition (4.3). By the definition of NS-C we know that 
                                 
                                    ∃
                                    !
                                    A
                                    ∈
                                    C
                                    |
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    H
                                    ⊆
                                    A
                                 
                              . We know that 
                                 
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    A
                                    )
                                    =
                                    ∅
                                 
                              , that 
                                 
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    H
                                    
                                    ≠
                                    
                                    A
                                    ,
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    
                                    ≠
                                    
                                    ∅
                                 
                              ; we call 
                                 
                                    B
                                    =
                                    ζ
                                    (
                                    A
                                    )
                                    =
                                    ⋃
                                    (
                                    A
                                    ⧹
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    A
                                    )
                                    )
                                 
                              . 
                                 
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    H
                                    
                                    ≠
                                    
                                    A
                                    ,
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ⊂
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    A
                                    )
                                    ⇒
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    
                                    ≠
                                    
                                    ∅
                                    ⇒
                                    ζ
                                    (
                                    A
                                    )
                                    ⊂
                                    ζ
                                    (
                                    H
                                    )
                                    ⇒
                                    ∀
                                    K
                                    ∈
                                    E
                                    ,
                                    B
                                    ⊆
                                    K
                                 
                              .

Condition (4.4). Let us consider three sets 
                                 
                                    H
                                    ,
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                 
                               such that 
                                 
                                    ζ
                                    (
                                    H
                                    )
                                    =
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                    ,
                                    ζ
                                    (
                                    K
                                    )
                                    =
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                    ,
                                    ζ
                                    (
                                    L
                                    )
                                    =
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                 
                              .

Ab absurdo suppose that 
                                 
                                    ∀
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                    |
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ⊆
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    
                                    ≠
                                    
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    ⇒
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    
                                    ≠
                                    
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                    ∧
                                    (
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ⊈
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                    ∧
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ⊈
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                 
                              . This means that, (H′⊈
                              L′)∧ (L′⊈
                              H′)⇒(L∥H). 
                                 
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    
                                    ≠
                                    
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                    ⇒
                                    
                                    ∄
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                    |
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ∩
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ⇒
                                    
                                    ∄
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    E
                                    |
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    ⊆
                                    
                                       
                                          H
                                       
                                       
                                          ′
                                       
                                    
                                    ∧
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    ⊆
                                    
                                       
                                          K
                                       
                                       
                                          ′
                                       
                                    
                                    ∧
                                    
                                       
                                          V
                                       
                                       
                                          ′
                                       
                                    
                                    ⊆
                                    
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                    ⇒
                                    
                                    ∄
                                    V
                                    ∈
                                    C
                                    |
                                    L
                                    ⊆
                                    V
                                    ∧
                                    K
                                    ⊆
                                    V
                                    ∧
                                    H
                                    ⊆
                                    V
                                    ⇒
                                    C
                                 
                               is not a NS-C.□

Let us see an example showing how the ζ function can be applied to the sample NS-C shown on the left-hand side of Fig. 10; in Fig. A.22
                         we can see each step of this mapping procedure.
                           Example 5
                           Let 
                                 
                                    C
                                 
                               be a NS-C and let 
                                 
                                    C
                                    =
                                    {
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    ,
                                    D
                                    ,
                                    E
                                    }
                                 
                               where A
                              ={a,
                              b,
                              c,
                              d,
                              e,
                              f,
                              g}, B
                              ={b,
                              g}, C
                              ={c,
                              d,
                              e}, D
                              ={d} and E
                              ={e}. Then 
                                 
                                    ζ
                                    (
                                    C
                                    )
                                    =
                                    E
                                    =
                                    {
                                    
                                       
                                          A
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          B
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          D
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          ′
                                       
                                    
                                    }
                                 
                              , where:


                              
                                 
                                    ζ
                                    (
                                    A
                                    )
                                    =
                                    
                                       
                                          A
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          H
                                          ∈
                                          {
                                          A
                                          ∪
                                          
                                             
                                                S
                                             
                                             
                                                -
                                             
                                          
                                          (
                                          A
                                          )
                                          }
                                       
                                    
                                    (
                                    H
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    =
                                    A
                                    ⧹
                                    ⋃
                                    {
                                    B
                                    ,
                                    C
                                    }
                                    =
                                    {
                                    a
                                    ,
                                    b
                                    ,
                                    c
                                    ,
                                    d
                                    ,
                                    e
                                    ,
                                    f
                                    ,
                                    g
                                    }
                                    ⧹
                                    {
                                    b
                                    ,
                                    c
                                    ,
                                    d
                                    ,
                                    e
                                    ,
                                    g
                                    }
                                    =
                                    {
                                    a
                                    ,
                                    f
                                    }
                                 
                               (step 1 of Fig. A.22).


                              
                                 
                                    ζ
                                    (
                                    B
                                    )
                                    =
                                    
                                       
                                          B
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          H
                                          ∈
                                          {
                                          B
                                          ∪
                                          
                                             
                                                S
                                             
                                             
                                                -
                                             
                                          
                                          (
                                          B
                                          )
                                          }
                                       
                                    
                                    (
                                    H
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    =
                                    (
                                    B
                                    ⧹
                                    {
                                    ∅
                                    }
                                    )
                                    ∪
                                    (
                                    A
                                    ⧹
                                    ⋃
                                    {
                                    B
                                    ,
                                    C
                                    }
                                    )
                                    =
                                    {
                                    b
                                    ,
                                    g
                                    }
                                    ∪
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    a
                                    ,
                                    f
                                    ,
                                    b
                                    ,
                                    g
                                    }
                                 
                               (step 2 of Fig. A.22).


                              
                                 
                                    ζ
                                    (
                                    C
                                    )
                                    =
                                    
                                       
                                          C
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          H
                                          ∈
                                          {
                                          C
                                          ∪
                                          
                                             
                                                S
                                             
                                             
                                                -
                                             
                                          
                                          (
                                          C
                                          )
                                          }
                                       
                                    
                                    (
                                    H
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    =
                                    (
                                    C
                                    ⧹
                                    {
                                    D
                                    ,
                                    E
                                    }
                                    )
                                    ∪
                                    (
                                    A
                                    ⧹
                                    ⋃
                                    {
                                    B
                                    ,
                                    C
                                    }
                                    )
                                    =
                                    {
                                    c
                                    }
                                    ∪
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                 
                               (step 3 of Fig. A.22).


                              
                                 
                                    ζ
                                    (
                                    D
                                    )
                                    =
                                    
                                       
                                          D
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          H
                                          ∈
                                          {
                                          D
                                          ∪
                                          
                                             
                                                S
                                             
                                             
                                                -
                                             
                                          
                                          (
                                          D
                                          )
                                          }
                                       
                                    
                                    (
                                    H
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    =
                                    (
                                    D
                                    ⧹
                                    {
                                    ∅
                                    }
                                    )
                                    ∪
                                    (
                                    C
                                    ⧹
                                    {
                                    D
                                    ,
                                    E
                                    }
                                    )
                                    ∪
                                    (
                                    A
                                    ⧹
                                    ⋃
                                    {
                                    B
                                    ,
                                    C
                                    }
                                    )
                                    =
                                    {
                                    d
                                    }
                                    ∪
                                    {
                                    c
                                    }
                                    ∪
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    d
                                    ,
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                 
                               (step 4 of Fig. A.22).


                              
                                 
                                    ζ
                                    (
                                    E
                                    )
                                    =
                                    
                                       
                                          E
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          H
                                          ∈
                                          {
                                          E
                                          ∪
                                          
                                             
                                                S
                                             
                                             
                                                -
                                             
                                          
                                          (
                                          E
                                          )
                                          }
                                       
                                    
                                    (
                                    H
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    =
                                    (
                                    E
                                    ⧹
                                    {
                                    ∅
                                    }
                                    )
                                    ∪
                                    (
                                    C
                                    ⧹
                                    {
                                    D
                                    ,
                                    E
                                    }
                                    )
                                    ∪
                                    (
                                    A
                                    ⧹
                                    ⋃
                                    {
                                    B
                                    ,
                                    C
                                    }
                                    )
                                    =
                                    {
                                    e
                                    }
                                    ∪
                                    {
                                    c
                                    }
                                    ∪
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    e
                                    ,
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                 
                               (step 5 of Fig. A.22).

Now, let us see the proof of Theorem 9 by showing how the ξ function allows us to map an INS-C into a NS-C.
                           Proof
                           Let us prove that 
                                 
                                    E
                                 
                               respects Condition (4.1) of Definition 1. 
                                 
                                    ∃
                                    B
                                    ∈
                                    C
                                    |
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    B
                                    ⊆
                                    H
                                    ⇒
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    B
                                    )
                                    =
                                    ∅
                                    ∧
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    
                                    ≠
                                    
                                    ∅
                                    ∧
                                    (
                                    H
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    ⊆
                                    (
                                    B
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    B
                                    )
                                    ⇒
                                    ∀
                                    H
                                    ∈
                                    C
                                    ,
                                    ⋃
                                    (
                                    H
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ⊆
                                    ⋃
                                    (
                                    B
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    B
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    B
                                    )
                                    ⇒
                                    ξ
                                    (
                                    H
                                    )
                                    ⊆
                                    ξ
                                    (
                                    B
                                    )
                                 
                              .

Let us prove that 
                                 
                                    E
                                 
                               respects Condition (4.2). 
                                 
                                    ∀
                                    H
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    H
                                    ⊆
                                    K
                                    ⇒
                                    (
                                    ⋃
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    K
                                    )
                                    ⊆
                                    ⋃
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    ∧
                                    (
                                    K
                                    ∈
                                    ⋃
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    ∧
                                    (
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    ⊆
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    K
                                    )
                                    )
                                    ⇒
                                    (
                                    ⋃
                                    (
                                    K
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    K
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    K
                                    )
                                    )
                                    ⊆
                                    (
                                    ⋃
                                    (
                                    H
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    H
                                    )
                                    )
                                    )
                                    ⇒
                                    ξ
                                    (
                                    K
                                    )
                                    ⊆
                                    ξ
                                    (
                                    H
                                    )
                                 
                              .

Ab absurdo suppose that 
                                 
                                    ∃
                                    ξ
                                    (
                                    H
                                    )
                                    ,
                                    ξ
                                    (
                                    K
                                    )
                                    ∈
                                    E
                                    |
                                    (
                                    ξ
                                    (
                                    H
                                    )
                                    ∩
                                    ξ
                                    (
                                    K
                                    )
                                    
                                    ≠
                                    
                                    ∅
                                    )
                                    ∧
                                    (
                                    ξ
                                    (
                                    H
                                    )
                                    ⊈
                                    ξ
                                    (
                                    K
                                    )
                                    )
                                    ∧
                                    (
                                    ξ
                                    (
                                    K
                                    )
                                    ⊈
                                    ξ
                                    (
                                    H
                                    )
                                    )
                                    ⇒
                                    ∃
                                    ξ
                                    (
                                    L
                                    )
                                    ∈
                                    E
                                    |
                                    (
                                    (
                                    ξ
                                    (
                                    L
                                    )
                                    ⊆
                                    ξ
                                    (
                                    H
                                    )
                                    )
                                    ∧
                                    (
                                    ξ
                                    (
                                    L
                                    )
                                    ⊆
                                    ξ
                                    (
                                    K
                                    )
                                    )
                                    )
                                    ⇒
                                    ∃
                                    L
                                    ∈
                                    C
                                    |
                                    (
                                    H
                                    ⊆
                                    L
                                    )
                                    ∧
                                    (
                                    K
                                    ⊆
                                    L
                                    )
                                    ∧
                                    (
                                    H
                                    |
                                    |
                                    K
                                    )
                                    ⇒
                                    (
                                    L
                                    ∩
                                    K
                                    
                                    ≠
                                    
                                    K
                                    ∩
                                    H
                                    )
                                    ∧
                                    (
                                    H
                                    ∩
                                    K
                                    
                                    ≠
                                    
                                    H
                                    ∩
                                    K
                                    )
                                    ⇒
                                    C
                                 
                               is not a INS-C. □

Let 
                                 
                                    C
                                 
                               be an INS-C and let 
                                 
                                    C
                                    =
                                    {
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    ,
                                    D
                                    ,
                                    E
                                    }
                                 
                               where A
                              ={a,
                              f}, B
                              ={a,
                              b,
                              f,
                              g}, C
                              ={c,
                              a,
                              f}, D
                              ={d,
                              c,
                              a,
                              f} and E
                              ={e,
                              c,
                              a,
                              f}. We can see a graphical representation of this INS-C on the right side of Fig. 10 and each step of the mapping procedure in Fig. A.23
                              .

If we apply the ξ function we obtain the following result:


                              
                                 
                                    ξ
                                    (
                                    A
                                    )
                                    =
                                    
                                       
                                          A
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    ⋃
                                    (
                                    A
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    A
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    A
                                    )
                                    =
                                    ⋃
                                    {
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    ,
                                    D
                                    ,
                                    E
                                    }
                                    ⧹
                                    ∅
                                    =
                                    {
                                    a
                                    ,
                                    b
                                    ,
                                    c
                                    ,
                                    d
                                    ,
                                    e
                                    ,
                                    f
                                    ,
                                    g
                                    }
                                 
                               (step 1 of Fig. A.23).


                              
                                 
                                    ξ
                                    (
                                    B
                                    )
                                    =
                                    
                                       
                                          B
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    ⋃
                                    (
                                    B
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    B
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    B
                                    )
                                    =
                                    ⋃
                                    {
                                    B
                                    }
                                    ⧹
                                    A
                                    =
                                    {
                                    a
                                    ,
                                    f
                                    ,
                                    b
                                    ,
                                    g
                                    }
                                    ⧹
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    b
                                    ,
                                    g
                                    }
                                 
                               (step 2 of Fig. A.23.


                              
                                 
                                    ξ
                                    (
                                    C
                                    )
                                    =
                                    
                                       
                                          C
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    ⋃
                                    (
                                    C
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    C
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    C
                                    )
                                    =
                                    ⋃
                                    {
                                    C
                                    ,
                                    D
                                    ,
                                    E
                                    }
                                    ⧹
                                    A
                                    =
                                    {
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    ,
                                    d
                                    ,
                                    e
                                    }
                                    ⧹
                                    {
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    c
                                    ,
                                    d
                                    ,
                                    e
                                    }
                                 
                               (step 3 of Fig. A.23.


                              
                                 
                                    ξ
                                    (
                                    D
                                    )
                                    =
                                    
                                       
                                          D
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    ⋃
                                    (
                                    D
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    D
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    D
                                    )
                                    =
                                    D
                                    ⧹
                                    ⋃
                                    {
                                    C
                                    }
                                    =
                                    {
                                    d
                                    ,
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                    ⧹
                                    {
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    d
                                    }
                                 
                               (step 4 of Fig. A.23).


                              
                                 
                                    ξ
                                    (
                                    E
                                    )
                                    =
                                    
                                       
                                          E
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    ⋃
                                    (
                                    E
                                    ∪
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    E
                                    )
                                    )
                                    ⧹
                                    ⋃
                                    
                                       
                                          D
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    E
                                    )
                                    =
                                    E
                                    ⧹
                                    ⋃
                                    {
                                    C
                                    }
                                    =
                                    {
                                    e
                                    ,
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                    ⧹
                                    {
                                    c
                                    ,
                                    a
                                    ,
                                    f
                                    }
                                    =
                                    {
                                    e
                                    }
                                 
                               (step 5 of Fig. A.23.


                        Theorem 10 which shows the equivalence between the tree and the NS-M is proved by the following proof.
                           Proof
                           Let us consider a bijective family of subsets
                                 20
                                 Let A be a set, I a non-empty set and 
                                       
                                          C
                                       
                                     a collection of sets of A. Then a function 
                                       
                                          A
                                          :
                                          I
                                          →
                                          C
                                       
                                     is defined to be a family of subsets of A. We call I the index set and we say that the collection 
                                       
                                          C
                                       
                                     is indexed by I.
                              
                              
                                 20
                               
                              
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                    :
                                    V
                                    →
                                    C
                                 
                               where the set of nodes V is its index set of the family and ∀v
                              
                                 i
                              
                              ∈
                              V, 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              . Let v
                              
                                 r
                              
                              ∈
                              V be the root of the tree then 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    )
                                    =
                                    V
                                 
                               and thus 
                                 
                                    V
                                    ∈
                                    
                                       
                                          {
                                          
                                             
                                                V
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          }
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          V
                                       
                                    
                                 
                               (Condition (4.1), Definition 1).

Now, we prove Condition (4.2) of Definition 1. Let v
                              
                                 h
                              ,
                              v
                              
                                 k
                              
                              ∈
                              V, h
                              ≠
                              k such that 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                h
                                             
                                          
                                       
                                    
                                    ∩
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          h
                                       
                                    
                                    )
                                    ∩
                                    
                                       
                                          Γ
                                       
                                       
                                          +
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          k
                                       
                                    
                                    )
                                    
                                    ≠
                                    
                                    ∅
                                 
                              , ab absurdo suppose that Γ
                              +(v
                              
                                 h
                              )⊈
                              Γ
                              +(v
                              
                                 k
                              )∧
                              Γ
                              +(v
                              
                                 k
                              )⊈
                              Γ
                              +(v
                              
                                 k
                              ). This means that the descendants of v
                              
                                 h
                               share at least one node with the descendants of v
                              
                                 k
                               but they do not belong to the same subtree. This means that 
                                 
                                    ∃
                                    
                                       
                                          v
                                       
                                       
                                          z
                                       
                                    
                                    ∈
                                    V
                                    |
                                    
                                       
                                          d
                                       
                                       
                                          V
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          z
                                       
                                    
                                    )
                                    =
                                    2
                                 
                              , but then T
                              =(V,
                              E) is not a tree. □

Let T
                              =(V,
                              E) be a tree where V
                              ={v
                              1,
                              v
                              2,
                              v
                              3,
                              v
                              4, v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8,
                              v
                              9, v
                              10,
                              v
                              11} and E
                              ={e
                              1,2,
                              e
                              1,5,
                              e
                              2,3,
                              e
                              2,4,
                              e
                              5,6,
                              e
                              5,9,
                              e
                              6,7,
                              e
                              6,8,
                              e
                              9,10,
                              e
                              9,11}, thus Γ
                              +(v
                              1)={v
                              1,
                              v
                              2,
                              v
                              3,
                              v
                              4,
                              v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8, v
                              9,
                              v
                              10,
                              v
                              11}, Γ
                              +(v
                              2)={v
                              2,
                              v
                              3,
                              v
                              4},
                              Γ
                              +(v
                              3)={v
                              3}, Γ
                              +(v
                              4)={v
                              4}, Γ
                              +(v
                              5)={v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8,
                              v
                              9,
                              v
                              10,
                              v
                              11},
                              Γ
                              +(v
                              6)={v
                              6,
                              v
                              7,
                              v
                              8},
                              Γ
                              +(v
                              7)={v
                              7}, Γ
                              +(v
                              8)={v
                              8}, Γ
                              +(v
                              9)={v
                              9,
                              v
                              10,
                              v
                              11}, Γ
                              +(v
                              10)={v
                              10}, and Γ
                              +(v
                              11)={v
                              11}.

Let 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               be a collection, where 
                                 
                                    V
                                    =
                                    {
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                4
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                5
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                6
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                7
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                8
                                             
                                          
                                       
                                    
                                 
                              , 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                9
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                10
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                11
                                             
                                          
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          3
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          4
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          7
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          8
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          10
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          11
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          3
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          4
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          3
                                       
                                    
                                    }
                                 
                              , and 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                4
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          4
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                5
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          7
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          8
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          10
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          11
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                6
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          7
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          8
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                7
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          7
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                8
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          8
                                       
                                    
                                    }
                                 
                              , 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                9
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          10
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          11
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                10
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          10
                                       
                                    
                                    }
                                 
                              , and 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                11
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          11
                                       
                                    
                                    }
                                 
                              . Then, from Theorem 10 it follows that 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               is a NS-C.

In this example the instance of the family 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               specifies the nodes of the tree as elements of the sets; it is possible to see that if the nodes of the tree contain elements other than the node itself, these elements become the content of the sets in 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                              .

The tree T
                              =(V,
                              E) and the collection 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               mapped from it are represented in Fig. 11.

The following proof verifies Theorem 11 by showing that a NS-C can be mapped into a tree by creating a node from every set in the NS-C.
                           Proof
                           We have to prove that ∃!v
                              
                                 r
                              
                              ∈
                              V such that

∣E
                              −(v
                              
                                 r
                              )∣=0∧∀v
                              
                                 j
                              
                              ∈
                              V,
                              j
                              ≠
                              r, ∣E
                              −(v
                              
                                 j
                              )∣=1. Ab absurdo suppose that ∃v
                              
                                 r
                              ,
                              v
                              
                                 k
                              
                              ∈
                              V such that (∣E
                              −(v
                              
                                 r
                              )∣=0∧∣E
                              −(v
                              
                                 k
                              )∣=0)∨∃v
                              
                                 j
                              
                              ∈
                              V such that ∣E
                              −(v
                              
                                 j
                              )∣>1. If ∃v
                              
                                 r
                              ,
                              v
                              
                                 k
                              
                              ∈
                              V such that ∣E
                              −(v
                              
                                 r
                              )∣=0∧∣E
                              −(v
                              
                                 k
                              )∣=0 it means that both v
                              
                                 r
                               and v
                              
                                 k
                               have no ancestors; this means that 
                                 
                                    ∃
                                    R
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    R
                                    )
                                    =
                                    0
                                    ∧
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    K
                                    )
                                    =
                                    0
                                 
                               but by the definition of NS-C we know that there is a set 
                                 
                                    T
                                    ∈
                                    C
                                 
                               that is the common superset of all the sets in 
                                 
                                    C
                                 
                              , then 
                                 
                                    ∄
                                    J
                                    ∈
                                    C
                                    |
                                    J
                                    
                                    ≠
                                    
                                    T
                                    ∧
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    J
                                    )
                                    =
                                    0
                                 
                              .

If ∃v
                              
                                 j
                              
                              ∈
                              V such that ∣E
                              −(v
                              
                                 j
                              )∣>1 this means that ∃v
                              
                                 k
                              ,
                              v
                              
                                 l
                              
                              ∈
                              V such that they are both parents of 
                                 
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ⇒
                                    ∃
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                    
                                    |
                                    
                                    J
                                    ⊆
                                    K
                                    ∧
                                    J
                                    ⊆
                                    L
                                    ⇒
                                    (
                                    L
                                    ∩
                                    K
                                    =
                                    J
                                    )
                                    ∧
                                    (
                                    L
                                    ⊈
                                    K
                                    ∨
                                    K
                                    ⊈
                                    L
                                    )
                                    ⇒
                                    C
                                 
                               is not a NS-C. □

Now we can prove the corresponding theorems for the INS-M which show how a tree can be mapped into an INS-C and vice versa.

The mapping between a tree and an INS-C reverses the idea described for the mapping of a tree into a NS-C; if a node is a parent of another node in a tree, this is mapped into a set which is a subset of the set created from its child node. The following proof proves Theorem 12.
                           Proof
                           Let us consider a family of subsets 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                    :
                                    V
                                    →
                                    C
                                 
                               where the set of nodes V is its index set of the family and ∀v
                              
                                 i
                              
                              ∈
                              V, 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              .

Let us prove Condition (4.3) of Definition 2. Let v
                              
                                 r
                              
                              ∈
                              V be the root of T. 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    )
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    }
                                    ⇒
                                    ∀
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ∈
                                    V
                                    ,
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    )
                                    ⊆
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    ⇒
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                    ⊆
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                              .

Let us prove Condition (4.4) of Definition 2. Ab absurdo suppose that 
                                 
                                    ∃
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                h
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    ∈
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                    |
                                    
                                       
                                          
                                             (
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         h
                                                      
                                                   
                                                
                                             
                                             ⊆
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                
                                             
                                             )
                                             ∧
                                             (
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                
                                             
                                             ⊈
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         h
                                                      
                                                   
                                                
                                             
                                             )
                                             ∧
                                             (
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         h
                                                      
                                                   
                                                
                                             
                                             ⊈
                                             
                                                
                                                   V
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                
                                             
                                             )
                                          
                                       
                                    
                                    ⇒
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    ∩
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    
                                    ≠
                                    
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    ∩
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                h
                                             
                                          
                                       
                                    
                                 
                              .

This means that ∃v
                              
                                 h
                              ,
                              v
                              
                                 k
                              ,
                              v
                              
                                 l
                              
                              ∈
                              V∣ ((Γ
                              −(v
                              
                                 h
                              )⊆
                              Γ
                              −(v
                              
                                 k
                              ))∧(Γ
                              −(v
                              
                                 l
                              )⊈
                              Γ
                              −(v
                              
                                 h
                              ))∧(Γ
                              −(v
                              
                                 h
                              )⊈
                              Γ
                              −(v
                              
                                 l
                              )))⇒
                              Γ
                              −(v
                              
                                 l
                              )∩
                              Γ
                              −(v
                              
                                 k
                              )≠
                              Γ
                              −(v
                              
                                 l
                              )∩
                              Γ
                              −(v
                              
                                 h
                              ). ∃v
                              
                                 j
                              
                              ∈
                              V
                              ∣
                              v
                              
                                 j
                              
                              ∈(Γ
                              −(v
                              
                                 l
                              )∩
                              Γ
                              −(v
                              
                                 k
                              ))∧
                              v
                              
                                 j
                              
                              ∉(Γ
                              −(v
                              
                                 l
                              )∩
                              Γ
                              −(v
                              
                                 h
                              ))⇒
                              v
                              
                                 h
                              
                              ∈
                              Γ
                              −(v
                              
                                 k
                              )∧
                              v
                              
                                 j
                              
                              ∈
                              Γ
                              −(v
                              
                                 k
                              )∧
                              v
                              
                                 j
                              
                              ∈
                              Γ
                              −(v
                              
                                 l
                              )∧
                              v
                              
                                 j
                              
                              ∉
                              Γ
                              −(v
                              
                                 h
                              ). This means that v
                              
                                 k
                               and v
                              
                                 h
                               must belong to the same branch of T; we know that v
                              
                                 j
                              
                              ∈
                              Γ
                              −(v
                              
                                 l
                              )∧
                              v
                              
                                 j
                              
                              ∈
                              Γ
                              −(v
                              
                                 k
                              ), thus v
                              
                                 k
                               and v
                              
                                 l
                               must have v
                              
                                 j
                               as a common ancestor and v
                              
                                 j
                              
                              ∉
                              Γ
                              −(v
                              
                                 h
                              ). This means that {v
                              
                                 j
                              ,
                              v
                              
                                 k
                              ,
                              v
                              
                                 l
                              }∈
                              Γ
                              +(v
                              
                                 h
                              ), but 
                                 
                                    (
                                    (
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          l
                                       
                                    
                                    )
                                    ⊈
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          h
                                       
                                    
                                    )
                                    )
                                    ∧
                                    (
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          h
                                       
                                    
                                    )
                                    ⊈
                                    
                                       
                                          Γ
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          l
                                       
                                    
                                    )
                                    )
                                    )
                                    ⇒
                                    
                                       
                                          d
                                       
                                       
                                          V
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          l
                                       
                                    
                                    )
                                    >
                                    1
                                    ⇒
                                    T
                                 
                               is not a tree.□

Let T
                              =(V,
                              E) be a tree where V
                              ={v
                              1,
                              v
                              2,
                              v
                              3,
                              v
                              4,
                              v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8,
                              v
                              9, v
                              10,
                              v
                              11} and E
                              ={e
                              1,2,
                              e
                              1,5,
                              e
                              2,3,
                              e
                              2,4,
                              e
                              5,6,
                              e
                              5,9,
                              e
                              6,7,
                              e
                              6,8,
                              e
                              9,10,
                              e
                              9,11}, thus Γ
                              +(v
                              1)={v
                              1,
                              v
                              2,
                              v
                              3,
                              v
                              4,
                              v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8, v
                              9,
                              v
                              10,
                              v
                              11}, Γ
                              +(v
                              2)={v
                              2,
                              v
                              3,
                              v
                              4},
                              Γ
                              +(v
                              3)={v
                              3}, Γ
                              +(v
                              4)={v
                              4}, Γ
                              +(v
                              5)={v
                              5,
                              v
                              6,
                              v
                              7,
                              v
                              8,
                              v
                              9,
                              v
                              10,
                              v
                              11}, Γ
                              +(v
                              6)={v
                              6,
                              v
                              7,
                              v
                              8}, Γ
                              +(v
                              7)={v
                              7}, Γ
                              +(v
                              8)={v
                              8}, Γ
                              +(v
                              9)={v
                              9,
                              v
                              10,
                              v
                              11}, Γ
                              +(v
                              10)={v
                              10}, and Γ
                              +(v
                              11)={v
                              11}.

Let 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               be a family, where 
                                 
                                    V
                                    =
                                    {
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                4
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                5
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                6
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                7
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                8
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                9
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                10
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                11
                                             
                                          
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          2
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          3
                                       
                                    
                                    }
                                 
                              , and 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                4
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          4
                                       
                                    
                                    }
                                 
                              , 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                5
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                6
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                7
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          7
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                8
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          8
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                9
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    }
                                    ,
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                10
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          10
                                       
                                    
                                    }
                                 
                              , and 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                11
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          v
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          5
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          9
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          11
                                       
                                    
                                    }
                                 
                              . Then, from Theorem 12 it follows that 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               is an INS-C. The tree T
                              =
                              V,
                              E and the family 
                                 
                                    
                                       
                                          V
                                       
                                       
                                          V
                                       
                                    
                                 
                               mapped from it are represented in Fig. 12.

Now we can prove Theorem 13 by showing how an INS-C 
                           
                              C
                           
                         is mapped into a tree T
                        =(V,
                        E).
                           Proof
                           We have to prove that (∃!v
                              
                                 r
                              
                              ∈
                              V such that ∣E
                              −(v
                              
                                 r
                              )∣=0)∧(∀v
                              
                                 j
                              
                              ∈
                              V,
                              j
                              ≠
                              r,∣E
                              −(v
                              
                                 j
                              )∣=1). Ab absurdo suppose that ∃v
                              
                                 r
                              ,
                              v
                              
                                 k
                              
                              ∈
                              V such that, (∣E
                              −(v
                              
                                 r
                              )∣=0∧∣E
                              −(v
                              
                                 k
                              )∣=0)∨∃v
                              
                                 j
                              
                              ∈
                              V such that ∣E
                              −(v
                              
                                 j
                              )∣>1.

If 
                                 
                                    ∃
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          k
                                       
                                    
                                    ∈
                                    V
                                    
                                    such
                                    
                                    that
                                    
                                    (
                                    (
                                    |
                                    
                                       
                                          E
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                    )
                                    |
                                    =
                                    0
                                    )
                                    ∧
                                    (
                                    |
                                    
                                       
                                          E
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          k
                                       
                                    
                                    )
                                    |
                                    =
                                    0
                                    )
                                    )
                                    ⇒
                                    ∃
                                    J
                                    ,
                                    K
                                    ∈
                                    C
                                    |
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    J
                                    )
                                    ∩
                                    
                                       
                                          S
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    K
                                    )
                                    =
                                    ∅
                                    )
                                    ⇒
                                    
                                    ∄
                                    B
                                    ∈
                                    C
                                    |
                                    B
                                    ⊆
                                    J
                                    ∧
                                    B
                                    ⊆
                                    K
                                    ⇒
                                    C
                                 
                               is not an INS-C.

If 
                                 
                                    ∃
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ∈
                                    V
                                    
                                    such
                                    
                                    that
                                    
                                    |
                                    
                                       
                                          E
                                       
                                       
                                          -
                                       
                                    
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    |
                                    >
                                    1
                                    ⇒
                                    ∃
                                    J
                                    ,
                                    K
                                    ,
                                    L
                                    ∈
                                    C
                                    |
                                    (
                                    K
                                    ⊆
                                    J
                                    ∧
                                    L
                                    ⊆
                                    J
                                    ∧
                                    K
                                    ∩
                                    L
                                    =
                                    ∅
                                    )
                                    ⇒
                                    L
                                    ∩
                                    K
                                    =
                                    ∅
                                    
                                    ≠
                                    
                                    L
                                    ∩
                                    J
                                    =
                                    L
                                    ⇒
                                    C
                                 
                               is not an INS-C. □

@&#REFERENCES@&#

