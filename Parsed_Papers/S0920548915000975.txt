@&#MAIN-TITLE@&#Declarative specifications for the development of multi-agent systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A multi-agent system development language based on declarative specifications


                        
                        
                           
                           Language is defined formally via denotational semantics and attribute grammars.


                        
                        
                           
                           Applying denotational semantics provided precise definitions of the language.


                        
                        
                           
                           We could generate the language automatically from formal semantics.


                        
                        
                           
                           Using attribute grammars made evolutionary language development easier.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Domain-specific language

Multi-agent system

Semantic Web

Formal semantics

Declarative specifications

@&#ABSTRACT@&#


               
               
                  The designing and implementation of a multi-agent system (MAS), where autonomous agents collaborate with other agents for solving problems, constitute complex tasks that may become even harder when agents work in new interactive environments such as the Semantic Web. In order to deal with the complexities of designing and implementing a MAS, a domain-specific language (DSL) can be employed inside the MAS's development cycle. In such a manner, a MAS can be completely specified by programs written in a DSL. Such programs are declarative, expressive, and at the right abstraction level. In this way the complexity of MAS development is then partially shifted to DSL development and the task herein can be much more feasible by using a proper DSL development methodology and related tools. This paper presents and discusses our methodology for DSL development based on declarative formal specifications that are easy to compose, and its usage during MAS development. A practical case-study is also provided covering an example of a MAS's development for expert finding systems. By using denotational semantics for precisely defining the language, we show that it is possible to generate the language automatically. In addition, using attribute grammars makes it possible to have modular methodology within which evolutionary language development becomes easier.
               
            

@&#INTRODUCTION@&#

A software agent is an encapsulated software system situated within a certain environment, and is capable of flexible autonomous action within this environment in order to meet its design objectives [1]. These autonomous, reactive, and proactive agents can also behave in a cooperative manner and collaborate with other agents for solving common problems. In this way, these intelligent agents constitute systems called multiagent systems (MASs).

The design and implementations of MASs are complex tasks when considering their dynamicity and autonomous characteristics. Their behaviour is more complex when taking into account the agent's interaction with new agent environments such as the Semantic Web [2,3].

The Semantic Web extends the current web in such a way that the web pages' contents can be interpreted using ontologies [2] that help machines to understand web-content. Software agents can fulfil the interpretations in question by handling the semantic contents on behalf of their human users by collecting web contents from diverse sources, processing the information, and exchanging the results.

In addition, autonomous agents can evaluate semantic data and collaborate with semantically-defined entities of the Semantic Web, such as semantic web services (SWS), by using content languages [4]. SWSs can be simply defined as the web services with semantic interfaces to be discovered and executed [5]. In order to support the semantic interoperabilities and automatic compositions of web services, the capabilities of web services are defined in service ontologies that provide the required semantic interfaces. Such interfaces of the SWSs can be discovered by software agents and these agents may then interact with these services to complete their tasks. The engagements and invocations of a semantic web service are also performed according to the service's semantic protocol definitions. For instance, the dynamic composition of heterogeneous services for the optimal selection of service providers can be achieved by employing agents and ontologies, as proposed in [6].

However, agent interactions with semantic web services add further complexities when designing and implementing MASs. Different methodologies can be applied in order to deal with this complexity. One of the possible alternatives is domain-specific languages (DSLs) [7–10] that have notations and constructs tailored towards a particular application domain (e.g. MAS and Semantic Web). In this way, DSLs raise the abstraction level, expressiveness, and ease of use. In other words, when using this methodology the users focus on the program model of the solution instead of a platform code for the solution, and they can automatically generate code from the model using DSL tools. As a result, the DSLs' users mostly need the knowledge from the problem domain [11] but little programming experience.

We are convinced that the use of a DSL can provide the required abstraction and support a more fruitful methodology for the development of MASs especially when working within a Semantic Web environment. Within this context, prior to the work discussed here, we first provided a metamodel defined in several viewpoints [12] for MASs working within a Semantic Web environment. Then, based on this metamodel, we developed a DSL called the Sematic web-Enabled Agent Language (SEA_L) [13,14] including an interpreter mechanism for SEA_L which is defined for enabling code generation regarding the implementation of SEA_L agents (e.g. in JADEX platform [15]).

Although syntax definition based on a metamodel is an essential part of a modelling language, an additional and required part is the determination and implementation of DSL constraints that constitute those semantics that cannot be defined solely by a metamodel or syntax. In line with these constraints, the semantics of a DSL include some rules that restrict the instance models created according to the language.

The definition of the semantic rules was provided towards this end in our previous study [16,17] focusing on Agent–Semantic Web Service interaction. However, the represented semantic rules were not implemented and applied to SEA_L language (although, it is one of the crucial tasks during a DSL's development). In other words, the defined formal semantic rules have not been applied to any translational/operational semantics and have no effects on the quality of the generated code. Such an application is important as the execution of the language is described directly or by translating to another language in translational/operational semantics.

Therefore, in this study, the specification of the static semantics regarding the interactions between software agents and semantic web services in SEA_L language is formally declared using denotational semantics [18] which paves the way for the implementation of these specifications using attribute grammars [19,20]. Static semantics is used to control some constraints during system modelling in the DSL. On the other hand, denotational semantics interpret the phrases of a language as mathematical denotations and conceptual meanings that can be thought of abstractly.

Our main motivation is that declarative specifications can present the meanings of both associations and constraints for the language in a formal way. The formal representation of the semantics helps to provide an unambiguous definition and precise meaning of a program. It also helps to have the possibility for more accurate code generation by the language-based tools [21], when they are implemented in the DSL (which is lacking in the related work). A successful system verification and validation can also be achieved with a proper formal semantics definition.

In order to implement the defined declarative semantics of SEA_L, we have employed the LISA tool [22] which is based on attribute grammars. As can be noticed in further sections of this paper, implementation using LISA enables the separation of concerns between the syntax and the semantics. Moreover, it offers tools for syntax and semantics evaluation separately.

Hence, the main contributions of this paper are listed as follows:
                        
                           •
                           a new DSL-based methodology for the development of MAS with Semantic Web, where DSLs are formally specified with formalism that enables incremental specifications; and

the implementation of the static semantics of SEA_L MAS development language and integrating them within the operational semantics of SEA_L in the form of declarative specifications using attribute grammars; this leads to productivity and advanced semantic controls in our DSL, and modularity and extendibility for the new language.

The remainder of the paper is organised as follows: Section 2 discusses the related work. The applied approach is elaborated in Section 3. The proposed methodology is discussed in Section 4 by especially taking into consideration the Agent–SWS interaction viewpoint of the system. In Section 5, use of the language and its semantics is presented using a case-study. Section 6 covers the evaluation and discussion for this study. Finally, the paper is concluded in Section 7.

@&#RELATED WORK@&#

The design and implementation of MAS working on the Semantic Web keep their emphasis since the first introduction of this new generation web in [2]. Berners-Lee et al. [2] took software agents as the central point of distributed content collection, knowledge formalisation, processing and interpretation of data, which are all required for the realisation of such a web environment. Hence MAS composed of many autonomous agents now became one of the major components of the Semantic Web. More specifically, the integration of agents and the knowledge ontologies steers the use of web services [23] and enables the automatic discovery and execution of services by the agents within the Semantic Web environment. Many researchers have investigated how the agents can participate in service execution inside the Semantic Web environment and have provided noteworthy methodologies and/or protocols for collaboration between agents and other Semantic Web entities, e.g. semantic web services. For instance, Paolucci et al. [24], Sycara et al. [5] and Li and Horrocks [25] proposed various capability representation mechanisms for semantic web services and discussed how they can be discovered and executed by agents. Agents infer about the suitability of the advertised semantic web services for the required action according to those defined service representations and decide on executing the more appropriate service. The studies in [26] and [27] described agent environments which use OWL-S ontologies to advertise descriptions of agent services to transport them using communication messages. Those descriptions provided for the use of agent services as if they were semantic web services. OWL-S [28] is an ontology built on top of Web Ontology Language (OWL) for describing Semantic Web Services and enables users and software agents to automatically discover, invoke, compose, and monitor Web resources offering services, under specified constraints. In addition, OWL [29] is a family of knowledge representation languages for authoring ontologies which are a formal way of describing taxonomies and classification networks.

A set of architectural and protocol abstractions that serves as a foundation for Agent–web service interactions on the Semantic Web was introduced in [30]. This initiative architecture addressed the requirements of dynamic service discovery, service engagement, service process enactment and management, community support and quality of service for the Semantic Web. The architecture is based on the MAS infrastructure because the specified requirements can be accomplished with asynchronous interactions and using goal-oriented software agents. Two implementations of this conceptual architecture were provided in [31] and [32] which mainly considered the service matchmaking, service discovery and service execution functionalities of software agents. Preparation of existing web services into the Semantic Web environment or migrating them via software agents is also possible by following approaches such as given in [33] and [31].

Similar to [5] and [25], Talantikite et al. [34] provided an input-output similarity measure for OWL-S ontologies for determining the best semantic services and compose them for meeting client requests. Instead of semantic web service profiles, the use of OWL-S process models is proposed during the service discovery in [35]. Hence, it is aimed at finding and matching more relevant services with the proposed algorithm. Kumar [36] discussed multi-attribute negotiation between the agents working on the Semantic Web and the benefits of such negotiation on both the selecting and composing of semantic web services. Our study contributes to the above-mentioned MAS and the Semantic Web research by providing a DSL which can be used to formally define and implement the interaction between software agents and semantic web services. MAS developers can use the specifications given in this paper to realise concrete implementations of collaboration protocols and abstract Semantic Web service architectures (e.g. [30] and [36]) discussed above; such that agents may interpret and reason with semantic descriptions during the deployment of semantic web services.

On the other hand, Agent-oriented Software Engineering (AOSE) is one of the major areas of agent research intersecting Software Engineering. Different researchers have applied model-driven techniques based on DSL and DSML (Domain-Specific Modelling Language), as a development methodology for MASs. In the remainder of this section, we discuss these studies and compare them with our study.

There are several studies that only describe the main elements and the relationships between them as a metamodel for MASs. Some of these studies have presented general-purpose metamodels e.g. AALAADIN [37], ACSM [38], PIM4Agents [39], and FAML [40], yet some others have presented metamodels for specific methodologies, e.g. [41] for ADELFE [42], Gaia [43], and PASSI [44]. Another example is the metamodel presented in [45] for SODA [46] agent development methodology. In fact, these studies present some conceptual class diagrams for MASs and are not considered as modelling languages.

Therefore, AOSE researchers have made great strides into developing MAS modelling languages in addition to MAS metamodelling studies. For instance, Depke et al. [47] introduced an agent-oriented modelling technique based on the UML notation. On the other hand, Agent UML (AUML) [48] is perhaps the better-known modelling language within the agent community, which presents new agent-based extensions to package and template structures and sequence, interaction, activity and class diagrams of UML. AUML relies too much on UML which is proposed for object-oriented system specification and also, as stated in [49], AUML's visual notation is incomplete and does not provide a textual notation for exchanging with other developers. The Agent Modelling Language (AML) [50] is another general modelling language for MASs that is based on the UML 2.0 superstructure. Although it provides a visual modelling language, it lacks textual notation and formal semantics. Another metamodel-driven agent modelling language is introduced in [51] which aims at expressing models for various AOSE methodologies and specifically enables both comprehension and interchange of MAS models amongst agent developers.

In order to present more powerful methodologies for MAS developers, some researchers have provided DSLs or DSMLs for MASs. For example in [52] and [53] the authors presented MAS metamodels and related tools and called them DSL and DSML respectively. However, they lack the concrete syntax and semantics that are required for a complete DSL. In [54], the authors defined and implemented a formalised syntax and semantics of DSL for mobile agents including a textual editor, and code generation. However, the introduced DSL considers the mobile agent domain that completely differs from the specific domain of SEA_L. Another DSML was provided in [55] for developing MASs using Prometheus methodology [56]. The abstract and concrete syntax, the tool, and the code generation for the JACK agent platform [57] were provided. A similar study was discussed in [58] that proposed a technique for defining agent-oriented engineering process models that can be used to define processes for creating both hardware and software agents. This study also offered a related model-driven development (MDD) [59] tool using Software & System Process Metamodel (SPEM) [60] and based on INGENIAS methodology [61] for MAS development. Nevertheless, both of the studies are bound to specific methodologies and their metamodels are not general enough for MASs. Also, neither [55] nor [58] covered software agents in the Semantic-Web.

In [62] a new DSML for MAS, called DSML4MAS, was introduced. The abstract syntax of DSML4MAS was provided from a platform-independent metamodel (PIMM) that contained several viewpoints of a MAS. The abstract syntax of a model is its structure described as a data type, independent of any particular representation or encoding. In addition, the concrete syntax provides a mapping between meta-elements and their representations for models and includes the set of notations which facilitates the presentation and construction of the language. The concrete syntax of DSML4MAS was provided by means of appropriate graphical notations for the concepts and relationships [63]. However, it supported neither the agents on the Semantic Web nor the interaction of Semantic Web-enabled agents with other environment members such as semantic web services. Our study contributed to the afore-mentioned efforts by also specialising in the Semantic Web support of MASs. In [64], the authors introduced their approach on integrating agents with semantic web services. In addition to the MAS metamodel described in [62], a new platform-independent metamodel was proposed for semantic web services. A relationship between these two metamodels was established in such a way that the MAS metamodel was extended with new meta-entities in order to support semantic web services' interoperabilities, and it also inherited some meta-entities from the metamodel proposed for semantic web services. Instead of using two separate metamodels, our DSL has a built-in support for the modelling of agent and semantic web services' interactions by including a special viewpoint. Finally, the work in [4] presented a methodology based on OMG's well-known Model Driven Architecture (MDA) [65] for modelling and implementing agent and service interactions on the Semantic Web. However, neither a DSL approach nor the semantics of service execution were covered in the study.

Semantics control and its formal representation are key factors in the success of DSLs and DSMLs. A few studies have considered this aspect of MDD on MAS development. For instance, the study in [66] uses the Object-Z language [67] for defining the formal semantics of DSML4MAS [62]. In this way, the system designer is supported when validating and verifying the generated design. In [68], the authors presented a framework for supporting the formal specifications and verifications of DIMA multi-agent models using Maude language [69] based on rewriting the logic. This presented work only covers DIMA MAS models and does not have a generic MAS perspective such as SEA_L's. In [70], the authors believed that Object-Z and statecharts individually were not powerful enough for specifying the complex MASs and hence they combined Object-Z and statecharts in order to define MASs based on an organisational model. AgentZ [71] extended Object-Z for specifying MASs by adding new constructs for improving its structure, namely agent-oriented entities such as agents, organisations, roles, and environments. Our work differs from these studies by specialising in the Semantic Web support in MASs.

Validation of the designed agent systems by applying formal methods can also be critical during MAS development. Related worthwhile approaches are extensively discussed in [72] and [73]. Considering the use of Alloy [74,75] in MAS development, Podorozhny et al. [76] presented an approach for designing a robust MAS and checking the properties of coordination, interaction, and agents' data structures, using the Alloy analyser. Additionally, Haesevoets et al. [77] formally defined the relationships between the interactions, the exposed information and provided policies and laws for an agent's middleware by using Alloy. In this way, they guaranteed a number of properties that are important in the usage of this middleware. Any kind of fully fledged DSL or DSML is not provided in these studies.

By considering our previous studies, in [78], we have shown how domain-specific engineering can provide the easy and rapid construction of a Semantic Web-enabled MASs. Ideas have been discussed for abstract syntax, concrete syntax, and formal semantics. Furthermore, a metamodel, which in fact constitutes the preliminary version of the abstract syntax of SEA_L, was introduced in [12]. Also, textual [14] and graphical [79] languages were presented that can be used during both the modelling of Semantic Web-enabled MASs and the syntactic checking of designed models. In addition, the formal semantics of the Agent–SWS interaction viewpoint regarding our DSL is introduced in [16] and [17]. Based on these building blocks, in this paper we discuss the representation of SEA_L's formal semantics in the form of denotational semantics and implementing them by transforming them to attribute grammars using LISA. In this way, the translational and denotational semantics come together in a modular way, which is lacking in the literature. The usefulness of attribute grammars as high-level declarative specifications for specifying various XML processing tasks have also been shown in [80]. Our approach for combining declarative attribute grammar specifications is more powerful than the approach presented in [80], where a combination of non-conflicting attribute grammar fragments is only possible. In other words, no conflicts amongst the combined specifications are allowed in [80], while our approach enables language extensions, language unifications, self-extension, and extension compositions of attribute grammar fragments [81].

A DSL life-cycle was described in [8,82]. It is comprised of the following phases: decision, domain analysis, DSL design, DSL implementation, DSL testing, DSL deployment, and DSL maintenance. During the decision phase several criteria need to be evaluated and contrasted to find out whether the development of a new DSL is a solution to our problem. In this respect decision patterns [8] might be helpful as they indicate those situations in the past where the introduction of a DSL into a process has been successful. If the decision about implementing a DSL was positive during the initial phase then the next stage is a DSL development, which is comprised of the following phases: domain analysis, DSL design, and DSL implementation. These phases are crucial during a DSL life cycle and appropriate methodology is needed to do it correctly. Many DSLs have been developed from scratch by informally performing a particular phase (domain analysis, DSL design, DSL implementation), certain parts of a phase (e.g., semantic part of a DSL design), or even all the phases. There are several problems with the ‘from scratch’ approach. The more notable problems are: that often unsatisfactory DSL is developed and several costly re-development iterations are needed, difficult maintenance, and that DSL evolution is hard. For example, often problems that should have been identified during early phases only become visible during later phases. Hence, such an informal approach to DSL development is not recommended. A formal approach to DSL development has already been proposed in Mernik et al. [8] and in this section a particular formal DSL development methodology is described. Namely, domain analysis, DSL design and DSL implementation are not narrow processes and various formalisms can be applied.

The task of domain analysis is to select and define the domain of focus, collect appropriate domain information, and integrate them into a coherent domain model that represents concepts within a domain and relationships within the domain concepts. Here several existing domain analysis methodologies can be used, such as: DARE—Domain Analysis and Reuse Environment [83], FAST—Family-Oriented Abstractions, Specification, and Translation [84], FODA—Feature-Oriented Domain Analysis [85], and ODE—Ontology-based Domain Engineering [86]. In our approach we have used FODA, as the common and variable properties of a domain are easy to identify in feature diagrams (i.e., variation points). In fact, the list of variations indicates precisely which information is required for specifying an instance within a system. This information must be directly specified within programs written in a DSL or be derived at from them. On the other hand, the commonalities are used for defining the execution model (through a set of common operations) and the primitives of the language. The outputs from domain analysis are: terminology, concepts, commonalities, and variations. These are easily identified from FODA feature diagrams [87] and should be used as inputs into the next phase—DSL design.

Designing a language involves defining the constructs within the language (syntax) and giving semantics to the language. Both sub-phases, syntax and semantics, can be managed informally or formally. The advantages of formal syntax and semantic specification of programming languages are well-known: the structure and meaning of a program is precisely and unambiguously defined, and it offers a unique possibility for the automatic generation of compilers or interpreters. Those programming languages that have been designed using one of the various formal methods for syntax and semantic definitions have better syntax and semantics, less exceptions, and are easier to learn. Moreover, researchers have recognised the possibility that many other language-based tools could be generated from formal language specifications. Therefore, many language implementation systems not only automatically generate a compiler/interpreter but also complete language-based environments including editors, type checkers, debuggers, various analysers, and animators [88]. The following formal methods for DSL syntax definition have been used: BNF, FDL [89], metamodels, DTD, and XML Schema. The powers of all these formal methods for syntax definition are the same. Hence, transformations between different syntax descriptions are more or less easy to achieve. In our DSL development methodology we have opted for metamodels because class diagrams are often familiar to programmers using object-oriented languages, and relationships between class diagram entities can also be named. We can define a metamodel as a model of a model, providing the frameworks, rules, and constraints for defining the models for modelling a predefined class of problems. Many language implementation systems (i.e., compiler generators) use variants of Backus–Naur Form (BNF) and additional transformation is needed from metamodels to BNF. BNF is a widely-known notation technique for context-free grammars, which is used to describe the syntax of a computer programming language. It provides an exact description for specifying the syntax of formal languages [90]. There are some compiler generators (e.g., YAJCo [91], Xtext [92]) where syntax definition is given with a metamodel. Transformation between BNF and metamodels was described in [93,94]. As semantic formalisms are usually based on abstract syntax instead of concrete syntax, both forms need to be developed as concrete syntax is needed later when parsing. While different syntax formalisms are equivalent, the situation is quite different for the semantics, where approaches such as attribute grammars, axiomatic semantics, operational semantics, denotational semantics, and translational semantics are complementary, and used by different stakeholders. For example, attribute grammars are used by compiler writers, while axiomatic and denotational semantics are used by language designers to prove various language properties without concentrating on particular implementation. On the other hand, operational semantics define the meaning of the language through configuration changes and are closer to the implementation on virtual machines. Another distinction amongst different semantic formalisms is whether they are able to describe the static and/or dynamic semantics of a language. In our DSL development methodology we have used a mixture of different semantic formalisms. For describing static and dynamic semantics, we have used denotational semantics, and for code generation the translational semantics.

Finally, after DSL has been designed, it is time for its implementation. Different approaches for DSL development have been introduced in [8]: interpreter, compiler/application generator, embedding, preprocessing, extensible compiler/interpreter, Commercial Off-The-Shelf (COTS), and the hybrid approach. Clearly we want to select an approach that requires the least effort during implementation and offers the greatest efficacy to the end-user [95]. In our approach to DSL development, the formal specifications during the design phase constitute an important part. Of course, it is harder to design a DSL formally than informally. This pays off during the DSL implementation phase, where a complete compiler/interpreter can be automatically generated. This is achieved in our case by mapping denotational and translational semantics to the language implementation system LISA [22], which is based on attribute grammars. LISA is a compiler generator and tool with the following features:
                        
                           •
                           It offers an integrated development environment where users can specify-generate-compile-execute programs in a newly specified language.

Lexical, syntax and semantic analysers can be of different types and can operate standalone;

It provides visual presentations of different structures, such as finite state automata, BNF, syntax tree, semantic tree, and dependency graphs.

Animation is possible for lexical, syntax and semantic analysers.

The specification language supports multiple attribute grammar inheritance, which enables regular definitions, grammar production rules, attributes, semantic rules and operations on semantic domains to be inherited, specialised or overridden from ancestor specifications.

Code generation using translational semantics is easy to implement in attribute grammars, while transformation from denotational semantics into attribute grammars is more complicated but similar to the translation scheme from natural semantics into attribute grammars [96]. The former transformation was described in [97].

The whole process of our methodology for DSL development is presented in Fig. 1
                     , where it can be seen that the outputs from syntax and semantic definitions are used as inputs into our language implementation system LISA. Section 4 shows how our DSL development methodology has been used for the development of the Agent–SWS interaction language.

Our approach to DSL development is clearly shown for the Agent–SWS interaction Language, which is a small sub-language of the Semantic web-Enabled Agent Language (SEA_L) [14]. SEA_L is a DSL for specifying agents interacting with each other within a MAS and with semantically-defined entities of the Semantic Web (e.g., Semantic Web Services). The main goal of this language is to provide a convenient environment for agent developers to construct and implement software agent systems working on various application domains. In order to support MAS experts when programming their own systems, and to be able to fine-tune them, SEA_L covers all aspects of an agent system from the internal view of a single agent to the complex MAS organisation. In addition to these capabilities, SEA_L also supports the model-driven design and implementation of autonomous agents who can evaluate semantic data and collaborate with semantically-defined entities of the Semantic Web, such as Semantic Web Services (SWS). That feature exactly differentiates SEA_L and makes it unique regarding any other MAS DSL currently available. Within this context, it includes new viewpoints which specifically pave the way for the development of software agents working on the Semantic Web environment. Modelling agents, agent knowledge-bases, platform ontologies, semantic web services, and interactions between agents and SWS are all possible in SEA_L.

The whole SEA_L is split into several sub-languages or viewpoints [12], each of which represents a different aspect for developing Semantic Web enabled MASs: Agent's Internal Viewpoint is related to the internal structures of semantic web agents (SWAs) and defines entities and their relationships required for the construction of agents. It covers both reactive and Belief-Desire-Intention (BDI) [98] agent architectures. Interaction viewpoint expresses the interactions and communications in a MAS by taking messages and message sequences into account. MAS Viewpoint solely deals with the construction of a MAS as a whole. It includes the main blocks that compose the complex system as an organisation. Role Viewpoint delves into the complex controlling structure of the agents and addresses role types. Environmental Viewpoint addresses the use of resources and interactions between agents within their surroundings. Plan Viewpoint deals with the internal structure of an agent's plan, which is composed of Tasks and atomic elements such as Actions. Ontology Viewpoint addresses ontological concepts that constitute an agent's knowledge-base (such as belief and fact). Agent–SWS interaction viewpoint defines the interactions of agents with semantic web services (SWS) [5] including the definition of entities and relationships for service discovery, agreement and execution. The relationships between these viewpoints for building the whole metamodel are depicted in Fig. 2
                     . The last viewpoint and definitely the more important sub-language, Agent–SWS interaction language, is mainly discussed in this paper.

The first step in our DSL development methodology (Section 3) is the domain analysis where a domain and its concepts and relationships amongst them are identified using FODA methodology [85]. A domain is an area of knowledge or activity characterised by a set of concepts and terminology understood by practitioners within that area. A domain model in FODA is captured using a feature diagram. It is obtained after an extensive study of the domain under discussion by studying existing literature, existing implementations, and discussions with domain experts. In the past we have been extensively involved in the development of MASs and Semantic Web Services (e.g. [4,78,79]). Hence identifying concepts and their relationships within this domain has been fairly easy. In Fig. 3
                     , a feature diagram for Agent–SWS interaction is presented, where it can be seen that the main concepts are: SemanticWebAgent (SWA), SemanticWebService (SWS), and SemanticMatchmakerAgent (SMA). A SWA, which interacts with SWSs, might play different Roles and have various Plans (e.g., registration, finding, agreement, and execution plans) for achieving its goals. These agents are planned to collect Web content from diverse sources, process the information and exchange the results on behalf of their human users. SWA can also evaluate semantic data within these MASs and collaborate with semantically defined entities such as SWSs by using content languages. A SWS represents any service (except agent services) the capabilities and interactions of which are semantically described. SWS modelling approaches (e.g., OWL-S [99], OWL-L [100]) mostly describe the services by three semantic documents: Service Interface, Process Model, and Physical Grounding. We represent them as Interface, Process and Grounding elements. On the other hand, to realise agents communicating with a service registry and to discover service capabilities, an entity called the Semantic Service Matchmaker Agent is used that stores the capability advertisements of SWSs within a MAS and matches those capabilities with the service requirements sent by the other platform agents by playing its Registration Role.

The second step in our DSL development methodology (Section 3) is DSL designing where the language syntax and semantics are defined using a metamodel for describing a structure and denotational/translational semantics for describing a meaning. Concepts from a feature diagram (e.g., Fig. 3) become classes within the conceptual class diagram [101], while the relationships amongst the concepts within the feature diagram become associations enhanced with cardinality, navigability, composition, aggregation, and inheritance. Note that a conceptual class diagram is just another name for a metamodel where, at higher abstraction levels, classes are used to describe different concepts within a domain (e.g. a declaration within a general-purpose programming language). While, at a more concrete level, classes are used to describe the structure of a concept (e.g. a variable declaration consists of a variable type and a variable name). Fig. 4
                      presents a metamodel for the Agent–SWS interaction sub-language. It was derived at from the feature diagram (Fig. 3) by adding additional information about cardinality, and the names of associations.

In Fig. 4, the elements filled-in with light grey come from those other viewpoints that are shown at the top or bottom of the element using “<<” and “>>” stereotypes. In other words, these elements are common elements amongst viewpoints, and tailored to each other according to Fig. 2. For example, in the Agent–SWS interaction viewpoint, the Role meta-element comes from <<Role Viewpoint>> (see Fig. 4). Furthermore, the main element of the viewpoint is depicted using darker borders. Taking the Agent–SWS interaction viewpoint into consideration, SWS is the main element of the viewpoint and has a darker border than the other elements of the viewpoint (see Fig. 4).

SWS describes services by Service Interface, Process Model, and Physical Grounding. Service Interface is represented as the Interface element and provides the capability representation of the service in which service Input, Output, Precondition, and Effect (IOPE) descriptions are listed. The Process Model, as represented by the Process element, describes the internal composition and execution dynamics of the semantic service including IOPE. Finally, Physical Grounding, represented by the Grounding element, defines the invocation protocol of the web service. As the operational part of today's semantic services is mostly a web service, the Web Service concept is also included within the metamodel and associated with the grounding mechanism.

SWAs apply Plans for discovering, negotiating and executing the SWSs dynamically. The SS_FinderPlan is a Plan in which the discovery of candidate SWSs (considering their Interfaces) takes place. The SS_AgreementPlan involves negotiation on the QoS metrics of the service (e.g., service execution cost, running time, location) and an agreement settlement using the service Interface. After service discovery and negotiation, the agent applies the SS_ExecutorPlan for executing appropriate SWSs regarding their Processes and Groundings.

However, a formal semantic description is usually based on abstract syntax. Here, we are using transformations between metamodel and BNF, as described in [93,94]. The abstract syntax given in Listing 1
                      was derived at from the metamodel shown in Fig. 4.

Note that in the abstract syntax, a non-terminal PROGRAM is denoted as the main concept. Classes from the metamodel are mapped to non-terminal symbols inside this starting non-terminal. For the purpose of readability, it has been decided to move most of the non-terminal definitions inside a new non-terminal DEFS. The exceptions are the main concepts: the semantic web agents (SWA), semantic web services (SWS), and semantic matchmaker agent (SMA). These metamodel classes may be represented in the abstract syntax as keywords. In this manner, SWA is denoted by the keyword “swa”. Furthermore, each non-terminal is defined with a corresponding metamodel's class attributes and connections. For instance, the terminal symbol “id” stands for SemanticWebAgent attribute “name”, and non-terminal APPLIES for connection with the class PLAN. Note that the cardinality of connections also needs to be transformed into the abstract syntax. For instance, from the metamodel we can see that SWA may have several Plans. For this purpose, non-terminal APPLIES contains first and third productions that bring the possibility of several plans' definitions inside the semantic web agent.

When the abstract syntax is defined, we can develop a concrete syntax in parallel, as needed for parsing and semantics, and needed for describing a meaning. A part of concrete syntax for Agent–SWS interaction sub-language is shown in Listing 2
                      where additional keywords are added and multiplicities are exactly defined.

Complex constraints and relationships amongst concepts in the Agent–SWS interaction sub-language is captured by denotational semantics. In order to define the meaning of language constructs, we first define their semantic domains followed by auxiliary functions and the semantic equations. The semantic domain describes the domains for each syntactic construct within the language. Part of the semantic domain is presented in Listing 3
                     . In addition some auxiliary functions are required for facilitating the implementation of semantic rules. Listing 3 shows the semantic domains and auxiliary functions for SWA, SWS, and SMA. For example, a “SW-Agents” is a domain mapping function which maps an id of the agent into a set of plans and a set of roles (along with additional description and properties) that are associated with that agent. The Plan, as defined for SWA, is a collection of FinderPlans, AgreementPlans and ExecutorPlans. In a similar way, the domains are defined for the FinderPlan, AgreementPlan and ExecutorPlan. Some of the auxiliary functions are also shown in Listing 3 for the domain elements. For example the getPlans function of SWA takes the id of the agent, the list of the agents, and returns the plans for that agent id.

The meaning of the language is defined using semantic equations of denotational semantics. Part of the semantic equations for SWA, SWS, and their relationships are given in Listing 4
                     .

Lines 2 and 3 of Listing 4 define the meaning of the “swa” rule within the concrete syntax. The meaning of the rule expression “swa id APPLIES PLAYS” for context elements such as ag, pl, and ro (representing agent, plan, and role) is a mapping from the id of the swa agent to the meaning of the APPLIES rule within the context of pl and the meaning of PLAYS rule within the context of ro. These denotations are defined in A1 and A2 respectively. Line 4 defines the rule called swas within the concrete syntax. Similarly the meanings of APPLIES and PLAYS rules are defined in Lines 6–9 and 11–14, respectively. The semantic equations in Listing 4 collect any necessary information about SWA, SWS, and SMA in order to perform various controls on the constraints between the concepts. For example, the following four semantic controls are considered, which cover almost all of the relationships in the metamodel (Fig. 4):
                        
                           A.
                           During the design of an Agent–SWS interaction, if a SWA applies the FinderPlan that discovers an Interface of a SWS then, as the result of this discovery can be positive, at least one of the following interactions (2, 3, and 4) should exist between the Agent and SWS through AgreementPlan and ExecutorPlan. In a short form:

If
                                 
                                    1)
                                    WA-FindPlan-Interface-SWS

Then

SWA-AgreePlan-Interface-SWS and

WA-ExecPlan-Process-SWS and

SWA-ExecPlan-Grounding-SWS

The philosophy behind Agent–SWS interaction is the designing of possible interactions between a SWA and a SWS. So, for each SWA, there should be at least one interaction in some way with one of the SWSs. This interaction can be realised using one of the following:
                                 
                                    1)
                                    SWA-Role-SWS

SWA-FindPlan-Interface-SWS

If a SWA associates with a SMA and an Interface through a FinderPlan, then the SMA should associate with the same Interface through RegPlan, and with the SWS of the Interface, through RegRole. In a short form:

If
                                 
                                    1)
                                    SWA-FindPlan-SMA and

SWA-FindPlan-Interface

Then

SMA-RegPlan-Interface and

SMA-RegRole-SWS

For each SWS there is a SWA, such that one of the rules in constraint B is true for these SWAs and SWSs. In other words, for each SWS, there should be a SWA in such a way that one of the followings is true:
                                 
                                    1)
                                    SWA-Role-SWS

SWA-FindPlan-Interface-SWS

In order to understand these semantic controls more easily, constraint A including four rules is illustrated on the Agent–SWS interaction diagram, see Fig. 5
                     . Some of the unrelated elements e.g. IOPE are unconsidered to make the rules simpler to understand.

Denotational semantics of a SEA_L program is used for specifying its meaning. To this end, the denotational equation of semantic function P with constraint A is shown in Listing 5
                     . Semantic function P defines the meaning of a program with the meaning of its main components such as SWA, SWS, and SMA. Correspondingly, the meanings of these components are defined by their plans, roles for SWAs, processes, interfaces and groundings for SWSs, and registration plan and registration roles for SMA.

The third and last step in our DSL development methodology (Section 3) is a DSL implementation, where a complete compiler/interpreter is automatically generated from formal specifications written in LISA tool. LISA specifications are attribute grammar-based and consist of lexical, syntax, and semantic parts (Listing 6
                     ). The LISA tool produces highly efficient source code for the scanner, parser, and interpreter/compiler in Java. The lexical and syntactical parts of a language's specification use well-known formal methods, such as regular expressions and BNF. The semantics are further defined using attribute grammars.

The lexicon part of the Agent–SWS interaction sub-language is defined as Listing 7
                      in LISA. In addition, those attributes that are needed for some of the non-terminals are shown in Listing 8
                     . Each attribute type can be any valid type of Java, including any class which we define. So, as we can see in Listing 8, “val” and “code” are attributes of type Java String but the attribute called “pro” is of type class Process, which is defined at the end of the language specification definition in LISA.

Attributes from Listing 8 directly correspond to the semantic domain defined by the denotational semantics in Listing 3. Some attributes have been added to support four different constraints and code generation, as defined in the denotational equations (Listing 5 shows just the equation for constraint A).

Therefore, an attribute definition such as “Grounding *.gro” means that an attribute named “gro” of type class Grounding is added to all the non-terminals of the language (due to *). Of course it is possible to define an attribute to a specific non-terminal, e.g. “Grounding GROUNDINGID.gro”, however, to ease the programming the attributes are defined for all of the non-terminals.

Generally in LISA, non-terminals are defined in capital letters and the first rule is automatically considered as the starting rule of the language. The start rule of the Agent–SWS interaction sub-language in LISA is shown in Listing 9
                     .

According to Listing 9, the rule named “program” is the starting rule of the language. So, the starting non-terminal is PROGRAM. As we can see, the attributes for that non-terminal are obtaining their values from child nodes which mean they are synthesised attributes. This is because, the starting non-terminal has no parent node and its attributes are always of the type synthesised. In this rule, all the attributes of the other non-terminals (DEFS, SWSS, SMAS, SWAS) are inherited attributes. Note that the generated code is kept in an attribute of the element called “code”, as defined in the attribute section (Listing 8). The main task of the specifications in Listing 9 is to collect important information from DEFS, SWSS, SMAS, and SWAS. The collected data is then used to generate a code. Note that the constraints from Listing 5 are not yet implemented. In other words, the code is generated regardless of whether the constraints are fulfilled or not.

In a similar manner, all of the required rules are defined to allow the developer to generate all the necessary elements and relationships, as is stated in the metamodel. For example, implementation of the semantic equations of SWS rules (named B, B1, B2, and B3 in Listing 4) is shown in Listing 10
                     .

The “sws” rule (Line 18 of Listing 10) represents semantic equation B (Line 21 in Listing 4) where the “sws” has an id, set of Processes, set of Interfaces and a Grounding implemented via DESCRIBES, PRESENTS, and SUPPORTS rules. These rules are implemented in Lines 24, 32, and 37 of Listing 10 for the semantic equations B1, B2, and B3, respectively (Lines 27, 31, and 35 of Listing 4).

Implementations of some of the auxiliary functions are displayed in Listing 11
                     .

According to the code of Listing 11, in order to create any new element within the new language, e.g. new SWS, a hash table is created and all the instances of the element are stored within it, SWServices. In fact this class, SWServices, is a type of attribute of the SWS. As a result, during compilation both the abstract syntax tree and semantic tree are built. The prior helps to find out if the structure/syntax of the program is accurate. The latter uses the computations and auxiliary functions, and creates hash tables as attributes and gathers whole information about the instances of the elements and their relationships, within these hash tables. The attributes can be strings representing the code needed to be generated for the element. This can help to provide code generation.

The modularity of a specification can easily be achieved in LISA through language inheritance [22]. We have decided to implement the constraints separately from the generation of the code. It can be learned, from Listing 12
                     , that language SWSIV_Constraints is an extension of language SWSIV_Generation. The extension of SWSIV_Generation was possible in a non-invasive way and corresponds to language extension pattern as a special case of language composition [81]. So, within the first language (see Listings 9) there is the functionality of code generation. The second language provides constraints checking. The only rule that needs to be written inside language SWSIV_ Constraints is the rule “program”. Note, that this one is the first rule of the language SWSIV_Generation and we are actually extending it. The attributes of language SWSIV_ Constraints are those that carry the results of constraints checking (constA, constB, constC, and constD) and are further given to the function that is responsible for the code generation. Note that attribute “code” is evaluated in both languages and as such the attribute grammar fragments are conflicting. Hence, the approach by Sarasa-Cabezuelo and Sierra [80] would be inapplicable for this example. However, in our approach the rule from language SWSIV_ Constraints extends the rule from the core language, and the semantic equation from the first language is overridden by the semantic equation from the language SWSIV_ Constraints.

During the parsing of the program, the code is generated while the parse tree is being established and is merged while traversing between the nodes of the tree. Finally, at the end of compiling, all the attributes including the code attribute are collected within the start symbol of the grammar, “PROGRAM”. According to the computation rules for the start symbol, all of the code attributes are collected within the code attribute of the start symbol using the “generate” function (Listing 13
                     ).

When considering the invocation of constraints A (in Listing 9 and 12), an attribute is added to the language specifications called “constA” and a computation rule is added to the start symbol as

PROGRAM.constA=checkConstraintInteractionAgentSWS(SWAS.ag, DEFS.sws);

The auxiliary function called checkConstraintInteractionAgentSWS, performs the required semantic controls declared in constraint A using some other auxiliary functions, and other attributes. This function is illustrated in Listing 14
                     .

In Listing 14, the list of agents including their plans and role relationships are taken in Line 1 and iteration is started in Line 5 over these plans and roles. Then the plans are extracted from the hash table in Line 7 and in the case of it not being empty, iteration is started over those plans in Line 10. Then if a plan is the type of FinderPlan in Line 12 (until now we have found a FinderPlan associated with our SWA), the control continues as follows: In Line 13, the elements of the FinderPlan and its relationships with other elements are extracted from its hash table and in Line 15 iteration is started over its elements (SMA and Interface). Line 18 checks if there is any Interface, with which the FinderPlan is associated, the list of the interfaces is extracted in Line 19, and iteration starts over them in Line 20. Until now, for our SWA, we have found an associated FinderPlan that has an association with an Interface. In the next step, we are going to find a SWS that the Interface describe. This is fulfilled in Lines 23–31. In Lines 32 and 33, if a SWS is found, the result of the first part of the semantic rule is true.

This means that there is a FinderPlan for the SWA with which it associates and the FinderPlan discovers an Interface of a SWS. The three other constraints are controlled in a similar manner and the result is manipulated using the logical ‘and’ operation, since “if A then B and C” is logically equal to “A and B and C”. The final result is used to control whether the code should be generated or a special error-code should be produced.

It is also possible to generate specific error codes depending on the place at which the rule goes wrong. The mechanism for this kind of error generation is conceptually specified in Listing 5 with the denotational equations for the semantic function (named P) of a SEA_L program considering constraint A (Listing 4). Accordingly, during implementation, different parts of a constraint, such as constraint A, can be checked and in the case of any violation, an error can be generated. For example, in Listing 14, considering the implementation of constraint A, it is possible to distinguish various cases for violation of the constraint and generate different errors, e.g. if a SWA has no plan at all in Line 08, we can return a specific error code. Similarly, in Line 18, we can check if there is no interface connected to the plan of the SWA, which violates the constraint A and is another type of error for constraint A.

SEA_L can be utilised for different domains when helping in the designs and developments of the agent-based systems of those domains such as agent-based business evaluation [102], e-commerce [103], document management [104], streaming on networks [105], energy saving [106], the e-barter system [107], and the stock exchange system [108]. In order to illustrate the usage of the introduced DSL and its semantics, the modelling of an Agent–SWS interaction for a multi-agent-based expert finding system is considered in this study.

Let us consider that there exist web services for supplying expert needs for people. Suppose that the software agents in an expert finding system work on the web by using service ontologies, find candidate services, and then try to make an agreement with those services on behalf of their human users by taking into consideration QoS metrics. Starting from a motivating example, we discuss the development of the system in the remainder of this section.

As a motivating example, consider the following scenario in which a user (person) requests an expert on communication services. The user Ann wants to communicate with her cousin Lee. However, she has had no contact with her for a long time and does not have Lee's contact information including what kind of communication services Lee uses, and those services which could be used to contact her (e.g. Social network, e-mail, VoIP, and mobile phone number).

First of all, Ann has to find the right person anyway. When she chooses to search, a graphical user interface is created automatically by her agent so that she can provide some information regarding the request about finding this person. She chooses the concept of a family tree from the filtering criteria in the user interface and then she enters the name, surname and relationship to her. Ann was a bit surprised when she received the results. She saw that Lee Smith could not be found, but the semantic matcher returned a person Lee Burke as a possible match according to the family ontology. If the search of Ann's agent had been based on a traditional text search, then Ann would not have found her cousin. However, the use of a semantic matcher that works on ontological representation of the family tree enabled Ann to find her cousin under another surname. Ann was surprised as she did not know her cousin had just got married. Nevertheless, the photo of her cousin definitely confirmed that the system had returned the right person.

Within a semantic environment, such a system works using ontology graphs. Semantic matchers traversed the family ontology to find Ann's cousin. Traversing on the graph and inference based on this traversal can be accomplished by the applications of certain algorithms that basically deal with information extraction. These approaches and algorithms can find the required approximate node on an ontology tree. In fact, they succeed in finding the nearest nodes to the desired value. Details of this ontology traversal and semantic matching operation are beyond the scope of this paper. However, interested readers may refer to [5] and [25] for the general idea of semantic matching.

After finding the right person, according to Ann's request for communicating with Lee, in the next graphical user interface, she is then asked by her agent to choose the way she wants to communicate. She prefers audio talking with her cousin. Her agent offers to contact Lee via a VoIP using GoogleTalk (GTalk) [109]. This selection is made upon the intelligence that checks both the user's input such as free talking and the user's information, which is gathered automatically using such as connection bandwidths, applications installed on mobile devices, and so on. In addition, Ann decides to send Lee a bunch of flowers, in view of her recent marriage. So, Ann asks her own agent to find the appropriate service. To do this, Ann enters the required information such as the desired flower's name, colour, amount, and the cost range, in order to limit the selections. The agent considers these parameters along with some other QoS parameters such as the distance of the flower shop from Lee's home address (which is automatically extracted), and the cost of the delivery service (as a composite service) accordingly. The result includes selecting a flower shop and a delivery service company that are altogether within the cost range of Ann's request.

When considering the system design of this case-study, the required result about communication and shopping services is gathered by the interaction between semantic services and agents within a MAS. Ann's request is held by a SWA inside a SS_FinderPlan instance according to the SEA_L's Agent–SWS interaction viewpoint. The SS_FinderPlan instance basically finds the appropriate semantic web services that have already been registered with a SS_RegisterPlan, and returns the list of these services to a SSMatchmakerAgent to advise Ann's agent about candidate services. The discovery of the semantic services by the SS_FinderPlan is made semantically by traversing the Service Ontology. A graphical representation of an example of the Service Ontology structure is given in Fig. 6
                      with ontology classes, and their subclass-superclass relationships.

Ann's agent (which is an instance of SEA_L SWA meta-entity) uses both the input given by Ann via the system interface and the information gathered by the agent while traversing the ontology graph. As a result for the communication part of the request, using ontologies, the agent decides that “talking” is a kind of communication that is online. The input requires a talk thus a chat or social network is unconsidered. According to the information, the bandwidth is insufficient for multimedia video talking. So, it goes on searching for a suitable medium within the VoIP services in regard to the sub-ontology, which is illustrated in Fig. 7
                     .


                     Fig. 7 shows a sample VoIP service ontology. Ann's agent communicates with Lee's agent to query whether Lee's phone has the required phone application. Since Ann and Lee's mobile phones have Internet connections, any kind of VoIP including phone to phone (P2P), web to phone (W2P), and web to web (W2W) is possible. However, when considering free calls, Nonoh [110] and Jajah [111] are excluded. In the same way, in regard to the applications installed on both mobile phones, Ann's agent's SS_FinderPlan provides the candidate services list containing GTalk and OOVOO [112] by interacting with the SSMatchmakerAgent. Then, the agent's SS_AgreementPlan chooses GTalk based on its sound quality.

In a similar manner, based on the human user request, the agent decides to buy the flowers from an e-flower shop called “Beautiful Flowers”, and sends them via a delivery company called “Deliver Anywhere”. The decision is made based on the QoS parameters that are both taken from Ann and extracted from the system automatically. For example, some of the flower shops are never considered in the result of the negotiation due to the type of flowers (see Fig. 6), their colors (exact matching), and some others that are not selected due to the result of negotiation regarding the price. Furthermore, some of the delivery companies are omitted because of their delivery times, the delivering service being unavailable for small things such as flowers, or as a result of negotiation on the cost of the delivery.

When considering the scenario, we modelled the communication and shopping processes using SEA_L. We considered SWA agent instances and modelled these agents' interactions with semantic web services and web service internal components.

In order to provide a bigger picture of the case-study, the general idea of the system from the Agent–SWS interaction point of view is depicted in Fig. 8
                     . This diagram shows the main elements of the expert finding system and its relationships. It is based on the metamodel discussed in Section 4. When considering this big picture of the system, we could easily write the program model in SEA_L.


                     Listing 15
                      shows the instance program model from the Agent–SWS interaction viewpoint including semantic services and the required plan instances. Ann's agent, “MobileUser”, is modelled with proper plan instances to find, make the agreement with and execute those services that are instances of the SS_FinderPlan, SS_AgreementPlan, and the SS_ExecutorPlan, respectively. The services are also modelled with the interaction between the semantic web service's internal components (such as Process, Grounding, and Interface), and the SWA's plans.

So, when considering Ann's communication request, her agent plays the “Search” role and applies its “Lookup” plan to find an appropriate “Communication” interface of “Communication” SWS. This plan realises the discovery via interacting with the “ServiceMatcher” that has registered the services by applying the “ServiceRegistration” plan. Next, the agent applies its “Negotiating” plan for negotiating with the already discovered services. This negotiation is done through the “Communication” interface of the SWS. Finally, if the result of the negotiation is positive, the agent applies the “EstablishingConnection” plan to call the “Calling Web Service” of the SWS by executing its “Communicator” process and using its “ServiceProvider” grounding with which the service is realised.

In a similar manner, due to Ann's request for flower shopping and delivery, her agent plays the “Search” role. It also applies the “Lookup” plan to find the “FlowerPresent” interface of the “FlowerDelivery” semantic web service, which is composed of the “E-Flower” and “Delivery” services. The “ServiceMatcher” and its “ServiceRegistration” plan help the “Lookup” plan in its goal. Then, the agent negotiates with the selected services' interfaces and if the result is successful, the agent applies its specific execution plan, “Carriage”, to call the “FlowerDelivery” SWS, by executing its “Shop&Deliver” process, and using its “FlowerProvider” grounding.

Finally, in order to develop the system the program model is controlled in SEA_L based on the constraints previously discussed in Section 4 and the architectural code is generated automatically for JADEX and OWL-S. A snapshot of the result for the semantics control is illustrated in Fig. 9
                     .

In Fig. 9, firstly the result of semantics control is provided and next a report for the generated code is shown. In the semantic control part, we can see the results for the rules within the constraints including constraints 1 to 4 and their sub rules. For the code generation, the language presents the number of ADF files, Plan files and OWL files that are generated from the program model.

As discussed in Section 4, modularity of specification was achieved with language extension [81] (see Listing 12, again). The language extension was easy, as concepts from language SWSIV_Constraints are orthogonal to the concepts from language SWSIV_Generation. As a result, we can also use the same DSL program (Listing 15) for original language SWSIV_Generation. Of course, the result of the program in Listing 15 on language SWSIV_Generation is different than in Fig. 9—the result contains only a summary of the generated code.

JADEX is one of the well-known and frequently used agent platforms in agent research and development studies. Its open-source Application Programming Interface (API) enables agent programmers to develop Belief-Desire-Intention (BDI) agents [98]. JADEX has an agent-oriented reasoning engine for coding rational agents with Extensible Markup Language (XML) and the Java programming language. The development of JADEX agents is based on a hybrid approach in which a declaration of static agent properties and the programming of executable agent plans take place. The declaration of static agent properties is given in files called Agent Definition Files (ADF). An ADF is written using XML and specifies the BDI model of the related agent. Moreover, agent plans are those executable components that are given in the Java program files. The JADEX reasoning engine starts the deliberation process by considering the goals requested by the agent. To this end, it adopts those goals stored in the database that contain all the adopted goals by the agent, called the agent's goal-base [15].

There is a base notation including three major terms regarding the JADEX architecture: beliefs, goals and plans. The beliefs are Java objects that represent the environmental facts that an agent has and are stored in a belief-base. The belief-base contains the facts that an agent possesses, in other words, it represents the knowledge of the world in which the agent is situated. Beliefs may change over the course of time within a dynamic environment, thus the belief-base needs to be updated in the long run. The goals in JADEX resemble the desires discussed in [98] to some extent. However, the goals are a vital part of JADEX rather than the events in traditional BDI systems. JADEX plans are Java classes that can be executed in order to achieve the goal of an agent. Plans have two parts: plan head and plan body. Furthermore, each agent has an ADF file, an XML-formatted file, in order to configure the agent's structure.

The result is an architectural code generated by the tool. For example, an ADF file is generated for the system agent, MobileUser. The generated ADF file is given in Fig. 10
                     . In this figure, all of the meta-elements and their attributes correspond to the related tags of JADEX ADF. An excerpt of the code for defining a “MobileUser” agent and some of its plans is given in Fig. 10. All the attributes of the JADEX metamodel are excluded in the SEA_L metamodel. Therefore, lines 21 and 30 contain the default values of the corresponding attributes. In order to prevent repetition, only two of the Plan instances are given in Fig. 10. The “Lookup” plan, Line 15 is the Finder Plan of the “MobileUser” agent for finding the “Communication” semantic web service. Similarly, the “Negotiating” plan in Line 24 is the Agreement Plan for negotiating with the “Communication” semantic web service.

By considering the generated artifacts, two types of files are generated for the Agent–SWS interaction viewpoint. One group is for the agent part of the system (JADEX agents) that includes the ADFs of the JADEX agents and different plans for these agents (e.g. RegisterPlan, FinderPlan, etc.). Another group is for the Semantic Web Service part of the system (OWL-S components) that includes related files for service interface, process, and grounding.

As a result of compiling the program for this case-study, 2 ADF ?thyc=5?> files (one for the SWA and one for the Matchmaker in the case model namely “MobileUser” and “ServiceMatcher” agents), 5 different plan files (EstablishingConnection, Lookup, Negotiating, ServiceRegistration, and Carriage plans for both agents), and 4 OWL documents are generated based on the designed model for the case-study, see code reporting part in Fig. 9. Fig. 10 shows an excerpt of the generated code for MobileUser agent in ADF format. As was discussed earlier, in this excerpt of the generated code, part of the header and the body of the generated ADF file are illustrated. As we can see, in the Plans section of the body, the definition of each plan of the agent is provided.

Generally, the semantics of the programming languages deal with the meanings of the programs written in those languages. Formal semantics try to describe the meaning using mathematical approaches.

In our previous studies [13,14] translational semantics were provided using transformations to other formal languages such as JADEX and OWL-S. That means we first defined entity mappings between SEA_L instance models and JADEX agent platform and again between SEA_L service entities and OWL-S profile, process and grounding components. Based on these mappings, rules were implemented for transformation from SEA_L to JADEX and OWL-S. At runtime, those rules were executed on SEA_L instance models and hence target instance models conforming to JADEX and OWL-S metamodels were automatically achieved. The operational or translational semantics are essential for a DSL or DSML in order to have executable results from these languages. Therefore, we also provided code generation from models using model-to-code transformations. However, the translational semantics are not powerful enough to provide a formal way of describing the meaning of the software system; and we needed more formal approaches for describing the specifications of these languages.

For this purpose, we used Alloy in [16] and [17] for providing formal semantics and describing the logic of the instance models. Alloy is based on a set theory, predicate logic and first-order logic [74,75] which have been used for analyses and the semantic controls in various studies [76,77,113]. It is suitable for representing the semantics of a DSL, as the meta elements can be represented by signatures (sets), and the relationships can be modelled as relationships between these sets. The constraints can be defined using multiplicity and the semantics rules can be stated as predicates in which we could have details of the rules described using predicate and first order logics. Hence, for each viewpoint of the language, we provided Alloy signatures, semantic constraints and rules ([16,17]). Inside the environment of the Alloy tool, such a definition of formal semantics enabled us to examine the scope of analysis regarding instance models, property checking based on some assertions, and model finding within a specified scope. In addition, monitoring the change encountered in agent models at runtime was also possible. For instance, the effect of creating and adding a new semantic web agent to a running MAS environment can be dynamically examined and checked according to the semantics of the language.

However, Alloy defines the elements and relationships using its own meta elements, signatures, and the relationships between them; and defines the rules based on these elements. In other words, axiomatic semantics generally and Alloy language specifically, make no distinction between a phrase's meaning and the logical formulas that describe it; its meaning is exactly what can be proven about it in some logic. When considering the representation of DSL semantics with Alloy, the formal semantics and the operational semantics cannot be covered within the same model. Although Alloy has the power of demonstrating the dynamic semantics using Time and Order concepts, operational and axiomatic semantics are not integrated. As a result, in our case, the code generation and semantic controls with Alloy could not be attributed to a single language.

Hence, we can state that the required language semantics were not built into the language itself in those previous works [13,14,16,17] and dynamic control of the semantics is directly bound within other environments. In our study, attribute grammars are used to implement part of the semantics of SEA_L. Attribute grammars can be mapped to denotational semantics where the target language is simply the original language enriched with attribute annotations. These attributes can be used to carry the desired semantics of the language.

Some of the constraint programming languages, e.g. OCL [114–116], can implement and integrate the constraint controls within the language and its translational semantics. In this way the translational semantics' and the constraints' controls are embedded within the language [117]. However, most researchers do not consider the representation of the semantics, some constraints in OCL, as a formal representation method. In addition, implementing these constraints in OCL is more difficult than implementing them within a general purpose language such as pure Java, in the case of attribute grammars in LISA.

However, this integration problem can be partially solved by other alternative formal approaches, e.g. by using denotational semantics, more specifically by using the attribute grammars in our study. In the case of MDA, where we can use a grammar to represent the abstract and concrete syntax, attribute grammars can be used for resolving some of the formal semantics' shortages discussed above. In fact, the grammar part of this approach helps to build a language that can be used to provide operational semantics and execution items, and on the other hand, attributes added to the grammar can represent those semantics used to control the constraints. In this way, both the translational and the formal semantics are integrated within a single language.

In addition, applying a formal declarative description for the syntax and the semantics of the language has other advantages. For example, it is possible to automatically generate the language from the high level descriptions. It is also possible to do automatic model checking from these descriptions. On the other hand, we can discover the problems with the language in the earlier stages of its development, during the design period. So, substantial effort and time are saved when testing and iterating the development process.

Moreover, the use of declarative description as the formal method for language description leads to higher modularity for the system. Not only does declarative description separate the syntax and semantics definitions but it also provides the required mechanism for dividing the grammar and semantics definitions in some modules. In other words, specification can be divided into different fragments, each dealing with different aspects. In this way the language is easy to extend, so the developer of the language can build the core of the language and provide new properties for the language by adding new modules; or even by inheriting from available languages and extending them within the new language (additional examples are shown in [81,118,119]). For example, in our case we developed the base language for SEA_L and then added the constraint controls in a separate module.

Finally, when using LISA as a tool to implement an attribute grammar based language, we could provide some additional advantages in addition to the above-mentioned advantages for declarative descriptions for formal semantics. LISA, as a compiler-compiler, is the provider of BNF Viewer, Syntax Tree Visualiser, Evaluator Tree Visualiser (Semantic Tree), Automata Visualiser, and DG (Dependency Graph) Viewer. When taking Semantic Tree into consideration (Fig. 11
                     ), it can provide the tree for representing the way the meaning of a program is calculated based on the semantic rules during the compilation. This is similar to the Syntax tree that shows how the syntax of the program is evaluated based on the underlying syntax rules of the grammar. Fig. 11 is the snapshot of a moment during the compilation and semantic computation. As the semantic for the whole case is very extensive, only a part of it is illustrated in Fig. 11. These facilities helped us during the development of the language and the semantics. They can also help the user to have more syntax and semantic control of his or her program during the early stages.

@&#CONCLUSION@&#

This paper presented the implementation of a DSL for MAS called SEA_L including its translational semantics (code generation) and semantics controls for the language (constraints to check the programs) in an integrated way. The syntax and semantics of the language are defined formally using denotational semantics and the implementation is realised based on the formal semantics using attribute grammars. In addition, the application of the language is represented via a case-study. The implementation is realised in LISA tool.

As with the methodology, the domain analysis is performed with FODA. We created a metamodel from the feature diagram by adding cardinality and more relationship types. Using this metamodel, the abstract syntax of the language was defined as a context-free grammar. By adding the keywords of the language to the context-free grammar and using syntax sugaring, we provided the concrete syntax which is implemented in LISA. At the same time, we defined the semantics' domains and their equations in the form of denotational semantics based on those constraints that we had extracted from the metamodel using our experience within that domain. Then, as a modular approach, firstly, we developed the core language including the syntax with the ability of code generation. Next, the core language was extended by transforming the semantic equations of the denotational semantics into semantics computations in LISA.

Applying denotational semantics provided us with accurate and precise definitions of the language. Also, by using the discussed methodology, we can generate the aimed language automatically from formal semantics. In addition, using attribute grammars adds modularity to our methodology. Not only the syntax (BNF) and the semantics (semantics computations) are separated but also the development of the problem domain can be realised step by step. In other words, the core language, e.g. syntax and code generation, can be implemented as the first step and a new extension of this language can be provided by adding semantic controls to the core language. This methodology makes evolutionary language development easier and may be a guide to the implementation of tools which support language extensions (e.g. Neverlang [120]).

Despite the advantages of this methodology, we experienced some challenges and difficulties. First of all, there is a learning-curve for beginners to become familiar with attribute grammars and denotational semantics. On the other hand, only the static properties can be checked using attribute grammars (i.e., only those which can be computed from a DSL program and not from its execution). For example, we would like to perform various checks depending on the availabilities of various web services, which can be computed only during DSL program run-times. Hence, in our next work, we will consider enriching the semantics of the language to include the dynamic semantics integrated within the language and with its operational semantics. The static semantics can help the user during the design time and these types of constraints are controlled during the compilation time. They can help the developer to determine the static problems of the program model. However, dynamic semantics can be checked during runtime in order to guide the user to observe the rules of the system as it runs. This kind of checking is more favourable within autonomous and dynamic systems such as MASs. Considering these rules during the design time can lead to the saving of substantial cost and effort during software development.

@&#ACKNOWLEDGMENT@&#

This study was funded as a bilateral project by the Scientific and Technological Research Council of Turkey (TUBITAK) under grant 109E125, and the Slovenian Research Agency (ARRS) under grant BI-TR/10-12-004.

@&#REFERENCES@&#

