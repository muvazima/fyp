@&#MAIN-TITLE@&#Robust diameter-based thickness estimation of 3D objects

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a robust diameter-based thickness estimation method for 3D objects.


                        
                        
                           
                           This method is based on the Shape Diameter Function and a robust distance function.


                        
                        
                           
                           Benchmark results against operations and artifacts show the robustness of our method.


                        
                        
                           
                           Results regarding the accuracy also show improvements.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

3D object

Surface

Mesh

Thickness

Robustness

Shape Diameter Function

@&#ABSTRACT@&#


               
               
                  We propose a robust thickness estimation approach for 3D objects based on the Shape Diameter Function (SDF). Our method first applies a modified strategy to estimate the local diameter with increased accuracy. We then compute a scale-dependent robust thickness estimate from a point cloud, constructed using this local diameter estimation and a variant of a robust distance function. The robustness of our method is benchmarked against several operations such as remeshing, geometric noise and artifacts common in triangle soups. The experimental results show a more stable local thickness estimation than the original SDF, and consistent segmentation results on defect-laden inputs.
               
            

@&#INTRODUCTION@&#

Estimating the local thickness of complex 3D objects is a multi-faceted problem with a variety of applications. In computer graphics, algorithms such as mesh partitioning or curve skeleton extraction can successfully rely on a local thickness estimate such as the so-called Shape Diameter Function (SDF) [1]. In these applications, the robustness of the local thickness estimate is still a challenge. In this paper the notion of robustness relates to the resilience of the thickness estimate to both editing and processing operations applied to the shape, as well as to defect-laden inputs.

A shape can be altered to meet the limited computational capabilities of heterogeneous computer hardware, by, e.g., matching a target level of detail. Assuming an input shape provided as a surface mesh, this goal commonly involves processing operations such as mesh simplification [2]. In this context, any thickness estimate should ideally be consistent for all levels of detail. A shape can also be animated, involving complex distortions. We expect that articulated animations have only minor effects on the thickness overall, as changes only occur at the joints which are in general a small subset of a shape. In this context, a local thickness estimate should ideally be consistent across all poses of an animation.

When digitizing, the original physical shape is only known through sampling and approximation. A triangle mesh is an instance of such piecewise-linear approximation of a surface. In addition to the inherent uncertainty of any measurement device and imperfections of the acquisition process, some imperfect algorithms along the geometry processing pipeline may produce a range of artifacts such as gaps, holes, non-manifold parts and triangle soups. While a thread of research has focused on repairing defect-laden data or removing artifacts, there is currently no definitive solution to such defects [3]. Moreover, some applications gather data from heterogeneous inputs and thus require converting between shape representations. These conversions also lead to artifacts such as handles or disconnected components. Ideally, a thickness estimation would provide results that are both robust and consistent for all these cases.

@&#RELATED WORK@&#

One definition of the local thickness of a 3D shape is based on its medial axis transform (MAT). The MAT was initially introduced to represent 2D shapes through the loci of maximally inscribed circles [4]. In 3D the medial axis 
                        
                           M
                        
                      is defined as the loci of centers of maximally inscribed spheres. The MAT of a 3D object is defined from the medial axis and the set of sphere radii, which defines a scalar field onto 
                        
                           M
                        
                     . On the boundary of a smooth 3D object, each point has a unique corresponding point on the medial axis, which is the center of the maximally inscribed sphere tangent to the boundary point. Through this correspondence one can map the radii of the spheres centered at the medial axis onto the surface, thus defining the local thickness for each boundary point [5] (Fig. 1
                     ). Extracting the medial axis of a surface is complex [6] however, as it is very sensitive to small variations of the surface. This issue is critical when dealing with defect-laden inputs as small irregularities on a smooth surface may create large spikes on the medial axis. To alleviate this issue some robust variants taking advantage of the notion of scale have been proposed [7].

An approach to compute an intuitive and pose-invariant local thickness from surface meshes was explored with the Shape Diameter Function (SDF), based on statistics upon local diameter estimates. Given a query boundary point q, a single local diameter estimate is defined as the length of the segment joining q and the first intersection between the input mesh and a ray shot from q and aligned to a vector located inside an inward cone. The diameter does not rely on computing the medial axis in order to alleviate the aforementioned issue. It is experimentally shown that the SDF is stable with respect to articulated deformations and provides an effective means to consistently partition surface meshes over multiple poses. Its robustness with respect to noise and defect-laden inputs can however be improved. The original SDF has also been improved in terms of computational complexity by performing down-sampling followed by efficient interpolation [8]. This procedure improves the computational time of the original SDF, at the cost of a lower robustness for segmentation.

Extending the SDF approach, we propose a robust method to estimate the local thickness of a 3D object bounded by a surface mesh. Inspired by ideas introduced for robust medial axis extraction, we devise a scale-dependent estimation method. As contributions we (i) improve the accuracy of the original SDF, and (ii) provide several experimental evidences that illustrate the robustness of the proposed approach. These results also show benefits for robust shape segmentation. In the following the term “thickness” relates to our robust scale-dependent diameter-based thickness, while “mathematical thickness” relates to the radius of the maximal inscribed sphere (MAT).

The input to our algorithm is a surface triangle mesh - denoted by 
                        
                           S
                        
                      - bounding the input 3D object. 
                        
                           S
                        
                      may contain defects such as noise or holes. The algorithm for computing the thickness of 
                        
                           S
                        
                      comprises two main steps. First, we compute a cloud 
                        
                           D
                        
                      of half-diameter points d
                     
                        i
                      (Section 3.1). This step extends a curve skeleton extraction technique [1] originally presented as a direct extension of the SDF computation. Second, we define a robust scale-dependent thickness function t
                     
                        k
                      (defined for arbitrary query points on 
                        
                           S
                        
                     ) using a noise- and outlier-robust distance function between each query point q
                     
                        i
                     , and the half-diameter point cloud (Section 3.2).


                     Algorithm 1 provides a general overview of our method.
                        Algorithm 1
                        Overview of our thickness estimation algorithm. 
                              
                                 
                                    
                                    
                                    
                                       
                                          1:
                                          
                                             Procedure Thickness(Input mesh 
                                                
                                                   S
                                                
                                             ; sampling size n; boundary point queries 
                                                
                                                   Q
                                                
                                             ; scale parameter k)
                                       
                                       
                                          2:
                                          
                                             Random sampling of 
                                                
                                                   S
                                                
                                              with n points
                                       
                                       
                                          3:
                                          
                                             
                                             for all Sample points p
                                             
                                                i
                                              
                                             do
                                          
                                       
                                       
                                          4:
                                          
                                             Probe mesh volume at sample p
                                             
                                                i
                                             
                                          
                                       
                                       
                                          5:
                                          
                                             Compute a local estimation of the diameter
                                       
                                       
                                          6:
                                          
                                             Create a half-diameter point d
                                             
                                                i
                                              and add it to 
                                                
                                                   D
                                                
                                             .
                                       
                                       
                                          7:
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          8:
                                          
                                             
                                             for all Query points q
                                             
                                                i
                                              in 
                                                
                                                   Q
                                                
                                              
                                             do
                                          
                                       
                                       
                                          9:
                                          
                                             Search appropriate k nearest neighbors d
                                             
                                                i
                                              in 
                                                
                                                   D
                                                
                                             .
                                       
                                       
                                          10:
                                          
                                             Compute robust distance function
                                       
                                       
                                          11:
                                          
                                             
                                             return scale-dependent thickness t
                                             
                                                k
                                             
                                          
                                       
                                       
                                          12:
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          13:
                                          
                                             end procedure
                                          
                                       
                                    
                                 
                              
                           
                        

The procedure for generating half-diameter points is summarized by Algorithm 2. The main input to the algorithm is a surface triangle mesh 
                           
                              S
                           
                        , which is first uniformly point sampled in order to generate a set of boundary points 
                           
                              P
                           
                        . Section 4.1.1 provides implementation details on this sampling step.

Given a boundary sample point p
                        
                           i
                        , the original SDF is computed by: (i) casting random rays inside an inward-oriented cone along the normal and computing their intersection with the input surface 
                           
                              S
                           
                        , which defines a series of segments; (ii) measuring statistics δ based on a weighted average and the variance of the lengths of these segments; and (iii) smoothing the final thickness function over a small neighborhood and normalizing the output in log-space [1].

While this algorithm yields a sufficiently discriminative diameter estimate for mesh segmentation, we introduce several methodological differences to improve its accuracy and robustness, starting from the random re-sampling of 
                           
                              S
                           
                        .

Although effective when dealing with normal distributions of lengths, the outlier-robust statistics δ computed in the SDF often yields counter-intuitive estimations of the diameter. Consider the following dummy example: with two (infinite) parallel planes, the diameter can be estimated exactly and is equal to (twice) the mathematical thickness. Most importantly, this configuration does not involve scale-dependent quantities. Therefore, any thickness computation algorithm should provide an estimate as close as possible to half the diameter value. However, averaging multiple lengths inside a cone systematically overestimates the diameter. When dealing with mechanical parts and piecewise flat surfaces, this situation is quite common and δ always over-estimates th expected value. A more accurate value for δ would then be (half) the minimum length of the rays cast inside the cone.

In the case of a tubular section with a circular cut, the mathematical thickness also coincides with half the length of a ray cast along the normal. This value is however not given by the minimum lengths of all possible random rays cast inside the cone. At the bifurcation of a Y-shape, the larger the opening of the cone, the more noise is added to the diameter estimation δ when taking an average ray length. In this case, notice that the outlier-robust strategy of the SDF, which is based on the median ray length, is inappropriate: the closest value to the mesh diameter (and the mathematical thickness) is given by a single minimal estimate among many noisy larger ones.

In all these examples, the larger the half-opening ϕ of the cone, the more δ differs from the mathematical thickness or from the mesh diameter. Nevertheless, a large opening angle is necessary to capture more information on the shape and to detect a masking feature such as protuberances or dents depicted by Fig. 2
                           c. All possible configurations are not addressed when designing statistics to compute δ from the R ray lengths. However, in cases where the notion of scale is not needed, and when the mathematical thickness and the mesh diameter are identical, the accuracy and relevance of δ can be measured by its closeness to, e.g., the mathematical thickness chosen as “ground-truth”.

To alleviate the dilemma between a large and a small opening angle of the cone to probe the local volume, we adopt an adaptive method when casting the rays inside the cone. Such a method provides a more conservative estimation of the diameter than the SDF. The aperture angle is initially set to a large value ϕ, and R rays are cast inside this cone. Let l
                           min be the minimum ray length. This ray casting procedure is iteratively repeated while decreasing the opening angle by a step η, yielding each time a new length l
                           min. At each step the stability of l
                           min is estimated by computing its absolute growth rate r (see Algorithm 2). If r is valued above a threshold τ, the process ends and δ is set to the previous l
                           min. Otherwise, δ is set to a final l
                           min after I iterations. In practice, we set ϕ
                           =25°, R
                           =5, η
                           =2°, τ
                           =0.8 and I
                           =10. Thus, the procedure either ends with a variation of l
                           min larger than 80%, or when the aperture of the cone reaches ϕ
                           −
                           Iη
                           =5°.

The results of this procedure are illustrated by Fig. 2. In Fig. 2a, δ is eventually set to half the length given by the ray cast along the normal. In Fig. 2b, the tubular section has a circular cut and our procedure ensures that the half-opening of the cone is very small when estimating the final l
                           min, thus improving the accuracy of the estimate: with the previously described parameter settings, r
                           <
                           τ holds true until ϕ reaches its minimum value of 5°. Fig. 2c shows that the adaptive closing algorithm stops when a large variation in the minimum ray length is detected. In this particular configuration, our procedure ensures that δ does not get too large.

We create the half-diameter cloud, a point set approximating the middle of the shape using the diameter information δ (Fig. 3
                           ). This step is similar to the one proposed for extracting a curve skeleton [1]: the sample points are projected into the shape using their normal direction at half δ, thus creating the point set denoted by 
                              
                                 D
                              
                           .
                              Algorithm 2
                              Half-diameter points computation. 
                                    
                                       
                                          
                                          
                                          
                                             
                                                1:
                                                
                                                   Procedure Half-diameter points(Input mesh 
                                                      
                                                         S
                                                      
                                                   ; boundary point queries 
                                                      
                                                         Q
                                                      
                                                   ; sampling size n; cone aperture ϕ; rays R; iterations I; step η; variation threshold τ)
                                             
                                             
                                                2:
                                                
                                                   
                                                   for all facets in 
                                                      
                                                         S
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                3:
                                                
                                                   
                                                   Generate (uniformly) a sampling set 
                                                      
                                                         P
                                                      
                                                   
                                                
                                             
                                             
                                                4:
                                                
                                                   
                                                   
                                                   for all 
                                                   
                                                      
                                                         
                                                            
                                                               p
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ∈
                                                         P
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                5:
                                                
                                                   
                                                   
                                                   
                                                   r
                                                   ←0, j
                                                   ←0
                                             
                                             
                                                6:
                                                
                                                   
                                                   
                                                   Cast R random rays from p
                                                   
                                                      i
                                                    inside cone (p
                                                   
                                                      i
                                                   ,
                                                   n
                                                   
                                                      p i,
                                                   ϕ) ▷Cone defined by apex p
                                                   
                                                      i
                                                   , direction as normal at p
                                                   
                                                      i
                                                   , aperture denoted by ϕ.
                                             
                                             
                                                7:
                                                
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                            
                                                               B
                                                            
                                                         
                                                         ←
                                                      
                                                    Compute minimum ray lengths
                                             
                                             
                                                8:
                                                
                                                   
                                                   
                                                   
                                                   While
                                                   j
                                                   <
                                                   I 
                                                   do
                                                
                                             
                                             
                                                9:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   j
                                                   ←
                                                   j
                                                   +1, ϕ
                                                   ←
                                                   ϕ
                                                   −
                                                   η
                                                
                                             
                                             
                                                10:
                                                
                                                   
                                                   
                                                   
                                                   Cast R rays from p
                                                   
                                                      i
                                                    inside cone (p
                                                   
                                                      i
                                                   ,
                                                   n
                                                   
                                                      p
                                                   
                                                   i,
                                                   ϕ)
                                             
                                             
                                                11:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   l
                                                   min
                                                   ←Compute minimum ray lengths
                                             
                                             
                                                12:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   r← 
                                                      
                                                         |
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                            
                                                               B
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                         
                                                         |
                                                         /
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                            
                                                               B
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                13:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   If
                                                   r
                                                   >
                                                   τ 
                                                   then
                                                
                                             
                                             
                                                14:
                                                
                                                   
                                                   
                                                   
                                                   break
                                             
                                             
                                                15:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   else
                                                
                                             
                                             
                                                16:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                            
                                                               B
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                17:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                18:
                                                
                                                   
                                                   
                                                   
                                                   end while
                                                
                                             
                                             
                                                19:
                                                
                                                   
                                                   
                                                   Add projection of p
                                                   
                                                      i
                                                    along n
                                                   
                                                      p
                                                   
                                                   i at 
                                                      
                                                         
                                                            
                                                               1
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               min
                                                            
                                                            
                                                               B
                                                            
                                                         
                                                      
                                                    to 
                                                      
                                                         D
                                                      
                                                   
                                                
                                             
                                             
                                                20:
                                                
                                                   
                                                   
                                                   end for
                                                
                                             
                                             
                                                21:
                                                
                                                   
                                                   end for
                                                
                                             
                                             
                                                22:
                                                
                                                   
                                                   return Set of half-diameter points 
                                                      
                                                         D
                                                      
                                                    (
                                                      
                                                         |
                                                         D
                                                         |
                                                         =
                                                         n
                                                      
                                                   )
                                             
                                             
                                                23:
                                                
                                                   end procedure
                                                
                                             
                                          
                                       
                                    
                                 
                              

Another difference between the proposed thickness approximation and the SDF is that none of its post-processing operations (the bilateral smoothing and the normalization) are performed on δ. These operations were initially designed to counterbalance the variations due to the pose. Instead, our approach uses a variant of a robust distance function [9] to compute a scale-dependent thickness t
                        
                           k
                         from the point cloud 
                           
                              D
                           
                        . Such an approach addresses both the issue of robustness and the constraint of having a single and intuitive parameter.

Let 
                              
                                 D
                              
                            be the set of half-diameter points, computed from the input surface mesh 
                              
                                 S
                              
                           , and 
                              
                                 n
                                 =
                                 |
                                 D
                                 |
                              
                            (which equals the sampling size). 
                              
                                 Q
                              
                            denotes the set of query points where the thickness is estimated. Given k
                           ∈〚1;n〛, the thickness t
                           
                              k
                           (q) 
                              
                                 (
                                 q
                                 ∈
                                 Q
                                 )
                              
                            is defined on the input surface as follows:
                              
                                 (1)
                                 
                                    ∀
                                    q
                                    ∈
                                    Q
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          k
                                       
                                    
                                    (
                                    q
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                k
                                             
                                          
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                ∈
                                                〚
                                                1
                                                ,
                                                k
                                                〛
                                             
                                          
                                          ‖
                                          
                                             
                                                qd
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                ‖
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           where d
                           
                              i
                            denotes the i
                           th closest point to q in 
                              
                                 D
                              
                            that verifies the condition:
                              
                                 (2)
                                 
                                    S
                                    ∩
                                    [
                                    
                                       
                                          qd
                                       
                                       
                                          i
                                       
                                    
                                    ]
                                    =
                                    {
                                    q
                                    }
                                 
                              
                           Eq. (2) ensures that half-diameter points and boundary query points are mutually visible. This is required to avoid the issue depicted by Fig. 4
                           .

We compute t
                           
                              k
                           (q) by iteratively retrieving the next closest point d
                           
                              i
                            
                           
                              
                                 (
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 D
                                 )
                              
                            to q. If Eq. (2) holds true for d
                           
                              i
                           , we increment i and add ∥qd
                           
                              i
                           ∥2 to t
                           
                              k
                           (q). This procedures either ends when i reaches k or when all points in 
                              
                                 D
                              
                            have been queried. In Eq. (1), 
                              
                                 
                                    
                                       1
                                    
                                    
                                       k
                                    
                                 
                              
                            is replaced by 
                              
                                 
                                    
                                       1
                                    
                                    
                                       v
                                       (
                                       q
                                       )
                                    
                                 
                              
                           , where v(q) is the number of points in 
                              
                                 D
                              
                            which are visible from q.

The main issue to compute t
                           
                              k
                            is related to the computational efficiency: if k
                           >
                           v(q), computing the thickness involves useless queries to all points in 
                              
                                 D
                              
                           . Although there is no way to exactly estimate v(q) without testing all half-diameter points, we introduce two tests to speed up the computation: a preliminary check and an upper-bound to the neighbor search.

Before performing any other computation, we check:
                              
                                 
                                    
                                       
                                          qd
                                       
                                       
                                          i
                                       
                                    
                                    ·
                                    
                                       
                                          n
                                       
                                       
                                          q
                                       
                                    
                                    ⩾
                                    0
                                 
                              
                           where n
                           
                              q
                            denotes the normal at q oriented inward. This condition is always verified by points visible from q. Since this test is substantially faster than a ray-shape intersection query, it generally improves the efficiency of the process.

We also add an upper-bound d
                           max to the acceptable distance ∥qd
                           
                              i
                           ∥, thus limiting the neighbor search to a sphere of radius d
                           max centered at q. When reaching a point d
                           
                              i
                            which does not verify Eq. (2), the computation of t
                           
                              k
                            terminates if ∥qd
                           
                              i
                           ∥⩾
                           d
                           max. Since the upper-bound is only applied when the search returns unusable points, half-diameter points outside the radius d
                           max may still be used in t
                           
                              k
                           (q). This heuristic is automatically dropped when the first point in 
                              
                                 D
                              
                            visible from q is farther than d
                           max, so that t
                           
                              k
                            remains well-defined.

Empirically, d
                           max is set to 
                              
                                 
                                    
                                       1
                                    
                                    
                                       5
                                    
                                 
                              
                            of the largest diagonal of the bounding box. In practice, this heuristic roughly speeds up the computation by one order of magnitude. Algorithm 3 details the work flow of this algorithm, whose output t
                           
                              k
                            is scale-dependent.
                              Algorithm 3
                              
                                 k-nn based thickness computation. 
                                    
                                       
                                          
                                          
                                          
                                             
                                                1:
                                                
                                                   Procedure DiameterToThickness(Input mesh 
                                                      
                                                         S
                                                      
                                                   ; half-diameter points 
                                                      
                                                         D
                                                      
                                                   ; boundary point query q, scale parameter k, upper-bound d
                                                   max)
                                             
                                             
                                                2:
                                                
                                                   
                                                   t
                                                   
                                                      k
                                                   
                                                   ←0, j
                                                   ←0
                                             
                                             
                                                3:
                                                
                                                   
                                                   while 
                                                   j
                                                   <
                                                   k AND 
                                                      
                                                         D
                                                         
                                                         ≠
                                                         
                                                         ∅
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                4:
                                                
                                                   
                                                   Pop next nearest neighbor 
                                                      
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ∈
                                                         D
                                                      
                                                    from q
                                                
                                             
                                             
                                                5:
                                                
                                                   
                                                   
                                                   if n
                                                   
                                                      q
                                                   
                                                   ·
                                                   qd
                                                   
                                                      i
                                                   
                                                   ⩾0 ▷n
                                                   
                                                      q
                                                    is the normal at q.
                                             
                                             
                                                6:
                                                
                                                   
                                                   
                                                   
                                                   if 
                                                   
                                                      
                                                         S
                                                         ∩
                                                         [
                                                         
                                                            
                                                               qd
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ]
                                                         =
                                                         {
                                                         q
                                                         }
                                                      
                                                   
                                                   then
                                                
                                             
                                             
                                                7:
                                                
                                                   
                                                   
                                                   
                                                   
                                                   j
                                                   ←
                                                   j
                                                   +1; update t
                                                   
                                                      k
                                                   
                                                
                                             
                                             
                                                8:
                                                
                                                   
                                                   
                                                   
                                                   else if ∥qd
                                                   
                                                      i
                                                   ∥⩾
                                                   d
                                                   max AND j
                                                   ≠0then
                                                
                                             
                                             
                                                9:
                                                
                                                   
                                                   
                                                   
                                                   break
                                             
                                             
                                                10:
                                                
                                                   
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                11:
                                                
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                12:
                                                
                                                   
                                                   end while
                                                
                                             
                                             
                                                13:
                                                
                                                   
                                                   return 
                                                   t
                                                   
                                                      k
                                                   (q)
                                             
                                             
                                                14:
                                                
                                                   end procedure
                                                
                                             
                                          
                                       
                                    
                                 
                              

For a given size of the sampling set n, the parameter k provides the user a means to trade robustness for discriminative capability of the thickness estimate. Large values of k increase the robustness through a lower sensitivity to outliers, but they also mean a low influence of small scale features since they are considered outliers compared to large scale features. In a nutshell, the scale of the thickness estimation is entirely controlled by the 
                              
                                 
                                    
                                       k
                                    
                                    
                                       n
                                    
                                 
                              
                            ratio.


                           Fig. 5
                            illustrates this behavior for the Hippo model and a fixed value of n. With a low k value, the importance of small scale features is enhanced for the toes and ears. This is indicated by the deep blue parts on the mesh (deep blue patches correspond to small values of t
                           
                              k
                           ). With larger values of k, small scale features become less significant, and larger parts, such as the torso, become more important: deep blue parts on the mesh are no longer visible, as they have been replaced by a global red patch (larger thickness values). Notice that, in some mesh parts, t
                           
                              k
                            does not change when increasing k because of the visibility condition.

Since the thickness should be pose-invariant, very large values of k may also induce issues: the probability that half-diameter points are not visible after a pose operation increases with their distance. In addition, the computation times directly depends on the parameters k and n.


                           Table 1
                            summarizes the main differences between our algorithm and the original SDF algorithm.

This section provides details on our technical choices for implementing the thickness estimation t
                     
                        k
                     . Our algorithm is implemented in C++ with components from the CGAL library [10]. The ray casting and intersection queries use an AABB tree data structure. The robust distance function uses an incremental neighbor search based on a kD-tree. Both processes are multi-threaded through OpenMP. On most 3D objects of our database (with a few thousands vertices), the algorithm takes around 30 s on a PC with two quad-core processors clocked at 2.93GHz and 12GB RAM.

We observed that when dealing with anisotropic meshes or low-complexity meshes, using only the facet centers to estimate the diameter produces biased or incorrect results with high dependency to the input discretization. The first step of our thickness estimation algorithm is thus a dense re-sampling of the input surface mesh 
                              
                                 S
                              
                            to generate a set of n points samples denoted by 
                              
                                 P
                              
                           . A mesh-independent solution consists in generating boundary points by casting random rays inside the bounding box of the object and computing intersection points with its surface. However, for shapes with very fine levels of detail this method requires a very dense sampling to avoid overlooking parts of the object. Our default random sampling method is thus based on uniform sampling of each triangular facet, with a number of samples proportional to the contribution of the facet to the total area of the input surface mesh. In Section 5.2.1, we detail how we set the value for n for benchmarking, as the scale of the thickness estimation is controlled by the ratio 
                              
                                 
                                    
                                       k
                                    
                                    
                                       n
                                    
                                 
                              
                           . Fixing n thus leads to a unique parameter for scale selection. In addition, when the set of point queries 
                              
                                 Q
                              
                            is known before thickness estimation, we add 
                              
                                 Q
                              
                            to 
                              
                                 P
                              
                           .

Note that such a choice departs from the recent down-sampling approach [8] for computing SDF values. Our goal is to improve both the robustness and accuracy of the thickness estimation, while the down-sampling strategy aims at decreasing the computation time of the SDF. Still, our initial re-sampling strategy could also be used to reduce the number of points at which the diameter will be estimated, e.g. by setting n to a lower value than the number of facets.

In the original SDF approach, the diameter estimation δ is obtained through an outlier-robust weighted average of the lengths of rays cast inside a cone. The weights are designed to compensate for the bias in the casting of random rays: uniformly generating angles in [0,ϕ], where ϕ denotes the half opening angle of the cone, yields a non-uniform ray sampling of the cone.

In our implementation the random rays are uniformly generated inside the cone. Let p denote a point on the surface, n
                           
                              p
                            the normal vector at p (unitary, pointing inward), (x
                           
                              p
                           ,
                           y
                           
                              p
                           ) two orthogonal unit vectors spanning the tangent plane to the surface at p and r the direction vector for the random ray. The cone is defined by its apex p, its direction n
                           
                              p
                            and its aperture ϕ. Let rnd[a,
                           b] denote a uniform random number generated within [a,
                           b]. r is then defined as follows:
                              
                                 (3)
                                 
                                    r
                                    =
                                    
                                       
                                          n
                                       
                                       
                                          p
                                       
                                    
                                    +
                                    λ
                                    (
                                    cos
                                    (
                                    θ
                                    )
                                    
                                       
                                          x
                                       
                                       
                                          p
                                       
                                    
                                    +
                                    sin
                                    (
                                    θ
                                    )
                                    
                                       
                                          y
                                       
                                       
                                          p
                                       
                                    
                                    )
                                 
                              
                           
                           
                              
                                 
                                    λ
                                    =
                                    
                                       
                                          rnd
                                          [
                                          0
                                          ,
                                          
                                             
                                                tan
                                             
                                             
                                                2
                                             
                                          
                                          ϕ
                                          ]
                                       
                                    
                                    
                                    θ
                                    =
                                    rnd
                                    [
                                    0
                                    ,
                                    2
                                    π
                                    [
                                 
                              
                           In addition, we always cast a ray in the direction of n
                           
                              p
                           .

Notice that by requiring that (i) the query points in 
                              
                                 Q
                              
                            at which t
                           
                              k
                            is to be estimated are used in the sampling procedure, (ii) the ray casting procedure always include the normal, (iii) δ is set to half the minimum ray length, and (iv) the projection of the samples is along the normal, we ensure that there is always at least one point d
                           
                              i
                            for which Eq. (2) is matched. The thickness t
                           
                              k
                           (q) is thus defined for all points in 
                              
                                 Q
                              
                           . Moreover, if 
                              
                                 S
                              
                            is a watertight surface mesh, all points in 
                              
                                 D
                              
                            are inside the mesh.

The complexity of the algorithms mainly depends on the number of ray casting queries, which itself depends on the number of facets 
                           
                              |
                              S
                              |
                           
                        . For the SDF, the complexity is 
                           
                              O
                              (
                              R
                              |
                              S
                              |
                              )
                              ,
                              R
                           
                         rays being cast at each facet center. For our method a worst case scenario has a complexity of 
                           
                              O
                              (
                              n
                              (
                              RI
                              +
                              |
                              Q
                              |
                              )
                              )
                           
                        , where n denotes the number of sampling points on the surface, and I is the maximum number of iterations of the adaptive ray casting procedure. This corresponds to a configuration where: (i) the adaptive ray casting always reaches the smallest opening angles; (ii) for each query point in 
                           
                              Q
                           
                        , all the medial points in 
                           
                              M
                           
                         have to be checked against Eq. (2). Conversely, the best case scenario involves 
                           
                              O
                              (
                              2
                              nR
                              +
                              |
                              Q
                              |
                              k
                              )
                           
                         ray casting queries: (i) the adaptive ray casting always ends after 1 iteration; (ii) Eq. (2) holds true for all query points in 
                           
                              Q
                           
                         and their k nearest medial points. In our experiments we observe that our implementation of the original SDF approach runs between 2 and 5 times faster than t
                        
                           k
                         on most meshes. These results however greatly depend on the input mesh and the number of visibility checks performed (Section 3.2.2), and is a direct function of the parameter settings described below.

@&#EXPERIMENTS@&#

In the following, we denote by δ
                     SDF the thickness computed using the original SDF method, with the following modifications: (i) we use the unbiased ray casting strategy described in Section 4.1.2, and therefore do not use any weight-based compensation mechanism; and (ii) we do not perform the log-based normalization, as we benchmark the accuracy of the estimate and require the actual thickness measurements.

The performance of δ
                           SDF and t
                           
                              k
                            are benchmarked on a database of 392 meshes. Most of them are watertight [11], and the number of facets ranges from a few hundreds to around 100k. These meshes contain both articulated and non-articulated shapes, as well as mechanical parts, as partially shown by Fig. 6
                           .

When benchmarking against specific distortions such as, e.g., addition of noise, a smaller subset of the database is used, described in Table 2
                           . This subset contains 4 articulated meshes and 1 mechanical mesh, with large variance in the number of facets and feature sizes.

We benchmark the (i) instability, (ii) accuracy, and (iii) robustness of the estimation algorithms against distortions such as noise addition, and simplification. The performances are always benchmarked both locally for a facet and globally for the entire mesh.


                           Instability. The instability measures the intrinsic uncertainty of a thickness estimate, as both δ
                           SDF and t
                           
                              k
                            are based on a stochastic approach. In the following, μ
                           
                              q
                           (f) denotes the average thickness estimated at the center of facet f over q runs of each algorithm. For instance, denoting by 
                              
                                 
                                    
                                       δ
                                    
                                    
                                       SDF
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 f
                                 )
                              
                            the estimated δ
                           SDF at trial 
                              
                                 i
                                 ,
                                 
                                    
                                       μ
                                    
                                    
                                       q
                                    
                                 
                                 (
                                 f
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       q
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       q
                                    
                                 
                                 
                                    
                                       δ
                                    
                                    
                                       SDF
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 f
                                 )
                              
                           . In addition, σ
                           
                              q
                           (f) denotes the standard deviation of the estimation.
                              
                                 1.
                                 The (intrinsic) local instability I
                                    
                                       q
                                    (f) is measured by the coefficient of variation of an estimate at a facet center, as follows:
                                       
                                          (4)
                                          
                                             
                                                
                                                   I
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             =
                                             
                                                
                                                   
                                                      
                                                         σ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   f
                                                   )
                                                
                                                
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   f
                                                   )
                                                
                                             
                                             .
                                          
                                       
                                    
                                 

The (intrinsic) global instability I
                                    
                                       q
                                     is defined as the average local instability over the surface mesh 
                                       
                                          S
                                       
                                    , as:
                                       
                                          (5)
                                          
                                             
                                                
                                                   I
                                                
                                                
                                                   q
                                                
                                             
                                             =
                                             
                                                
                                                   1
                                                
                                                
                                                   |
                                                   S
                                                   |
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      f
                                                      ∈
                                                      S
                                                   
                                                
                                             
                                             
                                                
                                                   I
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             .
                                          
                                       
                                    
                                 

Note that the instability is defined using several runs of an algorithm on the same mesh. We set q
                           =4 in all experiments.


                           Accuracy
                        

In general, the accuracy of a method is defined with regard to a so-called “ground-truth”. Given a ground-truth defined per facet, the following metrics are defined:
                              
                                 1.
                                 The local accuracy is measured for a given mesh facet by computing the relative error between the averaged output of an algorithm and the ground-truth at the facet center. Denote by g(f) the ground-truth at the center of facet f. We define the local accuracy a
                                    
                                       q
                                    (f) as:
                                       
                                          (6)
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             =
                                             
                                                
                                                   |
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   f
                                                   )
                                                   -
                                                   g
                                                   (
                                                   f
                                                   )
                                                   |
                                                
                                                
                                                   g
                                                   (
                                                   f
                                                   )
                                                
                                             
                                             .
                                          
                                       
                                    
                                 

The global accuracy on a mesh is then given by averaging the local accuracy over all facets.
                                       
                                          (7)
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   q
                                                
                                             
                                             =
                                             
                                                
                                                   1
                                                
                                                
                                                   |
                                                   S
                                                   |
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      f
                                                      ∈
                                                      S
                                                   
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             .
                                          
                                       
                                    
                                 

For the thickness computation, defining a ground-truth is a complex task. In the following, the mathematical thickness, which is defined at point p as the radius of the maximal ball associated with p (see Section 2), is selected. This choice requires computing the medial axis analytically, which is feasible for canonical shapes such as spheres, torii and infinite cylinders. However, for more complex shapes or noisy inputs, the notion of scale comes into play, and the mathematical thickness becomes an inappropriate ground-truth. Therefore, computing the accuracy with regard to the mathematical thickness would be irrelevant in most cases.


                           Robustness. The robustness of a method against distortions which preserve the connectivity is evaluated through the average relative error. Denote by f a facet of mesh 
                              
                                 S
                              
                            and f′ its image in a distorted mesh 
                              
                                 
                                    
                                       S
                                    
                                    
                                       ′
                                    
                                 
                              
                           . f′ is well-defined, since the distortion induces a one-to-one mapping between 
                              
                                 S
                              
                            and S′.
                              
                                 1.
                                 The local (per facet) error is defined as:
                                       
                                          (8)
                                          
                                             
                                                
                                                   R
                                                
                                                
                                                   S
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             =
                                             
                                                
                                                   |
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                   -
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   f
                                                   )
                                                   |
                                                
                                                
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         q
                                                      
                                                   
                                                   (
                                                   f
                                                   )
                                                
                                             
                                             .
                                          
                                       
                                    
                                 

The global error of an algorithm is then measured by:
                                       
                                          (9)
                                          
                                             
                                                
                                                   R
                                                
                                                
                                                   S
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                                
                                                   q
                                                
                                             
                                             =
                                             
                                                
                                                   1
                                                
                                                
                                                   |
                                                   S
                                                   |
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      f
                                                      ∈
                                                      S
                                                   
                                                
                                             
                                             
                                                
                                                   R
                                                
                                                
                                                   S
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                                
                                                   q
                                                
                                             
                                             (
                                             f
                                             )
                                             .
                                          
                                       
                                    
                                 

Notice that the larger R
                           
                              q
                           , the lower the robustness. In other words, R
                           
                              q
                            can be seen as a measurement of the inconsistency of an algorithm for a given distortion.

For modifications that do not preserve the mesh connectivity, i.e., when the mapping between f and f′ is lost through local mesh operators, depicting the thickness using identical color maps enables a visual comparison. A quantitative comparison is made using Eq. (8), where f′ is chosen as the nearest facet to f in 
                              
                                 
                                    
                                       S
                                    
                                    
                                       ′
                                    
                                 
                              
                           . Notice that in this case 
                              
                                 
                                    
                                       R
                                    
                                    
                                       S
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             ′
                                          
                                       
                                    
                                    
                                       q
                                    
                                 
                                 
                                 ≠
                                 
                                 
                                    
                                       R
                                    
                                    
                                       
                                          
                                             S
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       S
                                    
                                    
                                       q
                                    
                                 
                              
                           . Finally, another evaluation metric consists in comparing the normalized histograms of the thickness over 
                              
                                 S
                              
                            and 
                              
                                 
                                    
                                       S
                                    
                                    
                                       ′
                                    
                                 
                              
                           .

For comparison we define two comparable baseline parameter settings for δ
                        SDF and t
                        
                           k
                        . We then benchmark (i) the accuracy, (ii) the instability, and (iii) the robustness to pose for both algorithms. These last two criteria are already mentioned in the original SDF algorithm.

Using a robust distance function instead of the bilateral smoothing of the SDF presents the immediate advantage of reducing the number of parameters for this part of the algorithm. However, setting the parameter k for computing t
                           
                              k
                           (p) and setting the parameters of the bilateral filter are unrelated. Directly comparing the benefits and drawbacks of increasing k or the number of smoothing iterations is therefore not meaningful.

To compute δ
                           SDF, we start with a single diameter estimation for every facet center, and then apply i iterations of bilateral smoothing with a window of size w. In a regular 4–1 subdivision mesh, the size of the surface patch involved in this computation is m
                           =6iw(iw
                           +1), with m the number of facets. In practice, we choose m
                           =72 by setting i
                           =3 and w
                           =1, i.e. 3 iterations of a bilateral smoothing based on a 1-ring spatial neighborhood. Since the trade-off between robustness and accuracy for the estimation of local quantities depends on m, the same value is used for t
                           
                              k
                            when comparing results between algorithms.


                           Sampling size. Regarding t
                           
                              k
                           , we first set a normalized target sampling size 
                              
                                 
                                    
                                       n
                                    
                                    
                                       ̃
                                    
                                 
                                 =
                                 
                                    
                                       10
                                    
                                    
                                       5
                                    
                                 
                              
                            in all experiments. For a given mesh 
                              
                                 S
                              
                           , let A be the area of the surface, b the length of the space diagonal of the bounding box and 
                              
                                 |
                                 S
                                 |
                              
                            the number of facets in 
                              
                                 S
                              
                           . To ensures that the sampling size is scale-invariant, the actual sampling size is defined as follows:
                              
                                 (10)
                                 
                                    n
                                    =
                                    
                                       
                                          n
                                       
                                       
                                          ̃
                                       
                                    
                                    
                                       
                                          A
                                       
                                       
                                          
                                             
                                                b
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        


                           k-nn settings. Medial points being projections of uniformly sampled points, the area a of the surface boundary that is required to create k medial points is defined as follows, where d denotes the sampling density, which is set to be uniform over the mesh.
                              
                                 (11)
                                 
                                    a
                                    =
                                    
                                       
                                          k
                                       
                                       
                                          d
                                       
                                    
                                 
                              
                           Eq. (11) can then be rewritten using m, the average number of facets in area a as:
                              
                                 (12)
                                 
                                    m
                                    
                                       
                                          A
                                       
                                       
                                          |
                                          S
                                          |
                                       
                                    
                                    =
                                    
                                       
                                          k
                                       
                                       
                                          
                                             
                                                n
                                             
                                             
                                                A
                                             
                                          
                                       
                                    
                                    ⇒
                                    k
                                    =
                                    
                                       
                                          nm
                                       
                                       
                                          |
                                          S
                                          |
                                       
                                    
                                    .
                                 
                              
                           As we use m
                           =72 and 
                              
                                 
                                    
                                       n
                                    
                                    
                                       ̃
                                    
                                 
                                 =
                                 
                                    
                                       10
                                    
                                    
                                       5
                                    
                                 
                              
                            for our experiments, Eq. (10) and (12) show that k can be automatically set, its value ensuring a meaningful comparison between δ
                           SDF and t
                           
                              k
                           . In the following, we simply denote t
                           
                              k
                            as t.


                           Output. Finally, we set 
                              
                                 Q
                              
                           , the query points at which t is estimated, as all the facet centers. Therefore, for both δ
                           SDF and t, all parameters are automatically set, and a single value is finally assigned to each facet.


                           Table 3
                            summarizes the baseline parameter settings.


                           Sphere and Torus. We compare the accuracy of t and δ
                           SDF for a sphere of radius 1.0 (1740 facets), and a torus of minor radius 0.5 and major radius 2.0 (3200 facets). Fig. 7
                            depicts a normalized distribution of the per-facet values. Averaging multiple ray lengths in the case of a sphere yields a substantial underestimation of the actual radius: δ
                           SDF is around 0.65 all over the sphere instead of the expected unitary value. Among all rays cast inside a cone along the normal direction, only one yields the correct value (the actual radius), while the others yield smaller values. The global instability I
                           4 (i.e., over 4 iterations of the algorithm) of δ
                           SDF is around 2.5%, while it is about 1.6% for t.

For the torus, averaging ray lengths as in δ
                           SDF provides a better estimation of the half-section than for the radius of the sphere (theoretical value at 0.5), but leads to a slightly scattered distribution of δ
                           SDF around 0.48. The global instability I
                           4 is in this case around 3.0% against 0.03% for t. Finally, note that the inaccuracy of the estimation process is also due to the sampling, since both meshes are only approximations of the unit sphere and torus.


                           Ellipsoids. Both algorithms are evaluated on 81 ellipsoids (20k facets each), parameterized by their eccentricity. Their centers are at the origin, with two semi-axis (λ,
                           μ) ranging from 2×10−1 to 1 (step: 10−1) and the third semi-axis constantly set to c
                           =1. For each ellipsoid, the thickness t and δ
                           SDF are experimentally estimated as well as their local accuracy with regard to the mathematical thickness computed in closed form.


                           Fig. 8
                            depicts in gray-scale the global error between each thickness estimation algorithm and the mathematical thickness. All values are normalized in order to depict the results with the same scale. On average, t is closer to the mathematical thickness, which is visually verified as the diagram Fig. 8a is darker than the diagram Fig. 8b. However, when only looking at the diagonal from (λ,μ)=(1;1) to (λ,
                           μ)=(0.2;0.2),δ
                           SDF presents better results. These cases correspond to cigar-like ellipsoids, with one axis set to 1.0, and a circular cut (λ
                           =
                           μ). In the upper-right part of the diagram, when the ellipsoids are very close to the unit sphere, t is more accurate than δ
                           SDF, which is consistent with the results shown by Fig. 7. Finally, when transforming the unit sphere to a plate-like ellipsoid (λ or μ set to 1, i.e. only considering the first row or the first column of the diagrams), the accuracy of both algorithms drops abruptly, albeit less for t.

We measure the global instability I
                           4 of both thickness estimation methods on the entire mesh database. For δ
                           SDF, the instability is on average 3.4%. It is around 0.58% for t. Although these results confirm the stability of our thickness estimate, our computation time is about 3 times slower (around 30 s for every mesh instead of 10s for δ
                           SDF). Fig. 9
                            summarizes the results of the instability benchmark.


                           Fig. 9a shows the global instability for every mesh in our database (392 points). For δ
                           SDF, the values are more scattered around the average 3.4% than for t, which only exhibits 3 outliers (above 2% global instability). These outliers correspond to mechanical parts: the point close to the diagonal represents the “U” shape, while the points in the upper-part of the diagram stand for bowls or plates. All the articulated meshes are located around the point (0.5;3).


                           Fig. 9a shows the local instability of both methods for the Armadillo mesh. The average instability is around 0.5% for t and 2.8% for δ
                           SDF. Both methods exhibit local outliers, but their range are slightly different. For t, some facets have an instability below 0.1%, and a single facet has an instability above 10%. For δ
                           SDF, all values are above 0.1%, and many above 10%. In other words, the local instability of t: (i) has a lower upper-bound than δ
                           SDF, with very few unstable estimates; (ii) is lower than the local instability of δ
                           SDF for most facets (the point cloud is mostly above the diagonal); and (iii) has a few highly stable estimates.

A series of poses of the Elephant mesh are used to benchmark the robustness of δ
                           SDF and t. This mesh has 85k facets and contains some self-intersections at the ears. Fig. 10
                            shows the local thickness estimates on the reference mesh and two differently posed versions. This first experiment assesses the visual consistency of both algorithms over different poses.

A quantitative analysis of the robustness is depicted on Fig. 11
                           . Fig. 11a first illustrates the global robustness of δ
                           SDF and t using the global error R
                           4 and all the various poses of the Elephant mesh. Note that the reference values in Eq. (9) correspond to the ones computed on the reference pose (depicted on Fig. 10a and d). The error is upper-bounded by 16% for δ
                           SDF and by 11% for t. For almost all poses, t is more consistent than δ
                           SDF (points above y
                           =
                           x). Fig. 10b and e shows the local thickness for the single pose where δ
                           SDF is more consistent than t.


                           Fig. 11b illustrates the local robustness of both methods for one pose of the mesh. This pose corresponds to the point with coordinates (10.73;12.54) on the global error diagram (Fig. 11a), i.e. one of the worst result for both methods. The actual estimated thickness can be seen on Fig. 10c and f.

The local error for δ
                           SDF and t exhibits a large number of outlier values, i.e. facets for which the estimated thickness is highly modified, or conversely almost exactly identical between poses. The few facets with a large error (above 103%) could correspond to the joints of the model, at which the local thickness greatly varies between poses. However, these facets are not the same for δ
                           SDF and for t. Moreover, none of them are located at the joints, but only on the ears of the elephant. Furthermore, the largest local instability values (computed with Eq. (6)) are located in the same regions. This indicates a correlation between large local errors, large instability of the estimates, and the self-intersections of the mesh (which are located near the ears).

This section presents the results on the robustness of t w.r.t. a variety of synthetic distortions. Without a direct comparison with δ
                        SDF, the parameter settings established in Section 5.2.1 is no longer needed. In particular, setting k as a function of the number of facets 
                           
                              |
                              S
                              |
                           
                         is ill-suited for benchmarking against e.g. simplification. Similarly, making parameters dependent on the surface decreases the robustness against e. g. noise, as the parameters are altered over different noise magnitudes.

In the following, we simply change k so as to use a constant 
                           
                              
                                 
                                    k
                                 
                                 
                                    n
                                 
                              
                           
                         value. In other words, the scale at which the estimations are performed stays constant.

The most basic affine transformations in 
                              
                                 
                                    
                                       R
                                    
                                    
                                       3
                                    
                                 
                              
                            consists in rigid transforms (rotations, translations), for which all the algorithms are in theory invariant. For a scaling operation with ratio α, we simply compute an estimate 
                              
                                 
                                    
                                       α
                                    
                                    
                                       ̃
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       f
                                       ∈
                                       S
                                    
                                 
                                 
                                    
                                       
                                          
                                             μ
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       f
                                       )
                                    
                                    
                                       
                                          
                                             μ
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                    
                                 
                              
                            and compare it to α, using all the 392 meshes in our database. With α ranging in [10−3;103], the relative error between the estimation 
                              
                                 
                                    
                                       α
                                    
                                    
                                       ̃
                                    
                                 
                              
                            and the ground-truth is always below 0.01%.

The local thickness is estimated for the 5 meshes in Table 2 after modifying the vertex coordinates by adding a uniform noise vector along the normal. Denote by n the local unit normal. The noise vectors are locally generated uniformly within 
                              
                                 [
                                 -
                                 
                                    
                                       s
                                    
                                    
                                       2
                                    
                                 
                                 n
                                 ;
                                 
                                    
                                       s
                                    
                                    
                                       2
                                    
                                 
                                 n
                                 ]
                              
                           , with s the noise magnitude, corresponding to a ratio of the longest diagonal length of the bounding box. Fig. 12
                            summarizes the results of this benchmark.


                           Fig. 12a shows the global error vs. noise levels. For articulated meshes and s
                           ⩽0.1%,t yields on average consistent results. Above s
                           =0.5%, the thickness estimation exhibits low robustness, as the global error quickly increases. Conversely, for the mechanical part, t shows a larger initial global error, but a slower decrease in performance with larger values of s. For s
                           ⩽0.1% (around 2%), this is due to the high (intrinsic) global instability of the algorithm as shown in Section 5.2.3. For all the articulated meshes, this global instability stays around 0.5%, for all levels of noise.


                           Fig. 12b presents the local error for the Giraffe mesh. It shows that increasing s yields a global decrease in performance, as the local error increases for 90% of the facets. In particular, the large increase in the global error at s
                           =0.5% comes through a drop in robustness for all facets, and not for some specific parts of the mesh. Finally, Fig. 12c illustrates the location of the local error at s
                           =2% on the distorted mesh. Small error values are located on large features (torso), while small features, such as ears, exhibit the largest errors. This is explained by the fact that the additive noise is generated without taking into account the feature size: small features are relatively more distorted than larger features. This phenomenon is magnified by the size of the space diagonal of the bounding box w.r.t. most of the mesh features.

The robustness of the thickness estimate is benchmarked against a common mesh smoothing method [12] for the meshes in Table 2 (Fig. 13
                           ). We monitor the global error when increasing the number of smoothing iterations (Fig. 13a), and provide a close-up on the distribution of local error for the Armadillo (Fig. 13b), as well as its location (Fig. 13c).

For 3 out of 4 articulated models, t shows a large consistency (Elephant, Armadillo and Giraffe curves in Fig. 13a) over smoothing. For the U mesh, t conversely yields much lower consistency, with a global error above 10% after a single smoothing iteration. Finally, the results for the Fish mesh are significantly better than all the others, with a global error below 0.2% even after 20 smoothing iterations.

These results are closely correlated with the distortion introduced by the smoothing iteration and estimated through the Root Mean Square (from the distorted mesh to the original mesh) metric (RMS) [13]. For the U mesh, the RMS after 1 smoothing iteration is estimated around 4×10−2, while it is only in the order of 10−4 for the articulated meshes. This is caused by the sharp features of the mechanical parts, which are heavily distorted by the smoothing process. Similarly, the RMS for the Fish mesh stays very low (4×10−5 after 1 iteration and 4×10−4 after 20 iterations), as the original mesh does not present any sharp features.

Finally, the close-up on the distributions of the local error and the actual mesh of the Armadillo (Fig. 13b and c) shows that t is not only robust against smoothing operations at a global level, but also at a local level: the range of the local error for 90% of the facets stays approximately within two order of magnitude, i.e. between 0.1% and 10%. The largest local error values are also correlated with the small bumps on the mesh and the small extremities, e.g. the fingers, which are heavily modified by the smoothing process.

A triangle soup distortion is obtained by (i) disconnecting all facets of the mesh, (ii) creating holes by shrinking the triangles using a constant ratio r. Fig. 14
                            reports the consistency results of t against this type of distortions. Fig. 14a shows the global error for the 5 benchmarked meshes. Notice that although the connectivity has changed, an obvious 1 to 1 mapping exists between facets in the original and in the modified mesh. Computing the global error R
                           4 with Eq. (9) is therefore still straightforward. The curve corresponding to the U mesh clearly presents inconsistencies, as the error decreases with the magnitude of the distortion. For all articulated meshes, t shows consistency until r
                           =30%. An example for the Armadillo mesh and r
                           =40% is given in Fig. 14b.

These figures show that t relies loosely on the mesh connectivity, since all facets have been disconnected. This provides robustness in the presence of small holes and cracks.

A practical thickness estimation has to provide consistent results for different levels of detail of the same mesh (Fig. 15
                           ). On Fig. 15a, t is computed on the benchmarked meshes with levels of simplification ranging from 90% to 0.01% (indicating the percent of remaining edges w.r.t. the original mesh). For the U (resp. the elephant) mesh, with 252 (resp. 8337) edges, this simplification process quickly reaches too large a level of distortion for the model to be recognizable. The estimation of the global error becomes then meaningless, and the curves exhibit incoherences (decreased error with increased simplification). Moreover, computing a mapping between facets in the distorted and the original mesh based on their distance also creates issues with the global error computation. For the Armadillo, the Fish and the Giraffe, t shows robustness until a 5% simplification ratio.


                           Fig. 15b and c display the actual thickness computed on the original Fish mesh and a simplified version (5×10−2% remaining edges), showing the consistency of t at a local level. Fig. 15d presents the local error between these two versions: the errors are mostly located on the small features which are highly altered by the simplification process.

Finally, the robustness of t is benchmarked against a complete re-meshing process. We first estimate the local thickness on a watertight triangular mesh of a face with a hat. The mesh is then re-tessellated with a regular quadrangle mesh [14], then transformed back into a triangular mesh by splitting facets. t is then estimated once more, and the local error is depicted on Fig. 16
                           . The global error is about 0.23%, with a maximum around 2%. This shows the consistency of t w.r.t. remeshing operations.

One of the main potential application of a local thickness estimation is to enable a robust and efficient mesh partitioning. This was originally achieved by using a soft clustering of the SDF values, followed by a graph-cut computation [1]. Note that the segmentation method itself also improves the robustness of the processing pipeline, as regrouping facets into patches has an averaging effect.

The benefits of using t for segmentation purposes are first illustrated by Fig. 17
                        . We applied the segmentation process on an Elephant mesh (89k facets) with 3% noise (Fig. 17a). As a result, the segmentation based on δ
                        SDF (Fig. 17b) is highly modified and creates 44 small segments. The segmentation relying on t (Fig. 17c) provides a more intuitive partitioning of the mesh.

Regarding the robustness of mesh segmentation, Fig. 18
                         shows the median relative error in the number of segments for the t-based and the δ
                        SDF-based segmentation when applying different types of distortions to the meshes in our database: (i) an increasing number of smoothing iterations (Fig. 18a); and (ii) an increasing number of edge simplifications (Fig. 18b). These results show that even after a large number of smoothing iterations, e.g. 50, the number of segments created by the t-based segmentation algorithm is still very close to the original ones, around than 2% variation. In a similar manner, the segmentation based on t shows a large consistency, even after heavy simplification on the input meshes.

@&#CONCLUSION@&#

We have introduced a robust thickness estimation method based on a shape diameter estimation. We modified the original SDF algorithm [1] by (i) introducing an adaptive scheme when sampling the local volume of a mesh; and (ii) replacing the bilateral smoothing by a robust distance function to a cloud of half-diameter points, thus creating a scale-dependent robust thickness estimate over the mesh surface.

The rationale for changing the initial methodology was to increase (i) the accuracy with respect to a ground-truth defined through an exact medial axis extraction (for canonical shapes such as spheres or ellipsoids); (ii) the intrinsic stability of the stochastic process; and (iii) the robustness of the estimate against alterations of an original mesh. Our experiments confirm the accuracy of our thickness estimation, illustrated on some canonical examples for which an analytical ground-truth (the mathematical thickness) is both well-defined and meaningful. They also indicate a tangible improvement in the stability of the estimation process: with comparable parameter settings, the SDF-based thickness estimation shows on average an instability one order of magnitude larger than our method. We have also benchmarked our method against a wide range of modifications such as pose, noise addition, triangle soup, simplification and remeshing. The results show that for some distortions, our method exhibits an increased robustness with respect to the original strategy.

Our method has room for improvement: its application is in general limited to articulated shapes such as humanoids or animals. On mechanical parts, we have shown in Fig. 3 that our adaptive strategy could be improved. Some experiments also indicate that the robustness of our method could be improved by finding a more appropriate outlier-removal strategy. Finally, improving the stability and the robustness of the thickness estimation makes it suitable to other applications such as robust segmentation or robust watermarking.

@&#ACKNOWLEDGMENTS@&#

We wish to thank the authors of the original SDF algorithm [1] for making their code publicly available and providing us with their database of 3D objects. We also thank Ilker O. Yaz for his implementation of the SDF and segmentation algorithm available as a CGAL software component. We further thank David Bommes for help with remeshing. This work was funded by Technicolor. Pierre Alliez is funded by the European Research Council (ERC Starting Grant “Robust Geometry Processing”, Grant Agreement 257474).

@&#REFERENCES@&#

