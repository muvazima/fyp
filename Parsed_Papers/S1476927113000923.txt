@&#MAIN-TITLE@&#Computational investigations of folded self-avoiding walks related to protein folding

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We consider the folded and unfolded SAW.


                        
                        
                           
                           We show that these subsets are different for walks larger than 108 steps.


                        
                        
                           
                           We detail the computational methods used to discover examples.


                        
                        
                           
                           We present a tool for studying these subsets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Self avoiding walks

Protein folding

Protein structure prediction

@&#ABSTRACT@&#


               
               
                  Various subsets of self-avoiding walks naturally appear when investigating existing methods designed to predict the 3D conformation of a protein of interest. Two such subsets, namely the folded and the unfoldable self-avoiding walks, are studied computationally in this article. We show that these two sets are equal and correspond to the whole n-step self-avoiding walks for n
                     ≤14, but that they are different for numerous n
                     ≥108, which are common protein lengths. Concrete counterexamples are provided and the computational methods used to discover them are completely detailed. A tool for studying these subsets of walks related to both pivot moves and protein conformations is finally presented.
               
            

@&#INTRODUCTION@&#

Self-avoiding walks (SAWs) have been studied over decades for the extent and difficulty of the mathematical problems they provide Madras and Sokal (1988), Bacher and Bousquet-Mélou (2011), Beaton et al. (2012), and for their various contexts of application in physics, chemistry, and biology Slade (2011), de Gennes (1972), Flory (1949). Among other things, they are used to model polymers such as DNA, RNAs, and proteins. Numerous protein structure prediction (PSP) software iterate on self-avoiding walk subsets, often not clearly defined, of various lattices. The last produced SAW S has the length of the targeted protein P. When labeling S with the amino acids of P, S is (one of) the best solution(s) according to a scoring function that associates a value to a 2D or 3D conformation (depending on physical properties of the conformation as hydrophobic neighboring residues, etc.).

In previous studies Bahi et al. (2013a, 2012, 2011), authors of this manuscript have investigated some dynamic protein folding models. They have shown that the possible sets of conformations reachable by these numerous PSP software are not equal. This raises severe questionings on what is indeed really predicted by such software. In particular, they have shown that software that iteratively stretch the conformation from one amino acid until a self-avoiding walk having the length n of the protein, can reach all the n-step SAWs 
                        
                           G
                           n
                        
                     . Contrarily, the ones that iterate ±90° pivot moves on the n-step straight line can only reach what they call the subset of folded self-avoiding walks fSAW(n). It has been clearly established that, for some well-defined small n's, 
                        fSAW
                        (
                        n
                        )
                        ≠
                        
                           G
                           n
                        
                     . After having obtained this result, the authors’ intention was then to investigate more deeply these new kind of self-avoiding walks and other related subsets of walks they called unfolded SAWs, and to determine consequences of these investigations regarding the protein structure prediction problem.

This article is the third of a series of three researches we publish in that field. In Bahi et al. (2013b) we provide a general presentation of folded and unfoldable SAWs, and the collection of results we have obtained on these objects using both theoretical and computational approaches. Article Bahi et al. (2013c) focuses more specifically on the mathematical study of theses subsets of self-avoiding walks, by proving in particular that the number of unfolded SAWs is infinite. This article presents our computational investigations in detail.

After recalling in the next section the basis of self-avoiding walks, of folded SAWs, and of unfoldable SAWs, we explain in Section 3 how the number of folded self-avoiding walks has been computed and how we checked the unfoldable property in practice. The various methods that have been implemented to find the shortest currently known unfoldable SAW are presented too in this section. Then, in Section 4, some heuristics that could be determinant in further studies concerning these subsets of walks are introduced. The next section contains the last contribution of this research work: a free software realized to facilitate the study of folded and unfoldable SAWs. This document ends by a conclusion section, in which all these contributions are summarized and intended future work is proposed.

We recall in this section various notions and properties of self-avoiding walks and of some of theirs folded subsets: folded SAWs obtained by iterating pivot moves on the straight line and unfoldable SAWs on which no pivot move can be applied without breaking the self-avoiding property. Authors that would investigate more deeply these walks are referred to Madras and Slade (1993), Slade (2011), Hughes (1995) for the SAWs in general, and to Bahi et al. (2013b,c) for the folded case.

Let 
                           
                              ℕ
                           
                         be the set of all natural numbers, 
                           
                              
                                 
                                    ℕ
                                 
                              
                              *
                           
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           }
                         the set of all positive integers, and for 
                           a
                           ,
                           b
                           ∈
                           
                              
                                 ℕ
                              
                           
                           ,
                           a
                           ≠
                           b
                        , the notation 〚a, b〛 stands for the set {a, a
                        +1, …, b
                        −1, b}. |x| stands for the Euclidean norm of any vector 
                           x
                           ∈
                           
                              
                                 
                                    ℤ
                                 
                              
                              d
                           
                           ,
                           d
                           ≥
                           1
                        , whereas x
                        1, …, x
                        
                           n
                         are the n coordinates of x. The nth term of a sequence s is denoted by s(n). Finally, ♯X is the cardinality of a finite set X. Using this material, self-avoiding walk can be defined as follows Madras and Slade (1993), Slade (2011), Hughes (1995).


                        
                           Definition 2.1
                           Self-Avoiding Walk


                           Let d
                              ≥1. A n−step self-avoiding walk from 
                                 x
                                 ∈
                                 
                                    
                                       
                                          ℤ
                                       
                                    
                                    d
                                 
                               to 
                                 y
                                 ∈
                                 
                                    
                                       
                                          ℤ
                                       
                                    
                                    d
                                 
                               is a map 
                                 w
                                 :
                                 〚
                                 0
                                 ,
                                 n
                                 〛
                                 →
                                 
                                    
                                       
                                          ℤ
                                       
                                    
                                    d
                                 
                               with:
                                 
                                    •
                                    
                                       
                                          w
                                          (
                                          0
                                          )
                                          =
                                          x
                                        and 
                                          w
                                          (
                                          n
                                          )
                                          =
                                          y
                                       ,


                                       
                                          |
                                          w
                                          (
                                          i
                                          +
                                          1
                                          )
                                          −
                                          w
                                          (
                                          i
                                          )
                                          |
                                          =
                                          1
                                       ,


                                       
                                          ∀
                                          i
                                          ,
                                          j
                                          ∈
                                          〚
                                          0
                                          ,
                                          n
                                          〛
                                          ,
                                          i
                                          ≠
                                          j
                                          ⇒
                                          w
                                          (
                                          i
                                          )
                                          ≠
                                          w
                                          (
                                          j
                                          )
                                        (self-avoiding property). An illustration of a Self Avoiding Walk is given in Fig. 1
                                       .

In absolute encoding Hoque et al. (2009), Backofen et al. (1999), a n-step walk 
                           w
                           =
                           w
                           (
                           0
                           )
                           ,
                           …
                           ,
                           w
                           (
                           n
                           )
                           ∈
                           
                              
                                 (
                                 
                                    
                                       
                                          ℤ
                                       
                                    
                                    2
                                 
                                 )
                              
                              
                                 n
                                 +
                                 1
                              
                           
                         with 
                           w
                           (
                           0
                           )
                           =
                           (
                           0
                           ,
                           0
                           )
                         is a sequence s
                        =
                        s(0), …, s(n
                        −1) of elements belonging into 
                           
                              
                                 ℤ
                              
                           
                           /
                           4
                           
                              
                                 ℤ
                              
                           
                        , such that:
                           
                              •
                              
                                 s(i)=0 if and only if 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       1
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       1
                                    
                                    +
                                    1
                                  and 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       2
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       2
                                    
                                 , that is, 
                                    w
                                    (
                                    i
                                    +
                                    1
                                    )
                                  is at the East of 
                                    w
                                    (
                                    i
                                    )
                                 .


                                 s(i)=1 if and only if 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       1
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       1
                                    
                                  and 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       2
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       2
                                    
                                    −
                                    1
                                 : 
                                    w
                                    (
                                    i
                                    +
                                    1
                                    )
                                  is at the South of 
                                    w
                                    (
                                    i
                                    )
                                 .


                                 s(i)=2 if and only if 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       1
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       1
                                    
                                    −
                                    1
                                  and 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       2
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       2
                                    
                                 , meaning that 
                                    w
                                    (
                                    i
                                    +
                                    1
                                    )
                                  is at the West of 
                                    w
                                    (
                                    i
                                    )
                                 .

Finally, s(i)=3 if and only if 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       1
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       1
                                    
                                  and 
                                    w
                                    
                                       
                                          (
                                          i
                                          +
                                          1
                                          )
                                       
                                       2
                                    
                                    =
                                    w
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                       2
                                    
                                    +
                                    1
                                  (
                                    w
                                    (
                                    i
                                    +
                                    1
                                    )
                                  is at the North of 
                                    w
                                    (
                                    i
                                    )
                                 ).

Let us now define the following functions Bahi et al. (2013a).


                        
                           Definition 2.2
                           The anticlockwise fold function is the function 
                                 f
                                 :
                                 
                                    
                                       ℤ
                                    
                                 
                                 /
                                 4
                                 
                                    
                                       ℤ
                                    
                                 
                                 ⟶
                                 
                                    
                                       ℤ
                                    
                                 
                                 /
                                 4
                                 
                                    
                                       ℤ
                                    
                                 
                               defined by f(x)=
                              x
                              −1(mod4) and the clockwise fold function is f
                              −1(x)=
                              x
                              +1(mod4).

Using the absolute encoding sequence s of a n-step SAW 
                           w
                         that starts from the origin of the square lattice, a pivot move of +90° on 
                           w
                           (
                           k
                           )
                           ,
                           k
                           <
                           n
                        , simply consists to transform s into s(0), …, s(k
                        −1), f(s(k)), …, f(s(n)). Similarly, a pivot move of −90° consists to apply f
                        −1 to the queue of the absolute encoding sequence, like in Fig. 2
                        .

We can now introduce a graph structure that fits the description of iterations for ±90° pivot moves on a given self-avoiding walk.

Given 
                           n
                           ∈
                           
                              
                                 
                                    ℕ
                                 
                              
                              *
                           
                        , the graph 
                           
                              G
                              n
                           
                        , formerly introduced in Bahi et al. (2013a), is defined as follows:
                           
                              •
                              its vertices are the n−step self-avoiding walks, described in absolute encoding;

there is an edge between two vertices s
                                 
                                    i
                                 , s
                                 
                                    j
                                  if and only if s
                                 
                                    j
                                  can be obtained by one pivot move of ±90° on s
                                 
                                    i
                                 , that is, if there exists k∈〚0, n
                                 −1〛 s.t.:
                                    
                                       –
                                       either s
                                          
                                             j
                                          (0), …, s
                                          
                                             j
                                          (k
                                          −1), f(s
                                          
                                             j
                                          (k)), …, f(s
                                          
                                             j
                                          (n))=
                                          s
                                          
                                             i
                                          
                                       

or s
                                          
                                             j
                                          (0), …, s
                                          
                                             j
                                          (k
                                          −1), f
                                          −1(s
                                          
                                             j
                                          (k)), …, f
                                          −1(s
                                          
                                             j
                                          (n))=
                                          s
                                          
                                             i
                                          .

Such a digraph is depicted in Fig. 3
                        . The circled vertex is the straight line whereas strikeout vertices are walks that are not self-avoiding. Depending on the context, and for the sake of simplicity, 
                           
                              G
                              n
                           
                         will also refers to the set of SAWs in 
                           
                              G
                              n
                           
                         (i.e., its vertices).

Using this graph, the folded SAWs introduced in the previous section can be redefined more rigorously.


                        
                           Definition 2.3
                           
                              fSAW
                              
                                 n
                               is the connected component of the straight line 00…0 (n times) in 
                                 
                                    G
                                    n
                                 
                              , whereas 
                                 
                                    S
                                    n
                                 
                               is constituted by all the vertices of 
                                 
                                    G
                                    n
                                 
                              .

The Fig. 1 shows that the connected component fSAW(223) of the straight line in 
                           
                              G
                              223
                           
                         is not equal to the whole graph: 
                           
                              G
                              223
                           
                         is not connected. More precisely, this graph has a connected component of size 1: it is unfoldable whereas the SAW of Fig. 4
                         can be folded exactly once. Indeed, to be in the same connected component is an equivalence relation 
                           
                              R
                              n
                           
                         on 
                           
                              G
                              n
                           
                           ,
                           ∀
                           n
                           ∈
                           
                              
                                 
                                    ℕ
                                 
                              
                              *
                           
                        , and two SAWs 
                           w
                           ,
                           
                              w
                              ′
                           
                         are considered equivalent (with respect to this equivalence relation) if and only if there is a way to fold 
                           w
                         into 
                           
                              w
                              ′
                           
                         such that all the intermediate walks are self-avoiding. When existing, such a way is not necessarily unique.

These remarks lead to the following definitions.


                        
                           Definition 2.4
                           Let 
                                 n
                                 ∈
                                 
                                    
                                       
                                          ℕ
                                       
                                    
                                    *
                                 
                               and 
                                 w
                                 ∈
                                 
                                    S
                                    n
                                 
                              . We say that:
                                 
                                    •
                                    
                                       
                                          w
                                        is unfoldable if its equivalence class, with respect to 
                                          
                                             R
                                             n
                                          
                                       , is of size 1;


                                       
                                          w
                                        
                                       is a folded self-avoiding walk if its equivalence class contains the n-step straight walk 000…0 (n
                                       −1 times);


                                       
                                          w
                                        
                                       can be folded k times if a simple path of length k exists between 
                                          w
                                        and another vertex in the same connected component of 
                                          w
                                       .

Moreover, we introduce the following sets:
                                 
                                    •
                                    
                                       fSAW(n) is the equivalence class of the n−step straight walk, or the set of all folded SAWs.


                                       fSAW(n, k) is the set of equivalence classes of size k in 
                                          (
                                          
                                             G
                                             n
                                          
                                          ,
                                          
                                             R
                                             n
                                          
                                          )
                                       .


                                       USAW(n) is the set of equivalence classes of size 1 
                                          (
                                          
                                             G
                                             n
                                          
                                          ,
                                          
                                             R
                                             n
                                          
                                          )
                                       , that is, the set of unfoldable walks.


                                       f
                                       1
                                       SAW(n) is the complement of USAW(n) in 
                                          
                                             G
                                             n
                                          
                                       . This is the set of SAWs on which we can apply at least one pivot move of ±90°.


                        
                           Example 2.5
                           
                              Fig. 4 shows the two elements of a class belonging into fSAW(219, 2) whereas Fig. 1 is an element of USAW(223).

In Conway et al. (1993), Conway et al. have presented an algebraic technique for enumerating self-avoiding walks on a rectangular lattice. To recall in detail how the number 
                           ♯
                           
                              G
                              n
                           
                         of all possible SAWs has been computed until n
                        =71 is not the goal of this article. Let us just remark that they have rewritten the generating function for SAWs on the lattice using 5 irreducible components, whose generating functions are easier to calculate (see Formula 2.17 of Conway et al. (1993)). These irreducible components are obtained by considering projections of walks onto the y axis, and classify irreducible segments by the number of y bonds they span. The obtained cardinality of 
                           
                              G
                              n
                           
                        , is recalled in Table 2 for n
                        ≤31. For further detail, the reader is referred to Conway et al. (1993).

Authors of this research work have tried to adapt this very interesting approach by searching a way to decompose the generating function of folded self-avoiding walks in other generating functions easier to calculate. The way to take into account pivot moves that define such folded SAWs however has not yet been discovered. This is why the algebraic method has been abandoned after unsuccessful attempts to the benefit of a constructive brute force approach detailed in the following sections.

At each of our investigations, a draft program in Python language has been released first, to test rapidly the correctness of the approach. This code has been translated in an optimized C program and deployed on the supercomputer facilities of the Mésocentre de calcul de Franche-Comté. For readability and compactness, only the python programs are presented thereafter.

Python function called walks (Fig. 5
                        ) produces the list of all possible n-step walks as follows: the n-step walks are the walks of length n
                        −1 with 0, 1, 2, or 3 added to their tails (recursive call). The return is a list of walks, that is, a list of integers lists.

To obtain the walks belonging into 
                           
                              G
                              n
                           
                        , we first introduce the function points which aim is to produce the list of points (two coordinates) of the square lattice that corresponds to a given walk C. The encodes function that encodes a walk described as a list of points in its absolute encoding is provided in Fig. 6
                         with its decodes associated function.

On Fig. 7
                        , Function is_saw returns a Boolean: it is true if and only if the walk C satisfies the self-avoiding property. To do so, the list of its points in the lattice (its support) is produced, and it is regarded whether this list contains twice a same point (in other words, if the support has the same size than the list of points).

Function saws produces a generator. It returns the next SAW at each call of the next method on the generator. To do so, an exhaustive iteration of the list produced by walks is realized, and the is_saw function is applied to each element of this list, to test if this walk is self-avoiding.

These functions have been written and optimized in C language.

The folding property is checked thanks to the functions given on Fig. 8
                        . All the possible pivot moves (either in the clockwise direction, or in the anticlockwise) are checked to determine if a self-avoiding walk is unfoldable. The fold function tests, considering a given walk, a pivot move on residue number position following the given direction (+1 or −1, if clockwise or not). Function is_unfoldable applies the fold function to each residue of the candidate, and for the two possible directions. The function returns True if and only if no pivot move is possible.


                        Fig. 9
                         details how to enumerate walks in f
                        1
                        SAW(n) (the complement of USAW(n)) by constructing with a backtracking method all the k-step walks for k lower than a given threshold n, and increasing a counter at each time the walk is not unfoldable and of length n. The factor 4 at the end of the program is necessary as we always consider the first step of these walks to be 1 (South).

Backtracking method of Fig. 9 has been translated in C language, optimized, paralleled, and launched on the supercomputer facilities (at each time, SAWs are separated over available processors using MPI routines) as follows.

A first version of the program, with the print line above turned as non commented, has been launched with N
                        =14 and N
                        =20. By doing so, all the walks of 
                           
                              G
                              N
                           
                         that start in the East direction have been obtained (for N
                        =20, they represent 224424291 walks stored in 3 gigabytes of data). Then each of these 
                           |
                           
                              G
                              N
                           
                           |
                           /
                           4
                         self-avoiding walks has been the starting point of another backtracking discovery until n
                        >
                        N, and the unfoldable property of each of these n-step walk has been finally tested. This systematic approach as been successively launched until reaching n
                        =28, see Table 2. For (N, n)=(20, 28), 64 processors have been used during 70 hours in order to test the unfoldable property of 2351378582244 28-step self-avoiding walks, whereas no result has been obtained after 20 days of computation using the same facilities with (N, n)=(28, 30). We can summarize these results as follows:


                        
                           Proposition 3.6
                           
                              
                                 ∀
                                 n
                                 ≤
                                 28
                                 ,
                                 
                                    f
                                    1
                                 
                                 SAW
                                 (
                                 n
                                 )
                                 =
                                 
                                    G
                                    n
                                 
                              
                              .
                           

In the previous section, self-avoiding walks that can be folded at least once have been enumerated. That is, the cardinality of f
                        1
                        SAW(n) has been obtained for n
                        ≤28. A breadth first search is now presented to show how 
                           
                              G
                              n
                           
                           =
                           fSAW
                           (
                           n
                           )
                         has been obtained for n
                        ≤14.

The graph structure used in the Python draft program has been provided by the networkx library Hagberg et al. (2008), which is thus imported in the first line of Fig. 10
                        . The graph G representing 
                           G
                           (
                           n
                           )
                         is instantiated in the first line of Fig. 12, and the three following lines of this listing adds the node of the n-step straight line, shown as a word of n zeros. The association between relative encoding of a n-step walk described as an integer list and words on the alphabet {0, 1, 2, 3} of length n in the nodes of G is provided by function toString of Fig. 10.

Let us recall that there is an edge between two nodes in G if and only if the SAW of the second node can be obtained by a pivot move on the first walk. This pivot moves is realized on the integer lists of the relative encoding of the walk using the fold function presented in the previous section. This latter must be adapted a little, to match with the fact that G contains words (not lists of integers). This adaptation is also given in Fig. 10.

Then the whole connected component of the straight line is constructed using a breadth first search approach: at each iteration, the list of new walks that result from a fold on the last added nodes is obtained (with function explore of Fig. 11
                        ) and required connections are provided between last added walks and new discovered ones. The main issue in this approach is to prevent from visiting twice a given node, which is verified with the G.has_node method.

More precisely, given a last added node, function explore realizes a one depth exploration starting from this node, adds the new discovered nodes to G with related edges, and returns G with the list of these new nodes x. This x is used in Fig. 12 to constitute the next depth of exploration.

The current smallest unfoldable self-avoiding walk is a 107-step walk, as depicted in Fig. 13
                        
                        . The production of this counterexample and the systematic exploration of the connected component of the straight walk of 
                           
                              G
                              n
                           
                         for small n's presented previously allows us to claim that (see Table 2):


                        
                           Proposition 3.7
                           
                              Let ν
                              
                                 n
                               
                              the smallest n
                              ≥2 such that USAW(n)≠∅. Then 15≤
                              ν
                              
                                 n
                              
                              ≤107. In other words, 
                                 ∀
                                 n
                                 ≤
                                 14
                                 ,
                                 fSAW
                                 (
                                 n
                                 )
                                 =
                                 
                                    G
                                    n
                                 
                              
                              , whereas 
                              
                                 fSAW
                                 (
                                 107
                                 )
                                 ⊊
                                 
                                    G
                                    107
                                 
                              
                              .
                           

The key idea leading to our first discovery of an unfoldable self-avoiding walk is represented in Fig. 14
                        (a): a SAW constituted by two sub-walks that both fill almost 50% of a disc (approximately the same radius for the two sub-walks), when concatenated, can lead to an unfoldable self-avoiding walk if:
                           
                              •
                              when superposed, they fill almost 100% of the disc,

the extremities of the concatenated walks are near the center of the superposed disc.

Additionally, it is required that the first sub-walk ends itself by visiting its boundary circle whereas the second sub-walk starts by visiting this circle (more precisely, an equivalent circle with a slight different radius). These two sub-walks have been obtained by following two closed spiral trajectories in the opposite direction.

By this way, no pivot move should be realized without breaking the self-avoiding property. Indeed, due to the compactness of the resulting walk having the form of a disc, no pivot move should be achieved inside the disc, whereas a pivot move at its bounds (the circle) separates the whole disc in two overlapping ones, as depicted in Fig. 14(a). A first realization of such an unfoldable SAW is shown in Fig. 14(b).

After obtaining our first unfoldable self-avoiding walks, the second stage was to reduce their number of steps by removing the central part of the discs and reducing, bit by bit, its radius. The first operation has been realized by removing the head of the first sub-walk and the tail of the second one, whereas the second operation consists in removing the end (resp., the beginning) of the spirals mentioned above. After having found a self-avoiding walk having the form of a smaller disc, the use of the backtracking program of Fig. 9 has often been required to make this SAW as unfoldable. 1840 unfoldable self-avoiding walks have been discovered by doing so, a few of them being represented in Table 1
                        , while they are counted according to their number of steps in Table 2
                        .

A second approach to obtain unfoldable SAWs is to take a compact unfoldable SAW bounded by a kind of circle, and to extend it by two connected spirals covered in opposite direction, as depicted in Fig. 15
                        . A proof of the correctness of this approach, leading to an infinite number of unfoldable self-avoiding walks, is detailed in Bahi et al. (2013c).

However, as by this extension-based method it is obviously impossible to obtain the shortest unfoldable self-avoiding walk, such an approach will not be discussed in detail in this research work (for further details about this approach, the reader is referred to Bahi et al. (2013c)).

A first quite optimistic heuristic method to discover smaller unfoldable self-avoiding walks is to follow a Monte-Carlo approach, as described in what follows. Starts first with the origin (0, 0), then at each iteration:
                        
                           1
                           Pick randomly a stretching direction among the {0, 1, 2, 3} set.

If it is possible to extend the current walk in that direction while preserving the self-avoiding property, then:
                                 
                                    •
                                    do the extension;

if the obtained walk has the targeted number of steps, then tests if it is unfoldable.

If not, try to pick a new stretching direction again until reaching a predefined number of attempts. If this number is reached, then restart the whole process.

Of course, when picking a new direction in {0, 1, 2, 3}, the previous one is considered beforehand and the set is adapted: if the previous move was 0, then the next one is picked in {0, 1, 3}, as direct reversals are banished to preserve the self-avoiding property.

An implemented improvement of this Monte-Carlo based approach for finding unfoldable self-avoiding walks is to consider that such walks are perhaps more compact than other SAWs, as any pivot move must meet the tail of the structure. To take benefits of such an assessment, assuming that to be true, we have required in a new version of the Monte-Carlo program that the walks must stay in a N
                     ×
                     N lattice, restarting the process at each time a SAW has an height or a width exceeding N. We have experimentally limited the lattice to a square of size 13×13 and to self-avoiding walks having a number of steps lower than 100. However, no smaller unfoldable SAW has been discovered after 15 days of computation on the supercomputer facilities.

Remark that a second version of the backtracking algorithm has been written too, to take into account restrictive N
                     ×
                     N square lattices. However, this program has not allow the author's to discover smaller unfoldable self-avoiding walks than the one depicted in Fig. 13.

Other investigated approaches encompass stretching method presented in Fig. 16
                     , the computing of the fact that the extremities of the walk should be closed one to each other, and an adaptable probability distribution of the stretching direction set {0, 1, 2, 3} for favoring the ones that stretch the walk in the center of the walk. They all have lead to a failure in discovering shorter unfoldable self-avoiding walks.

To investigate folded and unfoldable self-avoiding walks, we have developed a Python Phyton (2013) interface hosted in https://code.google.com/p/pysaw and freely available
                        2
                     
                     
                        2
                        This python code is maintained by Christophe Guyeux (christophe.guyeux@univ-fcomte.fr, any feedback is welcome).
                     . The interface is depicted in Fig. 17
                      and its current functionality is detailed below.

The interface is divided in four parts: a sandbox where the SAW is drawn, two frames for configuration and backtracking, and the relative encoding of the depicted self-avoiding walk at the bottom of the window. A menu bar with common File, Edit, and Help items completes the interface.

In the sandbox frame, is is possible to construct a SAW step by step by using arrow keys (left, right, up, bottom). The initial vertex is the black square while the green square represents the last vertex. Other vertices and the remainder of the walk are represented in blue. A vertex V is represented by a circle when at least one of the two ±90° pivot moves on V leads to a new walk satisfying the self-avoiding property, whereas it is a square when this vertex is unfoldable. Intersections in the walk, for its part, are depicted by a red square, as represented in Fig. 17.

Various modification capabilities of the depicted walk have been added. Del key removes the last vertex whereas Back Space one deletes the first vertex. An item in the Edit menu allows the deletion of a sub-walk between two vertices selected by the right mouse button: the two remainder sub-walks are then concatenated. The Edit menu contains also an item that reverses the walk (maps 
                        w
                        (
                        0
                        )
                        …
                        w
                        (
                        n
                        )
                      in 
                        w
                        (
                        n
                        )
                        …
                        w
                        (
                        0
                        )
                     . A click on the left mouse button on a vertex realizes a +90° pivot move on this point whereas a right click makes a pivot move in the reverse direction. Another computed facility is the capability to extend a walk between two points by a right button drag-and-drop: the walk between the two extremities (vertices) of this drag-and-drop is replaced by the walk of the mouse motion. Control-s is a fast save of the walk in length.txt file, while Control-q quit the program. Finally, Control-z combination undoes the last modification whereas Control-Z redoes it. Let us remark that, at each modification, the relative encoding of the walk provided at the bottom of the window is naturally updated.

The representation of the walk in the sandbox can be altered by two check boxes in the Configuration panel. The Vertices check box enables or not the representation of the vertices as circles. When enabled, a second check box entitled “Unfoldable” enables the computation of each vertex: unfoldable (square) or not (circle). In Fig. 17 this check box is enabled whereas it is disabled in Fig. 18
                     . To disable this check box is a necessity for very long walks, due to computation time. Another check box specifies if origin and axes must be represented in the sandbox (the origin can be changed in the Edit menu). Other information represented in the Configuration panel are the number of steps of the walk (length), its width and height, its number of intersections and of unfoldable vertices. Such information is used when representing the walk. Indeed, when the check box “Figure adaptation” is enabled, then the representation of the walk is modified in such a way that this walk is always contained in the frame: the length of the step and the position of the walk are adapted to the frame, depending on the width and height of the walk. If not enabled, the walk can goes outside the frame during a pivot move (for instance), which can be desired to understand the effects of a given pivot move: the head of the walk does not move, is not adapted to the figure, during this pivot.

The position of the mouse is given too in the Configuration panel, depending on the chosen origin. Initially, this origin is set to the first node of the walk but, as stated before, it is possible to change it using New origin of the Edit menu. When the mouse is positioned on a vertex 
                        w
                        (
                        k
                        )
                      of the walk, its position k is informed in parenthesis and, if the “Show future intersection” check box is enabled, the list of intersections implied by ±90° pivot moves on 
                        w
                        (
                        k
                        )
                      is provided at the bottom of the Configuration panel.

Other functionality of the PyUSAW software encompasses a backtracking search of unfoldable SAWs, based on Fig. 9. The self-avoiding walk of the sandbox is extended systematically until reaching the specified deepness and, at each time an unfoldable SAW is found, its relative encoding is printed on the terminal. Drawn self-avoiding walks can be saved as a relative encoding text file, which can contain or not the position of 
                        w
                        (
                        0
                        )
                      in the square lattice, and naturally these text files can be opened by PyUSAW. Finally, the walk can be exported too in various image formats (SAWs represented in this research work have been obtained using this interface).

@&#CONCLUSION@&#

In this article, various computational methods have been proposed to investigate the newly discovered folded and unfoldable subsets of walks. These methods encompass backtracking, breadth first search, and Monte-Carlo approaches. The targeted goals was to find when the set of folded SAWs becomes different from the set of all self-avoiding walks, and to discover the shortest unfoldable SAWs. Significant advances have been achieved and explained with details, and an original Python tool to facilitate the study of these important SAW subsets has finally been presented.

In future work, the authors’ intention is to restrict the range of uncertainties regarding the smallest n such that 
                        fSAW
                        (
                        n
                        )
                        ≠
                        
                           G
                           n
                        
                     , which is currently known to belong in 〚15, 107〛. To do so, computational methods presented in this article, often quite naive, will be enhanced and optimized. Heuristic approaches encompassing swarm particles and genetic algorithms, will be regarded too to discover shorter unfoldable SAWs, if exist. Theoretically speaking, a complexity study of the protein structure prediction problem in the subset of folded SAWs will be realized, and we will try to rewrite the generating function of folded SAWs in other generating functions easier to calculate. Finally, consequences regarding the best ways to make protein structure prediction will be investigate.

@&#ACKNOWLEDGMENTS@&#

The authors wish to thank Thibaut Cholley, Raphaël Couturier, Jean-Marc Nicod, and Alain Giorgetti for their help in understanding folded and unfoldable SAWs. All the computations presented in the paper have been performed on the supercomputer facilities of the Mésocentre de calcul de Franche-Comté.

@&#REFERENCES@&#

