@&#MAIN-TITLE@&#Minimizing earliness and tardiness costs in stochastic scheduling

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We address the stochastic earliness/tardiness sequencing problem.


                        
                        
                           
                           A branch and bound algorithm finds optimal solutions to problems up to 20 jobs.


                        
                        
                           
                           For larger problems, it is possible to exploit asymptotic optimality.


                        
                        
                           
                           A heuristic solution method generated optimal solutions for all test problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Sequencing

Stochastic scheduling

Earliness/tardiness

Branch and bound

Neighborhood search

Due-date assignment

@&#ABSTRACT@&#


               
               
                  We address the single-machine stochastic scheduling problem with an objective of minimizing total expected earliness and tardiness costs, assuming that processing times follow normal distributions and due dates are decisions. We develop a branch and bound algorithm to find optimal solutions to this problem and report the results of computational experiments. We also test some heuristic procedures and find that surprisingly good performance can be achieved by a list schedule followed by an adjacent pairwise interchange procedure.
               
            

@&#INTRODUCTION@&#

The single-machine sequencing model is the basic paradigm of scheduling theory. In its deterministic version, the model has received a great deal of attention from researchers, leading to problem formulations, solution methods, scheduling insights, and building blocks for more complicated models. Extending that model into the realm of stochastic scheduling is an attempt to make the theory more useful and practical. However, progress in analyzing stochastic models has been much slower to develop, and even today some of the basic problems remain virtually unsolved. One such case is the stochastic version of the earliness/tardiness (E/T) problem for a single machine.

This paper presents a branch and bound (B&B) algorithm for solving the stochastic E/T problem with normally-distributed processing times and due dates as decisions. This is the first appearance of a solution algorithm more efficient than complete enumeration for this problem, so we provide some experimental evidence on the algorithm’s computational capability. Although B&B algorithms are not new, they have seldom been applied to problems in stochastic scheduling. Arguably, too little research has been done on the application of such optimization approaches in stochastic scheduling problems, so a broader goal of this paper is to demonstrate that methodologies common in deterministic scheduling can successfully be applied to problems in stochastic scheduling.

In addition, we explore heuristic methods for solving the problem, and we show that a relatively simple procedure can be remarkably successful at producing optimal or near-optimal solutions. These results reinforce and clarify observations made in earlier research and ultimately provide us with a practical method of solving the stochastic E/T problem with virtually any number of jobs.

In Section 2 we formulate the problem under consideration, and in Section 3 we review the relevant literature. In Section 4, we describe the elements of the optimization approach, and we report computational experience in Section 5. Section 6 deals with heuristic procedures and the corresponding computational tests, and the final section provides a summary and conclusions.

In this paper we study the stochastic version of the single-machine E/T problem with due dates as decisions. To start, we work with the basic single-machine sequencing model (Baker & Trietsch, 2009a). In the deterministic version of this model, n jobs are available for processing at time 0, and their parameters are known in advance. The key parameters in the model include the processing time for job j (pj
                     ) and the due date (dj
                     ). In the actual schedule, job j completes at time Cj
                     , giving rise to either earliness or tardiness. The job’s earliness is defined by Ej
                     
                     =max{0, dj
                     
                     −
                     Cj
                     } and its tardiness by Tj
                     
                     =max{0, Cj
                     
                     −
                     dj
                     }. Because the economic implications of earliness and tardiness are not necessarily symmetric, the unit costs of earliness (denoted by αj
                     ) and tardiness (denoted by βj
                     ) may be different. We express the objective function, or total cost, as follows:
                        
                           (1)
                           
                              G
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    n
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              (
                              
                                 
                                    α
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    E
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    β
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    T
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        
                     
                  

The deterministic version of this problem has been studied for over 30years, and several variations have been examined in the research literature. Some of these variations have been solved efficiently, but most are NP-Hard problems. In the stochastic E/T problem, we assume that the processing times are random variables, so the objective becomes the minimization of the expected value of the function in (1). The stochastic version of the E/T problem has not been solved.

To proceed with the analysis, we assume that the processing time pj
                      follows a normal distribution with mean μj
                      and standard deviation σj
                      and that the pj
                      values are independent random variables. We use the normal because it is familiar and plausible for many scheduling applications. Few results in stochastic scheduling apply for arbitrary choices of processing time distributions, so researchers have gravitated toward familiar cases that resonate with the distributions deemed to be most practical. Several papers have addressed stochastic scheduling problems and have used the normal distribution as an appropriate model for processing times. Examples include Anderson and Moodie (1969), Balut (1973), Cai and Zhou (2007), Jang (2002), Portougal and Trietsch (2006), Sarin, Erdel, and Steiner (1991), Seo, Klein, and Jang (2005), Soroush (1999), Soroush and Fredendall (1994), and Wu, Brown, and Beck (2009).
                  

In our model, the due dates dj
                      are decisions and are not subject to randomness. The objective function for the stochastic problem may be written as
                        
                           (2)
                           
                              H
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    n
                                 
                              
                              )
                              =
                              E
                              [
                              G
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    n
                                 
                              
                              )
                              ]
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              (
                              
                                 
                                    α
                                 
                                 
                                    j
                                 
                              
                              E
                              [
                              
                                 
                                    E
                                 
                                 
                                    j
                                 
                              
                              ]
                              +
                              
                                 
                                    β
                                 
                                 
                                    j
                                 
                              
                              E
                              [
                              
                                 
                                    T
                                 
                                 
                                    j
                                 
                              
                              ]
                              )
                           
                        
                     The problem consists of finding a set of due dates and a sequence of the jobs that produce the minimum value of the function in (2).

@&#LITERATURE REVIEW@&#

The model considered in this paper brings together several strands of scheduling research – namely, earliness/tardiness criteria, due-date assignments, and stochastic processing times. We trace the highlights of these themes in the subsections that follow.

Scheduling problems comprising both earliness costs and tardiness costs were first examined for the case in which processing times and due dates are given. This type of problem was first studied by Sidney (1977), who analyzed the minimization of maximum cost and by Kanet (1981), who analyzed the minimization of total absolute deviation from a common due date, under the assumption that the due date is late enough that it does not impose constraints on sequencing choices. This objective is equivalent to an E/T problem in which the unit costs of earliness and tardiness are symmetric and the same for all jobs. For this special case, Hall, Kubiak, and Sethi (1991) developed an optimization algorithm capable of solving problems with hundreds of jobs, even if the due date is restrictive. In addition, Hall and Posner (1991) solved the version of the problem with symmetric earliness and tardiness costs that vary among jobs. Their algorithm handles over a thousand jobs.

The case of distinct due dates is somewhat more challenging than the common due-date model. Garey, Tarjan, and Wilfong (1988) showed that the E/T problem with distinct due dates is NP-Hard, although for a given sequence, the scheduling of idle time can be determined by an efficient algorithm. Optimization approaches to the problem with distinct due dates were proposed and tested by Abdul-Razaq and Potts (1988), Ow and Morton (1989), Yano and Kim (1991), Azizoglu, Kondakci, and Kirca (1991), Kim and Yano (1994), Fry, Armstrong, Darby-Dowman, and Philipoom (1996), Li (1997), and Liaw (1999). Fry et al. addressed the special case in which earliness costs and tardiness costs are symmetric and common to all jobs. Their B&B algorithm was able to solve problems with as many as 25 jobs. Azizoglu et al. addressed the version in which earliness costs and tardiness costs are common, but not necessarily symmetric, and with inserted idle time prohibited. Their B&B algorithm solved problems with up to 20 jobs. Abdul-Razaq and Potts developed a B&B algorithm for the more general cost structure with distinct costs but prohibited inserted idle time. Their algorithm was able to solve problems up to about 25 jobs. Li proposed an alternative lower bound calculation for the same problem but still encountered computational difficulties in solving problems larger than about 25 jobs. Liaw’s subsequent improvements extended this range to at least 30 jobs.

Because optimization methods have encountered lengthy computations times for problems larger than about 25–30 jobs, much of the computational emphasis has been on heuristic procedures. Ow and Morton were primarily interested in heuristic procedures for a version of the problem that prohibits inserted idle time, but they utilized a B&B method to obtain solutions (or at least good lower bounds) to serve as a basis for evaluating their heuristics. They reported difficulty in finding optimal solutions to problems containing 15 jobs. Yano and Kim compared several heuristics for the special case in which earliness and tardiness costs are proportional to processing times. The B&B algorithm they used as a benchmark solved most of their test problems up to about 16 jobs. Kim and Yano developed a B&B algorithm to solve the special case in which earliness costs and tardiness costs are symmetric and identical. Their B&B algorithm solved all of their test problems up to about 18 jobs. Lee and Choi (1995) reported improved heuristic performance from a genetic algorithm. To compare heuristic methods, they used lower bounds obtained from CPLEX runs that were often terminated after 2hours of run time, sometimes even for problems containing 15 jobs. James and Buchanan (1997) studied variations on a tabu-search heuristic and used an integer program to produce optimal solutions for problems up to 15 jobs.

Detailed reviews of this literature have been provided by Kanet and Sridharan (2000), Hassin and Shani (2005) and M’Hallah (2007). The reason for emphasizing problem sizes in these studies, although they may be somewhat dated, is to contrast the limits on problem size encountered in studies of the distinct due-date problem with those encountered in the common due-date problem. This pattern suggests that stochastic versions of the problem may also be quite challenging when each job has its own due date.

The due-date assignment problem is familiar in the job shop context, in which due dates are sometimes assigned internally as progress targets for scheduling. However, for our purposes, we focus on single-machine cases. Perhaps the most extensively studied model involving due-date assignment is the E/T problem with a common due date. The justification for this model is that it applies to several jobs of a single customer, or alternatively, to several subassemblies of the same final assembly. The E/T problem still involves choosing a due date and sequencing the jobs, but the fact that only one due date exists makes the problem intrinsically different from the more general case involving a distinct due date assignment for each job. Moreover, flexibility in due-date assignment means that the choice of a due date can be made without imposing unnecessary constraints on the problem, so formulations of the due date assignment problem usually correspond to the common due-date problem with a given but nonrestrictive due date.


                        Panwalkar, Smith, and Seidmann (1982) introduced the due-date assignment decision in conjunction with the common due-date model, augmenting the objective function with a cost component for the lead time. In their model, the unit earliness costs and unit tardiness costs are asymmetric but identical across jobs. The results include a simple algorithm for finding the optimal due date. Surveys of the common due-date assignment problem were later compiled by Baker and Scudder (1990) and by Gordon, Proth, and Chu (2002). As discussed below, however, very little of the work on due-date assignment has dealt with stochastic models.

Actually, in the deterministic case, if due dates are distinct, then the due-date assignment problem is trivial because earliness and tardiness can be avoided entirely. Baker and Bertrand (1981), who examined heuristic rules for assigning due dates, such as those based on constant, slack-based, or total-work leadtimes, also characterized the optimal due-date assignment when the objective is to make the due dates as tight as possible. Seidmann, Panwalkar, and Smith (1981) proposed a specialized variation of the single-machine model with unit earliness and tardiness costs common to all jobs, augmenting the objective function with a cost component that penalizes loose due dates if they exceed customers’ reasonable and expected lead time. They provided an efficient solution to that version of the problem as well. Other augmented models were addressed by Shabtay (2008). Because the due-date assignment problem is easy to solve in the single-machine case when due dates are distinct, papers on the deterministic model with distinct due dates typically assume that due dates are given, and relatively few papers deal with distinct due dates as decisions. When processing times are stochastic, however, the due-date assignment problem becomes more difficult.

The stochastic counterpart of a deterministic sequencing problem is defined by treating processing times as uncertain and then minimizing the expected value of the original deterministic performance measure. Occasionally, it is possible to substitute mean values for uncertain processing times and simply call on results from deterministic analysis. This approach works for the minimization of expected total weighted completion time, which is minimized by sequencing the jobs in order of shortest weighted expected processing time, or SWEPT (Rothkopf, 1966). For the minimization of expected maximum tardiness, it is optimal to sequence the jobs in order of earliest due date, or EDD (Crabill & Maxwell, 1969). However, replacing uncertain processing times by mean values and calculating the deterministic objective function under EDD may not produce the correct value for the stochastic objective function. In fact, suppressing uncertainty seldom leads to the optimal solution of stochastic sequencing problems; problems that are readily solvable in the deterministic case may be quite difficult to solve when it comes to their stochastic counterpart. An example is the minimization of the number of stochastically tardy jobs (i.e., those that fail to meet their prescribed service levels). Kise and Ibaraki (1983) showed that even this relatively basic problem is NP-Hard.

Stochastic scheduling problems involving earliness and tardiness have rarely been addressed in the literature. Cai and Zhou (2007) analyzed a stochastic version of the common due-date problem with earliness and tardiness costs (augmented by a completion-time cost), with the due date allowed to be probabilistic and the variance of each processing time distribution assumed to be proportional to its mean. Although the proportionality condition makes the problem a special case, it can at least be considered a stochastic counterpart of a deterministic model discussed by Baker and Scudder (1990). Xia, Chen, and Yue (2008) described a heuristic procedure to solve the stochastic E/T problem with common earliness costs and common tardiness costs, augmented by a cost component reflecting the tightness of the due dates. This formulation is the stochastic counterpart of a special case of the problem analyzed by Seidmann et al. (1981), which was solved by an efficient algorithm.

The more general stochastic version of the common due-date problem has not been solved, and only modest progress has been achieved on the stochastic E/T problem with distinct due dates. Soroush and Fredendall (1994) analyzed a version of that problem with due dates given. Soroush (1999) later proposed some heuristics for the version with due dates as decisions, and Portougal and Trietsch (2006) showed that one of those heuristics was asymptotically optimal. However, an optimization algorithm for that problem has not previously been developed and tested. Thus, this paper develops an optimization algorithm to solve a problem that heretofore has been attacked only with heuristic procedures. One hint that B&B techniques may be successful in attacking a stochastic sequencing problem with due-dates as decisions comes from the recent results in Baker (2014), who showed how to solve a basic safe-scheduling problem with branch and bound.

To analyze the model in (2), we exploit the property that sums of normal random variables are also normal. Thus, in any sequence, the completion time of job j follows a normal distribution. Using notation, let Bj
                      denote the set of jobs preceding job j in the schedule. Then Cj
                      follows a normal distribution with mean 
                        
                           E
                           [
                           
                              
                                 C
                              
                              
                                 j
                              
                           
                           ]
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 ∈
                                 
                                    
                                       B
                                    
                                    
                                       j
                                    
                                 
                              
                           
                           
                              
                                 μ
                              
                              
                                 i
                              
                           
                           +
                           
                              
                                 μ
                              
                              
                                 j
                              
                           
                        
                      and variance 
                        
                           var
                           [
                           
                              
                                 C
                              
                              
                                 j
                              
                           
                           ]
                           =
                           
                              
                                 s
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 ∈
                                 
                                    
                                       B
                                    
                                    
                                       j
                                    
                                 
                              
                           
                           
                              
                                 σ
                              
                              
                                 i
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 σ
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                        
                     . To streamline the notation, we write 
                        
                           E
                           [
                           
                              
                                 C
                              
                              
                                 j
                              
                           
                           ]
                           =
                           
                              
                                 μ
                              
                              
                                 
                                    
                                       B
                                    
                                    
                                       j
                                    
                                 
                              
                           
                           +
                           
                              
                                 μ
                              
                              
                                 j
                              
                           
                        
                      and 
                        
                           
                              
                                 s
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                           =
                           
                              
                                 σ
                              
                              
                                 
                                    
                                       B
                                    
                                    
                                       j
                                    
                                 
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 σ
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                        
                     . Once we know the properties of the random variable Cj
                     , we can determine the optimal choice of dj
                     .
                        Theorem 1
                        
                           Given the mean E[Cj] and the standard deviation sj of the normal distribution for Cj, the optimal choice of the due date dj is given by:
                           
                              
                                 
                                    Φ
                                    (
                                    
                                       
                                          k
                                       
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                β
                                             
                                             
                                                j
                                             
                                          
                                       
                                       
                                          
                                             
                                                α
                                             
                                             
                                                j
                                             
                                          
                                          +
                                          
                                             
                                                β
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                           where 
                           
                              
                                 
                                    
                                       k
                                    
                                    
                                       j
                                    
                                    
                                       ∗
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                 
                                 -
                                 E
                                 [
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                                 ]
                                 )
                                 /
                                 
                                    
                                       s
                                    
                                    
                                       j
                                    
                                 
                              
                            
                           represents the standardized due date and where Φ(⋅) denotes the standard normal cdf.

This result is originally due to Soroush (1999). For completeness and consistency in notation, it is derived in Appendix A.
                        1
                        The appendices can be found in an Online Supplement.
                     
                     
                        1
                      The result is also familiar as the “newsvendor” property of inventory theory; it specifies the optimal service level (the probability that job j completes on time), thereby linking the model to basic notions of safe scheduling (Baker & Trietsch, 2009b).

The implication of Theorem 1 is that the appropriate choice for the due date of job j is
                        
                           (3)
                           
                              
                                 
                                    d
                                 
                                 
                                    j
                                 
                              
                              =
                              E
                              [
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ]
                              +
                              
                                 
                                    k
                                 
                                 
                                    j
                                 
                                 
                                    ∗
                                 
                              
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    μ
                                 
                                 
                                    
                                       
                                          B
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                              +
                              
                                 
                                    μ
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    k
                                 
                                 
                                    j
                                 
                                 
                                    ∗
                                 
                              
                              
                                 
                                    (
                                    
                                       
                                          σ
                                       
                                       
                                          
                                             
                                                B
                                             
                                             
                                                j
                                             
                                          
                                       
                                       
                                          2
                                       
                                    
                                    +
                                    
                                       
                                          σ
                                       
                                       
                                          j
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 
                                    1
                                    /
                                    2
                                 
                              
                           
                        
                     In this expression the due date dj
                      depends on the previous jobs in sequence via the set Bj
                     , and the objective is summarized in (2). From the algebraic derivation given in Appendix A, we can rewrite (2) by incorporating the optimal choice of dj
                     . The objective becomes
                        
                           (4)
                           
                              H
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    n
                                 
                                 
                                    ∗
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              φ
                              (
                              
                                 
                                    k
                                 
                                 
                                    j
                                 
                                 
                                    ∗
                                 
                              
                              )
                              (
                              
                                 
                                    α
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    β
                                 
                                 
                                    j
                                 
                              
                              )
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 k
                              
                              
                                 j
                              
                              
                                 ∗
                              
                           
                        
                      is the standard normal variate corresponding to the optimal service level of Theorem 1. However, from the given values of αj
                      and βj
                     , we can compute the corresponding value of 
                        
                           φ
                           (
                           
                              
                                 k
                              
                              
                                 j
                              
                              
                                 ∗
                              
                           
                           )
                        
                      and substitute 
                        
                           
                              
                                 c
                              
                              
                                 j
                              
                           
                           =
                           φ
                           (
                           
                              
                                 k
                              
                              
                                 j
                              
                              
                                 ∗
                              
                           
                           )
                           (
                           
                              
                                 α
                              
                              
                                 j
                              
                           
                           +
                           
                              
                                 β
                              
                              
                                 j
                              
                           
                           )
                        
                     , allowing us to rewrite the objective function more simply as
                        
                           (5)
                           
                              H
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    n
                                 
                                 
                                    ∗
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                           
                        
                     Having specified the objective function, we are interested in finding its optimal value. It is possible, of course, to find an optimum by enumerating all possible job sequences and then selecting the sequence with minimal objective function value. Until now, enumeration has been the only solution algorithm known for this problem, as in Soroush (1999). However, as a computational method, enumeration is ultimately limited by the size of the solution space. (Soroush reported obtaining solutions for 12-job problems in an average of more than 9hours of cpu time.) We can compute optimal solutions more efficiently by employing dominance conditions and a B&B algorithm, which we describe next.

Dominance conditions can accelerate the search for an optimal schedule. Job j is said to dominate job k if an optimal sequence exists in which job j precedes job k. If we confirm a dominance condition of this type, then in searching for an optimal sequence we need not pursue any partial sequence in which job k precedes job j. Dominance conditions can reduce the computational effort required to find an optimal schedule, but the extent to which they apply depends on the parameters in a given problem instance. For that reason, it is difficult to predict the extent of the improvement.

In our model, a relatively simple dominance condition holds.
                           Theorem 2
                           
                              For two jobs j and k, if cj
                                 ⩾ck and σj
                                 ⩽σk then job j dominates job k.

Suppose we have a partial sequence of the jobs, denoted by π, and we wish to compute a lower bound on the value of the objective function (5) that can be obtained by completing the sequence. From the partial sequence we can calculate the portion of the objective function contributed by the jobs in π. Now, let π′ denote the set of unscheduled jobs. In the set π′, we take the set of coefficients cj
                         in largest-first order and separately, the set of standard deviations σj
                         in smallest-first order, and we treat these values as if they were paired in the set of unscheduled jobs. These are fictitious jobs due to the rearrangement of coefficients and standard deviations. Next we calculate each fictitious job’s contribution to the objective and add it to the portion for the partial sequence π. This total provides a lower bound (denoted by LB1) on the value that could be achieved by completing the partial sequence in the best possible way. The justification is based on the following two (new) results.
                           Theorem 3
                           
                              For any sequence of coefficients cj, the expression 
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          s
                                       
                                       
                                          j
                                       
                                    
                                 
                               
                              is minimized by sequencing the σ-values in nondecreasing order. (See 
                              Appendix B 
                              for a proof.)
                           


                              For any sequence of σ-values, the expression 
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          s
                                       
                                       
                                          j
                                       
                                    
                                 
                               
                              is minimized by sequencing the c-values in nonincreasing order. (See 
                              Appendix B 
                              for a proof.)
                           

Thus, in the course of an enumerative search, if we encounter a partial sequence for which the lower bound is greater than or equal to the value of the objective function for a full sequence, we know that the partial sequence can never lead to a solution better than the full sequence. We can also combine lower bounds along with dominance conditions in the search. This combination involves the most testing of conditions, but it can eliminate the most partial sequences, and the combination leads to reduced computation times in all but the smallest problems.

To illustrate the calculations involved in the calculation of the lower bound, consider the five-job example in Table 1
                        , and assume that job 1 has been placed first in sequence so that π
                        ={1}, with the other four jobs remaining to be scheduled.

We first consider the four unscheduled jobs. If we order the jobs according to Theorem 2, with σ-values in nondecreasing sequence, the job sequence is 4-2-3-5. If we order the jobs according to Theorem 3, with c-values in nonincreasing sequence, the job sequence is 5-4-3-2. Thus, the sequence starting with job 1 followed by four fictitious jobs (f1–f4) exhibits the parameters obtained from these two sequences, as shown in Table 2
                        .

The lower bound LB1 is computed as 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                              =
                              91.560
                           
                        .

A different lower bound was described by Portougal and Trietsch (2006), although they did not test their bound in a B&B algorithm. Again, suppose we have a partial sequence of the jobs, denoted by π, and we wish to compute a lower bound on the value of the objective function (5) that can be obtained by completing the sequence. From the partial sequence we can calculate
                           
                              
                                 
                                    
                                       s
                                    
                                    
                                       0
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      ∈
                                                      π
                                                   
                                                
                                             
                                             
                                                
                                                   σ
                                                
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       1
                                       /
                                       2
                                    
                                 
                              
                           
                        Again, let π′ denote the set of unscheduled jobs and reorder them by nondecreasing ratios of 
                           
                              
                                 
                                    σ
                                 
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                              /
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                           
                        . Temporarily, we also renumber the jobs in π′ according to this ordering, and we let:
                           
                              
                                 
                                    
                                       s
                                    
                                    
                                       j
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          π
                                       
                                    
                                 
                                 
                                    
                                       σ
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ⩽
                                          j
                                       
                                    
                                 
                                 
                                    
                                       σ
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        For job j, a lower bound on its contribution (in this sequence) to the objective function is calculated as
                           2
                           An erroneous formula appeared in the original article due to a misprint.
                        
                        
                           2
                        
                        
                           
                              
                                 
                                    
                                       g
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       2
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                    
                                    
                                       3
                                       
                                          
                                             σ
                                          
                                          
                                             j
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   j
                                                
                                                
                                                   3
                                                
                                             
                                             -
                                             
                                                
                                                   s
                                                
                                                
                                                   j
                                                   -
                                                   1
                                                
                                                
                                                   3
                                                
                                             
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 .
                              
                           
                        Therefore, a lower bound (denoted by LB2) on the best objective that can be obtained by completing the partial schedule π takes the form 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    π
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          π
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    j
                                 
                              
                              .
                           
                         In this paper, we test for the first time the computational implications of using this bound.

To illustrate the calculations involved in the calculation of LB2, we return to the example in Table 1, with job 1 placed first in sequence. For this partial sequence, s
                        0
                        =5.

The unscheduled jobs are considered in nondecreasing order of their weighted variance, and the calculations of gj
                         follow. Finally, the lower bound is calculated as 
                           
                              LB
                              2
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    π
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    s
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          π
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    j
                                 
                              
                              =
                              8.775
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          π
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    j
                                 
                              
                              =
                              93.878
                           
                         (see Table 3
                        ).

Before describing the computational experiments, we pause to reflect on two special cases related to the development of the deterministic E/T problem. First, consider the special case in which earliness costs are the same for all jobs (αj
                        
                        =
                        α) and tardiness costs are the same for all jobs (βj
                        
                        =
                        β). In that case, the ratio βj
                        /(αj
                        
                        +
                        βj
                        ) is the same for all jobs. Thus, 
                           
                              φ
                              (
                              
                                 
                                    k
                                 
                                 
                                    j
                                 
                                 
                                    ∗
                                 
                              
                              )
                              =
                              φ
                              (
                              
                                 
                                    k
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         and cj
                        
                        =
                        c. The objective function in (5) becomes
                           
                              
                                 H
                                 (
                                 
                                    
                                       d
                                    
                                    
                                       1
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       n
                                    
                                    
                                       ∗
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       cs
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 c
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       s
                                    
                                    
                                       j
                                    
                                 
                              
                           
                        Therefore, by Theorem 3, the optimal sequence in the stochastic case is obtained by ordering the jobs by shortest variance (equivalently, shortest standard deviation). Thus, when the unit earliness and tardiness costs are common to all jobs, the optimal solution can be obtained efficiently. In the stochastic E/T problem, then, the problem becomes much more challenging when the unit costs are distinct. This property echoes the result of Seidmann et al. (1981) for the deterministic counterpart.

A further special case corresponds to the minimization of total expected absolute deviation (of completion time from due date), which corresponds to αj
                        
                        =
                        βj
                        
                        =1. In this case, the optimal sequence is again obtained by ordering the jobs by shortest variance. In addition, 
                           
                              
                                 
                                    k
                                 
                                 
                                    j
                                 
                                 
                                    ∗
                                 
                              
                              =
                              0
                           
                        , so each job’s due date is optimally assigned to the job’s expected completion time in the sequence. This property echoes the result of Baker and Bertrand (1981) for the deterministic counterpart.

For experimental purposes, we generated a set of test problems that would permit comparisons of the various algorithms. The mean processing times μj
                      were sampled from a uniform distribution between 10 and 100. Then, for each job j, the standard deviation was sampled from a uniform distribution between 0.10μj
                      and 0.25μj
                     . In other words, the mean was between 4 and 10 times the standard deviation, so the chances of encountering a negative value for a processing time would be negligible. (Very few precedents can be found in the literature for designing test problems for stochastic scheduling. However, this design resembles previous experimental work with the normal distribution: Xia et al. (2008) also generated mean values as small as 4 times the standard deviation, while Soroush (1999) and Cai and Zhou (2007) allowed for means as small as 3.4 times the standard deviation.) In addition, the unit costs αj
                      and βj
                      were sampled independently from a uniform distribution between 1 and 10 on a grid of 0.1. For each value of n, a sample of 100 randomly-generated problem instances was created.

The B&B algorithm was coded in VBA to maintain an easy interface with Excel and was implemented on a laptop computer using a 2.9gigahertz processor. Table 4
                      summarizes the computational experience in these test problems, using lower bounds LB1 and LB2, as compared to complete enumeration. Performance is measured by the average cpu time required and the average number of nodes encountered in the search. Each average was taken over 100 randomly-generated problem instances with the same parametric features.

As Table 4 shows, a 10-job problem took more than 50seconds on average to find a solution using complete enumeration. The other algorithms took less than 0.02second. Where enumeration is concerned, computation times become prohibitive for larger problem sizes. In particular, 12-job problems took roughly 1.7hours with complete enumeration. (This figure compares to the nine-hour solution times reported by Soroush; the improvement probably reflects advances in hardware since the time of his experiments.)

The results in Table 4 also show that lower bound LB1 yields slightly better performance than LB2, although this advantage disappeared for larger problem sizes. (As discussed below, additional experiments revealed better performance of LB2 compared to LB1 at problem sizes of n
                     ⩾15.)

Next, we report computational experience on larger problem sizes, but with an enhancement to the B&B algorithm. The enhancement is a preliminary step which finds a good solution using a heuristic method. In our case, as discussed in the next section, we found that an excellent heuristic procedure is represented by implementing a neighborhood search based on adjacent pairwise interchanges (API).


                     Table 5
                      summarizes results for problem sizes of 12⩽
                     n
                     ⩽20. As in Table 4, each entry is based on 100 randomly-generated problem instances generated under the same parametric conditions. For each algorithm, the table shows the average cpu time and the maximum cpu time in the 100 instances. Shown in parentheses is the number of times that the solution could not be confirmed in an hour of cpu time. For the larger problem sizes, the best results came from using LB2. The B&B algorithm based on LB2 was able to solve all 18-job problems in under an hour. By comparison, the algorithm based on LB1, was not quite able to do so, even with the API heuristic solution computed first. For the 20-job problems, the algorithm based on LB2 was able to solve 94 of the 100 test problems in less than an hour, and this figure remained the same when the API heuristic was incorporated. However, the average time required to find a solution was somewhat lower with the API heuristic.

Because the stochastic E/T problem is difficult to solve optimally, it is relevant to explore heuristic procedures that do not require extensive computing effort. In this section, we study the performance of some heuristic procedures.

A simple and straightforward heuristic procedure is to create a list schedule. In other words, the list of jobs is sorted in some way and then the schedule is created in one pass by sequencing the jobs in their sorted order. In some stochastic scheduling models, sorting by expected processing time can be effective, but in this problem, the optimal choice of the due dates adjusts for differences in the jobs’ processing times. Instead, it makes sense to focus on the standard deviations or variances of the processing times as a means of distinguishing the jobs. The simplest way to do so is to sort the jobs by smallest standard deviation or by smallest variance. Because the jobs are also distinguished by unit costs, it also makes sense to investigate cost-weighted versions of those orderings, such as smallest weighted standard deviation (SWSD), which takes the jobs in nondecreasing order of 
                        
                           
                              
                                 σ
                              
                              
                                 j
                              
                           
                           /
                           
                              
                                 c
                              
                              
                                 j
                              
                           
                        
                     , and smallest weighted variance (SWV) which takes the jobs in nondecreasing order of 
                        
                           
                              
                                 σ
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                           /
                           
                              
                                 c
                              
                              
                                 j
                              
                           
                        
                     . Soroush (1999) tested list schedules for these two rules and found that, at least on smaller problem sizes, they often produced solutions within 1% of optimality.

A standard improvement procedure for sequencing problems is a neighborhood search. In this case, we can use a sorting rule (SWV) to find an initial job sequence and then test adjacent pairwise interchanges (API) in the schedule to seek an improvement. If an improvement is found, the API neighborhood of the improved sequence is tested, and the process iterates until no further improvement is possible. API methods have proven effective in solving deterministic versions of the E/T problem, a finding that dates back to Yano and Kim (1991). In our tests, API methods were remarkably effective.

The quality of the heuristic solutions is summarized in Table 6
                      for the same set of test problems described earlier. Three summary measures are of interest: (1) the number of optima produced, (2) the average (relative) suboptimality, and (3) the maximum suboptimality. As the table shows, the performances of the heuristic procedures were quite different. The SWSD list schedule produced solutions that averaged about 2% above optimal, and the SWV list schedule produced solutions that were two orders of magnitude better. The SWV procedure also produced optimal solutions in about 60% of the test problems. However, perhaps the most surprising result was that the API heuristic generated optimal solutions in every one of the 700 test problems. (The API heuristic cannot guarantee optimality, however. This point is discussed in Appendix C.)

To some extent, these results are consistent with previous work on the stochastic E/T problem. Soroush (1999) provided computational results demonstrating the effectiveness of the SWV list schedule. His testbed was slightly different, but his results showed that SWV performed better than SWSD and frequently produced optimal sequences. Portougal and Trietsch (2006) showed that SWV is asymptotically optimal. In other words, the difference between the objective function produced by SWV and the optimal value becomes negligible (relative to the optimal value) as n grows large. Portugal and Trietsch discussed the fact that other rules, such as SWSD, do not possess this property. The difference between a rule that exhibits asymptotic optimality and a rule that does not is illustrated in our comparisons of SWV and SWSD. Neither of those earlier studies, however, tested the effectiveness of the API rule.

The feature of asymptotic optimality is important in two ways. First, although it is a limiting property, we can see in Table 6 that asymptotic behavior is approached in the range of problem sizes covered: the worst-case suboptimality drops to 0.1% by the time n reaches 20. We can expect that schedules produced by SWV are even closer to optimality for larger problem sizes. Second, the computational limits of the B&B algorithm – that is, the difficulty of finding optimal solutions for n
                     >20 – are not particularly worrisome. A practical approach to solving larger problems would be to sort the jobs by SWV (exploiting its asymptotic optimality property) and then optimize the sequence for the first 12 or 15 jobs using B&B. This approach gives us a reliable way of solving the stochastic E/T problem of virtually any size, with a strong likelihood that our solution will be within 0.1% of the optimum.

We have analyzed the stochastic E/T problem with distinct unit costs among the jobs and distinct due dates as decisions. In this problem, we seek to assign due dates and sequence the jobs so that the expected cost due to earliness and tardiness is as small as possible. We first noted that the optimal assignment of due dates translates into a critical fractile rule specifying the optimal service level for each job. We then described a B&B approach to this problem, incorporating lower bounds and dominance conditions to reduce the search effort. Our computational experiments indicated that we can solve problems of up to around 20 jobs within an hour of cpu time. Although these problem sizes might not seem large, our literature review reminds us that computational experience for the deterministic counterpart was seldom much better. In addition, the 20-job problem is about twice the size of a problem that could be solved by enumeration in an hour of cpu time. Nevertheless, a possible avenue for further research would be the development of more sophisticated dominance conditions and lower bounds.

We pointed out that a special case of this problem – when all jobs have identical (but asymmetric) unit costs of earliness and tardiness – can be solved quite efficiently, by sorting the jobs from smallest to largest variance. A cost-weighted version of this procedure is not optimal in the general problem but appears to produce near-optimal solutions reliably when used as a heuristic rule. Moreover, when that solution is followed with an Adjacent Pairwise Interchange neighborhood search for improvements, the resulting algorithm produced optimal solutions in all of our test problems.

Our analysis was based on the assumption that processing times follow normal distributions. The normal distribution is convenient because it implies that completion times follow normal distributions as well. As Portougal and Trietsch (2006) observed, the role of completion times in the objective function leads theoretically to the use of convolutions in the analysis. Among standard probability distributions that could be used for processing times, only the normal gives us the opportunity to rely on closed-form results. In place of the normal distribution, we could assume that processing times follow lognormal distributions. The lognormal is sometimes offered as a more practical representation of uncertain processing times; indeed, it may be the most useful standard distribution for that purpose. However, sums of lognormal distributions are not lognormal, implying that it would be difficult to model completion times exactly. Nevertheless, the lognormal is associated with a specialized central limit theorem which resembles the familiar one that applies to the normal distribution (Mazmanyan, Ohanian, & Trietsch, 2008). In other words, our analysis for the normal could be adapted, at least approximately, for the lognormal as well. However, by focusing here on the normal distribution, our analysis has been exact, and no approximations have been necessary.

Looking back to the research done on the deterministic counterpart, we note that the E/T model was sometimes augmented with an objective function component designed to capture the tightness of due dates or to motivate short turnaround times. Augmenting the stochastic E/T problem in such ways, as suggested in the safe-scheduling overview in Baker and Trietsch (2009b), would appear to be another fruitful area in which to build on this research.

@&#ACKNOWLEDGEMENTS@&#

The author wishes to thank the referees for their comments and suggestions on an earlier draft, which have altered and improved the paper considerably.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2013.12.011.


                     
                        
                           Supplementary data 1
                           
                        
                     
                  

@&#REFERENCES@&#

