@&#MAIN-TITLE@&#Multi-quantized local binary patterns for facial gender classification

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Multi-level quantization scheme is proposed to enhance discrimination power of LBP.


                        
                        
                           
                           The proposed method utilizes both the sign and magnitude components from GLD.


                        
                        
                           
                           The results of the experiments validate the robustness of the proposed method.


                        
                        
                           
                           Thorough evaluation of four popular features (LBP, CLBP, ELBP and LTP) is presented.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Feature extraction

Pattern classification

Local binary patterns

Gender classification

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           Image, graphical abstract
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

The human face is an information rich source providing cues to determine multiple traits such as identity, age, gender and ethnicity. This paper addresses the problem of automatic gender recognition from facial images. Automatic gender recognition has many potential applications like biometric authentication, surveillance, photo album management, image retrieval, human-computer interaction and targeted advertising.

Gender recognition is a binary classification problem. Every classification problem demands efficient feature representation as it heavily affects the performance of a classifier. The key issues in feature description are computational cost, robustness and generalization capability. The feature descriptor should have low computational cost, high robustness and it should perform well on unseen test samples. Numerous methods exist in the literature to describe facial features. These methods can be categorized as holistic or local. The former use whole face images and they do not incorporate any knowledge about input object. The simplest and probably the oldest holistic feature is the raw pixel intensity. Some of the early works [1–4] used raw pixel intensity for recognizing facial gender. In contrast, the famous work in [5] proposed a set of binary features generated from various types of pixel comparison operators. The other popular holistic features are principal component analysis [6] and linear discriminant analysis [7,8]. Holistic features though simple in nature perform inferior even for slight variations in illumination and pose [9].

Recently, local appearance-based features have gained increasing attention because of their robustness to illumination variation and high discrimination power. The works in [10–13] used Gabor wavelets for local feature extraction and had shown promising performance. However, the major drawback of Gabor features is high computational cost. Local binary pattern (LBP) on the other hand provides high discrimination power with great computational efficiency. The use of LBP for face description was pioneered by Ahonen et al. [14]. Subsequently, it has been widely used in face recognition and facial gender recognition.

The earliest attempts made in [15,16] demonstrated the success of LBP in gender classification of frontal face images. In contrast, the work in [17] revealed multi-view gender discrimination capability of LBP features. Later, Shan [18] addressed more difficult problem of classifying gender of real-world face images which contain significant variations in pose, illumination and expression. On a challenging LFW database [19], they validated a promising performance of LBP features. To improve further, they also proposed an Adaboost based boosting algorithm to select discriminative LBP histogram bins. The boosted LBP features were not only compact but also more efficient in classifying gender. To further enhance the performance of gender classification, LBP has been successfully employed in various fusion schemes. The works in [20,21] proposed a fusion of three different types of features including LBP, pixel intensity and edges histogram. The other interesting works employing LBP in information fusion schemes can be found in [22,23].

Since its introduction by Ojala et al. [24], LBP has enjoyed widespread popularity because of advantages such as computational simplicity, invariance to monotonic intensity transformation and availability of open source codes. However, LBP has also some serious drawbacks like sensitivity to noise and non-monotonic lighting variations. Many different variants of LBP have been proposed to overcome these limitations. Here, we briefly review some of the relevant variants only. Comprehensive review on LBP and its variants can be found in [25].

The use of binary quantization scheme makes LBP very sensitive to random noise. To enhance robustness against noise, Tan and Triggs [26] proposed a local ternary pattern (LTP) which employed three-level quantization scheme. The other major drawback of LBP is that the information about magnitude of gray level difference (GLD) is completely lost. This loss of information reduces the discrimination ability of the LBP operator. To handle this issue, Ylioinas et al. [27] proposed to combine contrast information with LBP and showed improved gender classification performance. The other two relevant works namely extended local binary pattern (ELBP) [28] and completed local binary patterns (CLBP) [29] followed a different approach to utilize GLD magnitude information. Both the above methods explicitly encode the sign and magnitude of GLD. To retain the magnitude information, the ELBP operator slices the GLD into three different layers, in addition to the fourth layer corresponding to sign information. Thus it generates four different patterns. In contrast, CLBP encodes magnitude information by comparing the magnitude of local GLD with the average magnitude of GLD of the whole image. Hence, it generates two different patterns namely CLBP_S and CLBP_M corresponding to sign and magnitude components respectively. In [29], the authors also proposed binary coding of center pixel (CLBP_C) which was fused with sign and magnitude components for further improvement. However, for fair comparison we have considered only two CLBP patterns corresponding to sign and magnitude information in this paper.

This paper also addresses the issue of enhancing the discrimination capability of LBP by utilizing the magnitude information of GLD. However, unlike CLBP and ELBP, we propose to generalize the concept of LBP by quantizing the GLD into multiple levels (Fig. 1
                     ). These multi-quantized local binary patterns (MQLBP) implicitly encode both the sign and magnitude information of GLD. Further, our method is conceptually different from LTP. Whereas LTP quantizes GLD into three fixed levels, we follow a more natural philosophy to quantize GLD into desired number of levels. To demonstrate enhanced discrimination capability of the MQLBP, we apply it to facial gender classification task. We designed a comprehensive experimental setup which included four different datasets under four different settings resulting in a total of 35 combinations. The results clearly indicated that MQLBP improves discrimination power, noise tolerance and generalization capability as compared to LBP, CLBP, ELBP and LTP.

The main contributions of the paper are highlighted below:

                        
                           •
                           We thoroughly evaluate the applicability of CLBP, ELBP and LTP features for gender classification task and demonstrate superior performance of these features over binary quantized LBP feature.

We generalize the concept of LBP and propose a scheme to quantize the GLD into multiple levels. The resulting multi-quantized local binary patterns are evaluated on four different experimental settings to demonstrate enhanced discrimination power, noise tolerance and generalization capability.

The paper contains experimental novelty which includes the gender classification of noisy images which has not been explored much in the literature. Further, we also carry out a challenging experiment of cross-database testing on noisy images. To the best of our knowledge, this experimental setting is the first of its kind. Even under this challenging setting, the proposed method showed promising results.

The rest of the paper is structured as follows: In Section 2, we briefly review the existing methods and then present the methodology of MQLBP. Experimental setup and its results are discussed in detail in Section 3. Finally, we present conclusions in Section 4.

LBP code for a center pixel at coordinates (xc, yc
                        ) is given as follows:

                           
                              (1)
                              
                                 
                                    LB
                                    
                                       P
                                       
                                          P
                                          ,
                                          R
                                       
                                    
                                    
                                       (
                                       
                                          
                                             x
                                             c
                                          
                                          ,
                                          
                                             y
                                             c
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          p
                                          =
                                          0
                                       
                                       
                                          P
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          f
                                          1
                                       
                                       
                                          (
                                          
                                             
                                                g
                                                p
                                             
                                             −
                                             
                                                g
                                                c
                                             
                                          
                                          )
                                       
                                       
                                          2
                                          p
                                       
                                    
                                 
                              
                           
                        where gc
                         and gp
                         indicate a pixel intensity of a center pixel and its pth neighbor in the circular neighborhood of radius R. Parameter P indicates the total number of neighboring pixels. The function f
                        1(x) is defined as

                           
                              (2)
                              
                                 
                                    
                                       f
                                       1
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   x
                                                   ≥
                                                   0
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To reduce noise sensitivity of LBP, Tan and Triggs [26] proposed a three-level quantization scheme as shown in Fig. 1(b) to derive a method namely local ternary pattern. Using an additional thresholding parameter, they quantized GLD into three levels using a function as shown below:

                           
                              (3)
                              
                                 
                                    
                                       f
                                       2
                                    
                                    
                                       (
                                       
                                          x
                                          ,
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   −
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   ≤
                                                   −
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   −
                                                   t
                                                   <
                                                   x
                                                   <
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   ≥
                                                   t
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To reduce feature dimensionality, the ternary code was split into two parts to generate two binary patterns by encoding positive and negative quantization levels. More details can be found in [26].

To enhance the discrimination capability, Guo et al. [29] proposed completed local binary patterns by utilizing sign and magnitude patterns from GLD. The component namely CLBP_S is the same as original LBP which retains the sign of GLD. Further, the magnitude information was utilized using an additional pattern (CLBP_M) as follows:

                           
                              (4)
                              
                                 
                                    
                                       CLBP
                                       _
                                    
                                    
                                       M
                                       
                                          P
                                          ,
                                          R
                                       
                                    
                                    
                                       (
                                       
                                          
                                             x
                                             c
                                          
                                          ,
                                          
                                             y
                                             c
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          p
                                          =
                                          0
                                       
                                       
                                          P
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          f
                                          3
                                       
                                       
                                          (
                                          
                                             
                                                |
                                                
                                                   
                                                      g
                                                      p
                                                   
                                                   −
                                                   
                                                      g
                                                      c
                                                   
                                                
                                                |
                                             
                                             ,
                                             τ
                                          
                                          )
                                       
                                       
                                          2
                                          p
                                       
                                    
                                 
                              
                           
                        where the symbol |.| denotes an absolute value. The function f
                        3(x, τ) is defined as

                           
                              (5)
                              
                                 
                                    
                                       f
                                       3
                                    
                                    
                                       (
                                       
                                          x
                                          ,
                                          τ
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   ≥
                                                   τ
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   <
                                                   τ
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where the variable τ denotes the thresholding parameter which is set to mean value of the GLD magnitude of the whole image. More details can be found in [29].

The work in [28] followed a different approach to utilize the magnitude information of GLD. They used four different binary patterns corresponding to four layers obtained from GLD. The first layer retains the sign of GLD and hence returns the same code as LBP. The remaining layers encode the magnitude of GLD which can take any value in the range of (0, 255) assuming 8-bit images. They assumed that the neighboring pixels have a smaller difference in their intensities. Hence, they encoded GLD magnitude into 8 levels corresponding to range (0, 7). The first seven codes (0–6) represent the actual GLD magnitude, while all the magnitudes higher than six were assigned a common code of 7. These octal codes from all the neighbors were then converted to three-bit binary numbers which were used separately to build three LBP-like codes using respective bit position. More details and numerical example can be found in [28].

It is clear from Eq. (1) that the computation of LBP requires three major steps:

                           
                              1.
                              Compute the GLD between a center pixel and its neighbors.

Encode the GLD using a binary quantization function which retains the sign information only.

Get the LBP code by converting the binary pattern into a decimal form.

Resulting GLD after the first step can take up any value in the range of (−255, 255) assuming 8-bit gray scale images. The second step encodes the GLD using a binary quantization function. In other words, the output range of difference operator is quantized into two levels as shown in Fig. 1(a). Such two-valued encoding function leads to computational simplicity. However, the information about the magnitude of the difference is completely lost in the process which limits the discrimination capability of LBP. To overcome this limitation, Ylioinas et al. [27] proposed to combine LBP with contrast information to improve gender classification performance. The contrast information was computed using the local variance measure (VAR) as follows:

                           
                              (6)
                              
                                 
                                    VA
                                    
                                       R
                                       
                                          P
                                          ,
                                          R
                                       
                                    
                                    
                                       (
                                       
                                          
                                             x
                                             c
                                          
                                          ,
                                          
                                             y
                                             c
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       1
                                       P
                                    
                                    
                                       ∑
                                       
                                          p
                                          =
                                          0
                                       
                                       
                                          P
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      g
                                                      p
                                                   
                                                   −
                                                   μ
                                                
                                                )
                                             
                                          
                                          2
                                       
                                       ,
                                       
                                       where
                                       
                                       μ
                                       =
                                    
                                    
                                       1
                                       P
                                    
                                    
                                       ∑
                                       
                                          p
                                          =
                                          0
                                       
                                       
                                          P
                                          −
                                          1
                                       
                                    
                                    
                                       g
                                       p
                                    
                                 
                              
                           
                        
                     

As variance measure provides a continuous valued output, they proposed to quantize the feature space for obtaining histogram descriptor. However, there are two major issues with this approach: (1) to determine the cut values for histogram bins, additional training stage is required. (2) The choice of the number of bins is also crucial for better classification performance. If the less number of bins are chosen, it reduces the discrimination ability while the large number of bins increases the feature size which may result in unstable histograms.

To avoid aforementioned issues, we propose a generalized form of LBP which implicitly captures both the magnitude and sign information from the gray level difference. The generalized form of LBP builds upon the basic idea of quantizing the output range of GLD operator. However, instead of limiting up to a binary quantization, we propose to quantize the output range into multiple levels and hence the resulting patterns will be known as multi-quantized local binary patterns (MQLBP). Multi-level quantization of GLD is carried out using a thresholding parameter t as shown in Fig. 1(c) and (d). It is important to note that MQLBP is conceptually different from LTP. As shown in Fig. 1(b) LTP quantizes GLD into three fixed levels, whereas the MQLBP extends the idea to quantize GLD into desired number of levels. Moreover, LTP ignores the sign information when GLD is quantized into middle level (level 0) which limits its discrimination power. As shown in Fig 1(c) and (d), our proposed method overcomes this limitation by symmetrically quantizing the GLD with respect to zero. The proposed quantization function fL
                        (x, t) for level L (L > 0) is formally defined as follows:

                           
                              (7)
                              
                                 
                                    
                                       f
                                       L
                                    
                                    
                                       (
                                       
                                          x
                                          ,
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   <
                                                   −
                                                   (
                                                   L
                                                   −
                                                   1
                                                   )
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   −
                                                   (
                                                   L
                                                   −
                                                   1
                                                   )
                                                   t
                                                   ≤
                                                   x
                                                   <
                                                   −
                                                   (
                                                   L
                                                   −
                                                   2
                                                   )
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                ⋮
                                             
                                             
                                          
                                          
                                             
                                                
                                                   L
                                                   −
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   −
                                                   t
                                                   ≤
                                                   x
                                                   <
                                                   0
                                                
                                             
                                          
                                          
                                             
                                                
                                                   L
                                                   ,
                                                
                                             
                                             
                                                
                                                   0
                                                   ≤
                                                   x
                                                   <
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   L
                                                   +
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   t
                                                   ≤
                                                   x
                                                   <
                                                   2
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                ⋮
                                             
                                             
                                          
                                          
                                             
                                                
                                                   2
                                                   L
                                                   −
                                                   2
                                                   ,
                                                
                                             
                                             
                                                
                                                   (
                                                   L
                                                   −
                                                   2
                                                   )
                                                   t
                                                   ≤
                                                   x
                                                   <
                                                   (
                                                   L
                                                   −
                                                   1
                                                   )
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   2
                                                   L
                                                   −
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   ≥
                                                   (
                                                   L
                                                   −
                                                   1
                                                   )
                                                   t
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Thus 1-level quantization, as used in original LBP, segments the whole output range in two different parts. At each higher level of quantization, each sub-part is further quantized into two different segments. Hence, it results in a total of 2L segments and MQLBP code corresponding to i
                        th segment is computed as follows:

                           
                              (8)
                              
                                 
                                    
                                       MQLBP
                                       
                                          P
                                          ,
                                          R
                                          ,
                                          L
                                       
                                       i
                                    
                                    
                                       (
                                       
                                          
                                             x
                                             c
                                          
                                          ,
                                          
                                             y
                                             c
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          p
                                          =
                                          0
                                       
                                       
                                          P
                                          −
                                          1
                                       
                                    
                                    
                                       δ
                                       
                                          (
                                          
                                             
                                                f
                                                L
                                             
                                             
                                                (
                                                
                                                   
                                                      g
                                                      p
                                                   
                                                   −
                                                   
                                                      g
                                                      c
                                                   
                                                   ,
                                                   t
                                                
                                                )
                                             
                                             −
                                             i
                                          
                                          )
                                       
                                       
                                          2
                                          p
                                       
                                    
                                    ,
                                    
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   i
                                                   =
                                                   1
                                                   ,
                                                   L
                                                   =
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ≤
                                                   i
                                                   ≤
                                                   2
                                                   L
                                                   −
                                                   1
                                                   ,
                                                   L
                                                   >
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The binary function δ(x) is defined as below:

                           
                              (9)
                              
                                 
                                    δ
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   x
                                                   =
                                                   0
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To describe each face image using MQLBP, spatially enhance histograms are computed as suggested in [14]. Each MQLBP image is divided into non-overlapping rectangular blocks to compute local histograms which are concatenated to build a feature vector. These feature vectors of all MQLBP images are further concatenated to build a final face descriptor. The flowchart summarizing the steps involved in the proposed algorithm is illustrated in Fig. 2
                        . It is clear that feature dimension is directly proportional to number of levels used in computing MQLBP. To demonstrate more discrimination power of MQLBP while keeping lower feature dimensionality, we consider only two-level MQLBP in this work.


                        Fig. 3
                         shows the numerical example, which also highlights computational differences between LBP, LTP and MQLBP. It is important to note that MQLBP is capable of retaining both the sign and magnitude information about the GLD computed in the first step outlined above. Hence, we hypothesize that MQLBP should enhance the discrimination ability of LBP. An example showing improved discrimination ability of 2-level MQLBP over LBP and CLBP is shown in Fig. 4
                        . The figure shows sample face images of each gender from PAL database. As shown in the figure, the enlarged rectangular patches of both the images represent the same sign vector (CLBP_S). Hence, the resulting LBP and CLBP_S codes are the same as shown in the figure. However, it is difficult to state that both the patches share similar local structure because they belong to two different genders.

Though, CLBP can improve the discrimination ability by the use of magnitude component (CLBP_M), their CLBP_S codes are still the same. Hence, out of two CLBP codes, only one of them is different in contrast to four different codes generated by MQLBP. Thus, the less correlation between the MQLBP codes of two different patches may provide better discrimination as compared to CLBP. To obtain the required codes we have assumed the threshold t = 5, without loss of generality.

Before presenting experimental results, we would like to highlight the differences between the proposed work and the work in [27]. To make comparison easier, the differences are tabulated in Table 1.
                        
                     

Further, it is possible to have the same contrast measure for two different texture patterns. To understand this point, consider the illustrative example shown in Fig. 5
                         which shows two different blocks and resulting codes for LBP, variance (VAR) and MQLBP. As shown in the figure, the LBP and VAR result in the same codes for both the blocks. However, it is difficult to conclude that they have the same texture. Thus the combination of LBP and VAR fails to distinguish the difference between the patterns represented by these blocks. However, our proposed method provides different codes for each block and thus capable to discriminate between them. In this example, the VAR values are considered to be exactly same. However, even if their continuous values are not exactly the same, their discrete values may still fall into the same histogram bin after quantization which can limit the discrimination capability.

@&#EXPERIMENTAL RESULTS@&#

This section describes the methodology used to evaluate the performance of MQLBP approach. We have carried out comprehensive experiments on four different datasets which are briefly described in Section 3.1. Parameter settings for different features and classification are presented in Section 3.2. We have carried out four different experiments which are detailed in Section 3.3 through Section 3.6. Comparison of computational complexity of various local descriptors is presented in Section 3.7.

The proposed approach is evaluated on four different publicly available datasets: FERET [30], PAL [31], CASIA [32] and FEI [33].

The FERET dataset is one of the most widely used database in facial gender classification studies. It comprises good quality gray scale images of 1199 subjects. In our work, we employ the same subset as used in [34] which was also followed in [20,21]. On visual verification, we have found one duplicate image which was discarded, making a total of 410 images.

The PAL dataset contains frontal images of 580 individuals. This dataset is very challenging as it contains individuals with large age variations (18–93 years) and five different ethnicities. To keep a balance between male/female ratio, we have used a subset containing 221 images of each gender.

The CASIA dataset contains 2500 images from 500 young individuals from Asian origin. The images contain variations in pose and illumination. For our experiments, we have used a subset containing frontal face images of 454 subjects.

The FEI database consists of 400 images of 200 individuals. All images are frontal face images with two expressions: Neutral and smiling face. This dataset is balanced in terms of gender and contains 100 individuals from each gender. Moreover, all the images are manually aligned to reduce the effects of misalignment. In this paper, we have used 200 images corresponding to neutral expression only.


                        Table 2
                         presents a summary of images used in experiments. To restrict the classifier from learning identity information, we have ensured that only one image from each subject is present in each of the datasets.

We have designed experiments with the following objectives:

                           
                              •
                              To demonstrate the performance gain achieved by MQLBP on clean images.

To evaluate the robustness of MQLBP in presence of random noise.

To assess the generalization ability of MQLBP on unseen test data.


                        Table 3
                         summarizes the settings
                         of extensive experiments carried out on four different datasets under four different conditions. The details of experiments are discussed in subsequent sections.

To extract
                         the features, the original images were cropped after detecting the faces using a cascaded face detection algorithm [35]. The cropped images were resized to 48 × 48 pixels to maintain uniformity. The works in [8,
34] suggested to avoid automatic face alignment step as it does not apparently improve the classification performance. Hence, face alignment was not performed in this work. Further, for a fair comparison and to investigate the actual capability of local features, no other form of pre-processing was applied.

The proposed MQLBP method is compared with four different LBP variants: LBP, CLBP, ELBP and LTP. All methods used uniform patterns extracted with P = 8 and R = 1. The thresholding parameter t required in LTP and MQLBP was varied from 1 to 15 for all experiments. To compute spatially enhanced histograms, the images were divided into non-overlapping blocks of size 8 × 8 resulting in a total of 36 blocks. To focus on the strength of the features rather than the classifier, we have used a linear support vector machine (SVM) for classification and fixed the soft margin parameter C = 100 as done in [20].

The first experiment was designed to compare the performance of MQLBP with other LBP variants. In this experiment, average classification accuracy after five-fold cross validation is reported for every dataset. As clean images were used, the performance of the first experiment can be considered as a baseline performance.

Different datasets contain variations in pose, expression, ethnicity and capturing device used for collecting images. Such variations cause different classification rates for each dataset as shown in Table 4. The proposed MQLBP method achieved the highest classification rates across all the datasets demonstrating better discrimination capability. Further inferences from the Table 4 are as follows:

                           
                              1.
                              Multi-quantization schemes (as used in LTP and MQLBP) perform significantly better than binary quantization scheme of LBP.

Although better than LBP, the results of LTP could not compete with the MQLBP. The reason is one extra quantization level used in MQLBP. The LTP used three quantization levels against four used in the MQLBP.

The MQLBP performs better than CLBP and ELBP. Both the latter methods use explicit encoding for sign and magnitude components of the GLD. In contrast, the MQLBP employs more natural and implicit encoding which turns out to perform better.

The maximum improvement in performance of MQLBP over other feature types is found on PAL dataset. This is a significant result because PAL dataset is relatively more challenging as the images contain large variations in age (18–93 years) and they cover five different ethnic groups: African, American, Asian, Caucasian and Hispanic.

Second experiment was designed to evaluate the robustness of the MQLBP against noise degradation. For this experiment, each dataset was split into two fixed parts with 60% data for training set and remaining 40% data for test set. The training set contained clean images without any type of noise. All the images in the test set were degraded by adding Gaussian noise with zero mean and different levels of variance corresponding to 5, 10, 15 and 20 dB signal-to-noise ratio (SNR). For each level of SNR the experiment was repeated 20 times to reduce variability in classification rates. The examples of noisy images are illustrated in Fig. 6. The original sample image was taken from PAL database.


                        Fig. 7 shows the plot of classification rate vs. threshold t at four different noise levels for each dataset. These plots demonstrate promising performance of the MQLBP in the presence of noise. Especially, it is known that detection of facial texture under high level of noise (5 dB SNR) is extremely challenging task. Even though, the MQLBP is able to achieve classification rates above 60.00% in all datasets. Further, the proposed MQLBP method significantly outperforms LBP, CLBP and ELBP at all noise levels for every dataset. The performance of LTP is comparable to the MQLBP. However, under optimal setting of threshold the MQLBP performs better than LTP at all noise levels for all the databases.

The aim of third experiment is to evaluate the generalization ability of different features. The linear SVM classifier was trained with FERET and remaining datasets were separately used for testing. The parameters for feature extraction and classification were the same as used in the first experiment. The results are shown in Fig. 8
                        . The bar graphs show the performance gain achieved using the MQLBP over other feature types. Each bar consists of two parts: The lower part shows the classification rate (indicated by a number) achieved using a specified feature type while the upper part shows improvement (indicated by a number) achieved by MQLBP. The exact classification rates obtained using MQLBP are also indicated on top of each bar.

Among three different combinations, cross-database testing on FEI database showed the maximum performance for each feature type. This behavior may be due to similar demography between FEI and FERET datasets. In contrast, CASIA dataset mainly contains Chinese subjects with different background conditions than FERET images. Hence, it showed the minimum performance. The PAL database contains subjects with mixed demography and homogeneous background which resulted in moderate performance.

On comparing the performance of different features, it is evident that MQLBP provides significant performance gain on all three different test sets. The only exception is in case of FEI database where the MQLBP performed marginally better than the LTP. However, both the features provide competitive classification rates of 93.50% and 94.00% which are more difficult to improve. Overall, the results clearly indicate superior generalization ability of the MQLBP over other feature types.

The fourth experiment is the most challenging as it was designed to evaluate cross-database performance in the presence of noise. This is very practical scenario, but often overlooked in computer vision research. To the best of our knowledge, this is the first such attempt being applied to facial gender classification problem. The results are shown in Fig. 9
                        . It is once again evident from the results that MQLBP performs much better than LBP, CLBP and ELBP across all the test datasets for each noise level. The MQLBP also performs slightly better than LTP in all of the cases. Most noticeable point is that even at 5 dB SNR along with cross-database testing, the MQLBP could achieve classification rate of 60.00% or more for each test set. Hence, the results indicate greater robustness along with good generalization ability achieved using multi-quantization scheme proposed in this paper.

The experimental results indicated that the MQLBP provides more discrimination power along with better generalization ability and improved noise tolerance. These three-fold benefits have come at the cost of increased feature vector length which requires more computational time. Table 5
                         shows the comparison of feature vector length and computational time for various local features. To calculate the computation time, 300 FERET images were randomly chosen. The features were extracted with parameter settings of Experiment 1. For each image the time required to obtain the specified feature vector was measured. Finally, the mean of computation time is reported for each of the feature vector. The experiments were carried out using MATLAB 2013a on Intel quad-core CPU @ 3.40 GHz with 8 GB RAM. The proposed method requires 10.0 ms time with feature size of 8496 which is 4 times of LBP and 2 times of CLBP and LTP. However, it is important to note that we have used un-optimized MATLAB code to measure computational time. Further, such computational complexity is usually under control in view of high-performance computing machines being easily available now-a-days.

@&#CONCLUSION@&#

Local binary patterns (LBP) employ the binary quantization on a gray level difference between a center pixel and a neighboring pixel. This simple yet effective method however discards magnitude of gray level difference. To address this issue, we have extended the vector quantization concept which is not restricted to binary quantization. The proposed MQLBP approach implicitly encodes both the sign and magnitude information of gray level difference which improves the discrimination capability. In contrast to LTP, CLBP and ELBP which use fixed number of quantization levels, the proposed method is more generic as desired number of quantization levels can be obtained. To demonstrate the effectiveness of the proposed approach, comprehensive experiments were carried out using two-level MQLBP on four different datasets such as FERET, PAL, CASIA and FEI. The results clearly indicated that the proposed method has three-fold advantages including higher gender classification accuracy, improved robustness to noise and better generalization capability.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank the anonymous reviewers for insightful comments and helpful suggestions to improve the quality of this manuscript. Bhavik Patel is grateful to A.D. Patel Institute of Technology, New Vallabh Vidyanagar, All India Council for Technical Education, New Delhi and QIP Centre, Indian Institute of Technology Roorkee for providing financial assistance by grant 784-20-79-428 under QIP scheme.

@&#REFERENCES@&#

