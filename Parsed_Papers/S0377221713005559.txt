@&#MAIN-TITLE@&#Breakout local search for the Steiner tree problem with revenue, budget and hop constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           STPRBH is a generalization of the conventional Steiner tree problem.


                        
                        
                           
                           We propose a heuristic algorithm based on the Breakout Local Search (BLS).


                        
                        
                           
                           The proposed heuristic is assessed on 240 well known benchmark instances.


                        
                        
                           
                           BLS finds improved results for 49 out of the 56 most challenging instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Steiner tree problems

Network design

Constrained combinatorial optimization

Heuristic search

Adaptive perturbation

@&#ABSTRACT@&#


               
               
                  The Steiner tree problem (STP) is one of the most popular combinatorial optimization problems with various practical applications. In this paper, we propose a Breakout Local Search (BLS) algorithm for an important generalization of the STP: the Steiner tree problem with revenue, budget and hop constraints (STPRBH), which consists of determining a subtree of a given undirected graph which maximizes the collected revenues, subject to both budget and hop constraints. Starting from a probabilistically constructed initial solution, BLS uses a Neighborhood Search (NS) procedure based on several specifically designed move operators for local optimization, and employs an adaptive diversification strategy to escape from local optima. The diversification mechanism is implemented by adaptive perturbations, guided by dedicated information of discovered high-quality solutions. Computational results based on 240 benchmarks show that BLS produces competitive results with respect to several previous approaches. For the 56 most challenging instances with unknown optimal results, BLS succeeds in improving 49 and matching one best known results within reasonable time. For the 184 instances which have been solved to optimality, BLS can also match 167 optimal results.
               
            

@&#INTRODUCTION@&#

Many problems in network designing, e.g., electricity, telecommunication, heating, transportation, should determine a least cost tree spanning all or some of the vertices of a given graph (Avella, Villacci, & Sforza, 2005; Voß, 2006). These problems usually can be modeled as the Steiner tree problem (STP) or the minimum spanning tree problem (MSTP), which are generally formulated as follows: given a graph G
                     =(V,
                     E) with vertex set V
                     ={1,…,
                     n} which is partitioned into two sets: a set of terminal vertices and a set of Steiner vertices, and edge set E
                     ={(i,
                     j): i,
                     j
                     ∈
                     V,
                     i
                     ≠
                     j} where each edge (i,
                     j)∈
                     E has an associated cost c
                     
                        ij
                     
                     ⩾0. In some cases, a specified vertex is chosen as the root vertex. The STP consists of determining a subtree spanning all terminal vertices (including the root vertex) and possibly some Steiner vertices, so as to minimize the total cost of the obtained tree. As a special variant of the STP, for the MSTP, all vertices are terminal which should be included in any feasible solution. Unlike the MSTP that can be solved to optimality within polynomial time (Prim, 1957), the STP has proven to be NP-hard (Garey, Graham, & Johnson, 1977).

In this paper, we study an important variant of the STP: the Steiner tree problem with revenue, budget and hop constraints (denoted by STPRBH, as formulated in Costa, Cordeau, & Laporte, 2009). In this problem, in addition to the costs c
                     
                        ij
                     
                     ⩾0 associated with each edge (i,
                     j)∈
                     E, there is also a revenue r
                     
                        i
                     
                     ⩾0 associated with each vertex i
                     ∈
                     V. The problem consists of determining a rooted (without loss of generality, vertex 1 is fixed as the root) subtree of graph G, so as to maximize the collected revenues, while guaranteeing that the total cost of the solution does not exceed a given budget B (budget constraint), and the number of edges from the root to any vertex in the solution subtree does not exceed an upper bound equal to h (hop constraint). As a generalization of both the STPP (STP with profits, see Johnson, Minkoff, & Phillips, 2000; Costa, Cordeau, & Laporte, 2006; Haouari, Layeb, & Sherali, 2013) and the STPH (STP with hop constraints, see Voβ, 1999; Akgün, 2011), the STPRBH is theoretically important and can be used to model many real-life problems, e.g., local access and telecommunication networks, heating or water supply systems, transportation planning, etc., in which the collected revenues should be maximized, while the available budget is limited and the reliability of the system should be guaranteed. For the STPRBH, researchers have developed various solution approaches. Respectively, Costa, Cordeau, and Laporte (2008) proposed several fast heuristics, including a greedy algorithm, a destroy-and-repair algorithm and a tabu search (TS) algorithm. Computational results for instances with up to 500 vertices and 12,500 edges were reported. In addition to the heuristics, several exact algorithms have also been proposed, including branch-and-cut (Costa et al., 2009), branch-and-price (Sinnl, 2011). Note that all the existing exact algorithms can only solve instances with up to 500 vertices and 625 edges to optimality, for larger instances, no result has been reported by any exact algorithm.

In this paper, we are interested in the STPRBH and propose a heuristic algorithm based on the Breakout Local Search (BLS) for this problem. BLS follows the general Iterated Local Search scheme (Lourenco, Martin, & Stützle, 2003) and alternates between a neighborhood search phase and a perturbation phase. BLS has recently shown its effectiveness for solving several combinatorial optimization problems, such as sum coloring (Benlic & Hao, 2012), maximum clique (Benlic & Hao, 2013a), quadratic assignment (Benlic & Hao, 2013b), and max-cut (Benlic & Hao, 2013c). For the STPRBH, the proposed BLS algorithm integrates a probabilistic constructive procedure to generate its initial solution, a Neighborhood Search (NS) procedure based on three specifically designed move operators to discover local optima, and an adaptive perturbation strategy to continually move from one local optimum to another one, by varying its perturbations depending on the search status. As a supplementary technique, a number of high-quality solutions are stored in a solutions pool, in order to provide useful information for local optimization and perturbations. Computational results based on a set of 240 STPRBH instances, including 56 the most challenging instances with unknown optimal solutions, demonstrate the effectiveness of the proposed BLS algorithm. In particular, it succeeds in improving 49 and matching one best known results out of these 56 unsolved instances.

The rest of this paper is organized as follows: After giving some preliminary definitions in Section 2, Section 3 describes the details of the proposed BLS approach. Computational results are provided in Section 4, and Section 5 concludes this paper.

In this section, we provide some preliminary definitions which are useful for a precise description of the proposed algorithm.
                        Definition 1
                        A budget and hop constrained Steiner tree (BHS-tree) is a rooted subtree of graph G meeting both the budget and hop constraints. A BHS-tree is also called a feasible solution of the problem.

Given a BHS-tree T, a feasible candidate path with respect to T is a path originating at a vertex i
                           ∈
                           v(T) (v(T) denotes the set containing all the vertices belonging to solution T) and connecting to an uncollected profitable vertex j (j
                           ∉
                           v(T), r
                           
                              j
                           
                           >0), such that even after inserting this path to T, the obtained solution is still a BHS-tree, i.e., satisfying both the budget and hop constraints.

A saturated BHS-tree is a BHS-tree for which no feasible candidate path exists. Otherwise, the BHS-tree is an unsaturated (or partial) BHS-tree. Contrary to a saturated BHS-tree, an unsaturated (or partial) BHS-tree can be further extended by adding some feasible candidate path without violating the budget and hop constraints.

The constrained search space Ω is composed of all possible BHS-trees (including saturated ones or unsaturated ones). The saturated constrained search space 
                           
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ¯
                                    
                                 
                              
                            is composed of all possible saturated BHS-trees which is clearly a subspace of Ω.

As detailed below, our BLS algorithm restricts its search within the saturated constrained search space 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                        
                     . By doing so, the search process focuses always on the reduced zones composed of the most promising candidate solutions.

In this paper, we present for the first time a Breakout Local Search (BLS) approach for solving the STPRBH, just as outlined in Algorithm 1, whose key components are presented in the following subsections.
                        Algorithm 1
                        Breakout Local Search BLS(G,
                           B,
                           h) for the STPRBH
                              
                                 
                                    
                                    
                                       
                                          
                                             Require: Graph G(V,
                                             E), budget limit B, hops limit h, jump magnitude L
                                             ∈[L
                                             
                                                min
                                             ,
                                             L
                                             
                                                max
                                             ], high-quality (elite) solution pool HSP
                                       
                                       
                                          
                                             Ensure: The best solution found meeting both the budget and hop constraints
                                       
                                       
                                          1: /∗ Initialization phase ∗/
                                       
                                       
                                          2: HSP
                                             ←
                                             InitHSP()/∗ Initialize HSP, see Section 3.3.2 ∗/
                                       
                                       
                                          3: T
                                             ←
                                             InitSolution(G,
                                             B,
                                             h)/∗ Construct an initial solution, see Section 3.2 ∗/
                                       
                                       
                                          4: T
                                             ←
                                             NS(T)/∗ Optimize T by neighborhood search, see Section 3.3 ∗/
                                       
                                       
                                          5: T
                                             
                                                best
                                             
                                             ←
                                             T
                                          
                                       
                                       
                                          6: L
                                             ←
                                             L
                                             
                                                min
                                             
                                          
                                       
                                       
                                          7: /∗ Main search procedure which is iterated until the stop condition is met ∗/
                                       
                                       
                                          8: while The stop condition is not met do
                                          
                                       
                                       
                                          9: /∗ Perturb T with L and HSP (Section 3.4) and then improve it (Section 3.3) ∗/
                                       
                                       
                                          10: 
                                             T′←
                                             Perturb(T,
                                             HSP,
                                             L)
                                       
                                       
                                          11: 
                                             T
                                             ∗
                                             ←
                                             NS(T
                                             ’)
                                       
                                       
                                          12: /∗ Update the best solution T
                                             
                                                best
                                              found so far if needed ∗/
                                       
                                       
                                          13: 
                                             if 
                                             T
                                             ∗ is better than T
                                             
                                                best
                                              (see Section 3.3.1) then
                                          
                                       
                                       
                                          14: 
                                             T
                                             
                                                best
                                             
                                             ←
                                             T
                                             ∗
                                          
                                       
                                       
                                          15: 
                                             end if
                                          
                                       
                                       
                                          16: /∗ Determine the jump magnitude L adaptively, detailed in Section 3.4 ∗/
                                       
                                       
                                          17: 
                                             if 
                                             T
                                             ∗ is too close to T (defined in Section 3.4) then
                                          
                                       
                                       
                                          18: 
                                             L
                                             ←
                                             Min(L
                                             +1,
                                             L
                                             
                                                max
                                             )
                                       
                                       
                                          19: 
                                             else
                                          
                                       
                                       
                                          20: 
                                             L
                                             ←
                                             Max(L
                                             −1,
                                             L
                                             
                                                min
                                             )
                                       
                                       
                                          21: 
                                             end if
                                          
                                       
                                       
                                          22: /∗ Update T, which serves as the starting point of a new round of search ∗/
                                       
                                       
                                          23: 
                                             T
                                             ←
                                             T
                                             ∗
                                          
                                       
                                       
                                          24: end while
                                          
                                       
                                       
                                          25: return 
                                             T
                                             
                                                best
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Our BLS algorithm operates within the saturated constrained search space 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                        
                      (Section 2). The main idea of the approach for the STPRBH can be described as follows: starting from a saturated BHS-tree probabilistically constructed by the dedicated probabilistic constructive procedure (see Algorithm 1, line 3 and Section 3.2), BLS applies a Neighborhood Search (NS) procedure to reach a local optimum at first (line 4, see Section 3.3). After local optimization, BLS then attempts to continually move from one local optimum to another by employing varying perturbations, depending on the state of the search. For this purpose, an adaptive perturbation mechanism is developed, which is guided by some dedicated information of a number of recorded high quality solutions stored in the HSP (line 2 and line 10, see Sections 3.3.2 and 3.4). Each time the incumbent solution is perturbed, the NS procedure is called again to improve it to a new local optimum (line 11). If the NS procedure reaches a local optimum not far enough from the original one, BLS then perturbs it more strongly, otherwise, BLS switches to weaker perturbations subsequently (lines 16–21). This process is repeated until (1) the upper bound of the collected revenues in Eq. (2) (see Section 3.2.2) is reached (meaning that an optimal solution is obtained), or (2) the best found solution cannot be further improved after visiting M new local optima (M is a parameter), or (3) the allowed computation time is consumed.

The performance of the BLS algorithm relies on several key factors. First, the initialization procedure should be able to generate different solutions of reasonable quality, which serve as the restarting points of independent runs of BLS. Second, the neighborhood structure is also a key component because different neighborhoods lead to different search trajectories, thus solutions of different qualities. Third, we should control the jump magnitude, denoted by L, which determines the perturbation intensity applied to the current solution. In our case, this corresponds to decide how many paths to delete when perturbing the incumbent solution. Indeed, if L is too small, the search usually returns to the original local optimum, leading to search stagnation. Otherwise, if L is too large, the perturbation is reduced to random restarting. Finally, it is important to consider the perturbation type, e.g., directed perturbation or random perturbation. Unlike conventional pure random perturbations, we additionally employ a directed perturbation operator with the aid of selected high quality solutions, which provides useful information to guide the search towards good solutions. The components of the proposed BLS algorithm for the STPRBH are described below.

To represent the candidate solutions of the problem in a convenient way, we adopt a compact representation using a one-dimensional vector T
                        ={t
                        
                           i
                        ,
                        i
                        ∈
                        V} which is explained as follows. Precisely, according to the constraints of the STPRBH, each feasible solution is a rooted tree with fixed root vertex 1. Therefore, for each vertex i belonging to a feasible solution T (except the root vertex), we can identify and record its parent vertex t
                        
                           i
                        . Specifically, the elements of T
                        ={t
                        
                           i
                        ,
                        i
                        ∈
                        V} are defined such that t
                        
                           i
                         = the parent vertex of vertex i if i
                        ∈
                        v(T)⧹1; Otherwise t
                        
                           i
                        
                        =Null.

Consequently, each feasible solution is uniquely identified by a vector T
                        ={t
                        
                           i
                        ,
                        i
                        ∈
                        V}. Inversely, given a vector T
                        ={t
                        
                           i
                        ,
                        i
                        ∈
                        V} corresponding to a feasible solution, it is easy to reconstruct the corresponding solution.

Like any meta-heuristic based algorithm, BLS requires an initial solution to start its search. Moreover, given its stochastic nature, multiple runs of BLS from different initial solutions are typically applied to find the best possible solutions for a problem instance. To generate an initial solution, we use the criteria developed by Costa et al. (2008) for identifying, evaluating and selecting feasible candidate paths for insertion and devise a probabilistic constructive procedure in order to be able to obtain different initial solutions for multiple runs of the procedure. Starting from an empty solution containing only the root vertex, the constructive procedure identifies all the feasible candidate paths with respect to the incumbent solution at first and evaluates their priorities subsequently. Then, it probabilistically selects a candidate path to insert to the incumbent solution, according to its priority. This process is repeated until no feasible candidate path exists, meaning that a saturated BHS-tree satisfying both the budget and hop constraints is obtained, which would serve as the starting point of our BLS algorithm.

Before presenting the criteria for identifying, evaluating and selecting a candidate path, we should solve the hop constrained shortest path problem at first, i.e., the problem of determining a shortest path between two vertices containing at most h edges. This problem can be solved efficiently by dynamic programming (Lawler, 1976): let L(i,
                           j,
                           l) represent the cost of the shortest path between vertex i and vertex j, containing at most l edges, then:
                              
                                 (1)
                                 
                                    
                                       
                                          
                                          
                                             
                                                L
                                                (
                                                i
                                                ,
                                                i
                                                ,
                                                0
                                                )
                                                =
                                                0
                                                ,
                                                
                                                i
                                                ∈
                                                V
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                L
                                                (
                                                i
                                                ,
                                                j
                                                ,
                                                0
                                                )
                                                =
                                                ∞
                                                ,
                                                
                                                i
                                                ,
                                                j
                                                ∈
                                                V
                                                ,
                                                
                                                j
                                                
                                                ≠
                                                
                                                i
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                L
                                                (
                                                i
                                                ,
                                                j
                                                ,
                                                l
                                                )
                                                =
                                                
                                                   min
                                                
                                                {
                                                L
                                                (
                                                i
                                                ,
                                                j
                                                ,
                                                l
                                                -
                                                1
                                                )
                                                ,
                                                
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         k
                                                         |
                                                         (
                                                         k
                                                         ,
                                                         j
                                                         )
                                                         ∈
                                                         E
                                                      
                                                   
                                                
                                                {
                                                L
                                                (
                                                i
                                                ,
                                                k
                                                ,
                                                l
                                                -
                                                1
                                                )
                                                +
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      kj
                                                   
                                                
                                                }
                                                ,
                                                
                                                i
                                                ,
                                                j
                                                ∈
                                                V
                                                ,
                                                
                                                l
                                                ⩾
                                                1
                                                }
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           Note that in Costa et al. (2008), each time a new path is inserted, the costs of all the edges belonging to the incumbent solution are reset to 0 and the hop constrained shortest path algorithm is run again to re-calculate all the possible L(1,
                           j,
                           l), l
                           ⩽
                           h. Contrary to this, with our BLS algorithm, we apply a preprocessing step to calculate and store all the possible L(i,
                           j,
                           l), i,
                           j
                           ∈
                           V,
                           r
                           
                              j
                           
                           >0, 1⩽
                           l
                           ⩽
                           h which are then used directly during the search process, instead of re-calculating them repeatedly. This technique allows the algorithm to save computation time. In the following subsections, whenever reporting the computation time of BLS, this preprocessing time is always included.

After calculating all the possible L(1,
                           j,
                           h), we can recognize all the vertices reachable within h hops, i.e., L(1,
                           j,
                           h)<∞. Then, we get an upper bound R
                           
                              ub
                            of the collected revenues as follows:
                              
                                 (2)
                                 
                                    
                                       
                                          R
                                       
                                       
                                          ub
                                       
                                    
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             L
                                             (
                                             1
                                             ,
                                             j
                                             ,
                                             h
                                             )
                                             <
                                             ∞
                                          
                                       
                                    
                                    
                                       
                                          r
                                       
                                       
                                          j
                                       
                                    
                                    .
                                 
                              
                           Clearly, if the collected revenues reaches the upper bound R
                           
                              ub
                           , then the incumbent solution corresponds to an optimal solution and the search process stops. This rule is indeed used as one of the termination criteria of the proposed BLS algorithm.

At each step of constructing a saturated BHS-tree, we use the following criterion to dynamically identify all the feasible candidate paths. Specifically, for each profitable vertex j uncollected by the incumbent partial BHS-tree T (r
                           
                              j
                           
                           >0 and j
                           ∉
                           v(T)), let L(i,
                           j,
                           h
                           −
                           h
                           
                              i
                           ) denote the cost of the hop-constrained shortest path between vertex j and a vertex i
                           ∈
                           v(T), containing at most h
                           −
                           h
                           
                              i
                            edges, h
                           
                              i
                            being the number of edges between vertex i and the root vertex. We use min{L(i,
                           j,
                           h
                           −
                           h
                           
                              i
                           ), i
                           ∈
                           v(T)} to denote the cost of the hop-constrained shortest path between vertex j and the partial BHS-tree T. Consequently, if 
                              
                                 min
                                 {
                                 L
                                 (
                                 i
                                 ,
                                 j
                                 ,
                                 h
                                 -
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 i
                                 ∈
                                 v
                                 (
                                 T
                                 )
                                 }
                                 ⩽
                                 B
                                 -
                                 
                                    
                                       ∑
                                    
                                    
                                       (
                                       m
                                       ,
                                       n
                                       )
                                       ∈
                                       e
                                       (
                                       T
                                       )
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       mn
                                    
                                 
                              
                            (e(T) is the set containing all the edges of T, and 
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       (
                                       m
                                       ,
                                       n
                                       )
                                       ∈
                                       e
                                       (
                                       T
                                       )
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       mn
                                    
                                 
                              
                            represents the total cost consumed by T), it corresponds to a feasible candidate path connecting vertex j. Otherwise, no feasible candidate path connecting vertex j exists.

At each step of initial solution construction, there may be more than one feasible candidate paths available. In Costa et al. (2008), the ratio 
                              
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                          
                                             3
                                          
                                       
                                    
                                    
                                       L
                                       (
                                       1
                                       ,
                                       j
                                       ,
                                       h
                                       )
                                    
                                 
                              
                            which considers both the objective and the constraint is used to evaluate the priority of each candidate path connecting an uncollected profitable vertex 
                              
                                 j
                                 
                                 ∉
                                 
                                 v
                                 (
                                 T
                                 )
                              
                           . In this work, we use instead the ratio 
                              
                                 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             j
                                          
                                          
                                             3
                                          
                                       
                                    
                                    
                                       min
                                       {
                                       L
                                       (
                                       i
                                       ,
                                       j
                                       ,
                                       h
                                       -
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       ,
                                       i
                                       ∈
                                       v
                                       (
                                       T
                                       )
                                       }
                                    
                                 
                              
                            for this evaluation. Given two paths, the path with a higher ratio is considered to be of more priority than the other one. Additionally, due to the reasons described in Section 3.2.1, this criterion is essentially equivalent to the one developed in Costa et al. (2008).

After identifying all feasible candidate paths, we should decide which path to insert to the incumbent solution. In order to be able to start the search from different starting points, we introduce the following randomized selection rule:
                              
                                 (1)
                                 If no feasible candidate path is available, stop the constructive procedure and return the incumbent solution (which is already a saturated BHS-tree) as the initial solution.

If there is only one feasible candidate path available, select and insert it into the incumbent solution.

If there are m (m
                                    >1) feasible candidate paths available, select the path with the ith (2⩽
                                    i
                                    ⩽
                                    m) highest priority with probability (1−
                                    θ)
                                       i−1
                                    θ, θ
                                    ∈(0,1], and select the path with the highest priority with probability 
                                       
                                          1
                                          -
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                2
                                             
                                             
                                                m
                                             
                                          
                                          
                                             
                                                (
                                                1
                                                -
                                                θ
                                                )
                                             
                                             
                                                i
                                                -
                                                1
                                             
                                          
                                          θ
                                          =
                                          θ
                                          +
                                          
                                             
                                                (
                                                1
                                                -
                                                θ
                                                )
                                             
                                             
                                                m
                                             
                                          
                                       
                                    , so as to guarantee that the accumulated probability is equal to 1.

The above probabilistic criterion has two interesting features. First, each feasible candidate path has the opportunity to be selected and inserted. Consequently the probabilistic constructive procedure is theoretically able to cover the whole solution space. Second, the probability that a feasible candidate path is selected is proportional to its priority. As such, the constructed initial solutions tend to be of good quality.

In addition, because of the hop-constraints, cycles may occur after inserting a new path. In this case, we destroy cycles by inspecting vertices with two incoming edges and eliminating the first inserted edge, as suggested in Costa et al. (2008).

Finally, in the above-described probabilistic constructive procedure, if we let θ
                           =1.0, it is reduced to the greedy algorithm (Costa et al., 2008). However, after a series of preliminary experiments (detailed in Section 4.2, Fig. 2), we find that the generalizations with small values of θ (i.e., θ
                           <0.5) generally perform better than large ones (i.e., θ
                           >0.5), especially than the choice of the greedy algorithm (i.e., θ
                           =1.0), which unexceptionally selects the candidate path with the highest priority.

From an initial solution constructed above, our BLS algorithm improves it to a local optimum by using a specifically designed Neighborhood Search (NS) procedure, which iteratively replaces the incumbent solution with the best improving solution of its neighborhood, until such a solution does not exist. The proposed NS procedure is detailed in the following subsections.

To identify the best neighboring solution of the incumbent solution T within the neighborhood N(T) (see next subsection), BLS uses the objective value (i.e., the collected revenues) as the main evaluation criterion. Thus given two solutions, the one collecting a higher revenue is better than the one collecting a lower revenue. If both solutions collect the same amount of revenue, the solution with a lower cost is naturally considered to be the better one. Given this evaluation rule, BLS identifies at each iteration the best improving solution among all the candidate neighboring solutions in N(T) and moves to this selected solution.

The neighborhood structure is the key component of any neighborhood-based search method. We design three dedicated move operators for the SPTRBH denoted by Move_k(i
                           1,…,
                           i
                           
                              k
                           ), 1⩽
                           k 
                           ⩽3 for generating neighboring solutions. As a preliminary, we first introduce two basic operators: Delete(i), Insert() as follows.


                           Delete(i): delete the path connecting leaf vertex i from the incumbent solution. Note that for path deletion, we just delete the edges between vertex i and the first met branch vertex or profitable vertex, while maintaining the left edges between vertex i and the root vertex (e.g., Fig. 1
                           , a
                           →
                           b
                           →
                           c, see below for more comments).


                           Insert(): iteratively insert one path (excluding the recently deleted ones) connecting some profitable vertex to the incumbent solution, according to the criteria described in Section 3.2, until the incumbent solution becomes a saturated BHS-tree, i.e., no feasible candidate path can be further inserted. Note that zero or several paths may be inserted by Insert() (as shown in Fig. 1, c
                           →
                           d).

With these two basic operators, three move operators for generating neighboring solutions, i.e., Move_k(i
                           1,…,
                           i
                           
                              k
                           ), 1⩽
                           k
                           ⩽ 3, are implemented as follows.
                              
                                 (3)
                                 
                                    
                                       
                                          
                                             Move
                                             _
                                             1
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             =
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             +
                                             Insert
                                             (
                                             
                                             )
                                             ,
                                          
                                       
                                       
                                          
                                             Move
                                             _
                                             2
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             =
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             +
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             +
                                             Insert
                                             (
                                             
                                             )
                                             ,
                                          
                                       
                                       
                                          
                                             Move
                                             _
                                             3
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             
                                                
                                                   i
                                                
                                                
                                                   3
                                                
                                             
                                             )
                                             =
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             +
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             +
                                             Delete
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   3
                                                
                                             
                                             )
                                             +
                                             Insert
                                             (
                                             
                                             )
                                             .
                                          
                                       
                                    
                                 
                              
                           where i
                           1, i
                           2, i
                           3
                           ∈
                           lv(T), lv(T) is the set containing all the leaf vertices of the incumbent solution T.

With these move operators, the generated neighboring solutions are denoted by T⊕Move_k(i
                           1,…,
                           i
                           
                              k
                           ). Note that different k corresponds to different neighboring solutions.

For example, Fig. 1 illustrates the process for generating a neighboring solution by Move_2(8,7), where the profitable vertices with r
                           
                              i
                           
                           >0 are drawn in box (i.e., vertices 1, 3, 4, 7, 8, 9, 11, 13, 14), and the others are drawn in circle (i.e., vertices 2, 5, 6, 10, 12). As shown in Fig. 1, from the original solution a, the path connecting leaf vertex 8 is deleted at first to get solution b. Then the path connecting leaf vertex 7 is deleted to get solution c. Finally, three new paths connecting profitable vertices 11, 13, 14 are inserted into c to obtain a neighboring solution d of the original solution a, i.e., d
                           ←
                           a⊕Move_2(8,7).

Given that vertex 6 is a branch vertex that has two branches, when deleting the path connecting leaf vertex 8 from a, we only delete edge (6,8) from a, instead of deleting all the edges between vertex 8 and the root. Similarly, because vertex 4 is a profitable vertex with r
                           4
                           >0, when deleting the path connecting leaf vertex 7, we only delete edges (4,6) and (6,7) from b.

Clearly, if ∣lv(T)∣=
                           m, there are 
                              
                                 
                                    
                                       C
                                    
                                    
                                       m
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 
                                    
                                       m
                                       !
                                    
                                    
                                       k
                                       !
                                       (
                                       m
                                       -
                                       k
                                       )
                                       !
                                    
                                 
                              
                            possible neighboring solutions with move operator Move_k(i
                           1,…,
                           i
                           
                              k
                           ). Therefore, if we consider all the possible neighboring solutions, the neighborhood N(T) contains O(m
                           3) neighboring solutions. Although larger neighborhoods generally lead to better local optimal solution, more computation time is also needed. For the trade-off between solution quality and efficiency, in this work, we try to reduce the neighborhood N(T) to contain O(m) solutions selected from all the O(m
                           3) possible candidate ones by the following steps.
                              
                                 (1)
                                 Let N(T,
                                    k), 1⩽
                                    k
                                    ⩽3 denote the sub-neighborhood associated with operator Move_k(i
                                    1,…,
                                    i
                                    
                                       k
                                    ). Then, initialize N(T,1) to contain all the m possible neighboring solutions generated by Move_1(i
                                    1), and initialize N(T,2), N(T,3) to be ∅.

As a preliminary, try to construct and fill a high-quality (or elite) solution pool HSP as follows. For each individual, call the probabilistic constructive procedure described in Section 3.2 to construct an initial solution, and then iteratively replace the incumbent solution with the best improving neighboring solution of its smallest sub-neighborhood N(T,1), until no improving solution exists in N(T,1). Independently repeat this process Q times to obtain Q local optima, i.e., T
                                    1,…, T
                                    
                                       Q
                                    , then calculate their average collected revenues and retain the ones collecting no less revenues than the average value. These selected solutions are considered as high-quality solutions and stored into the HSP.

For each vertex i, calculate the probability p
                                    
                                       i
                                     that vertex i belongs to the solutions stored in the HSP, i.e.,
                                       
                                          (4)
                                          
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               a
                                                            
                                                         
                                                         ∈
                                                         HSP
                                                      
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                
                                                
                                                   |
                                                   HSP
                                                   |
                                                
                                             
                                             .
                                          
                                       
                                    where 
                                       
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                             
                                                a
                                             
                                          
                                       
                                     indicates whether vertex i belongs to solutions T
                                    
                                       a
                                    
                                    ∈
                                    HSP or not. If 
                                       
                                          i
                                          ∈
                                          v
                                          (
                                          
                                             
                                                T
                                             
                                             
                                                a
                                             
                                          
                                          )
                                          ,
                                          
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                             
                                                a
                                             
                                          
                                          =
                                          1
                                       
                                    , otherwise, 
                                       
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                             
                                                a
                                             
                                          
                                          =
                                          0
                                       
                                    .

Apply a probabilistic deletion operator, denoted by ProbDel(k), to probabilistically delete k paths connecting k leaf vertices from the incumbent solution T, with the aid of the HSP (as detailed in Algorithm 2). Note that in Algorithm 2, each time one path connecting a leaf vertex is deleted, some branch vertex may become a new leaf vertex. The path connecting this new leaf vertex should also be considered when deciding the next path to delete.

For each k, 2⩽
                                    k
                                    ⩽3, generate ∣lv(T)∣=
                                    m neighboring solutions and add them into sub-neighborhood N(T,
                                    k) as follows: for each leaf vertex i
                                    ∈
                                    lv(T), delete the path connecting vertex i at first, and then execute the probabilistic deletion operator ProbDel(k
                                    −1) to probabilistically delete k
                                    −1 paths. After that, execute the basic operator Insert() to insert as many feasible candidate paths (excluding the recently deleted ones) as possible into the incumbent solution, to obtain a saturated BHS-tree, i.e.,
                                       
                                          (5)
                                          
                                             N
                                             (
                                             T
                                             ,
                                             k
                                             )
                                             =
                                             {
                                             T
                                             +
                                             Delete
                                             (
                                             i
                                             )
                                             +
                                             ProbDel
                                             (
                                             k
                                             -
                                             1
                                             )
                                             +
                                             Insert
                                             (
                                             
                                             )
                                             ,
                                             
                                             i
                                             ∈
                                             lv
                                             (
                                             T
                                             )
                                             }
                                             ,
                                             
                                             2
                                             ⩽
                                             k
                                             ⩽
                                             3
                                             .
                                          
                                       
                                    
                                 

Let N(T) be the union set of all the above three sub-neighborhoods, i.e.,
                                       
                                          (6)
                                          
                                             N
                                             (
                                             T
                                             )
                                             ←
                                             N
                                             (
                                             T
                                             ,
                                             1
                                             )
                                             ∪
                                             N
                                             (
                                             T
                                             ,
                                             2
                                             )
                                             ∪
                                             N
                                             (
                                             T
                                             ,
                                             3
                                             )
                                             .
                                          
                                       
                                    
                                 


                                 ProbDel(k) for probabilistically deleting k paths from the incumbent solution T
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   Require: Solution T, elite solution pool HSP, number of paths to delete k
                                                
                                             
                                             
                                                
                                                   Ensure: Solution after deleting k paths
                                             
                                             
                                                1: for each vertex i 
                                                   do
                                                
                                             
                                             
                                                2: Calculate the probability p
                                                   
                                                      i
                                                    that vertex i belongs to the solutions stored in the HSP, according to Eq. (4)
                                                
                                             
                                             
                                                3: end for
                                                
                                             
                                             
                                                4: l
                                                   ←0
                                             
                                             
                                                5: while 
                                                   l
                                                   <
                                                   k and leaf vertex i
                                                   ∈
                                                   lv(T), p
                                                   
                                                      i
                                                   
                                                   <1 exists do
                                                
                                             
                                             
                                                6: 
                                                   Deleted
                                                   ←
                                                   false
                                                
                                             
                                             
                                                7: 
                                                   while 
                                                   Deleted
                                                   =
                                                   false 
                                                   do
                                                
                                             
                                             
                                                8: Randomly select a path connecting some leaf vertex i
                                                   ∈
                                                   lv(T), p
                                                   
                                                      i
                                                   
                                                   <1
                                             
                                             
                                                9: /∗ Delete the path connecting leaf vertex i with probability 1−
                                                   p
                                                   
                                                      i
                                                    ∗/
                                             
                                             
                                                10: 
                                                   if 
                                                   GetRandomNum(100)>100×
                                                   p
                                                   
                                                      i
                                                    
                                                   then
                                                
                                             
                                             
                                                11: 
                                                   
                                                   T
                                                   ←
                                                   Delete(i)
                                             
                                             
                                                12: 
                                                   
                                                   Deleted
                                                   ←
                                                   true
                                                
                                             
                                             
                                                13: 
                                                   end if
                                                
                                             
                                             
                                                14: 
                                                   end while
                                                
                                             
                                             
                                                15: 
                                                   l
                                                   ←
                                                   l
                                                   +1
                                             
                                             
                                                16: end while
                                                
                                             
                                             
                                                17: return 
                                                   T
                                                
                                             
                                          
                                       
                                    
                                 
                              

The neighborhood N(T) defined in Eq. (6) will be used as the final neighborhood of the NS procedure. The following properties of this neighborhood are worth mentioning. First, each sub-neighborhood N(T,
                           k), 1⩽
                           k
                           ⩽3 contains m neighboring solutions, hence the final neighborhood N(T) contains 3m neighboring solutions, instead of the original O(m
                           3) possible ones. Second, N(T,
                           k
                           1)⋂
                           N(T,
                           k
                           2)=∅, k
                           1
                           ≠
                           k
                           2, it means that any neighboring solution belongs to only one sub-neighborhood. Third, for each leaf vertex i
                           ∈
                           lv(T), at least one neighboring solution corresponding to deleting the path connecting vertex i belongs to each sub-neighborhood N(T,
                           k), 1⩽
                           k
                           ⩽3. This feature could be helpful to reinforce the diversity of the solutions of the neighborhood. Fourth, the higher the probability p
                           
                              i
                            of leaf vertex i, the larger its probability to be retained while generating neighboring solutions. We utilize this mechanism to select O(m) promising neighboring solutions among all the O(m
                           3) candidates. Finally, every neighboring solution is unexceptionally a saturated BHS-tree, thus the search is restricted within the saturated constrained search space 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ¯
                                    
                                 
                              
                           .

In addition, to verify the impact of the neighborhood structure, we tested two other different neighborhoods, i.e., N(T,1) and N(T,1)∪
                           N(T,2) respectively, and compared their performances with the neighborhood defined by Eq. (6). Experiments showed that BLS with Eq. (6) yielded statistically much better results (in terms of solution quality) than these two compared variants, though some more (remaining reasonable) computational time is needed. To ensure that BLS finds high quality solutions, we adopt Eq. (6) as the final neighborhood.

Based on the above described neighborhood and the way to identify the best improving neighboring solution, the NS procedure starts from a given initial saturated BHS-tree T, and iteratively replaces T with the best improving neighboring solution of its neighborhood N(T). This process continues until no such solution exists in the neighborhood. At this point, a local optimum is reached. To continue its search, our BLS procedure applies a dedicated perturbation mechanism for escaping from the incumbent local optimum, according to the procedure detailed below.

The purpose of the perturbation mechanism is to allow BLS to escape from the current local optimum in order to discover other local optima of better quality. For this, we employ as follows an adaptive perturbation mechanism which varies the perturbation intensity, depending on the search status.

Precisely, each time the search reaches a local optimum T, we perturb it to obtain a new solution. The perturbation consists in deleting L (initialized to L
                        
                           min
                        ) paths from T and inserting subsequently as many feasible candidate paths as possible into the incumbent solution. From this perturbed solution, we call the NS procedure to reach another local optimal solution T
                        ∗. If the new solution T
                        ∗ is too close to T (see below for the exact definition), we increase the jump magnitude L by 1, unless L
                        =
                        L
                        
                           max
                        ; otherwise, we decrease L by 1, unless L
                        =
                        L
                        
                           min
                        . This process is repeated, until the stop condition is met.

To assess if two solutions T
                        
                           a
                         and T
                        
                           b
                         are close or not, we calculate their Hamming distance D(T
                        
                           a
                        ,
                        T
                        
                           b
                        ), based on which we further define the average distance between the solutions of the high-quality solutions pool HSP (Section 3.3.2, step 2), denoted by AvgDis(HSP), as follows:
                           
                              (7)
                              
                                 AvgDis
                                 (
                                 HSP
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             
                                                
                                                   T
                                                
                                                
                                                   a
                                                
                                             
                                             ,
                                             
                                                
                                                   T
                                                
                                                
                                                   b
                                                
                                             
                                             ∈
                                             HSP
                                             ,
                                             a
                                             <
                                             b
                                          
                                       
                                       D
                                       (
                                       
                                          
                                             T
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       
                                          
                                             T
                                          
                                          
                                             b
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             1
                                          
                                          
                                             2
                                          
                                       
                                       ×
                                       |
                                       HSP
                                       |
                                       ×
                                       (
                                       |
                                       HSP
                                       |
                                       -
                                       1
                                       )
                                    
                                 
                                 .
                              
                           
                        Based on this, T
                        ∗ is considered to be too close to T if D(T,
                        T
                        ∗)<
                        α
                        ×
                        AvgDis(HSP). Parameter α would be further discussed in Section 4.2.

In addition to the jump magnitude L, BLS also considers the type of perturbations. In this work, we develop a directed perturbation operator, with the aid of the HSP. The basic idea is that the vertices which frequently occur in high-quality solutions are more likely to belong to the global optimal solution. Therefore, when we perturb the incumbent solution, it would be wise to retain these specific vertices with a larger probability, and retain the others with a smaller probability. Specifically, let T be the current local optimal solution, we perturb T by the following three steps, with a given jump magnitude L.
                           
                              •
                              For each vertex i
                                 ∈
                                 v(T), calculate the probability p
                                 
                                    i
                                  that vertex i belongs to the solutions stored in the HSP, according to Eq. (4).

Call Algorithm 2 to probabilistically delete L paths, unless no leaf vertex with p
                                 
                                    i
                                 
                                 <1 exists.

Execute the basic operator Insert() (Section 3.3.2) to insert as many feasible candidate paths (excluding the paths deleted in above step) as possible into the incumbent solution, until no path can be further inserted.

This perturbation procedure has the following features. First, the incumbent solution is perturbed in an adaptive way, controlled by the jump magnitude L, i.e., the larger the magnitude L, the stronger the perturbation. Second, the perturbation attempts to reconstruct a new incumbent solution in a biased mode, guided by some dedicated information from the high-quality solutions in the HSP. Finally, the new solution never violates the budget and hop constraints and is always a saturated BHS-tree, hence no repair is required and the search always operates within the saturated constrained search space 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                        .

@&#DISCUSSIONS@&#

As shown previously, the probabilistic constructive procedure used by our BLS approach is inspired by the greedy heuristic from Costa et al. (2008) and provides a natural generalization. In addition, BLS distinguishes itself from the existing heuristics by several significant features. First, unlike previously heuristics, BLS follows the iterated local search framework which includes an adaptive breakout perturbation strategy to escape from local optima. Second, with its dedicated neighborhood structure, we ensure that BLS operates within a largely reduced and more focused search space, i.e., the saturated constrained search space 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                        . This is in shape contrast with respect to the existing heuristics which explore usually much larger spaces including unfeasible or unsaturated solutions. As we show in the next section, the proposed BLS algorithm equipped with these particular features is able to reach very competitive results with respect to the existing methods in terms of both solution quality and computational time.

We evaluate our BLS algorithm on a large number of benchmark instances of the literature and compare our results with the best known published results. Given that it is difficult to make a really fair comparison of the computational efforts based on different platforms, we consider the collected revenues (objective function values) as our main evaluation criterion, and include the runtime just for indicative purposes. For information, the BLS algorithm is implemented in C++
                        1
                        The source code of the BLS algorithm is available at http://www.info.univ-angers.fr/pub/hao/stprbh.html.
                     
                     
                        1
                      and executed on an Intel Xeon E5440 2.83giga hertz processor (with a peak value of 25.5, according to the Standard Performance Evaluation Corporation via www.spec.org) and 2gigabytes RAM, while an AMD Opteron machine with 2.39giga hertz CPU (with a peak value of 18.7) and 2gigabytes RAM was used in Costa (2006, 2008, 2009), and a computer with an Intel Xeon E5540 2.53giga hertz processor (with a peak value of 29.4) and 3gigabytes RAM was used in Sinnl (2011). In order to make the comparisons as fair as possible, whenever reporting the results corresponding to the reference algorithms, their CPU times are harmonized with respect to our processor according to the peak values evaluated by SPEC. Respectively, the CPU times reported in Costa (2006, 2008, 2009) are multiplied by 0.73 
                        
                           
                              
                                 
                                    
                                       
                                          18.7
                                       
                                       
                                          25.5
                                       
                                    
                                 
                              
                           
                        
                     , while the CPU times reported in Sinnl (2011) are multiplied by 1.15 
                        
                           
                              
                                 
                                    
                                       
                                          29.4
                                       
                                       
                                          25.5
                                       
                                    
                                 
                              
                           
                        
                     .

We use the 40 challenging benchmark graphs from Costa (2006) and Costa et al. (2008), which are adapted Steiner graphs from the series C of the OR-Library
                           2
                           These instances and the solution certificates of our BLS algorithm are available at http://www.info.univ-angers.fr/pub/hao/stprbh.html. The initial Steiner graphs are available at http://people.brunel.ac.uk/mastjjb/jeb/orlib/steininfo.html.
                        
                        
                           2
                         (Beasley, 1990). These instances are also used in Costa et al. (2009) and Sinnl (2011). Note that for each graph, 6 different scenarios are considered, leading to 40×6=240 cases. These 240 cases are further classified into 3 groups as follows.


                        Group 1: This group contains 60 cases from the first 10 graphs (steinc1_10, …, steinc5_10, steinc1_100, …, steinc5_100), all with 500 vertices and 625 edges. For each graph, 6 different cases associated with different 
                           
                              B
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ∈
                                          E
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          ij
                                       
                                    
                                 
                                 
                                    b
                                 
                              
                           
                         and h, i.e., b
                        =10, 30 and h
                        =5, 15, 25, are created. These 60 cases have all been solved to optimality by exact algorithms, with a time limit of 5256seconds in Costa et al. (2009) or 11,500seconds in Sinnl (2011) (after harmonizing by SPEC).


                        Group 2: This group contains 72 cases from 12 different graphs (steinc8_10, steinc8_100, steinc9_10, steinc9_100, steinc10_10, steinc10_100, steinc13_10, steinc13_100, steinc14_10, steinc14_100, steinc15_10, steinc15_10), with 500 vertices and up to 2500 edges. These cases are rather large and cannot be solved by the above exact algorithms. However, for 16 special cases, the allowed budget is abundant enough that it is not difficult for heuristics to reach the upper bound R
                        
                           ub
                         of the collected revenues (see Eq. (2)). Meanwhile, for the remaining 56 cases, the optimal results still remain unknown. These 56 cases can thus be considered as the most challenging problems.


                        Group 3: The last group contains the remaining 108 cases corresponding to the remaining 18 graphs, with 500 vertices and up to 12,500 edges. These cases are really large scale and no result is reported by any exact algorithm. However, like the 16 special instances of the second group, for each of these instances, the allowed budget is abundant enough that heuristics can easily reach the upper bound of the collected revenues. Hence, these cases have all been solved to optimality (with collected revenues reaching the upper bound) by previous heuristics.

It should be mentioned that the four heuristics proposed in Costa et al. (2008), i.e., greedy, D&R, TS(2000), TS(10000), were evaluated in two different modes. For each test case, the two deterministic heuristics, i.e., greedy and D&R, were executed only once, while the two randomized heuristics, i.e., TS(2000) and TS(10000), were independently run 10 times. Since only the mean computing time of the 10 runs for TS(2000) and TS(10000) was reported, the total used time for 10 runs should be multiplied by 10 (we have confirmed this point with Dr. AM Costa), just as shown in the following Tables. For fair comparisons, we also evaluate the performance of our BLS algorithm in two different modes, named Single-BLS and Multiple-BLS respectively. With Single-BLS, we run our BLS algorithm only once for each test case, while for Multiple-BLS, we independently run BLS 10 times from different initial solutions generated by the probabilistic constructive procedure (Section 3.2). The cutoff time for each independent run is set to 12min (for Single-BLS), thus up to two hours (12×10min) is allowed for Multiple-BLS.

The six parameters used in our BLS algorithm are given in Table 1
                        . L
                        
                           min
                         and L
                        
                           max
                         are respectively the lower and upper bound of the jump magnitude L. Since L is tuned in an adaptive way (see Section 3.4), we just need to make sure that L
                        
                           min
                         (L
                        
                           max
                        ) is small (large) enough within a reasonable range. In this paper, we set L
                        
                           min
                         to equal 1, and set L
                        
                           max
                         to equal ∣pv(T)∣−1, where pv(T) is the set containing all the profitable vertices of the incumbent solution T. Apparently, L
                        
                           min
                         (L
                        
                           max
                        ) is the possible minimum (maximum) number of paths that could be deleted while perturbing the incumbent solution (the root vertex is not permitted to be deleted). Parameter Q is used to control the size of the elite solution pool HSP (Section 3.3.2). Preliminary tests show that when Q
                        ⩾100, no statistically significant difference (in terms of solution quality) is observed with different values of Q. Hence we choose 100 as its default value.

In addition to these three robust parameters, BLS has three other parameters, i.e., θ, α, M. Parameter θ determines the probability for selecting a candidate path to insert to the solution (Section 3.2.5). α is used in the adaptive perturbation mechanism to control the distance between the incumbent solution and the perturbed solution (Section 3.4). M serves as one of the terminal criteria of BLS (second paragraph of Section 3). Preliminary experiments using the Friedman test demonstrate that these three parameters are sensitive, thus deserve a careful tuning. In what follows, we briefly describe how these parameters are tuned.

In order to identify an appropriate value for a given parameter, we vary its values within a reasonable range and compare their performances, while keeping the other parameters with their default values (as those shown in Table 1). To compare the results in terms of both solution quality and computation time, we use the popular box and whisker plots based on a sample of 12 instances taken (without bias) from the 56 most challenging cases.

For the purpose of conciseness, we take parameter θ as an example and show in Fig. 2
                         the box and whisker plots obtained with ten different values θ
                        ∈(0,1]. The left sub-figure corresponds to solution quality expressed as the percentage deviation of the obtained results from the best-known results reported in the literature, while the right sub-figure concerns computational time. X-axis indicates the tested θ values and Y-axis shows the performance (solution quality and computational time in seconds). It is clearly observed that small values of θ (i.e., θ
                        ⩽0.5) yield better results than large ones (i.e., θ
                        >0.5). Specifically, the variant with a deterministic insertion (θ
                        =1.0) which always selects the path with the highest priority for insertion (Costa et al., 2008) performs the worst. In addition, we observe that among the variants with θ
                        ⩽0.5, BLS with θ
                        =0.3 performs the best in terms of computation time. Therefore, θ
                        =0.3 is used as the default value by BLS.

To tune parameters α and M, we use the same procedure and choose α
                        =0.3, M
                        =100 as their default values.

We first consider the first group of 60 cases, corresponding to 10 different graphs of series C. For these cases which have already been solved to optimality by previous exact algorithms, we summarize in Table 2
                         (the detailed results are provided as an appendix in Table 5) the results obtained by our BLS, with respect to the existing exact or heuristic approaches. In Table 2, column ‘Method’ lists, in addition to our Single-BLS and Multiple-BLS algorithms (last two rows), the reference approaches. The first six approaches, i.e., S1, S3, S5 (Costa et al., 2009), BP1, BP2, BP3 (Sinnl, 2011) are exact algorithms, while the following four approaches, i.e., greedy, D&R, TS(2000) and TS(10000) (Costa et al., 2008) are heuristics. Column ‘Success (Opt)’ indicates the number of cases (out of 60) for which the optimal value is reached by each method. Column ‘Fail (Sub-Opt)’ indicates the number of cases where the corresponding exact approach cannot terminate within the allowed time (5256seconds in Costa et al. (2009) and 11,500seconds in Sinnl (2011)) or the corresponding heuristic approach misses the optimal solutions. Columns ‘Mean Gap’ and ‘Max Gap’ respectively list the mean gap (only for the cases missing the optimal solutions) and maximal gap between the optimal solutions and the best solutions obtained by each heuristic approach (exact approaches can always solve the problem to optimality, unless they cannot terminate within the limited time). Columns ‘Mean Time’ and ‘Max Time’ present the mean CPU time and maximal CPU time (in seconds, after harmonizing by SPEC, so as the follows) used by each method to reach its solutions. For our Single-BLS and Multiple-BLS algorithms, the preprocessing time (see Section 3.2.1) is also included, as well as in the following tables.

As shown in Table 2, the previous exact approaches, i.e., S1, S3, S5, BP1, BP2, BP3 can respectively solve 59, 59, 36, 58, 59, 59 cases to optimality within different time limits (5256seconds for S1, S3, S5 and 11,500seconds for BP1, BP2, BP3), with a mean time of 190.38seconds, 250.26seconds, 2164.78seconds, 766.33seconds, 443.01seconds, 376.65seconds, respectively. On the other hand, the previous heuristics: greedy, D&R, TS(2000), TS(10000) respectively reach 28, 34, 29, 30 optimal solutions, with a mean time of 0.02seconds, 2.26seconds, 30.05seconds, 145.55seconds, and with mean gaps 9.68%, 8.09%, 5.36%, 4.26% respectively. For comparison, BLS with a single run (Single-BLS) and multiple runs (Multiple-BLS) respectively reaches 35 and 43 optimal results out of these 60 cases, with a small mean gap of 2.78% and 1.48%, while consuming a mean time of 17.70seconds and 79.51seconds. Multiple-BLS clearly dominates TS(10000), which is the best heuristic in Costa (2006) and Costa et al. (2008). It is remarkable that even Single-BLS performs better than TS(10000) in terms of both solution quality and computation time, indicating the effectiveness of BLS against TS. As to the deterministic heuristic D&R, Single-BLS yields much better results than D&R, but requires more computing time. Finally, as a special case of our probabilistic constructive procedure, the greedy algorithm (corresponding to θ
                        =1.0) is extremely fast, but for challenging instances, it generally leads to solutions of inferior quality.

We now show the results of BLS on the second group of 72 cases, corresponding to 12 different graphs from series C, with 500 vertices and up to 2500 edges. This group of cases are the most challenging ones of all the three groups of 240 cases, due to two reasons. On one hand, due to their large size, no optimal result has been reported by any exact algorithm. On the other hand, due to their strict budget limitation, except 16 special cases with best known results already reaching the upper bound of the collected revenues, the optimal results of the remaining 56 cases still remain unknown. Therefore, for these 56 cases, there is room for improvement with respect to the best known results reported in the literature.

The results of Single-BLS and Multiple-BLS and those of the reference heuristics (Costa, 2006, 2008) are provided in Table 3
                        . The first three columns respectively denote the graph name, the budget limit 
                           
                              B
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ∈
                                          E
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          ij
                                       
                                    
                                 
                                 
                                    b
                                 
                              
                           
                         and the hop limitation h. The following eight columns list the results reported by the reference heuristics, i.e., columns 4–7 indicate the collected revenues R and consumed CPU time t (seconds) of the two deterministic heuristics: greedy and D&R, columns 8–11 indicate the best collected revenues R
                        
                           best
                         among 10 runs and the consumed CPU time t (seconds) of TS(2000) and TS(10000) (after harmonizing by SPEC). Columns 12–13 list the collected revenues R and consumed CPU time t (seconds) of Single-BLS. The last 5 columns show the results obtained by Multiple-BLS, including the best (R
                        
                           best
                        ) and the average (R
                        
                           avg
                        ) of the collected revenues among 10 runs, the times that Multiple-BLS improves (column √) or matches (column =) the best known result among the 10 runs, and its CPU time t (seconds). The results in bold indicate the best results for each test case, obtained by all the listed algorithms, while the results in italic indicate that the results reach the upper bound.

As shown in Table 3, for the 16 cases with the best known results already reaching the upper bound, Single-BLS and Multiple-BLS can unexceptionally reach the upper bound within very short time. More importantly, for the 56 unsolved cases with unknown optimal solutions, Single-BLS (Multiple-BLS, respectively) succeeds in improving 32 (49) and matching one current best known results. Statistically, the mean improvement gained by Single-BLS (Multiple-BLS, respectively) over the best known results on these 72 cases is 1.34% (3.12%), indicating that BLS produces competitive results for this group of challenging benchmarks. On the other hand, the mean CPU time on these 72 cases corresponding to Single-BLS (Multiple-BLS, respectively) is 36.95seconds (294.62seconds), while the mean CPU times corresponding to greedy, D&R, TS(2000), TS(10000) are 0.19seconds, 29.80seconds, 55.14seconds, 258.97seconds respectively.

Specifically, statistical results show that Multiple-BLS gains a mean improvement of 3.44% over TS(10000), while consuming nearly the same mean CPU time. Furthermore, Single-BLS leads to a mean improvement of 1.66%, 2.66%, 4.01% over TS(10000), TS(2000), and D&R, respectively, while consuming much less CPU time than TS(10000), TS(2000), and about 23% more CPU time than D&R. Finally, we do not directly compare BLS with the greedy heuristic, given that it is a special case of our probabilistic constructive procedure for initialization.

In addition, from Table 3, we see that Multiple-BLS performs very well for the cases with large h, but fails to match the best known results of six cases with a very small hop limitation, i.e., h
                        =5. One explanation is that when h is very small, cycles frequently occur after inserting a new path to the incumbent solution. In this case, the proposed algorithm should detect and eliminate cycles efficiently. Our current version of BLS perhaps does not deal well with this special situation, which merits certainly further research.

The last group of 108 large cases from 18 graphs of series C have 500 vertices and up to 12,500 edges. They are too large to be solved by the existing exact algorithms. However, as described in Section 4.1, all the cases of this group have large budgets so that several heuristics can reach the upper bound of the collected revenues. Indeed, these cases have all been solved to optimality by previous heuristics. Like for the first group, we summarize the existing results and our results in Table 4
                         (the detailed results are provided as an appendix in Table 6). The meaning of each column in Table 4 is similar to that of Table 2. From Table 4, one observes that the previous heuristics: greedy, D&R, TS(2000), TS(10000) respectively miss four, zero, two, and two optimal results out of the 108 cases, while Single-BLS and Multiple-BLS respectively miss one and zero optimal result with much less computing times than the main reference heuristics TS(10000), TS(2000), and D&R.

@&#CONCLUSION@&#

We have proposed a Breakout Local Search (BLS) algorithm for the Steiner tree problem with revenue, budget and hop constraints (STPRBH), which can model a number of network designing problems. The proposed BLS approach relies on a probabilistic constructive procedure for initialization, a neighborhood search procedure based on several specifically designed move operators for local optimization, and an adaptive breakout perturbation mechanism for escaping from local optima. Experiments based on three groups of 240 representative benchmarks from the literature demonstrate that BLS is a competitive algorithm for the STPRBH, compared to previous proposed approaches. For the 184 cases with known optimal solutions, BLS can attain an optimal result for 167 cases (90.8%) within short computing time. More importantly, for the 56 most challenging cases with unknown optimal solutions, BLS finds 49 improved solutions and matches one more best known results within reasonable time. Nevertheless, BLS misses the best known solutions for six cases, in particular with very small hop limitations.

The work described in this paper can be further extended by following several directions: (1) design specific techniques to deal with the cases with very small hop limitations, (2) investigate other move operators and perturbation strategies, (3) combine BLS with a population-based method like the memetic framework, and (4) adapt the ideas of this research to other STP variants.

@&#ACKNOWLEDGEMENTS@&#

We are grateful to the reviewers for their helpful comments and suggestions. The work is partially supported by the Conseil General 49 and the Pays de la Loire Region within the RaDaPop (2009–2013) and LigeRO (2010–2014) projects. Our sincere thanks to Dr. AM Costa for kindly making the benchmark instances available to us and answering our questions.

Herein, we provide as appendices in Tables 5 and 6
                     
                      the results obtained by our BLS (Single-BLS, Multiple-BLS respectively) for the first and third group of test cases (each row lists two cases, corresponding to the same graph and the same hop constraint h, but different budget constraint 
                        
                           B
                           =
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       ∈
                                       E
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       ij
                                    
                                 
                              
                              
                                 b
                              
                           
                        
                     ). In Table 5, column ‘Opt’ indicates the optimal results obtained by previous exact algorithms, while in Table 6, column ‘UB’ indicates the upper bound of the collected revenues calculated by Eq. (2). The meanings of the other columns are similar to the ones in Table 3.

@&#REFERENCES@&#

