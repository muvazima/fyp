@&#MAIN-TITLE@&#Design pattern modeling and extraction for CAD models

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Design pattern is introduced into the CAD field.


                        
                        
                           
                           The characteristics and conditions of a good design pattern are defined.


                        
                        
                           
                           A platform-independent design pattern model is constructed.


                        
                        
                           
                           A multi-phases design pattern extraction approach is proposed.


                        
                        
                           
                           The design pattern extraction approach is efficient and effective.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Design pattern

Design reuse

Design patterns modeling

Graph-oriented agglomerative hierarchical clustering

Design semantics

Reusable region

@&#ABSTRACT@&#


               
               
                  Design pattern is widely used in the software engineering field, which enables designers to reuse existing mature designs from a high level perspective. Inspired by this idea, a novel approach is proposed to extract design patterns in the CAD field. First, the characteristics for a good design pattern are analyzed and the model for representing design patterns is elaborated. Then, given a set of 3D feature-based CAD models, the corresponding extraction approach is proposed, which includes three important phases: (1) extracting reusable regions with high cohesion, low coupling and moderate complexity so as to form a relative integrated function; (2) constructing candidate design patterns by clustering reusable regions using a graph-oriented agglomerative hierarchical clustering algorithm; (3) determining the final design patterns by choosing those candidate design patterns with high frequency and sufficient information. Finally, a design pattern extraction prototype system is developed, and the experimental results are presented to demonstrate the effectiveness of the approach.
               
            

@&#INTRODUCTION@&#

In the past two decades, the CAD industry has experienced some major technological innovations and paradigm shifts. One of the most important R&D problems is renovating CAD systems for efficient knowledge reuse so as to avoid time-consuming and expensive design from scratch. There is a broad consensus that in the mechanical design field, the tasks of design ideation and conceptual design are critical to the design process [1]. As a result, the designers must, in their early design stage, concentrate on the functional and structural design and avoid taking into account more detailed information. How to retrieve and reuse existing designs through some functional or structural information in early design stage is the key issue. One of the possible solutions may be defining, extracting, and reusing the design patterns of 3D CAD models.

Design pattern was first proposed by Christopher Alexander in the field of architecture [2]. It describes reusable regions in architecture with a simple technical language so that architects are able to easily understand and reuse these regions. Currently, design pattern has been applied in various other disciplines, for example, software engineering [3]. Inspired by the ideas in these disciplines, we introduce design pattern into the mechanical CAD field so as to enable designers to reuse successfully developed design cases from a high perspective. Because most of the product information, such as materials, cost, analysis data and manufacturing process, is shape-related, in this work, the design pattern for CAD is defined as a reusable region of a set of given CAD models with a special function that designers are able to understand and reuse. Here, the subpart is a subpart of a 3D CAD model that consists of a set of simple features. When the subpart is too large as a whole 3D CAD model, we define it as a standard part; and when the subpart is too small to split, we define it as a feature.

With the continuous development of 3D modeling technology, more and more advanced modeling technologies, such as “SpaceClaim”, make it easy to add a relative independent subpart into another existing design. Consequently, substantial work are proposed on how to find the relative independent subparts so as to support the design reuse [4–8]. We have also done some work on design reuse [9,10]. However, in the preliminary stage, the design patterns are just defined as those representative structures appearing with a high frequency found in the past design results, and thus it does not truly capture the connotation of design patterns of the reusable field. This paper, inspired by design patterns in software engineering, focuses on modeling and extracting design patterns for 3D CAD models. The innovative contributions are: (1) introducing design pattern into the CAD field so as to facilitate design reuse from a high level perspective, (2) presenting five specific characteristics and corresponding six conditions of a good design pattern, and constructing a platform-independent design pattern model based on Core Product Model (CPM), (3) proposing a multi-phases design pattern extraction approach. It should be stated that, in this work, we also extract reusable regions based on complexity, which is similar to the idea of the work in Ref. [9], but the algorithm for calculating complexity of a given region has been reasonably improved.

The remaining sections of the paper is organized as follows. First, a brief review of the related literature is given in Section 2 and the definition and modeling of design patterns are presented in Section 3. Then, Section 4 describes the three important phases of our approach for extracting design patterns: the extraction of the reusable regions based on design semantics, the construction of the candidate design patterns based on graph-oriented agglomerative hierarchical clustering (G-AHC), and the determination of the final design patterns based on information entropy theory. Following this, in Section 5, the implementation and some results are presented. Finally, we conclude the paper and present several further work directions.

@&#RELATED WORK@&#

Design reuse and design pattern are the key issues of the proposed work. Firstly, we review the related work of design reuse in this section. Meanwhile, design pattern extraction is mainly related to common design structure discovery and clustering, of which both issues are widely studied in the areas of computer science and engineering. We will also review the work about common design structure discovery and clustering of 3D CAD models.

In one of the review papers of design reuse [11], Shahin pointed out that design reuse in the CAD filed was aimed at maximizing the utilization of design by the reuse of successful past designs in part and in whole for new design. The strategy of design reuse avoids expensive and time-consuming development from scratch. Scherer et al. [12] pointed out that in future CAD systems the reuse of already existing design objects would become a key functionality. Moreover, Altmeyer et al. [13] proposed a feature-based model for the reuse of design objects in CAD frameworks; Mok et al. [14] developed a reuse and retrieval system so as to support the reuse of standard parts; Chen et al. [10] proposed a flexible assembly retrieval approach for model reuse; Li et al. [15] proposed the CAD model retrieval based on general and partial shapes for mechanical design reuse. All these works focus on design reuse of whole CAD models, yet as the design become more and more complex, design reuse exists in not only whole models, but also partial models. Huang et al. [4–6] and our team [9] have done some preliminary research on design reuse oriented partial retrieval of CAD models. However, Jackson and Buxton [16] have indicated that 48% of the surveyed researchers highlight the major challenge for design reuse is inflexible design models that fail after changes, and the primary cause is the constraints and the interdependencies between features of the design models. Therefore, analyzing the interdependencies between features and extracting reusable subparts from CAD models are worthy of research.

Most partial retrieval methods extract comparable subparts of 3D models in advance and add the subparts into a database for partial retrieval. To some extent, the extracted comparable subparts can correspond to the common design structures in 3D models .

One type of these methods extracts comparable subparts by clustering polyhedral patches on 3D mesh models. Bespalov et al. [7] extracted local features based on recursive Scale-Space decomposition of polyhedral surfaces into surface patches and cluster those similar patches into a subpart. Gal et al. [8] constructed a salient geometric feature by clustering together a set of descriptors that are interesting enough in the sense that they have a high curvature relative to their surroundings, and a high variance of curvature values. Biasotti et al. [17] recognized similar subparts of objects represented as 3D polygonal meshes by Reeb graphs. However, these 3D segmentation methods are easily affected by minor changes of shapes being segmented. Furthermore, these methods may produce segments that are too trivial to support design reuse for CAD models.

Another type of these methods extracts comparable subparts by subgraph identification. Face attributed relational graphs of B-rep models [18,19] and feature-based graphs of CAD model such as FDAG (Feature Dependency Directed Acyclic Graph) [20] are used in this type of method. Based on different graph descriptors, various graph partitioning methods are proposed to extract comparable subparts of CAD models. Compared to the aforementioned 3D mesh clustering methods, this type of method can extract more meaningful subparts of CAD models. However, all the subparts in these methods are just extracted by subgraph identification, without any account of their reusability, thus the subparts may not be reusable or easy to reuse.

Recently, research attention has also been focused on constructing regularity features for solid models so as to find the underlying design intent [21,22]. To some extent the regularity features are also common design structures; however, they are always too small and only correspond to the simple design features, therefore, they can be classified as feature recognition for solid models.

In their series of research papers [4–6], Huang et al. proposed a method for extracting common local structures. The common local structures are representative structures appearing with a high frequency in the past design results. Their work is important for extracting design patterns for CAD models. However, their extracted subparts are similar to the design features for CAD models, which is still too small for design reuse. Furthermore, reusability is the most important factor for design patterns, while they only take repeatability into account , but overlook the reusability, and therefore their work is still of very limited value in design reuse.

In summary, the research on common design structure discovery for design reuse is in its infancy. The few existing methods are still far from the expectation of designers.

Clustering algorithms have been applied to a variety of applications. However, there are still very few clustering algorithms dedicated to 3D CAD models. According to clustering objects, the clustering algorithms can be broadly classified into two classes.

One class of clustering algorithms is oriented to vectors. In the research, the 3D CAD models are characterized by feature vectors, thus the traditional clustering algorithms can be directly used to cluster the models. Surveys by Jayanti et al. [23] analyzed many relevant research in this area. Some latest typical research include: Hesham et al. proposed K-means clustering algorithm [24], Regli et al. proposed SVM clustering algorithm [25], Li et al. proposed AP clustering algorithm [26], and Endoh et al. proposed random decision tree based clustering algorithm [27].

Another class of clustering algorithms is oriented to graphs. Limited to the structure, feature vectors can only achieve the rough description of overall geometries of 3D models, without description of topology relationships between the various subparts of a model. However, the topology structures of 3D CAD models are crucial in the CAD field. Such limitations seriously affect the clustering effect. Directly aimed at this problem, the clustering algorithm based on graphs, i.e. model signature graphs, is proposed in [28]. By this method, firstly a mapping from the B-rep of the solid model to a model signature graph structure is constructed; the graphs are then projected into vector spaces; finally the clustering of solid models are implemented in the vector spaces. The method can partially describe topology structures of 3D models; however, the original topology information in the model signature graphs is lost in the process of transforming graphs to vectors, which inevitably affects the finally clustering effect.

In other areas, many researchers have also explored clustering methods for graphs, such as the graph clustering methods based on minimum cuts within the graph [29], spectral partitioning [30], random walk model [31] and genetic algorithm [32] etc. The objective of the above research is clustering nodes of a graph and the clustering results correspond to the partition of the given graph. Therefore, these kinds of clustering methods are suitable to break a CAD model into meaningful subparts, but unsuitable to cluster a set of independent 3D CAD models or their subparts.

In the CAD field, a design pattern is defined as a set of similar reusable regions in CAD models with same functions that every designer is able to easily understand and reuse it. Here, a good design pattern must have the following characteristics:

                           
                              (1)
                              Reusability: easy to reuse the original design pattern in other CAD models;

Scalability: easy to add new features into the original design pattern;

Maintainability: easy to modify and improve the original design pattern;

Comprehensibility: easy to understand the design pattern;

Portability: easy to use the design pattern in different CAD systems.

Accordingly, the target for modeling and extracting the design patterns of CAD models is to meet the five characteristics wherever possible. It is emphasized that, for this target, we assume that all the CAD models in the library are design feature-based CAD models. This is because feature-based design is dominant in the CAD field and it can explicitly express the design semantics as well as the geometry of a product. Furthermore, by analyzing the above characteristics of a good design pattern, it can be concluded that a subpart consisting of a number of design features is usually a good design pattern if the subpart satisfies the following six conditions:

                           
                              (1)
                              The features in the subpart must be simple design features [9], which make it possible for the subpart to be migrated into different CAD systems.

It has high cohesion, that is, all features in the subpart are connected. This property guarantees that the subpart has connectedness and focuses on a single function, which is beneficial for maintenance, comprehension and reuse of the design pattern. For example, the four subparts colored in red in Fig. 1
                                  satisfy this condition, and we can see that all the features in each of the subparts focus on a single function.

It has low coupling, that is, the subpart is relatively independent of the rest of the model. Here, the subpart depends on a feature whenever any one feature of this subpart directly depends on the feature; while a subpart is said to be independent of a feature if, and only if, none of the subpart directly depends on the feature [33]. This property ensures that a subpart has relative integrality and independency, which reduces the possibility of changing as other features changes, thereby has the benefit of improving the design pattern’s maintainability, reusability and scalability. In this paper, to make a subpart easy to reuse, we further constrain that the subpart only have one dependent feature.

Obviously, the subpart satisfying “high cohesion and low coupling” is easily migrated and can form a relative integrated function shared by different parts. Taking the subparts in Fig. 1 as examples, the subparts 1–3 can satisfy both conditions (1) and (2), each of which corresponds to a relative independent and integral assembly interface; while the subpart 4 connects with two different features simultaneously, thereby corresponds to part of an assembly interface.

In fact, high cohesion and low coupling are complementary. If a subpart has low cohesion, each feature in the subpart must undertake much responsibility, thereby increasing its dependency with other features, i.e., the subpart must have high coupling, or vice versa. Accordingly, we can conclude that cohesion is closely related to coupling, and poor cohesion will lead to poor coupling, therefore, they must be considered as a whole.

It is of moderate complexity, which makes the subpart worthy of design reuse. Evidently, if a subpart is simple, then designers can easily design and model the subpart themselves with current CAD tools without the need to spend time searching for it. The subparts 1 and 3 in Figure1 are the case. In contrast, if a subpart is complex, i.e. the direct design and modeling of the subpart are difficult and time-consuming, then the subpart is worthy of being reused by designers, such as subpart 2 in Fig. 1.

It is of high repetition rate, that is, the subpart frequently appears in multiple models, which means that the designers often consciously or unconsciously create the subpart repeatedly in different parts. From a statistical point of view, this property guarantees that the subpart has certain reusability.

It contains rich information. If a subpart is so common that it appears almost in every model, obviously, the subpart can only provide little information thereby making it meaningless for a designer to spend time extracting and reusing it, or vice versa.

Based on the above analysis, Table 1
                         gives the corresponding relationship between the five characteristics and the six conditions of a good design pattern. In this work, the above-mentioned six conditions are used as the criteria for modeling and extracting design patterns. For other cases where the subparts do not satisfy the conditions, yet still have significantly reuse value for engineers, they can be defined as custom design patterns.

As the above subsection analyzed, a good design pattern could be reused and shared by different designs, different designers and even different CAD systems, hence a proper model for design pattern must be platform-independent; meanwhile, the model must describe its physical entity, semantic information and their association. To this end, based on the NIST’s Core Product Model (CPM) [34], we construct a consistent formal model for the design pattern. As Fig. 2
                         shows, a design pattern is composed of a set of features with specific relationships. The descriptions of the classes closely related to the design pattern class are the following.

                           
                              •
                              Artifact represents a distinct physical entity in a product, whether that is a component, part, subassembly, or assembly. All these can be represented and interrelated through the subArtifact/subArtifactOf containment hierarchy.

Feature is a portion of the artifacts form that has some specific function. In this work, the feature refers in particular to design feature.

Function is what the artifact is supposed to do, that is, its intended behavior.

Form is the proposed solution for the design problem specified by the function, represented in terms of its geometry and material.

DesignPattern is composed of a set of features and corresponds to a portion of the artifact’s form that has some specific function and is reused in different CAD models. Design pattern has its own containment hierarchy, so that compound design patterns can be created out of other design patterns (but not artifacts).

Geometry is the spatial description of the artifact. Subgeometries may contain diverse geometries. In this work, a B-rep geometry representation is chosen.

There are five classes related to the B-rep model, i.e., Solid, Face, Loop, HalfEdge and Vertex.

There are 46 classes closely related to features. Here, features can be divided into two types: the primary feature corresponding to the overall shape of the 3D CAD model; and the subsidiary feature corresponding to a portion of the 3D CAD model [9]. Every design feature-based CAD model consists of only one primary feature and a number of subsidiary features. Moreover, the subsidiary feature refers to simple design feature, which is divided into three further subtypes: basic feature that cannot be divided into fine features, including boss, slot, hole, notch and pocket; combined feature composed of a series of basic features with the same type but different parameters, including combined hole and combined boss; and pattern features consisting of a certain number of the same type of basic features arranged according to some rule, including boss array, slot array, hole array, notch array and pocket array.

There are 6 classes closely related to the association between features, i.e., EntityAssociation, DirectedAssociation, UndirectedAssociation, DependentRelationship, IntersectingRelationship and AdjacentRelationship. Here, entity association is a set of membership relationship between the two related design features, which can be classified into directed association and undirected association. The directed association records dependent relationship, which means that a feature is dependent on another feature; and the undirected association records paralleled relationship, which can be further classified into intersecting relationship and adjacent relationship.

The associations closely related to the design pattern class are the following.

                           
                              •
                              Associations between an Artifact and its Features. An artifact is composed of the form of B-rep representation. These associations construct the bridge between the feature-based CAD model and the B-rep model.

Associations between a DesignPattern and related Artifacts as well as associations between a DesignPattern and its Functions, both of them construct the bridge between physical entity and semantic information of the design pattern.

Aggregations : Function, Form, and Behavior aggregate into Artifact; Features aggregate into DesignPattern; Function and Form aggregate into Feature; Geometry and Material aggregate into Form; Vertices aggregate into HalfEdge; HalfEdges aggregate into Loop; Loops aggregate into Face; Faces aggregate into Solid; Solids aggregate into B-rep.

As an example, Fig. 3
                         shows an instance diagram for a simple design pattern instance.

Based on the above analysis of design patterns of 3D CAD models, we propose a design pattern extraction approach. Fig. 4
                         shows the overview of the approach. It could be seen that our approach starts when a set of 3D CAD models and their extended feature trees are input, and ends with outputting the design patterns of these models, which contains three main phases: (1) extracting reusable regions, (2) constructing candidate design patterns, and (3) determining final design patterns. Here we give a brief description of each phase respectively.

                           
                              a.
                              
                                 Extracting reusable regions: With a set of 3D CAD models and their extended feature trees as input, this process extracts reusable regions using the following two steps: first, the candidate reusable regions with high cohesion and low coupling are extracted based on the extended feature tree of each 3D CAD model; Then, the final reusable regions are extracted by calculating and comparing the complexities of the candidate reusable regions. After the above two steps, the reusable regions extracted can satisfy the first four conditions of a good design pattern.


                                 Constructing candidate design patterns: In this process, all extracted reusable regions are divided into different clusters based on G-AHC, each of which corresponds to a candidate design pattern. There are three main steps in this process: (1) calculating the distance between different reusable regions, (2) clustering the reusable regions into different classes based on G-AHC, and (3) constructing candidate design pattern. With the above steps, this process can provide candidate design patterns for the final process.


                                 Determining final design patterns: In this process, candidate design patterns with high frequency and sufficient information are determined as the final design patterns. After filtering by the two indicators, the remaining design patterns are always of high repetition rate and rich information, thereby satisfying the last two conditions of a good design pattern. Accordingly, the design patterns extracted by this approach are reusable regions in CAD models with a special function that every designer is able to understand and reuse them conveniently.

According to the model for representing design patterns, we introduce the extended feature trees in [9] to represent the given 3D CAD models, and the extraction of reusable regions is based on the subtrees decomposition and complexity analysis. Before describing the algorithm for automatically extracting reusable regions, some related terminology definitions are first given below.

The first four definitions are about extended feature trees, which are proposed in our previous work [9]. Details are given as follows:

                              Definition 1
                              Extended Feature Tree (EFT): The extended feature tree of a design feature-based CAD model is the attributed minimum spanning tree of the model’s feature graph G. The nodes of the tree consist of all the nodes of G, the edges of the tree consist of those edges of G representing dependent relationships between design features, and one attribute of each node represents the paralleled relationships, including adjacent relationships and intersecting relationships [9]. Specifically, the types of features and their relationships can refer to the model of design patterns in Fig. 2.

In this work, every 3D CAD model is represented as an extended feature tree, whose root node always corresponds to the overall shape of the model and the nodes with different depths correspond to different levels of details of the models geometry. Obviously, the extended feature tree can represent the association between boundary representation and feature-based representation, thereby explicitly expresses design semantics as well as the geometry of a product. In addition, this representation has two advantages for supporting design reuse: (1) its explicit hierarchy can be used to facilitate the reuse-oriented segmentation of CAD models; (2) sub-tree matching is easier than sub-graph matching.

                              Definition 2
                              Isolated Node (IN): An isolated node of an extended feature tree is the node of the tree which has no adjacent or intersecting relationship with others. For convenience, a minimal set of nodes of an extended feature tree is also called an isolated node if each node in the node set only has adjacent or intersecting relationships with other nodes in the set. Note that in an extended feature tree, all nodes belonging to an isolated node have the same parent node [9].

Isolated Subtree (IS): An isolated subtree of an extended feature tree is the maximal subtree or the set of maximal subtrees rooted at an isolated node [9].

Isolated Proper Subtree (IPS): An isolated proper subtree of an extended feature tree is an isolated subtree not rooted at the root of the tree [9].

As an example, Fig. 5 shows the extended feature tree of a given 3D CAD model. It can be seen that in an EFT, the root node corresponds to the overall shape of the model and the nodes with different depths correspond to different levels of details of the model’s geometry. Based on the EFT, the extracted isolated nodes are {Primary Feature}, {Close Pocket 1}, {Non-Circular Boss, Circular Boss}, {Blind Hole 1}, {Close Pocket 2} and {Blind Hole 2}. Here, the isolated node {Circular Boss, Non-Circular Boss} is an isolated node set, and both features in this set have the same parent feature “Close Pocket 1” . Rooted as these isolated nodes, the isolated proper subtrees are extracted and highlighted in different colors. It can be seen that every isolated proper subtree in the EFT corresponds to a relatively independent subpart of the model, and the root node reflects the overall shape of the corresponding subpart.

Because the complexity definition in our previous work [9] fails to fully consider the dependency between features, we give a new complexity definition as follows.

                              Definition 5
                              Complexity of a subpart. The complexity of a subpart of a CAD model is a quantitative indicator for evaluating its design complexity, which is determined by the complexities of both its design features and relationships between different design features. Before giving a concrete expression, the complexities of three types of basic sets are first analyzed and defined as follows.


                                    The complexity of the first type of feature set: The first type of feature set, denoted as Si
                                    , is composed of a set of simple design features which are independent of each other, such as the feature set {Blind Hole 1, Blind Hole 2} in Fig. 5. The complexity of the set is determined by the complexity of the most complex design feature in this set; this is because the design procedures for these features are independent of each other. Specifically, the complexity of the first type of feature set is defined as follows.

                                       
                                          (1)
                                          
                                             
                                                
                                                   
                                                   
                                                   
                                                      
                                                         C
                                                         P
                                                         
                                                            (
                                                            
                                                               S
                                                               i
                                                            
                                                            )
                                                         
                                                         =
                                                         
                                                            max
                                                            
                                                               S
                                                               i
                                                            
                                                         
                                                         
                                                            (
                                                            C
                                                            P
                                                            
                                                               (
                                                               μ
                                                               )
                                                            
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                            S
                                                            i
                                                         
                                                         
                                                         is
                                                         
                                                         a
                                                         
                                                         feature
                                                         
                                                         set,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         where
                                                         
                                                         ∀
                                                         μ
                                                         ,
                                                         ν
                                                         ∈
                                                         
                                                            S
                                                            i
                                                         
                                                         ,
                                                         
                                                            R
                                                            d
                                                         
                                                         
                                                            (
                                                            μ
                                                            ,
                                                            ν
                                                            )
                                                         
                                                         =
                                                         0
                                                         ∧
                                                         
                                                            R
                                                            p
                                                         
                                                         
                                                            (
                                                            μ
                                                            ,
                                                            ν
                                                            )
                                                         
                                                         =
                                                         0
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

Here, 
                                    CP(μ) is the complexity of the simple design feature μ, which will be defined later; Rd
                                    (μ, ν) characterizes whether feature μ is dependent on feature ν in the set (including both direct and indirect dependent relationships), and if so, 
                                       
                                          
                                             R
                                             d
                                          
                                          
                                             (
                                             μ
                                             ,
                                             ν
                                             )
                                          
                                          =
                                          1
                                       
                                    ; otherwise 
                                       
                                          
                                             R
                                             d
                                          
                                          
                                             (
                                             μ
                                             ,
                                             ν
                                             )
                                          
                                          =
                                          0
                                       
                                    ; Rp
                                    (μ, ν) characterizes whether feature μ has paralleled relationship with feature ν in the set (including both intersecting relationship and adjacent relationship), and if so, 
                                       
                                          
                                             R
                                             p
                                          
                                          
                                             (
                                             μ
                                             ,
                                             ν
                                             )
                                          
                                          =
                                          1
                                       
                                    ; otherwise 
                                       
                                          
                                             R
                                             p
                                          
                                          
                                             (
                                             μ
                                             ,
                                             ν
                                             )
                                          
                                          =
                                          0
                                       
                                    .


                                    The complexity of the second type of feature set: The second type of feature set, denoted as Sp
                                    , is composed of a set of simple design features which have paralleled relationships with each other, such as the feature set {Circular Boss, Non-Circular Boss} in Fig. 5. The complexity of the set is determined by the complexities of all design features in this set; this is because when designers design this type of feature set, they have to consider not only these features but also their constraint relationships. Specifically, the complexity of the second type of feature set is defined as follows.

                                       
                                          (2)
                                          
                                             
                                                
                                                   
                                                   
                                                   
                                                      
                                                         C
                                                         P
                                                         
                                                            (
                                                            
                                                               S
                                                               p
                                                            
                                                            )
                                                         
                                                         =
                                                         
                                                            ∑
                                                            
                                                               S
                                                               p
                                                            
                                                         
                                                         
                                                            (
                                                            C
                                                            P
                                                            
                                                               (
                                                               μ
                                                               )
                                                            
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                            S
                                                            p
                                                         
                                                         
                                                         is
                                                         
                                                         a
                                                         
                                                         feature
                                                         
                                                         set,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         where
                                                         
                                                         ∀
                                                         μ
                                                         ∈
                                                         
                                                            S
                                                            p
                                                         
                                                         ,
                                                         ∃
                                                         ν
                                                         ∈
                                                         
                                                            S
                                                            p
                                                         
                                                         ,
                                                         
                                                            R
                                                            p
                                                         
                                                         
                                                            (
                                                            μ
                                                            ,
                                                            ν
                                                            )
                                                         
                                                         =
                                                         1
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 


                                    The complexity of the third type of feature set: The third type of feature set, denoted as Sd
                                    , is composed of a set of simple design features, each two features of which have dependent relationship (direct or indirect dependent relationship). The feature set {Close Pocket 1, Blind Hole 1} is this case, while the feature set {Close Pocket 1, Blind Hole 1, Circular Boss} is not this case because both the features “Blind Hole 1” and “Circular Boss” or the features “Circular Boss” and “Blind Hole 1” have no dependent relationship. The complexity of the set is the same as the set of the second type; this is because when designers design this type of feature set, they also have to consider not only these features but also their constraint relationships. Specifically, the complexity of the third type of feature set is defined as follows:

                                       
                                          (3)
                                          
                                             
                                                
                                                   
                                                   
                                                   
                                                      
                                                         C
                                                         P
                                                         
                                                            (
                                                            
                                                               S
                                                               d
                                                            
                                                            )
                                                         
                                                         =
                                                         
                                                            ∑
                                                            
                                                               S
                                                               d
                                                            
                                                         
                                                         
                                                            (
                                                            C
                                                            P
                                                            
                                                               (
                                                               μ
                                                               )
                                                            
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                            S
                                                            d
                                                         
                                                         
                                                         is
                                                         
                                                         a
                                                         
                                                         feature
                                                         
                                                         set,
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         where
                                                         
                                                         ∀
                                                         μ
                                                         ,
                                                         ν
                                                         ∈
                                                         
                                                            S
                                                            d
                                                         
                                                         ,
                                                         
                                                            R
                                                            d
                                                         
                                                         
                                                            (
                                                            μ
                                                            ,
                                                            ν
                                                            )
                                                         
                                                         =
                                                         1
                                                         ∨
                                                         
                                                            R
                                                            d
                                                         
                                                         
                                                            (
                                                            ν
                                                            ,
                                                            μ
                                                            )
                                                         
                                                         =
                                                         1
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

Considering comprehensively the above three types feature sets, we define the complexity of a subpart LR as:

                              
                                 (4)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                C
                                                P
                                                
                                                   (
                                                   L
                                                   R
                                                   )
                                                
                                                =
                                                max
                                                
                                                   (
                                                   
                                                      ∑
                                                      S
                                                   
                                                   
                                                      (
                                                      C
                                                      P
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                S
                                                ⊂
                                                L
                                                R
                                                ∧
                                                S
                                                ⊂
                                                (
                                                
                                                   S
                                                   d
                                                
                                                ∪
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                {
                                                μ
                                                
                                                |
                                                
                                                μ
                                                
                                                is
                                                
                                                a
                                                
                                                feature,
                                                ∃
                                                ν
                                                ∈
                                                
                                                   S
                                                   d
                                                
                                                ,
                                                
                                                   R
                                                   p
                                                
                                                
                                                   (
                                                   μ
                                                   ,
                                                   ν
                                                   )
                                                
                                                =
                                                1
                                                }
                                                )
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In the above formulas, the complexity CP(μ) of a simple design feature μ is defined by the design complexity of μ. As both the combined feature and the pattern feature are composed of several basic features and more complex than a single basic feature, the design complexity of a combined feature or a pattern feature should be larger than the design complexity of a basic feature. Therefore, we define the complexity of a combined feature or a pattern feature using a larger value than that of the complexity of a basic feature. Specifically, in this work, the complexity of a combined feature or a pattern feature is defined as 2, while the complexity of a basic feature is defined as 1.

Calculated based on above formulas, the complexity of the subpart CRR1 shown in Fig. 5 is calculated as follows:

                              
                                 
                                    
                                       
                                          
                                             
                                                C
                                                P
                                                (
                                                L
                                                R
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                max
                                                (
                                                
                                                   ∑
                                                   
                                                      μ
                                                      ∈
                                                      
                                                         S
                                                         n
                                                      
                                                      ,
                                                      1
                                                      <
                                                      n
                                                      ≤
                                                      11
                                                   
                                                
                                                
                                                   (
                                                   
                                                      (
                                                      C
                                                      P
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      μ
                                                      ∈
                                                      
                                                         S
                                                         10
                                                      
                                                   
                                                
                                                
                                                   (
                                                   
                                                      (
                                                      C
                                                      P
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      )
                                                   
                                                   =
                                                   
                                                      ∑
                                                      
                                                         μ
                                                         ∈
                                                         
                                                            S
                                                            11
                                                         
                                                      
                                                   
                                                   (
                                                
                                                
                                                   (
                                                   C
                                                   P
                                                   
                                                      (
                                                      μ
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                (
                                                C
                                                P
                                                (
                                                CP1
                                                )
                                                +
                                                C
                                                P
                                                (
                                                NCB
                                                )
                                                +
                                                C
                                                P
                                                (
                                                CB
                                                )
                                                +
                                                C
                                                P
                                                (
                                                BH2
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             4
                                          
                                       
                                    
                                 
                              
                           Here, “CP”,“NCB”,“CB” and “BH” are the abbreviations of “Close Pocket”,“Non-Circular Boss”,“Circular Boss” and “Blind Hole” respectively; and the feature set S1={Close Pocket 1}, S2={Blind Hole 1}, S3={Close Pocket 2}, S4={Blind Hole 2}, S5={Close Pocket 1, Blind Hole 1}, S6={Circular Boss, Non-Circular Boss }, S7={Close Pocket 1, Non-Circular Boss, Circular Boss }, S8={Circular Boss, Non-Circular Boss, Close Pocket 2}, S9={Circular Boss, Non-Circular Boss, Blind Hole 2}, S10= {Close Pocket 1, Circular Boss, Non-Circular Boss, Close Pocket 2}, S11={Close Pocket 1, Circular Boss, Non-Circular Boss, Blind Hole 2}.

According to the definition, an isolated proper subtree of the extended feature tree of a solid model directly corresponds to a subpart with high cohesion and low coupling. All the features inside the subtree are connected and only dependent on a single feature outside the subtree. Furthermore, any other node set of the model excluding the isolated proper subtrees cannot satisfy the two conditions at the same time. Therefore, we can conclude that a subpart of a design feature-based model is a candidate reusable region if, and only if, the subpart corresponds to an isolated proper subtree of the extended feature tree of the model.

Based on the analysis above, given the extended feature tree of a solid model, we can extract all the candidate reusable regions of the model by determining all the isolated proper subtrees of the extended feature tree using the isolated subtree extraction algorithm. Specifically, the algorithm contains the following steps:


                           Step 1: Determine the subtree of the extended feature tree rooted at each node in the isolated node, denoted as {ST
                           1, ST
                           2, ..., STn
                           }, where n is the number of the nodes in the isolated node;


                           Step 2: Merge all subtrees from ST
                           1 to STn
                            into a larger subtree using the adjacent or intersecting relationships between them. The larger subtree is the isolated subtree of the given isolated node.

Here, in order to facilitate comprehension, we take a simple solid model shown in Fig. 5 as an example and extract its reusable regions according to the above method. Here, the five candidate reusable regions from CRR1 to CRR5 are extracted, and it can be seen that all the candidate reusable regions are relatively independent and easily migrated for design reuse. However, some of them such as CRR3, CRR4 and CRR5, are too simple to be worthy of reuse. Accordingly, they are to be removed from reusable regions in the next step.

After candidate reusable regions are extracted from a solid model, the final reusable regions can be obtained by selecting those relatively complex subparts from them. According to the definition of the complexity, we can easily evaluate the design complexity of each candidate reusable region by using formula (4).

Among the candidate reusable regions shown in Fig. 4, after performing a complexity evaluation with 3 as a threshold, only CRR1 and CRR2 are determined as the final reusable regions of the model. CRR3, CRR4 and CRR5 are excluded because they are too simple.

Having extracted all the reusable regions of solid models by using the algorithm above, in this subsection, we discuss how to cluster the reusable regions so as to effectively support efficient design pattern extraction.

In general, the clustering algorithms are designed for feature vectors. Thus it is difficult to cluster graph features such as extended feature trees. For solving this problem, we present a graph feature oriented clustering algorithm, i.e. a graph-oriented agglomerative hierarchical clustering algorithm. Specifically, the input of the algorithm is a distance matrix. Therefore, we will introduce below how to calculate the distance matrix of a set of reusable regions.

Given a reusable region, we directly take the corresponding extended feature subtree as its descriptor. In order to achieve high accuracy in geometric perspective for representing the region, for each node in the tree, besides its “feature type” and “paralleled relationships”, two major geometric attributes of its corresponding features are also stored in the node, including “feature size” and “face number”. Here, the attribute “feature size” characterizes the geometry scale of a feature, which is measured by the volume of the corresponding feature’s bounding box; while the attribute “face number” reflects the shape complexity of the corresponding feature to a certain extent, which is measured by the face number of the corresponding feature.

Having obtained the descriptor for every reusable region, the distance matrix of these reusable regions can be calculated as follows.


                           Step 1: Calculate the distance between every two reusable regions.

Let the descriptor of the two reusable regions be tree Q(NQ, EQ, RQ
                           ) and tree T(NT, ET, RT
                           ), where N is the node set, E is the edge set and R is the root. The distance between the two regions is in essence equivalent to the distance between the tree Q and the tree T.


                           Step 1-1: Judge whether tree Q can be embedded in the tree T or tree T can be embedded in the tree Q according to the algorithm described in [35]. If it can, calculate the distance between them; otherwise, the algorithm is finished and output “does not match”.


                           Step 1-2: Extract the roots of the tree Q and the tree T, find out the optimal matching scheme between them according to optimal bipartite graph algorithm [36], and put the optimal matching scheme in the stack Sm
                           . Here, the optimal matching scheme is the scheme with minimal distance between two given nodes. Given two nodes μ, f(μ) in the scheme, the distance between them is determined by the following three parts: the paralleled relationships, the feature types and the geometric attributes of the two nodes, and the distance is defined as follows:

                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                D
                                                (
                                                μ
                                                ,
                                                f
                                                (
                                                μ
                                                )
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                1
                                                −
                                                (
                                                
                                                   ω
                                                   r
                                                
                                                *
                                                
                                                   
                                                      
                                                         N
                                                         s
                                                      
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      ∧
                                                      
                                                         N
                                                         s
                                                      
                                                      
                                                         (
                                                         f
                                                         
                                                            (
                                                            μ
                                                            )
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         N
                                                         s
                                                      
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      ∨
                                                      
                                                         N
                                                         s
                                                      
                                                      
                                                         (
                                                         f
                                                         
                                                            (
                                                            μ
                                                            )
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                +
                                                
                                                
                                                   ω
                                                   n
                                                
                                                *
                                                
                                                   S
                                                   t
                                                
                                                
                                                   (
                                                   μ
                                                   ,
                                                   f
                                                   
                                                      (
                                                      μ
                                                      )
                                                   
                                                   )
                                                
                                                *
                                                
                                                   S
                                                   g
                                                
                                                
                                                   
                                                      (
                                                      μ
                                                      ,
                                                      f
                                                      
                                                         (
                                                         μ
                                                         )
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here, Ns
                           (μ) and Ns
                           (f(μ)) are the paralleled relationship numbers of nodes μ and f(μ), respectively; ∧ is inner product, Ns
                           (μ) ∧ Ns
                           (f(μ)) is the matched paralleled relationships number of nodes μ and f(μ); ∨ is outer product, Ns
                           (μ) ∨ Ns
                           (f(μ)) is the maximal number of Ns
                           (μ) and Ns
                           (f(μ)); St
                           (μ, f(μ)) is the similarity between their feature types; Sg
                           (μ, f(μ)) is the similarity between their geometric attributes; ωr
                            and ωn
                            are weights devised to meet the requirements of different applications with 
                              
                                 
                                    ω
                                    r
                                 
                                 +
                                 
                                    ω
                                    n
                                 
                                 =
                                 1
                              
                           . Considering comprehensively the two kinds of geometric attributes of every node, the geometric similarity Sg
                           (μ, f(μ)) is defined as follows:

                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   S
                                                   g
                                                
                                                
                                                   (
                                                   μ
                                                   ,
                                                   f
                                                   
                                                      (
                                                      μ
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                1
                                                −
                                                α
                                                
                                                   
                                                      |
                                                      s
                                                      i
                                                      z
                                                      e
                                                      (
                                                      μ
                                                      )
                                                      −
                                                      s
                                                      i
                                                      z
                                                      e
                                                      (
                                                      f
                                                      (
                                                      μ
                                                      )
                                                      )
                                                      |
                                                   
                                                   
                                                      m
                                                      a
                                                      x
                                                      (
                                                      s
                                                      i
                                                      z
                                                      e
                                                      (
                                                      μ
                                                      )
                                                      ,
                                                      s
                                                      i
                                                      z
                                                      e
                                                      (
                                                      f
                                                      (
                                                      μ
                                                      )
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                −
                                                
                                                β
                                                
                                                   
                                                      |
                                                      f
                                                      N
                                                      u
                                                      m
                                                      (
                                                      μ
                                                      )
                                                      −
                                                      f
                                                      N
                                                      u
                                                      m
                                                      (
                                                      f
                                                      (
                                                      μ
                                                      )
                                                      )
                                                      |
                                                   
                                                   
                                                      m
                                                      a
                                                      x
                                                      (
                                                      f
                                                      N
                                                      u
                                                      m
                                                      (
                                                      μ
                                                      )
                                                      ,
                                                      f
                                                      N
                                                      u
                                                      m
                                                      (
                                                      f
                                                      (
                                                      μ
                                                      )
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here, the second item is used to calculate the distance between two nodes’ sizes; the third item is used to calculate the distance between two nodes’ face numbers; the weights α and β are devised to meet the requirements of different applications.


                           Step 1-3: If Sm
                            is not empty: firstly, pop the matched node set (ν, ν′) off the stack Sm
                           , and add the set into the queue Lfm
                           ; then extract their child node sets and find out the optimal matching scheme between them according to optimal bipartite graph algorithm; finally, put all matched nodes into the stack Sm
                           . Check the state of Sm
                           : if the Sm
                            is not empty, return to the beginning of the Step 1-3; otherwise, the algorithm has concluded and the queue Lfm
                            records the final matching scheme f, thereby calculating the distance between the tree Q and the tree T as follows:

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                D
                                                
                                                   (
                                                   Q
                                                   ,
                                                   T
                                                   )
                                                
                                                =
                                                D
                                                
                                                   (
                                                   f
                                                   )
                                                
                                                =
                                                
                                                   ∑
                                                   
                                                      (
                                                      μ
                                                      ,
                                                      f
                                                      (
                                                      μ
                                                      )
                                                      )
                                                      ∈
                                                      f
                                                   
                                                
                                                
                                                   ω
                                                   μ
                                                
                                                *
                                                D
                                                
                                                   (
                                                   μ
                                                   ,
                                                   f
                                                   
                                                      (
                                                      μ
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here, ωμ
                            is the weight set to node pair (μ, f(μ)) and can be devised to meet different requirements with 
                              
                                 
                                    ∑
                                    μ
                                 
                                 
                                    ω
                                    μ
                                 
                                 =
                                 1
                              
                           .

In theory, the above algorithm cannot guarantee to obtain the optimal matching scheme between the tree Q and the tree T, but since the nodes of an upper layer are always much more important than the nodes of a lower layer in an extended feature tree, it is often the case that the matching scheme obtained by this algorithm is exactly the optimal matching scheme; meanwhile, this top-down algorithm can avoid time-cost caused by exhaustion search and significantly improve matching efficiency.


                           Step 2: Construct the distance matrix of a set of reusable regions.

Now, given a set of reusable regions 
                              
                                 S
                                 G
                                 =
                                 
                                    {
                                    
                                       G
                                       i
                                    
                                    ,
                                    1
                                    ≤
                                    i
                                    ≤
                                    n
                                    }
                                 
                                 ,
                                 ∀
                                 
                                    G
                                    i
                                 
                                 ∈
                                 S
                                 G
                                 ,
                                 
                                    G
                                    j
                                 
                                 ∈
                                 S
                                 G
                                 ,
                              
                            their distance Dij
                            can be calculated according to formula (7), and the final distance matrix of the reusable region set is

                              
                                 
                                    
                                       D
                                       =
                                       
                                          [
                                          
                                             
                                                
                                                   
                                                      D
                                                      11
                                                   
                                                
                                                
                                                   
                                                      D
                                                      12
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         1
                                                         n
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      D
                                                      21
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         2
                                                         n
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                             
                                             
                                                
                                                   
                                                      D
                                                      
                                                         n
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      D
                                                      
                                                         n
                                                         2
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         n
                                                         n
                                                      
                                                   
                                                
                                             
                                          
                                          ]
                                       
                                       .
                                    
                                 
                              
                           
                        

Given a set of reusable region 
                              
                                 S
                                 G
                                 =
                                 {
                                 
                                    G
                                    i
                                 
                                 ,
                                 1
                                 ≤
                                 i
                                 ≤
                                 n
                                 }
                              
                            and their distance matrix, let the ith class (cluster), merged in the kth cluster be 
                              
                                 
                                    C
                                    
                                       i
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 ,
                              
                            and 
                              
                                 S
                                 
                                    C
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       C
                                       
                                          i
                                       
                                       
                                          (
                                          k
                                          )
                                       
                                    
                                    ,
                                    1
                                    ≤
                                    i
                                    ≤
                                    m
                                    )
                                 
                                 
                                    }
                                 
                              
                            be the clustering collection after the kth cluster, which has m clusters.

The basic idea of G-AHC is consistent with the general agglomerative hierarchical clustering algorithm, which has the following steps:


                           Step 1: Initial classification. Let 
                              
                                 k
                                 =
                                 0
                              
                            and 
                              
                                 m
                                 =
                                 n
                                 ,
                              
                            where m is the number of classes. Moreover, make each instance as a separate class, i.e. 
                              
                                 
                                    C
                                    
                                       i
                                    
                                    
                                       (
                                       0
                                       )
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       G
                                       i
                                    
                                    ,
                                    1
                                    ≤
                                    i
                                    ≤
                                    m
                                    )
                                 
                                 
                                    }
                                 
                              
                           .


                           Step 2: Calculate the distance between different classes and construct the distance matrix

                              
                                 
                                    
                                       
                                          D
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       =
                                       
                                          [
                                          
                                             
                                                
                                                   
                                                      D
                                                      
                                                         11
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      D
                                                      
                                                         12
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         1
                                                         m
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      D
                                                      
                                                         21
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         2
                                                         m
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   ⋯
                                                
                                             
                                             
                                                
                                                   
                                                      D
                                                      
                                                         m
                                                         1
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      D
                                                      
                                                         m
                                                         2
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      D
                                                      
                                                         m
                                                         m
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                          ]
                                       
                                       .
                                    
                                 
                              
                           
                        


                           Step 3: Search for the pair of classes with minimal distance in the distance matrix and merge them into a new class, thereby forming a new clustering collection. At this point, set 
                              
                                 k
                                 =
                                 k
                                 +
                                 1
                                 ,
                                 m
                                 =
                                 m
                                 −
                                 1
                                 ,
                              
                            then update 
                              
                                 S
                                 
                                    C
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       C
                                       
                                          i
                                       
                                       
                                          (
                                          k
                                          )
                                       
                                    
                                    ,
                                    1
                                    ≤
                                    i
                                    ≤
                                    m
                                    )
                                 
                                 
                                    }
                                 
                              
                           .


                           Step 4: Check the termination condition and if the termination condition is reached, output the clustering results; otherwise, return to Step 2.

Here, the distance of two clusters is necessary for the above algorithm, which is easy to calculate for vector features but difficult for graph features. In this work, the distance of two clusters is defined based on the central instance of a cluster. Supposing the cluster 
                              
                                 C
                                 
                                    o
                                 
                                 k
                              
                            has l instances 
                              
                                 {
                                 
                                    G
                                    
                                       o
                                       1
                                    
                                    k
                                 
                                 ,
                                 
                                    G
                                    
                                       o
                                       2
                                    
                                    k
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    G
                                    
                                       o
                                       l
                                    
                                    k
                                 
                                 }
                              
                            and Dij
                            is the distance between the instances of 
                              
                                 
                                    G
                                    
                                       o
                                       i
                                    
                                    k
                                 
                                 
                                 and
                                 
                                 
                                    G
                                    
                                       o
                                       j
                                    
                                    k
                                 
                                 ,
                              
                            the central instance 
                              
                                 S
                                 
                                    o
                                 
                                 
                                    (
                                    k
                                    )
                                 
                              
                            of the cluster 
                              
                                 C
                                 
                                    o
                                 
                                 k
                              
                            is defined as follows:

                              
                                 (8)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                
                                                   S
                                                   
                                                      o
                                                   
                                                   
                                                      (
                                                      k
                                                      )
                                                   
                                                
                                                =
                                                
                                                   G
                                                   
                                                      o
                                                      a
                                                   
                                                   
                                                      (
                                                      k
                                                      )
                                                   
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                if
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   l
                                                
                                                
                                                   D
                                                   
                                                      a
                                                      j
                                                   
                                                   k
                                                
                                                ≤
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   l
                                                
                                                
                                                   D
                                                   
                                                      b
                                                      j
                                                   
                                                   k
                                                
                                                ,
                                                ∀
                                                b
                                                ≠
                                                a
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Thus, given two clusters 
                              
                                 
                                    C
                                    
                                       i
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 
                                 and
                                 
                                 
                                    C
                                    
                                       j
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 ,
                              
                            if their central instances are 
                              
                                 
                                    S
                                    
                                       i
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 
                                 and
                                 
                                 
                                    S
                                    
                                       j
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                              
                            respectively, then the distance between the clusters is defined as follows:

                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   D
                                                   
                                                      i
                                                      j
                                                   
                                                   k
                                                
                                                =
                                                D
                                                
                                                   (
                                                   
                                                      S
                                                      
                                                         i
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                   ,
                                                   
                                                      S
                                                      
                                                         j
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here, 
                              
                                 D
                                 (
                                 
                                    S
                                    
                                       i
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 ,
                                 
                                    S
                                    
                                       j
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 )
                              
                            is the distance measure between two trees defined in formula (7).

Careful analysis shows that the above clustering algorithm does not have any constraints with the features and is less susceptible to noise and outliers, thereby having good robustness.

It is worth noting that when a cluster contains only two instances, we cannot obtain its central instance. For this particular case, the distance between two clusters can be calculated based on the average chain. Specifically, given two clusters 
                              
                                 
                                    C
                                    
                                       i
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 
                                 and
                                 
                                 
                                    C
                                    
                                       j
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 ,
                              
                            if both of them just have two instances, the distance between them is defined as follows:

                              
                                 (10)
                                 
                                    
                                       
                                          D
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                       =
                                       
                                          1
                                          4
                                       
                                       
                                          ∑
                                          
                                             a
                                             =
                                             1
                                          
                                          2
                                       
                                       
                                          ∑
                                          
                                             b
                                             =
                                             1
                                          
                                          2
                                       
                                       d
                                       
                                          (
                                          
                                             G
                                             
                                                i
                                                a
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                          
                                          ,
                                          
                                             G
                                             
                                                j
                                                b
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                          
                                          )
                                       
                                       ,
                                       
                                          G
                                          
                                             i
                                             a
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       ∈
                                       
                                          C
                                          
                                             i
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       ,
                                       
                                          G
                                          
                                             j
                                             b
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       ∈
                                       
                                          C
                                          
                                             j
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

Otherwise, for the given two clusters, if only one cluster has two instances, let this cluster be 
                              
                                 C
                                 
                                    i
                                 
                                 
                                    (
                                    k
                                    )
                                 
                              
                            and let the central instance of another cluster be 
                              
                                 
                                    S
                                    
                                       j
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 
                                 ,
                              
                            then the distance between them is defined as follows:

                              
                                 (11)
                                 
                                    
                                       
                                          D
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                       =
                                       
                                          1
                                          2
                                       
                                       
                                          ∑
                                          
                                             a
                                             =
                                             1
                                          
                                          2
                                       
                                       d
                                       
                                          (
                                          
                                             G
                                             
                                                i
                                                a
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                          
                                          ,
                                          
                                             S
                                             
                                                j
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                          
                                          )
                                       
                                       ,
                                       
                                          G
                                          
                                             i
                                             a
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       ∈
                                       
                                          C
                                          
                                             i
                                          
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

Termination condition is another key factor affecting G-AHC clustering results. Let S be the central instance of the cluster C, we define the dissimilarity function of instances in cluster C as H(C). Set θH
                            is a reasonable threshold of H(C), and if the following condition is satisfied, the algorithm is ended:

                              
                                 (12)
                                 
                                    
                                       
                                          
                                             
                                                H
                                                (
                                                C
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                max
                                                
                                                   (
                                                   d
                                                   
                                                      (
                                                      
                                                         G
                                                         i
                                                      
                                                      ,
                                                      S
                                                      )
                                                   
                                                   )
                                                
                                                ,
                                                
                                                   G
                                                   i
                                                
                                                ∈
                                                C
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                ∃
                                                
                                                   C
                                                   
                                                      i
                                                   
                                                   
                                                      (
                                                      k
                                                      )
                                                   
                                                
                                                ∈
                                                S
                                                
                                                   C
                                                   
                                                      (
                                                      k
                                                      )
                                                   
                                                
                                                :
                                                H
                                                
                                                   (
                                                   
                                                      C
                                                      
                                                         i
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                   
                                                   )
                                                
                                                >
                                                
                                                   θ
                                                   H
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here, the threshold θH
                            can be set by users for diverse requirements.

Having obtained the clusters of a set of reusable regions, the candidate design patterns are exactly these clusters, and we denote them as 
                              
                                 S
                                 C
                                 D
                                 P
                                 =
                                 {
                                 C
                                 D
                                 
                                    P
                                    i
                                 
                                 ,
                                 1
                                 ≦
                                 i
                                 ≦
                                 m
                                 }
                                 ,
                                 m
                                 
                                 is
                                 
                                 the
                                 
                                 number
                                 
                                 of
                                 
                                 clusters
                              
                           .

Given a set of CAD models 
                           
                              S
                              M
                              =
                              {
                              
                                 M
                                 1
                              
                              ,
                              
                                 M
                                 2
                              
                              ,
                              ⋯
                              ,
                              
                                 M
                                 n
                              
                              }
                           
                         and their candidate design patterns 
                           
                              S
                              C
                              D
                              P
                              =
                              {
                              C
                              D
                              
                                 P
                                 1
                              
                              ,
                              C
                              D
                              
                                 P
                                 2
                              
                              ,
                              ⋯
                              ,
                              C
                              D
                              
                                 P
                                 m
                              
                              }
                              ,
                           
                         the final design patterns can be obtained by evaluating two key indicators: the frequency “F” and the amount of information “I”. Specifically, we define the CDPi
                         as a design pattern if it satisfies the following two conditions.

                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             F
                                             
                                                (
                                                C
                                                D
                                                
                                                   P
                                                   i
                                                
                                                )
                                             
                                             =
                                             
                                                |
                                                C
                                                D
                                                
                                                   P
                                                   i
                                                
                                                |
                                             
                                             >
                                             
                                                θ
                                                F
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             I
                                             
                                                (
                                                C
                                                D
                                                
                                                   P
                                                   i
                                                
                                                )
                                             
                                             =
                                             −
                                             
                                                log
                                                2
                                             
                                             
                                                (
                                                
                                                   P
                                                   i
                                                
                                                )
                                             
                                             >
                                             
                                                θ
                                                I
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                             
                                                P
                                                i
                                             
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   
                                                      (
                                                      φ
                                                      
                                                         (
                                                         C
                                                         D
                                                         
                                                            P
                                                            i
                                                         
                                                         ,
                                                         
                                                            M
                                                            j
                                                         
                                                         )
                                                      
                                                      )
                                                   
                                                
                                                n
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             φ
                                             
                                                (
                                                C
                                                D
                                                
                                                   P
                                                   i
                                                
                                                ,
                                                
                                                   M
                                                   j
                                                
                                                )
                                             
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            
                                                            if
                                                            
                                                            any
                                                            
                                                            region
                                                            
                                                            in
                                                            
                                                            C
                                                            D
                                                            
                                                               P
                                                               i
                                                            
                                                            
                                                            exists
                                                            
                                                            in
                                                            
                                                            
                                                               M
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         
                                                            
                                                            otherwise
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

From formula (13), we can find that the larger the value of F(CDPi
                        ), the higher the frequency of the CDPi
                        , which means the design pattern is highly repeated in this set of 3D CAD models. We also can find from formula (14) that if a candidate design pattern exists in almost every model, it has little information; otherwise, it has much information. It is very easy to understand that if designers can find out one candidate design pattern in almost every 3D CAD model, it is meaningless for the designers to spend time on extracting and reusing this candidate design pattern, or vice versa. Substituting every CDP into formulas (13) and (14), those CDPs with high frequency and enough information are determined as the final design patterns.

As Burgess et al. pointed out in [37], to facilitate design reuse, three types of information are identified as essential: obtaining the component, what to use and where to use the component. Although this paper focuses on obtaining the component, we will still simply discuss the later two problems in this section.

                           
                              •
                              What to use: In this paper, we assume that all CAD models in the library are design feature-based CAD models and we also extract the design patterns based on the feature-based CAD models. Here, the design feature-based CAD model explicitly expresses design semantics besides the geometry of a product. In the process of extracting the design patterns, all key techniques such as reusable regions extraction, clustering, are based on the feature-based CAD models. Although the assessment of the clustering is partly based on shape, it also implies other product information, such as function, because function is shape-related. Therefore, not only design patterns but also the related information can be reused. Because the identification of functions is very complex [38], currently, in this work, we provide a user interface to experts so that they can add corresponding functions and application fields to the extracted design patterns. In the future, ontology modeling for design patterns should be addressed to make design patterns having more rich semantics so that more valuable information can be reused.

Where to use: The range of situations in which a design pattern can be used is called its context. As a solution to a given problem in a context, design patterns having different contexts should be distinguished. In this work, the context is mainly influenced by the interactive form between design instances and their depending features, such that the design instance having a flat contact surface with its depending feature is easily reused by another feature with a flat contact surface but difficult to be reused by a feature with a curved contact surface. Therefore, according to types of the contact surface between the design instance and its dependent feature, we further divide design instances of each design pattern into three different sets: set I, design instances depending on one flat contact surface; set II, design instances depending on one curved contact surface; set III, design instances depending on more than one contact surface. Consequently, design patterns with different contexts are distinguished and thereby easily support reuse.

The proposed design pattern extraction approach has been developed on the platforms of Visual C++ and Solid Modeler ACIS in this research. The UI module (Fig. 6) is developed by using MFC and HOOPS 11.0, the core module mainly includes design pattern extraction, model and pattern management and retrieval based on design patterns, and the database management module is implemented by using MySQL5.0. Currently, 438 design feature-based CAD models are stored to test the algorithms. All these models are converted from B-rep models by interactively defining simple design features involved in the B-rep model and automatically recognizing the relationships between them. Fig. 7
                         shows a portion of the models in the library.

As mentioned above, distance matrix is the input of G-AHC to constructing candidate design patterns, and thus different distance calculation can generate different design patterns. In this work, we extract the design patterns in a multi-layer hierarchical structure: the first layer design patterns are determined just by feature structures, while the second layer design patterns are determined by both feature structures and geometry attributes. Here, 
                           
                              
                                 ω
                                 r
                              
                              =
                              0.4
                              ,
                              
                                 ω
                                 n
                              
                              =
                              0.6
                              ,
                              
                                 S
                                 t
                              
                              
                                 (
                                 μ
                                 ,
                                 f
                                 
                                    (
                                    μ
                                    )
                                 
                                 )
                              
                           
                         is set to 1 if the fine feature types of the two nodes are the same; otherwise, St
                        (μ, f(μ)) is set to 0.5; ωμ
                         is set to 0.6, 0.25, and 0.15 when the node u is in the 1st, 2nd, and 3rd layer of a tree respectively and is set to 0 for other layer. Moreover, the conditions for determining a design patterns are: 
                           
                              C
                              P
                              ≥
                              3
                              ,
                              
                                 θ
                                 H
                              
                              =
                              0.3
                              ,
                              
                                 θ
                                 F
                              
                              =
                              3
                              ,
                              
                                 θ
                                 I
                              
                              =
                              4
                           
                        . In addition, for the first layer design patterns, 
                           
                              α
                              =
                              0
                              ,
                              β
                              =
                              0
                           
                        ; for the second layer design patterns, 
                           
                              α
                              =
                              0.5
                              ,
                              β
                              =
                              0.5
                           
                        .

@&#EXPERIMENTS@&#

Using the prototype system developed, we have conducted several experiments to validate our design patterns extraction approach.

Some test results are shown in Fig. 8
                           . Obviously, all the design instances of extracted design patterns satisfy the conditions of the good design pattern: high cohesion, low coupling, moderate complexity, certain repetition rate, and rich information. All these properties guarantee that the extracted design patterns have the reusability, scalability, maintainability, comprehensibility and portability.

It can also be seen from the results in Fig. 8 that the design instances of the same coarse design pattern have the same feature structures but they may have different geometries, while the design instances of the same fine design pattern often have both the same feature structures and similar geometries. We can also see that some design instances of the same fine design pattern look dissimilar. This is because only “feature size” and “face number” are considered in this work and they are too rough to distinguish more details in geometry.

According to definition, the design pattern is a solution which can be repeated millions of times, but its specific form can be different. Fig. 9
                            shows the design pattern details that demonstrate this characteristic of the proposed approach. Obviously, based on the extended feature trees, those design instances with same rough design feature structures but different detailed feature design structures (those design features are in the fourth or more deep layers) can be classified into the same design pattern, which exactly demonstrate the above characteristic of design pattern.

In addition, using the extended feature tree as descriptors, directed association enables design patterns to have the characteristic of distinguishing their contexts to some extent. Fig. 10
                            shows the details of two similar design instances with different interaction with their parent feature, so they are classified into different design patterns.

The goal of this experiment is to test the functions of the extracted design patterns. Based on the test results shown in Fig. 8, we invited an expert in the field of mechanical engineering to add corresponding functions for the six extracted design patterns. The expert pointed out that the design patterns (a), (d) and (f) are rib reinforcements, while the design patterns (b) and (c) are plate connectors, while the design pattern (e) cannot correspond to any function. From these experiments we can find that most extracted design patterns can directly correspond to specific functions so that they can be easily reused for designers, while some design patterns can not correspond to any specific functions due to the complexity of design functions.

In this experiment, the extracted design patterns in Fig. 8 are further divided into three different sets according to the contexts. Table 2
                            shows the final results. It can be seen that most design instances of a design pattern have the same contexts, such as design patterns (a), (d), (e) and (f). For the design pattern (b), some of the design instances have flat contact surfaces with the depending features, each of which is easily reused to another feature with a flat contact surface but difficult to be reused to a feature with a curved contact surface, and vice versa. For the design instance c-4, which depends on more than one contact surface, it is obvious that it is difficult to be directly reused to another feature with only one contact surface, and vice versa. It can be concluded that the further distinction of design patterns according to their contexts is meaningful.

For a comprehensive analysis of the proposed approach, Table 3
                            gives some statistics of the prototype system. It can be seen that there are 438 3D CAD models, and we extracted 608 reusable regions and 56 CDPs from these models. After filtering by the frequency “F”, only 36 CDPs are left; and after filtering by the amount of information “I”, 36 CPDs are left; finally, 36 design patterns are extracted in this experiment. Fig. 11
                            shows two examples of the discarded CDPs based on “F”. Both of the two CDPs only have one instance, and they do not satisfy the “repeating” requirement, thus they are filtered out. In addition, there are no CDPs filtered out by the indicator “I”. By careful analysis we find that the 3D CAD models used in this experiment are downloaded from multiple online CAD model repositories, and they are so unsystematic that no design patterns can have a significant number of instances, thus no candidate design patterns can be filtered out by the indicator “I”. For a specific field or a specific enterprise, it is not the case, and the indicator “I” is useful for them.

For our approach, the clustering algorithm is the dominant factor affecting its efficiency for extracting design patterns. In theory, the time complexity of the G-AHC algorithm is O(n
                           3). For further validation, we have constructed an experiment shown in Fig. 12
                           . It can be seen that the clustering time is gradually increasing with the increase of models’ number, but the time growth is less than O(n
                           3) with the models’ scale in practice. Overall, for a database with 1500 models, the clustering time is less than 10 s; while when the scale of the database increased to 10,000, the clustering time is about 10 m, which is still in an acceptable range for an offline operation.

The last experiment was conducted to demonstrate the possibility to effectively design a model from a high level perspective based on the design patterns. In this application case, a user wanted to design a “chassis socket flange” for electrical engineering field, and he/she has figured out the function and application field. As illustrated in Fig. 13
                           (a), related design patterns are directly obtained as soon as the user inputs the query “connector and electrical engineering”, thus the user can browse these connectors and look over the design instances of interested design patterns. Fig. 13(b) shows the reuse-based design process. Because all design instances correspond to independent functional regions, once some design instances satisfy design requirements, based on synchronous modeling technology, the designer can reuse these design instances conveniently. Obviously, based on design patterns, user can retrieve and reuse existing designs through some functional or application field information in the early design stage so as to help them construct design ideation and complete conceptual design; Meanwhile, they enable designers to reuse the existing mature designs so as to benefit from the experiences of others and avoid designing from the ground up.

@&#DISCUSSION@&#

The proposed design patterns can help designers inspire their design ideation and enable them reuse existing mature design so as to improve design quality and efficiency. Nonetheless, there are still several issues about the design patterns and their extraction that need to be discussed here:

                           
                              (1)
                              Design patterns extraction is based on the input of “extended feature tree”, which is proposed in our previous work [9] and has been proved to be effective. Having extracted design patterns, their reuse is based on the history-free modeling technology, such as synchronous modeling technology of Siemens PLM software and direct modeling technology of PTC and so on. All these history-free modeling technologies can support design reuse between different CAD modeling system, and thus they can support design reuse of partial regions to some extent. However, limiting to current synchronous modeling technology and insufficient CAD models, the experiments of design patterns extraction and reuse look unpractical. However, with the developing of history-free modeling technology, the design patterns might be a good solution to future design.

In the software engineering field, design pattern enables designers to design from a high level perspective so as to liberate themselves from the early details, to reuse existing mature designs, and to establish generic terms for collaborative design. We also expect to introduce design pattern into the mechanical CAD field so as to solve similar problems in this field. However, in this paper, we focus on design reuse. Currently, by retrieving and reusing the design patterns and their design instances, the extracted design patterns can be used to inspire designers in a high perspective and support design reuse. However, for communicating designs with different specialists, the design patterns extraction is just a foundation. To address this issue, further research such as terms definition and semantic annotation might be necessary.

In this paper, the design pattern is introduced into the CAD field, a specific analysis and model for the design pattern are presented and an effective approach is proposed for extracting the design patterns from a 3D CAD model library. The analysis for design patterns reveals that a good design patterns should have five specific characteristics and thus satisfy six conditions: composed of simple design features, of high cohesion, low coupling, moderate complexity, high repetition rate and rich information. Moreover, a platform-independent design pattern model is constructed based on CPM. A multi-phases design pattern extraction approach is proposed: in the first phase, a reusable region extraction algorithm is used to extract reusable regions which have high cohesion, low coupling and moderate complexity; in the second phase, a G-AHC clustering algorithm is used to cluster the reusable regions into different classes so that similar reusable regions are in the same classes and dissimilar reusable regions are in the different classes, and every class forms a candidate design pattern; in the last phase, a filtering algorithm based on two indicators for frequency and amount of information is introduced to determine the final design patterns, which guarantees the extracted design patterns satisfy the proposed six conditions at the same time. Finally, a prototype system is developed to verify our design pattern extraction approach, which shows good performance and efficiency. Meanwhile, the successful application of design patterns in other areas demonstrates a promising future for it.

In the future, several works could be done to improve the design pattern extraction approach presented in this paper:

                        
                           •
                           The design instances of the same design patterns in Section 5 show that there are still some occasional models inconsistent in geometry. To further improve the precision, more effective geometry attributes should be carefully considered, and the similarity calculation should be carefully modified.

The current design pattern extraction approach does not consider the reusable subparts corresponding to the overall shape of the models, which also should correspond to design patterns. Therefore, further research should be put into finding a supplementary way so as to add this kind of subparts into design patterns.

Ontology modeling for design patterns should be addressed to make design patterns have rich semantics.

@&#ACKNOWLEDGMENTS@&#

We thank the anonymous reviewers for their constructive comments. This work was partially supported by grants from the National Natural Science Foundation of China (Project no. 61163016 and Project no. 61502129), the University Science Foundation of Ningxia Province of China (Project no. NGY2015161), and the Natural Science Foundation of Zhejiang Province of China (Project no. LQ16F020004).

@&#REFERENCES@&#

