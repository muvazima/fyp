@&#MAIN-TITLE@&#Generative and accumulative recursion made fun for beginners

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Teaching generative and accumulative recursion to beginners is effective and fun.


                        
                        
                           
                           Beginners learn depth-first, breadth-first, and heuristic-based searching.


                        
                        
                           
                           Functional video games motivate students to learn principles of Computer Science.


                        
                        
                           
                           Functional video games help close the Computer Science gender gap.


                        
                        
                           
                           Beginners are introduced to the perils and benefits of randomness.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Generative recursion

Accumulative recursion

Functional video games

Heuristic search strategies

Computer Science education

@&#ABSTRACT@&#


               
               
                  In a programming classroom for beginners, a delicate balance must be struck between teaching the design, implementation, and testing fundamentals of programming and the need for students to find their first programming course enjoyable. A course that focuses solely on the fundamentals is not likely to nourish the excitement a student may have for Computer Science. A course that focuses solely in making programming fun is not likely to have students walk away with a solid grasp of the fundamentals. A very successful approach to strike this balance uses functional video games to motivate the need to learn principles of program design and Computer Science in a context that is of interest and fun for most students. Such an approach has successfully engaged students to learn design and implementation principles using primitive data, finite compound data, structural recursion for compound data of arbitrary size, and abstraction. This article explores how to use a functional video game approach to engage beginning students in problem solving that employs generative and accumulative recursion while at the same time reinforcing the lessons on structural recursion and abstraction. In addition to these two new forms of recursion, beginning students are also introduced to depth-first searching, breadth-first searching, heuristic-based searching, and the use of randomness. The article uses the N-puzzle problem to illustrate how all these topics are seamlessly addressed in the beginner׳s classroom while keeping student enthusiasm high as evidenced by student feedback.
               
            

@&#INTRODUCTION@&#

To a programming course for beginners, Computer Science students usually come with a great deal of enthusiasm. Their minds are imagining the creation of video games, chat tools, graphics, and other applications that are part of popular culture. This enthusiasm ought to be nurtured to motivate the principles of the discipline the students are entering and to avoid the development of apathy for material that appears irrelevant to their creative desires. In other words, student enthusiasm can be harnessed to learn programming and Computer Science principles by applying said principles to the development of applications that capture a student׳s imagination and that allow for a student׳s creativity to make a contribution. The key to success then becomes striking the right balance between learning principles and using them in a fun context for the students. One approach to striking this balance is to use the development of a video game to motivate the principles students need to learn.

Based on the teaching philosophy of program by design (PBD) put forth in the textbook How to Design Programs (HtDP) [6], the development of functional video games has proven to be an effective medium through which to engage students in learning while harnessing their enthusiasm and creativity [2,5,13–15]. At the heart of HtDP methodology is the design recipe—a series of steps that take you from a problem statement to a working solution. To provide support for beginners, PLT׳s DrRacket [7] integrates a hierarchy of student languages for use in conjunction with HtDP.
                        1
                     
                     
                        1
                        The reader should note that students in the course considered in this article are not taught Racket, but do learn Racket-like syntax on a need-to-know basis.
                      This approach is popular with students, because the student languages allow for the generation of error messages that are meaningful for beginners and the development of a video game provides an exciting development domain. From a Computer Science educator׳s perspective this approach is successful, because beginners are liberated from having to reason about state-based computations allowing them to learn principles and algorithms, such as heuristic-based searching, the use of randomness, and minimax searching, that traditionally have been restricted to advanced undergraduate courses.

The ideas presented in this article were motivated by trying to find a way to continue to feed student enthusiasm once students master the basics of structural recursion using the PBD methodology. Students are guided to explore generative and accumulative recursion. This transition is best made by having the students discover the need for something more than structural recursion. This approach strongly contrasts with a student simply arriving to class one day and discovering that a new topic called “generative recursion” is being covered. For instance, consider presenting students with the problem of finding a path from node A to node B in a directed acyclic graph. It is not difficult for students to realize that a path from A to B is a path that starts at A and that is followed by a path from a successor of A to B. The students can see that this is a recursive process, but it is certainly not structural recursion. They have discovered generative recursion: the subproblem generated is a new instance (hopefully smaller) of the original problem that is not derived from the structure of the input. Students contrast this with, for example, searching for the maximum of a list of numbers where the subproblem is based on the rest of the input list—that is, it is derived from the structure of the input. Extending this example to a directed graph (one that may have cycles), students discover that their implemented solution no longer works. Upon further analysis, they realize that in the presence of a cycle it is necessary to not visit a node more than once during the search. Otherwise, the search process may never exit a cycle in the graph. To avoid this, the nodes that have been visited must be remembered from one recursive call to the next. The students have discovered the need for a new kind of recursion: accumulative recursion where knowledge is accumulated from one recursive call to the next. This type of approach motivates the need to study two new forms of recursion, but fails at getting students truly excited about the material. Students can surmise that such a function may be useful for building a GPS navigator, but they are not actually building a navigator nor are they presented with an opportunity to creatively inject their personalities into their solutions.

Students get excited by actually building a product in a domain that they consider fun and which allows them to express their creativity. This article advocates the position that video games ought to be used with beginners to motivate the need to study generative and accumulative recursion. It presents an example on how to make the transition from structural recursion to generative and accumulative recursion using the N-puzzle problem. This road map is used in the curriculum at Seton Hall University. The primary goal is to introduce these topics in a context that allows students to express their creativity and that reinforces lessons on PBD, structural recursion, and abstraction. Equally important goals are to expose students to ideas that they may encounter in upper-level courses such as heuristic search strategies, the A⁎ algorithm, and the use of random number generators.

This article has grown out from the original presentation of the material published in the proceedings of Trends in Functional Programming 2011 [13]. It varies significantly from that original presentation in the following manner:
                        
                           1.
                           The introduction describes the author׳s classroom experience motivating the study of generative and accumulative recursion through the process of discovery. In addition, it argues that traditionally considered advance topics in Artificial Intelligence can be successfully introduced to beginners.

The discussion on the first classroom encounter with the N-puzzle problem reflects current practices. It addresses how to expose students to the perils of generative recursion and of randomness to motivate careful study. Throughout the article, current practices are emphasized.

The discussion of accumulative recursion revisits the use of randomness and describes how to expose students to a useful application of randomness.

There is a new section that discusses empirical data obtained from student feedback suggesting that the approach described is well-received by beginners.

@&#RELATED WORK@&#

As argued by McCracken [12], recursion is one of the foundations of Computer Science that provides an effective problem-solving approach. It is not a topic that ought to be considered advanced and, in fact, can be understood and used by beginners in their second year as Computer Science majors. As McCracken, this article argues that recursion is an effective problem-solving approach that can be used by beginners. In contrast to McCracken, in this article “beginners” does not refer to second-year CS students, but to first-year students (including non-CS majors). Historically, however, recursion has been considered one of the most difficult topics to teach [1,8,9,18]. Much of the difficulty, in the author׳s opinion, is attributable to the conceptual models historically used to explain recursion in the classroom. Wu [19], for example, identifies five widely used models of which three are considered concrete and two are considered abstract. The concrete models include Russian Dolls, Process Tracing, and Stack Simulation. These models emphasize the mechanics of how recursion is implemented, which can be valuable, but fail to encourage the development of abstract thinking skills where the power of a recursive design lies. This may explain why others have observed that students are able to display some understanding of how a program is evaluated, but are unable to determine its purpose [11]. The abstract models include Mathematical Induction and Structure Template. The first introduces recursion in terms of proofs by induction and program correctness. This approach may be effective with mathematically mature students, but there is no denying that proofs require insight usually gained from experimentation and the skill to develop insightful examples—neither of which are common commodities in a beginner׳s toolbox. The second, traditionally, has meant to provide examples of code as templates and then programming is reduced to filling in base and recursive cases differently for a different problem. The difficulty with this approach is that it fails to provide students with the skills to develop the templates in the first place. In no uncertain terms, the development of templates is ignored and only a tenuous connection is made with the (structure of) data. Furthermore, it fails to illuminate students on how to design code using generative and accumulative recursion, where the recursion is not based on the structure of the data processed. In contrast, the approach taken in HtDP and at Seton Hall is to make explicit the connection between the problem being solved and recursion. A key skill students develop is being able to identify the subproblems that ought to be solved recursively. In other words, they learn to think recursively and abstractly endowing them with the ability to tackle problem solving in general—and not just problems similar to the templates they have been given in the classroom.

The most closely related work on teaching generative and accumulative recursion to beginners is presented in HtDP. HtDP presents generative recursion as programs that have recursive calls that do not operate on part of the input. Instead, they generate a new instance of the problem. The examples used include quicksort, Euclid׳s greatest common divisor algorithm, computing Sierpinski׳s triangle (i.e., fractals), binary search, Newton׳s method, Gaussian elimination, and finding a path in an acyclic graph. Of these, the only example that truly captures the imagination of students, as judged by their reactions, is programming with fractals. The reason is that fractals allow for a student to personalize their solutions to problems and allows them to have something they can share with others (e.g., friends and parents). The other problems, although very important, do not permit for the personality of a student to be incorporated into programs. If HtDP׳s approach is combined with the development of a video game, like the N-puzzle, students are more receptive to studying generative recursion. In other words, fractals and the N-puzzle problem provide students with a creative outlet that allows them to personalize their work and share it with others. Thus, they feel personally vested in software development. This is less easy to do with the other problems. The important lesson for a Computer Science educator is to strike a balance between problems that allow personalization and important problems that do not. Beginners need and ought to be exposed to both. The value of learning about generative recursion immediately becomes personal for a student when the class delivers on developing a game, like the N-puzzle, that requires using generative recursion.


                     HtDP introduces accumulative recursion as a solution to the loss of knowledge between recursive calls. The loss of knowledge is a two-fold problem. The first, when using structural recursion, the loss of knowledge can lead to issues of efficiency. To illustrate this consider the problem of reversing a list. Fig. 1
                      presents a solution using structural recursion. Fig. 2
                      presents a solution that uses accumulative recursion. At first sight, beginning students do not see why it is a good idea to use accumulative recursion. However, if we time the execution of both functions on a list of 100,000 randomly generated numbers (using Racket׳s time function), we can observe that rev1 takes approximately 231,604ms to evaluate while rev2 only takes approximately 185ms to evaluate.
                        2
                     
                     
                        2
                        Timing done on a Samsung Tablet 700T.
                      Such an experimental result does peek the interest of many students. Students agree that computers should be as fast as possible (something that they take personal), thus, accumulative recursion as a technique that may improve performance is interesting. The second, when using generative recursion, the loss of knowledge may lead to problems not being solved (i.e., going into an infinite recursion). A classical example of this, mentioned in Section 1, is finding a path in a graph (that may have cycles). Here, once again, students seem to need a problem that makes the issue personal to them. A video game, like the N-puzzle, is an effective means to make the issue personal to students given that they are personally vested in the development of the game.

Outside of the realm of HtDP, reported efforts to introduce students to generative and accumulative recursion per se are scarce. One effort employs 3-D graphical animations developed by students using Alice 
                     [4]. Alice introduces recursion as a means to repeat actions. Each repetition of an action brings closer the completion of a task. Animations are developed using generative and tail recursion, but no effort is reported on teaching design principles using these types of recursion. The authors do report a high level of student involvement using 3-D animations which is similar to the results obtained from the video game approach described here. In contrast, the work in this article emphasizes design as a natural means to using generative and accumulative/tail recursion. That is, problem analysis provides insight that intuitively leads to the use of generative and accumulative/tail recursion.

To the best knowledge of the author, heuristic search techniques and implementing A⁎-like algorithms are topics that up to now were reserved for advanced undergraduate courses like Introduction to Artificial Intelligence and Data Structures and Algorithms. The N-puzzle game has been used to motivate topics in Artificial Intelligence and Machine Learning [10]. In addition to using the N-puzzle in an undergraduate AI course, the authors report using the N-puzzle game in a data structure and algorithms course. In contrast, the approach presented in this article demonstrates that these topics are within reach of beginners when sound design principles are taught. There is evidence that others share this point of view as traditional topics in a Artificial Intelligence course, such as the minimax algorithm, are now being included in textbooks for beginners [2].

At Seton Hall University, students take a year-long (2-semester) introduction to program design. No background in programming or Computer Science is assumed. Students are, however, required to have taken high school algebra. In the first semester, students are introduced to designing programs based on the type of the input and to thinking of functions as they have in their mathematics courses. That is, functions receive input and produce output. Among other things, this means that their programs are assignment-free and are designed using familiar concepts from high school algebra as domain, range, function composition, and compound functions. As a semester-long project, students create a graphics-rich video game, such as a Space-Invaders-like game [14], using iterative refinement. The development of the game is used as motivation to study the topics covered in the course. Students first learn to program using primitive data (i.e., data that is not decomposable into component parts) such as images, numbers, symbols, and Booleans. After this, students are introduced to designing functions that process compound data. First, students work with structures. Then students learn to design functions for recursively defined data such as lists, trees, and natural numbers using structural recursion. This naturally leads to studying functional abstraction and higher-order functions such as map, filter, and fold. The first semester ends with an introduction to distributed programming (where, for example, students design a communication protocol and create a multiplayer video game) [15].

The material presented in this article is part of the second semester. In addition to generative and accumulative recursion, the course includes topics such as computation with inexact numbers, state-based computation, and an introduction to asymptotic running time. The number of lectures spent on the N-puzzle game varies from 4 to 5 depending on how much guidance the students require. As in the first semester, the game is used as a motivation tool. Two lectures are used to motivate generative and accumulative recursion using the N-puzzle. Two or three lectures are devoted to developing the solutions outlined in this article. Although this game is not as graphics-rich as in the first semester, students are still able to tailor the game to their liking by selecting the format and colors of the tiles, the size of the board (e.g., 4×4), the winning board, and the look of the help button.

The N-puzzle game is one that is likely to be familiar to an international milieu of students and is simple enough that students can easily grasp how the game works. It consists of an N×N board with 
                        
                           
                              N
                           
                           
                              2
                           
                        
                        −
                        1
                      tiles
                        3
                     
                     
                        3
                        The choice of a square board is arbitrary, but facilitates developing a program.
                      and an empty square or blank space that does not contain a tile. Each tile contains some form of symbolic or numeric data. Fig. 3
                      displays a sample board using numeric tiles for the 3-puzzle
                        4
                     
                     
                        4
                        It is also common to refer to this version of the puzzle as the 8-puzzle.
                      game in which the empty space is at the center of the board. Every N-puzzle game must also define a winning board. That is, a board that defines the target position of all the tiles in the puzzle. Fig. 4
                      displays the traditional winning board for the numeric 3-puzzle problem.

A player can move tiles by swapping the blank space with one of its neighbors (i.e., right, left, up, or down). The goal of the game is to make a sequence of moves that leads to the winning board. A player, of course, at some point during the game may feel stuck and the game should provide a mechanism, like a help button, to ask the computer to make the next move. The help button, of course, requires the program to choose a move for the player. Specifying how the help button chooses a move is the responsibility of the programmer.

To make the game more challenging and more interesting the game can be parameterized with a constant N. In this manner, students are free to make the board larger or smaller according to the level of the challenge they desire. A CS1 instructor should note, however, that as N increases the effective use of the help button decreases which can discourage some students.

As outlined in Section 3, students that are presented with the N-puzzle game are familiar with designing programs that use structures, recursive data types, and abstraction. Most relevant to the material presented in this article are, for example, programming with lists and trees as well as familiarity with basic abstraction patterns that involve the use of higher-order functions such as map and filter.

When students are first presented with the N-puzzle game, they are asked what is changing while the game is played and how can it be represented. This leads to defining a board as a list of numbers.
                        5
                     
                     
                        5
                        The number in position i of the list corresponds to the tile in row (quotient i N) and in column (remainder i N).
                      A list, not a structure,
                        6
                     
                     
                        6
                        In the course׳s nomenclature a structure refers to compound data of finite size. In contrast, a list is compound data of arbitrary size.
                      is chosen given that the game is parameterized by N. If a fixed N is chosen a priori to develop an instance of the game, then the representation used ought to be a structure. In addition to the data definition, students develop a template for a function on a board. Both are displayed in Fig. 5
                     . This brings the N-puzzle game into a realm that is familiar to the students and provides an opportunity to reinforce lessons on structural recursion. In the interest of focusing on new material, at this point students are provided with an implementation of the game in which the help button does nothing. That is, it makes no move on behalf of the player. The code that is provided is developed using only programming constructs that the students have studied and students must edit it if they wish to personalize the game. The code provided includes, for example, functions to build the winning board, to find the position of the empty space, and to swap two tiles as displayed in Fig. 6
                     . In this manner, the development of the game focuses solely on how to implement the help button. In addition, students less interested in personalizing a video game may solely focus on the implementation of the help button.

Students are asked what does it mean to find a solution when the player requests the computer to make the next move by hitting the help button. After some discussion, it becomes clear that finding a solution is finding a sequence of moves from the current board to the winning board. A common data definition for a sequence of moves suggested by students is: 
                        
                           
                              
                              
                                 
                                    
                                       A sequence of moves (som) is either:
                                    
                                 
                                 
                                    
                                       
                                       1. empty
                                    
                                 
                                 
                                    
                                       
                                       2. (cons board som)
                                    
                                 
                              
                           
                        
                     Armed with the idea that the help button needs to compute a sequence of moves from current board to WIN, students are asked how can such a sequence be found. The answer that arises quickest is that the program randomly chooses a move and finds a sequence from the resulting board to WIN. This approach merits analysis in class, because finding such a sequence of moves for board b means finding a solution for one of the possible successors of b, child
                     
                        b
                     , obtained by making a single move and adding the move that takes b to child
                     
                        b
                     . Observe that such a strategy is no longer in the domain of structural recursion. Students have discovered generative recursion. Better stated, students have reasoned generative recursion into existence.

Without knowing anything about the perils of nor how to design functions using generative recursion, students are asked to implement this strategy for the help button. Fig. 7
                      displays a typical implementation developed in class with students. In essence, the code finds the position of the blank, determines the neighbors of the blank, and builds a som from the current board and the solution found starting from a board obtained by swapping the blank and a randomly chosen neighbor. Much to the surprise of students this solution makes the game unbearable. Simply stated, either the help button is too slow (and there is nothing worse than a slow video game) or the help button appears to never find a som. The question now becomes how do you design solutions to problems using generative recursion and the course proceeds to study the development of selected problems in HtDP. A secondary question is whether randomness is ever useful.

In addition to presenting the development of classical examples using generative recursion (such as quicksort, fractals, binary search, greatest common divisor, and Newton׳s method) special attention is given to depth-first search and backtracking algorithms as these are essential principles in Computer Science that in the past students have struggled with at Seton Hall. To make them fun and get students personally vested in them, they are used to solve the N-puzzle. Much like in HtDP, finding a path in a directed acyclic graph is used to illustrate depth-first search with backtracking. The restriction to acyclic graphs is made for students to gain experience in making valid termination arguments. During their first steps studying how to design generative recursion functions, it is easier to restrict the domain to make the development of termination arguments easier.

Once the students have some experience with generative recursion, the time comes to return the focus to our motivating N-puzzle. In the N-puzzle game, with the current knowledge the students have, we are unable to restrict our sequences of moves to those that are finite. That is, there is no notion of using accumulative recursion to remember visited nodes in order to prune the search tree and avoid cycles. Students, in general, are not aware that the search tree can be pruned and at this point they can be led to develop a solution that seems reasonable. Class discussion is focused again on how to choose a successor of the current board to find a solution. No student suggests randomly picking a successor, but most are at a loss to answer this question. This presents the opportunity to introduce beginning students to heuristics. A heuristic can be used to choose which child of a board, b, is chosen to explore for a solution. It is important to remark to students that a heuristic is a rule that estimates how many moves away the current board is from the winning board which is used in the hope that it leads to a solution. At this point, most students will have no way to judge this statement and simply trust the professor. This trust opens the door for reinforcing lessons on the importance of testing and careful design in programming. As the reader knows, this approach is destined to immediate failure, but also to eventual triumph as the process of iterative refinement progresses.

There is a simple heuristic that students can understand and implement for the N-puzzle problem. The heuristic chooses to explore the child of b that has the smallest Manhattan distance. The Manhattan distance of a board is the sum of how far away each tile is from its correct position. For example, the Manhattan distance of the board in Fig. 4 is 0 given that all tiles are in the correct position. In Fig. 3, tile 1 is in the right position and contributes 0 to the Manhattan distance while the blank space, in position 4 and whose correct position is 8, contributes 2 to the Manhattan distance. The code to compute the Manhattan distance of a board is displayed in Fig. 8
                     . Observe that the code only requires arithmetic and structural recursion on natural numbers which provides the opportunity to reinforce material that students have already seen and to make this material relevant to their interests in video games.

Armed with the power of a heuristic, the class can now delve into designing a new N-puzzle solver to implement the help button using a depth-first search algorithm. If the given board is the same as the winning board, then the solution is trivial: a list containing the given board. Otherwise, create a list from the given board and the solution generated starting from the best child of the given board. The function to generate the children of a given board can either be done using structural recursion or map. It only entails swapping the blank space with its neighbors. Finding the best board from a list of boards also only requires structural recursion. A sample implementation is displayed in Fig. 9
                     .

The benefits of using the N-puzzle to reinforce lessons from structural recursion, to motivate generative recursion, and to capture the interest of students are likely to be self-evident to any instructor at the helm of a beginner׳s class. Clearly, this video game also provides the opportunity to introduce students quite naturally to depth-first search and to heuristic-based programming, which is quite novel as far as the author knows. There are, however, three more benefits that deserve to be mentioned. The first is making the importance of developing a termination argument—a step in the design recipe for functions that use generative recursion—resonate in students. This is achieved in the classroom by mimicking the common student behavior of skipping the development of a termination argument and discovering that such behavior has led us astray. The second is reinforcing the value of testing. The instructor can strategically provide initial boards to test the help button. The code in Fig. 9 does, indeed, find a solution for some test boards while at the same time fails to return a solution for some test boards. This leads to an exploration of why the program, which seems quite reasonable to most students, fails to return a solution. The third is reinforcing the value of iterative refinement. Although the proposed solution does not work, it can be refined to create a working solution.

The exploration of why the program fails to return a solution to some boards leads to the discussion of a situation like the one depicted in Fig. 10
                     . If the current board is the one at the root of the tree, it has two children both of which have a Manhattan distance of 18. The algorithm chooses the right child as the board to explore. This board has three children that, from left to right, have Manhattan distances of 20, 20, and 16. The rightmost child is chosen for exploration as it has the smallest Manhattan distance. At this point, all students can see the problem. The algorithm cycles through the same set of boards never choosing a different board to escape the cycle. In other words, students understand why there is an infinite recursion and why it is impossible to argue that the algorithm terminates as is required by the design recipe for programs based on generative recursion. Some readers may argue that developing a termination argument ought to always be done before implementing an algorithm. At Seton Hall, we have discovered that this is not always true. Much of it depends on the CS-maturity that students bring to the classroom. In our course, it is assumed that students have little or no background in Computer Science when they start. For such students, theoretical termination arguments do not easily flow. Understanding why an implemented algorithm fails, on the other hand, presents an excellent learning experience and brings home the importance of developing termination arguments. We conjecture that as students gain experience it becomes easier for them to visualize, before implementation, termination arguments.

After understanding why the algorithm does not always terminate, students are guided to think that a solution to this problem requires that all sequences starting at the given board must be explored instead of choosing to only explore the sequence of best children. This requires that all paths explored so far be remembered. Through this analysis, students have reasoned accumulative recursion into existence and this is used as motivation to return to HtDP and study how to design programs that exploit this new kind of recursion.

One of the functions students can develop while exploring how to design programs that use accumulative recursion is a function to present a player with an initial board to solve. This presents an interesting task, because not all possible orderings of tiles in a board are valid boards in the N-puzzle game. Thus, it does not suffice to simply randomly choose the position of the tiles. In the 3-puzzle game, for example, the ordering that has 1, 2, 3 in the 0th row, 4, 5, 6, in the 1st row, and 8, 7, blank in the 2nd row is an invalid board. The challenge, therefore, is to design a strategy to compute an initial board that does not simply randomly assign tiles to positions in the board. After some discussion, a natural strategy to follow is to start from the winning board and randomly make k valid moves. This strategy is a good one to choose in a beginner׳s class for three reasons. The first is that it provides students at this early stage in their studies with an example of where the use of randomness is useful (unlike the attempt to find a solution by making random moves). The second is that it requires an accumulator to “remember” the board created so far. That is, after every random move a new board is created and the new board needs to be used to make any further moves. The third is that it brings accumulative recursion into the domain of structural recursion on natural numbers—a familiar world for students that have followed an HtDP-based curriculum. This approach, for example, is implemented by students as displayed in Fig. 11
                     . The function make-moves is written using the design recipe for structural recursion on natural numbers to which an accumulator has been added. As per the design recipe for designing functions using accumulative recursion, students must develop an accumulator invariant. Although the invariant in this case may seem straightforward to an experienced programmer, its development by beginning students usually requires some coaching. One effective strategy is to have students trace an example, before writing any code, to help them visualize what characteristics of the parameters remain unchanged for every recursive call. For the function make-moves in Fig. 11, for example, the parameter b is an accumulator. Initially, students are led to reason that b is the board obtained by making a number of random moves starting from WIN. This reasoning is then refined to precisely define the number of moves: (- NUM-INIT-MOVES nummoves). Students can now argue that for every recursive call a move is made and the number of moves is reduced by 1. Thus, they can conclude that the accumulator invariant holds for every recursive call and that when nummoves is 0 the initial board has been computed.

The heuristic-based depth-first N-puzzle solver assumed a solution can be found by always exploring the best successor of the current board. This assumption is removed and all possible sequences starting at a given board are explored. This requires that a list of all sequences generated so far be maintained. It is important during the exploration of this idea in the classroom to have students realize that this list of sequences must be maintained in order by length. Otherwise, the strategy may degenerate into a depth-first search that leads to an infinite recursion. The experienced reader will recognize that such a list is, in essence, a queue. It presents an opportunity to develop an interface for queues, but our success with having students reason about queues is mixed. Beginning students need to work on several queue-based solutions to different problems to internalize what a queue is. Therefore, we usually only mention queues in passing and allow students to structure their reasoning using a list of sequences ordered by length.

The implementation builds on the work done for the heuristic-based depth-first N-puzzle solver. The function find-solution-bfs takes as input a board, b, and returns a sequence of moves from b to WIN. To accomplish this, a helper function, search-paths, is called that takes as input an accumulator that stores the list of all sequences generated so far. Initially, this list of sequences contains a single list that contains b. The function search-paths is a combination of generative recursion and accumulative recursion. Each time the function is called, it checks if the first board in the first sequence is WIN and, if so, it returns the first sequence. Otherwise, the successors of the first board in the first sequence are generated and a new sequence is generated for each successor by adding it to the front of the first sequence. To maintain the accumulator invariant, the list of sequences that does not include the first sequence is appended with the new sequences generated for the recursive call. A sample implementation is displayed in Fig. 12
                        .

Students must develop an accumulator invariant as well as an argument for termination. The accumulator invariant is developed, as mentioned above, during the exploration of the idea to search all possible sequences. The argument for termination hinges on having students realize that as paths get longer the number of moves required for one or more paths to reach the winning board gets smaller. Thus, the number of moves required to reach the winning board will eventually reach 0 for some path and the algorithm returns the appropriate sequence as long as the initial board is valid. This is a good opportunity to highlight properties of breadth-first searching and contrast it with depth-first searching in a manner that is meaningful to beginners. Students are explained that a breadth-first will always find an answer if one exists, but it may do so solely given that it performs an exhaustive search. This is the case for the N-puzzle game. In contrast, depth-first search may find a solution faster. However, a depth-first search is not guaranteed to find a solution as is also the case with the N-puzzle problem. Students have expressed that writing the N-puzzle game has definitely helped them understand and make a connection with these concepts.

The breadth-first N-puzzle solver does find a solution for any given board, but students soon discover that the help button is very sluggish and in some cases extremely so. The problem, of course, is that exploring all possible sequences starting at a given board is a great deal of work. Students can be led to realize that the number of sequences being searched surpasses 29 after 10 moves and surpasses 219 after 20 moves.
                           7
                        
                        
                           7
                           29 and 219 are, respectively, the number of leaves in a binary tree that describes the search space after 10 and 20 moves if all boards only had two successors.
                         This provides an opportunity to expose students to the problems of exponential growth. At this point, students are asked if searching all possible sequences and searching all possible sequences at the same time is necessary. This is a difficult question for them to answer. Most students will say yes to both questions, because they believe that all possible sequences must be searched. In other words, most students at this level are unlikely to realize on their own that the search tree can be pruned and that not all unpruned sequences need to be simultaneously searched.

There are two main ideas that must be planted in students’ minds. The first idea is that not every sequence needs to be explored. We draw on the experience obtained from the depth-first N-puzzle solver. If any successor, s, of a given board, b, has been explored (i.e., the successors of s have been generated), then the path through b to s need not be explored. The reason is that a sequence, of equal or shorter length, to s has already been generated. The second idea is that we can choose to explore the most “promising” sequence first instead of blindly exploring all possible sequences at the same time. This leads the class discussion back to the Manhattan distance heuristic as a mechanism for deciding which sequence is the most promising. The idea to always explore the most promising sequence first is the one that beginning students can grasp and implement.


                        Fig. 13
                         displays an implementation of this strategy. The function search-paths requires two accumulators each with its own invariant. The accumulator visited is a list of all the boards whose successors have been generated. The accumulator paths is a list of all the sequences starting at b that may need to be explored such that no sequence has a repeated board. Both invariants, with some guidance, can be developed by students. The development of these invariants is likely to be the most time-consuming exercise in class. The rest of the implementation flows faster. The code finds the best sequence in paths. If the winning board has been reached by the best sequence, then the best sequence is returned. Otherwise, the program filters the successors of the last board
                           8
                        
                        
                           8
                           Note that sequences are reversed making the last board in the sequence the first in the list.
                         in the most promising sequence to remove boards that have already been explored. New sequences are generated using map to add each remaining successor to the most promising sequence. Notice that both of these computations are achieved by reinforcing lessons on abstraction that students have been exposed to in the near past. Finally, to maintain the two accumulator invariants, the last board of the most promising sequence is added to visited and the new sequences are appended with sequences obtained from removing the most promising sequence from paths. The only remaining tasks students must implement is finding the most promising sequence and removing a sequence from a list of sequences. The first can be done either by using accumulative recursion with an accumulator that remembers the best sequence so far or using structural recursion. The second is a straightforward exercise using structural recursion.
                           9
                        
                        
                           9
                           These functions do not appear in Fig. 13 due to space limitations for figures.
                        
                     

The algorithm developed is in essence an A⁎-like algorithm [16,17]. That is, it is a combination of a breadth-first strategy and a depth-first with backtracking strategy. Such algorithms are commonly referred to as informed heuristic search strategies 
                        [17]. What is most noteworthy is the fact that the development flows naturally from following the steps of the design recipe and iterative refinement. Students reason the algorithm into existence instead of being told about an algorithm. Such a development challenges the tacit assumption that A⁎-like algorithms are too complex for beginning students to understand and, therefore, are left as material restricted to more advanced courses such as an Introduction to Artificial Intelligence. There is, of course, one important observation about the N-puzzle domain that allowed us to simplify the design. Once a board is encountered there is no need to change its predecessor, because the cost of reaching it through the sequence of a previous encounter is always as good or better than the cost through the new sequence. In a full-fledged A⁎ algorithm, the costs of the different sequences to a board must be examined to always maintain the sequence with the least cost.

The course using this material has been taught four times with an average course size of 19 students. Each edition taught includes all the material discussed above in the same manner with the exception that over the years the discussion of the benefits and the pitfalls of randomness has matured. At the end of each edition of the course, students are anonymously surveyed to ascertain their impressions.
                        10
                     
                     
                        10
                        Anonymity was guaranteed by having students distribute and collect the surveys in class and by indicating to students not to identify themselves on the survey.
                      Students at all levels of their college career as well as high school students have enrolled. Although most students have been Computer Science majors, the course has become popular with students of other majors (along with high school students over the summer). Data is presented on several survey questions answered by students. Virtually all students answered the survey (a total of 75 students representing a 97% response rate) of which 24% are female and 76% are male. The data is presented separately for males and females to ascertain the impact of this course based on gender. Student opinions of the course and the material covered have been consistent over the years with no significant differences observed between different editions of the course.

Before presenting the results of the survey, it is prudent to discuss caveats concerning how much the observed results can be generalized. First, each edition of the course has been taught by the author whom also developed the material discussed above. Although that in itself does not mean the results cannot be reproduced elsewhere, it still remains to be seen if the results extend when a large pool of different instructors use the material in their courses. Second, the material has only been used in relatively small class sizes. There is no reason to believe that the material cannot be effectively covered in classes with large enrollments. Nonetheless, it remains to be seen how the material is received by students enrolled in large class sizes. Finally, the total number of students that have been exposed to the methodology described is still small and from a single institution. As the work is disseminated to other institutions and the number of students exposed grows, it will be seen if the observed results are maintained. The expectation is that the trend of consistent results will be maintained across a larger number of students and across more institutions.

Students were asked their overall opinion of the course using the following scale:
                        
                           1.
                           A complete waste of time.

Difficult and a lot of work, not enjoyable, and learned very little of any use.

Difficult and a lot of work, but not enjoyable despite learning something useful.

Difficult and a lot of work, but I enjoyed it and I am glad I took it.

Beyond Excellent.

Students were also asked to rate their interest in programming after the course. The measurement scale ranges from 1 (not at all interested) to 5 (very interested). Figs. 16 and 17
                     
                      graphically summarize the responses. Among female respondents, 50% rated their interest in programming to be 4 or 5. Among males, 63% rated their interest in programming to be 4 or 5. Although interest in programming among males that took the course is higher than among females, these statistics are encouraging. They suggest that functional video games can become an effective medium to close the gender gap.

Students were also asked if they felt they were better problem solvers by knowing how to design and implement programs. The measurement scale ranges from 1 (not at all) to 5 (very much so). The responses are summarized in Figs. 18 and 19
                     
                     . Among female respondents, 57% answered 4 or 5 indicating that they felt rather strongly about being better problem solvers. Among male respondents the proportion is 61%. This data suggests that the majority of students, both male and female, feel they are walking away with skills they did not have before. It is encouraging to see that virtually the same proportion of males and females feel that they are better problem solvers.

Finally, students were asked if they felt empowered by knowing how to design and implement programs. The measurement scale ranges from 1 (not at all empowered) to 5 (very empowered). The summarizing histograms are displayed in Figs. 20 and 21
                     
                     . Among females, 63% of respondents answered 4 or 5 indicating that a substantial majority feels empowered. Among males, 64% of respondents answered 4 or 5 also indicating that a substantial majority feels empowered. The inescapable conclusion is that male and female students feel equally empowered when the delivery of a beginner׳s course is made appealing to both genders.

Overall, the data suggests that students, both male and female, are responding well to a course that uses functional video games as motivation. It also suggests that the gender gap in Computer Science may be closed by using a creative medium like video games. Certainly, this hypothesis merits further study given the results presented.

Functional video games provide the opportunity to engage beginning students of both genders in a fun and effective way to advanced principles of Computer Science. The work presented in this article demonstrates how the development of a video game can serve as motivation to study and learn about generative and accumulative recursion. In addition, a well-chosen game provides the opportunity to expose beginners to concepts, traditionally reserved for advanced undergraduate courses, like breadth-first and depth-first searching, heuristic-based searching and the use of randomness. This demonstrates that these fundamental Computer Science techniques are not beyond the grasp of beginners. In fact, students can reason many techniques into existence instead of simply (and only) reading about them in a textbook. This claim may go against the grain of popular culture in Computer Science, but results speak for themselves. Enriching beginners in this manner is a trend that is likely to and ought to flourish. This trend is currently rooted in functional programming and provides an opportunity to raise the importance of functional programming in Computer Science education. Others are also making strides in this direction [2] and many more are likely to make contributions.

Empirical data presented suggests that functional video games are an effective way to engage female students and close the gender gap in Computer Science. The data also begins to debunk the myth that males are inherently more interested and feel more empowered by computers, programming, and Computer Science. It is the delivery in the classroom that makes a difference. Engaging students by offering them creative outlets works equally well for male and female students. In a field like Computer Science that is relevant to virtually all other disciplines, there is lots of room to be inventive and harness the enthusiasm and creativity beginners bring to the classroom.

@&#REFERENCES@&#

