@&#MAIN-TITLE@&#Container relocation problem with time windows for container departure

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We combine the container relocation problem with the truck appointment system.


                        
                        
                           
                           We model the container relocation problem with time windows for container departure.


                        
                        
                           
                           We develop the abstraction heuristic, which improves the tree search by node caching.


                        
                        
                           
                           We develop an index-based heuristic that outperforms the random selection heuristic.


                        
                        
                           
                           The heuristic provides near-optimal solutions in a short time for large instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Logistics

Container relocation problem

Truck appointment system

Stochastic dynamic programming

Abstraction heuristics

@&#ABSTRACT@&#


               
               
                  The blocks relocation problem is a classic combinatorial optimisation problem that occurs in daily operations for facilities that use block stacking systems. In the block stacking method, blocks can be stored on top of each other in order to utilise the limited surface of a storage area. When there is a predetermined pickup order among the blocks, this stacking method inevitably leads to the reshuffling moves for blocks stored above the target block and the minimisation of such unproductive reshuffling moves is of a primary concern to industry practitioners. A container terminal is a typical place where this problem arises, thus the problem being also referred to as the container relocation problem. In this study, we consider departure time windows for containers, which are usually revealed by the truck appointment system in port container terminals. We propose a stochastic dynamic programming model to calculate the minimum expected number of reshuffles for a stack of containers which all have departure time windows. The model is solved with a search-based algorithm in a tree search space, and an abstraction heuristic is proposed to improve the time performance. To overcome the computational limitation of exact methods, we develop a heuristic called the expected reshuffling index (ERI) and evaluate its performance.
               
            

@&#INTRODUCTION@&#

Ever since the first containers were introduced around 1950–60s, container handling techniques and strategies have always been key factors in measuring the efficiency of terminal operation. Especially, the dramatic growth in the volume of container traffic in more recent years has posed a serious challenge for terminal operators because the available surface for managing such traffic has remained virtually unchanged. Due to this space limitation, most container terminals as opposed to some terminals using wheeled terminal operation adopt block stacking systems, in which containers are stacked on top of each other using handling equipment such as rubber-tired gantry cranes (RTGCs), rail-mounted gantry cranes (RMGCs) or straddle carriers (SCs). An analytical comparison of SCs, RTGCs and RMGCs is presented in Chu and Huang (2005), which show that the handling capacities increase from SC over RTGC to RMGC. Also, optimisation strategies for handling containers have been studied widely to foster the efficiency of container terminal operation. Comprehensive surveys on optimisation strategies for handling containers can be found in Stahlbock and Voß (2008) and Steenken, Voß, and Stahlbock (2004).

In a marine container terminal, import containers are unloaded from ships and stored in a storage yard until their owners pick them up by dispatching trucks. The container dwell time, or the duration during which a container stays in the storage yard, usually takes from hours to days and often depends on free storage days of each terminal. In Ports of Auckland (POAL), for instance, the monthly average dwell time for import containers was about 2 days in 2013, ranging from 1.8 days to 2.6 days (Ports of Auckland eNews (2013)) and the standard deviation of the dwell time during a specific month was around 1.7 days (POAL internal data, June 2013). While the arrival times of import containers are predictable by the ship arrival time and the ship operation schedule, the departure times of them are subject to high variability due to the unpredictability of trucks’ arrival times. It is typical that hauliers send some pre-information about trucks’ visits to the terminal before their trucks arrive at the terminal. A truck appointment system (TAS) is one such system that includes the information about the time window for the arrival of the trucks.

The main purpose of the TAS in container terminals is to alleviate the imbalance of peaks and troughs of truck arrival times and be related to solving terminal gate congestion as well as reducing the environmental impact of long-waiting trucks. By restricting the number of truck visits in each time slot, the TAS can reduce the number of trucks during peak hours, thus improving the overall turnaround time of external trucks. This study suggests that the TAS can also lend itself to improving the reshuffling efficiency for pickup containers. Hongkong International Terminal (HIT) appears to be the first terminal that implemented such an appointment system around 1997. The current appointment system implemented in HIT is a straightforward quota system in which the number of appointments is allocated in every 30-minute time slot (Murty et al. (2005b)). The effective size of each time slot varies by terminals. In New Zealand, for example, POAL has introduced an appointment system called Vehicle Booking System around 2007 and has allocated one hour for each time slot.

The most optimistic scenario with the TAS is that all trucks arrive at the terminal during the appointed time slots, but in reality it is hard to live up to this optimism due to several reasons. Each port may have different context for the reasons. In a survey on the hauliers in the California region, which had passed a bill in 2002 to enforce marine port terminals to take measures to reduce truck emissions and in response several ports established truck appointment systems, Giuliano and O’Brien (2007) identified the reasons as follows: freeway congestion, delays on the customer end, delays at marine terminals and others. A study done by Morais and Lord (2006) confirmed that the implementation of an appointment system at west coast terminals in the US could be effective in reducing truck idling/queuing at west coast terminals. However, they pointed out that the impacts were dependent on the factors that were producing congestion. In HIT where most external trucks bring export containers from mainland China, the drivers could not provide reliable arrival times due to the fact that the drivers could not control the border crossing time. Hence, HIT required only trucks coming to the terminal for pickups to make appointments and only for the terminal peak time of 8 AM to 5 PM (Murty et al. (2005b)). In 2013, POAL achieved trucks’ on-time ratio for the appointment to be around 55–60 percent, which was considerably higher than the previous years (Ports of Auckland eNews (2013)). This level of improvements could be made after years of implementation experience and continuous improvements such as with incentives, e.g. faster processing, for on-time trucks.

In the existing literature on the TAS, only a little addresses yard handling issues in a container terminal. Huynh and Walton (2008) focused on finding the appropriate level of capping for the allowable number of trucks given the input parameters such as the target average truck turn time and the number of yard equipment available at each yard zone and each time window. An ad hoc heuristic was used to solve their formulation. Jones and Michael Walton (2002) studied how the information about the departure times of import containers could be used to manage the container stack. They presented three methods of stacking import containers – noninformed strategy, informed strategy and random strategy – and developed an event-based simulation model that captures the interactions among various subsystems. They assumed that the port must have some method for gathering information about the departure time, e.g. the expected dwell time. Namboothiri and Erera (2008) addressed the TAS from a drayage company’s perspective and studied how the TAS affected the management of a fleet of trucks providing container pickup and delivery services to a port. Zhao and Goodchild (2010) assumed that trucks’ arrival times could be obtained after import containers were stored in the yard. They experimented with simulation programs to analyse the rehandling reductions under a variety of information quality regarding the truck arrival sequence and observed that significant reductions in rehandles could be obtained with small improvements in terminal information regarding truck arrivals. van Asperen, Borgman, and Dekker (2013) used a discrete-event simulation model to evaluate the impact of a TAS on the performance of online container stacking rules studied in their prior research (Borgman, van Asperen, & Dekker (2010)). Zehendner and Feillet (2014) proposed a mixed integer programming model to determine the number of appointments to offer with regard to the overall workload and the available handling capacity. Their model aims at minimising overall delays at the terminal, and discrete event simulation validates the results obtained by the optimisation model in a stochastic environment.

Storage yard in a container terminal consists of a number of stacks where containers are stored temporarily before they are claimed by external trucks or loaded onto a ship. The stack in this paper refers to a two-dimensional stock space comprised of multiple horizontal columns (or piles) and vertical tiers. Once containers are stacked in a stack, they can be accessed only from above. If there are containers on top of the target container, the above containers should be relocated to different columns, resulting in unproductive moves. According to Caserta, Schwarze, and Voß (2011), three types of post-stacking problems have been identified, namely, (i) the remarshalling problem, (ii) the premarshalling problem and (iii) the relocation problem. In the literature, the last problem is referred to as the container relocation (reshuffling, rehandling) problem (CRP) or the blocks relocation problem (BRP), which is the main discussion of this paper. Researchers note that container rehandles are a major source of inefficiency in most terminals when retrieving containers from yards. Most research that addresses the issue of container rehandling has the objective of minimising the number of reshuffles or, alternatively, the reshuffling time.

The CRP can be formally defined as follows: given a pickup order for containers stacked in a given stack layout, the objective is to clear all containers from the stack with the least number of reshuffling moves. A general version of this problem is known as the blocks world planning (BWP), the goal of which is to build any feasible stacking configuration of blocks. The complexity of the BWP has been proven NP-hard by Gupta and Nau (1992) and the complexity of the CRP has recently been proven NP-hard by Caserta, Schwarze, and Voß (2012).

The CRP has first been formulated by Kim and Hong (2006) with a dynamic programming (DP) model. Since this work, several variants to the CRP appear in the literature as noted in Ku and Arthanari (2016). By the assumption of container arrivals during the retrieval process, the static and dynamic (Borjian, Manshadi, Barnhart, and Jaillet (2013); Akyüz and Lee (2014); Wan, Liu, and Tsai (2009)) versions of the CRP are studied. Also, by the allowance of cleaning (or premarshalling) moves, the restricted and unrestricted versions of the CRP are studied. One latest trend of approaching this problem has a focus on investigating the informed searches and look-ahead methods in the unrestricted variant (Expósito-Izquierdo, Melián-Batista, and Moreno-Vega (2014); Jin, Zhu, and Lim (2015); Petering and Hussein (2013); Zhu, Qin, Lim, and Zhang (2012)). We also note that Ünlüyurt and Aydın (2012) study the same problem as Kim and Hong (2006) but extend it by considering the distance travelled by the crane.

Aside from the formalism proposed by Kim and Hong (2006), the model of the rehandling problem is influenced by the stack type (export or import). For export container stacks, Kim, Park, and Ryu (2000) derived an optimal stacking strategy for export containers with weight group information. Murty, Liu, Wan, and Linn (2005a) developed a system for determining a storage position of an arriving container to minimise the number of reshuffles measured by the reshuffle index (RI). Kang, Ryu, and Kim (2006) studied the rehandling problem for export containers and proposed a simulated annealing method to derive a good stacking strategy for containers with uncertain weight information. Based on this, they introduced classifiers for weight grouping to evaluate the derived strategies. Yang and Kim (2006) discussed the storage demand unit, which can be stored together and be retrieved in any order, in finding the stacking policy to minimise the total number of reshuffles.

For import container stacks, Watanabe (1991) proposed an accessibility index as an indication of rehandling occurrences and applied it to both the SC system and the transfer crane system to estimate the expected number of reshuffles for a given storage bay. de Castillo and Daganzo (1993) proposed two basic strategies for storing import containers, the first being based on the expected number of moves per container and the second being based on segregating containers according to their arrival times. Kim (1997) proposed analytic evaluations to estimate the expected number of reshuffles to retrieve all containers in a bay. Sauri and Martin (2011) developed a mathematical model based on probabilistic distribution functions for container dwell time to evaluate the stacking strategies by the number of reshuffling moves generated.

The present paper considers only import container stacks and follows the static version for container arrivals. However, it differs from other studies by assuming randomness for container departures among containers booked in the same time window. We term this problem class the CRP with Time Windows or CRPTW. The arrival times of trucks assigned for pickup containers are usually unpredictable in container terminals that do not use appointment systems, but our model assumes that the time windows for trucks’ visits are available by a TAS. Under this setting, there is a clear precedence relationship for pickup among containers in different time windows, but the precedence relationship among containers in the same time window is unclear. The objective of this problem is (i) to find the optimal decision for reducing the rehandles of pickup containers given the time windows usually informed by truck appointments and (ii) to calculate the minimum expected number of rehandles to clear containers from the stack.

The remainder of this paper is organised as follows: in the next section, the problem is formulated into a stochastic dynamic programming (SDP) model; in Section 3, the abstraction heuristics are proposed to improve the time performance of the tree search; in Section 4, a heuristic rule called the expected reshuffle index (ERI) is described; in Section 5, we report the results of the computational experiments with the methods discussed in this paper; in the last section, we conclude our findings and suggest future research directions.

To focus on the stochastic nature of our model, we confine our model to the static and restricted version, and the following two assumptions are generic to this variant of the CRP: (i) No container is arriving in the stack during the retrieval process; (ii) Containers are reshuffled if and only if any container below them is to be retrieved.

To include the components of the TAS, we also make the following assumptions in the model: (iii) Each container in the stack is booked to a time window, which then is mapped to a pickup sequence in an ascending order by the hour; (iv) Trucks associated with pickup containers in the stack arrive at the terminal within their appointed time windows.

When a group of containers are assigned to the same time window, they are all mapped to the same sequence, in which case the precedence relationship among them is unknown. We assume that there is an equal chance for any departure among containers with the same sequence. This stochastic scenario is different from the scenario modelled in Kim and Hong (2006) where a group of containers with the same sequence can be retrieved in any order. Below we introduce the notations for our SDP model.

                        
                           –
                           
                              N: the total number of containers in the initial stack


                              ak
                              : the action taken for the removal of the kth container


                              Sk
                              : the state of the stack after k containers are removed from the stack


                              ck
                              : the container to be removed during action 
                                 
                                    
                                       a
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    
                                       (
                                       k
                                       =
                                       0
                                       ,
                                       …
                                       ,
                                       N
                                       −
                                       1
                                       )
                                    
                                 
                              . It is a random variable


                              pk
                              (ck
                              ): the probability of removing ck
                               given the state Sk
                              
                           


                              π(Sk, ck
                              ): the state transformation function that observes container ck
                               to be removed from the state Sk
                              
                           


                              
                                 
                                    S
                                    
                                       k
                                       ′
                                    
                                 
                              : the state transformed by π(Sk, ck
                              ), i.e. 
                                 
                                    
                                       S
                                       
                                          k
                                          ′
                                       
                                    
                                    =
                                    π
                                    
                                       (
                                       
                                          S
                                          k
                                       
                                       ,
                                       
                                          c
                                          k
                                       
                                       )
                                    
                                 
                              
                           


                              
                                 
                                    r
                                    (
                                    
                                       a
                                       k
                                    
                                    |
                                    
                                       S
                                       
                                          
                                             (
                                             k
                                             −
                                             1
                                             )
                                          
                                          ′
                                       
                                    
                                    )
                                 
                              : the number of rehandles that occur during action ak
                               given the state 
                                 
                                    S
                                    
                                       
                                          (
                                          k
                                          −
                                          1
                                          )
                                       
                                       ′
                                    
                                 
                              
                           


                              f(Sk
                              ): the expected minimum total number of rehandles to remove the remaining containers from the state Sk
                              .

The model can be formulated as a recursive function as in Eq. (1). ck
                      is a random variable because which state the current state will be transformed into is uncertain before ck
                      is observed by external factors, e.g. truck arrivals. From Eq. (1), a general recursive function can be derived as in Eq. (2).

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          f
                                          (
                                          
                                             S
                                             0
                                          
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          E
                                          [
                                          
                                             min
                                             
                                                a
                                                1
                                             
                                          
                                          
                                             [
                                             r
                                             
                                                (
                                                
                                                   a
                                                   1
                                                
                                                )
                                             
                                             +
                                             f
                                             
                                                (
                                                
                                                   S
                                                   1
                                                
                                                )
                                             
                                             ]
                                          
                                          |
                                          π
                                          ,
                                          
                                             S
                                             0
                                          
                                          ]
                                       
                                    
                                 
                                 
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                c
                                                0
                                             
                                          
                                          
                                             p
                                             0
                                          
                                          
                                             (
                                             
                                                c
                                                0
                                             
                                             )
                                          
                                          
                                             min
                                             
                                                a
                                                1
                                             
                                          
                                          
                                             [
                                             r
                                             
                                                (
                                                
                                                   a
                                                   1
                                                
                                                |
                                                
                                                   S
                                                   
                                                      0
                                                      ′
                                                   
                                                
                                                )
                                             
                                             +
                                             f
                                             
                                                (
                                                
                                                   S
                                                   1
                                                
                                                )
                                             
                                             ]
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          w
                                          h
                                          e
                                          r
                                          e
                                          
                                          
                                          
                                             S
                                             
                                                0
                                                ′
                                             
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          π
                                          
                                             (
                                             
                                                S
                                                0
                                             
                                             ,
                                             
                                                c
                                                0
                                             
                                             )
                                          
                                          
                                          
                                          a
                                          n
                                          d
                                          
                                          
                                          
                                             S
                                             0
                                          
                                          
                                             
                                             
                                          
                                          
                                             →
                                             
                                                
                                                   S
                                                   
                                                      
                                                         0
                                                      
                                                      ′
                                                   
                                                
                                                ,
                                                
                                                   a
                                                   1
                                                
                                             
                                          
                                          
                                          
                                          
                                             S
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          f
                                          
                                             (
                                             
                                                S
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                c
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          
                                             p
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             
                                                c
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                          
                                             min
                                             
                                                a
                                                k
                                             
                                          
                                          
                                             [
                                             r
                                             
                                                (
                                                
                                                   a
                                                   k
                                                
                                                |
                                                
                                                   S
                                                   
                                                      
                                                         (
                                                         k
                                                         −
                                                         1
                                                         )
                                                      
                                                      ′
                                                   
                                                
                                                )
                                             
                                             +
                                             f
                                             
                                                (
                                                
                                                   S
                                                   k
                                                
                                                )
                                             
                                             ]
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          f
                                          (
                                          
                                             S
                                             N
                                          
                                          )
                                          
                                          
                                          =
                                          
                                          
                                          0
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          w
                                          h
                                          e
                                          r
                                          e
                                          
                                          
                                          
                                             S
                                             
                                                
                                                   (
                                                   k
                                                   −
                                                   1
                                                   )
                                                
                                                ′
                                             
                                          
                                          =
                                          π
                                          
                                             (
                                             
                                                S
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             ,
                                             
                                                c
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                          
                                          
                                          f
                                          o
                                          r
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          N
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          a
                                          n
                                          d
                                          
                                          
                                          
                                             S
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          
                                          
                                          
                                             →
                                             
                                                
                                                   S
                                                   
                                                      
                                                         (
                                                         k
                                                         −
                                                         1
                                                         )
                                                      
                                                      ′
                                                   
                                                
                                                ,
                                                
                                                   a
                                                   k
                                                
                                             
                                          
                                          
                                          
                                          
                                             S
                                             k
                                          
                                          
                                          
                                          f
                                          o
                                          r
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          N
                                       
                                    
                                 
                              
                           
                        
                     
                  

The previous state and the action taken there are independent of future random variables, i.e. 
                        
                           S
                           
                              k
                              −
                              1
                           
                        
                      and ak
                      are independent of 
                        
                           
                              c
                              k
                           
                           ,
                           
                              c
                              
                                 k
                                 +
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              c
                              
                                 N
                                 −
                                 1
                              
                           
                        
                     . Also, the optimal action in the given state is independent of future actions, i.e. 
                        
                           S
                           
                              k
                              −
                              1
                           
                        
                      and ak
                      are independent of 
                        
                           
                              a
                              
                                 k
                                 +
                                 1
                              
                           
                           ,
                           
                              a
                              
                                 k
                                 +
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              a
                              N
                           
                        
                     . Thus, we can transform the recursive function of Eq. (2) into a general function as in Eq. (3). Its derivation may be inferred from the model by Zhang, Chen, Shi, and Zheng (2010), which is a corrected version of the model by Kim et al. (2000).

                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          f
                                          (
                                          
                                             S
                                             0
                                          
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                c
                                                0
                                             
                                          
                                          
                                             min
                                             
                                                a
                                                1
                                             
                                          
                                          
                                             ∑
                                             
                                                c
                                                1
                                             
                                          
                                          
                                             min
                                             
                                                a
                                                2
                                             
                                          
                                          ⋯
                                          
                                             ∑
                                             
                                                c
                                                
                                                   N
                                                   −
                                                   1
                                                
                                             
                                          
                                          
                                             min
                                             
                                                a
                                                N
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          ×
                                          
                                          
                                             [
                                             
                                                ∏
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                p
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             
                                                (
                                                
                                                   c
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                )
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                N
                                             
                                             r
                                             
                                                (
                                                
                                                   a
                                                   k
                                                
                                                |
                                                
                                                   S
                                                   
                                                      
                                                         (
                                                         k
                                                         −
                                                         1
                                                         )
                                                      
                                                      ′
                                                   
                                                
                                                )
                                             
                                             ]
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          f
                                          (
                                          
                                             S
                                             N
                                          
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       0
                                    
                                 
                              
                           
                        
                     
                  

The solution procedure of a DP model can often be modelled as a tree search in a state space starting from some given initial state with rules describing how to transform one state into another. They will be applied over and over again to eventually satisfy some goal condition. In the context of the CRP, each node in the search tree corresponds to a stack layout (see Fig. 1
                        ). The root node represents an initial state of the layout and the leaf nodes the empty layout, i.e. the goal state.

A decision tree in a stochastic DP model consists of chance and decision nodes. A chance node is a tree structure expressing the stochasticity while a decision node expresses possible decisions. A circle is normally used to define a chance node while a square is used for a decision node. From a decision node, descendant nodes (or successors) are reachable by an action, i.e. one or a series of moves; from a chance node, descendant nodes are branched out by a random variable, which observes a container to be the next target for pickup among containers assigned to the earliest time window (see Fig. 2
                        ).

Let n be any node between the initial node and the goal during the search. Each node in the decision tree has the cost function, denoted f(n), which combines the path cost from the root node to node n and the estimated cost of the cheapest path from n to the goal as in Eq. (4). In the context of CRPTW, f(n) is the sum of the number of reshuffles incurred thus far, denoted g(n), and the minimum expected number of future reshuffles, denoted h(n).

                           
                              (4)
                              
                                 
                                    f
                                    (
                                    n
                                    )
                                    =
                                    g
                                    (
                                    n
                                    )
                                    +
                                    h
                                    (
                                    n
                                    )
                                 
                              
                           
                        
                     

In essence, the objective of the CRPTW is to predict f(n), or h(n), at the root node. At any node n, getting g(n) is trivial given the decision tree, but predicting h(n) may be difficult in the remaining depth of the node n. Let there be m successors from any node n and each successor from the node n be denoted 
                           
                              
                                 n
                                 k
                              
                              
                              
                                 (
                                 k
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 m
                                 )
                              
                           
                        . Also, let cost(n, nk
                        ) be the number of reshuffles by the action taken to transform the node n into its successor nk
                        . If the node n is a decision node, we find Eq. (5); if the node n is a chance node, we find Eq. (6), assuming the equal chance of the node n being transformed into any node nk
                        .

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             h
                                             
                                                (
                                                n
                                                )
                                             
                                             =
                                             min
                                             
                                                [
                                                c
                                                o
                                                s
                                                t
                                                
                                                   (
                                                   n
                                                   ,
                                                   
                                                      n
                                                      k
                                                   
                                                   )
                                                
                                                +
                                                h
                                                
                                                   (
                                                   
                                                      h
                                                      k
                                                   
                                                   )
                                                
                                                ]
                                             
                                             ,
                                             
                                             
                                             k
                                             =
                                             1
                                             ,
                                             2
                                             ,
                                             …
                                             ,
                                             m
                                          
                                       
                                    
                                    
                                       
                                          
                                             w
                                             h
                                             e
                                             r
                                             e
                                             
                                             n
                                             
                                             i
                                             s
                                             
                                             a
                                             
                                             d
                                             e
                                             c
                                             i
                                             s
                                             i
                                             o
                                             n
                                             
                                             n
                                             o
                                             d
                                             e
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             
                                                h
                                                
                                                   (
                                                   n
                                                   )
                                                
                                                =
                                                
                                                   1
                                                   m
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   m
                                                
                                                h
                                                
                                                   (
                                                   
                                                      n
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             w
                                             h
                                             e
                                             r
                                             e
                                             
                                             n
                                             
                                             i
                                             s
                                             
                                             a
                                             
                                             c
                                             h
                                             a
                                             n
                                             c
                                             e
                                             
                                             n
                                             o
                                             d
                                             e
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The decision tree in Fig. 2 is an illustrative mapping of layouts in Fig. 1. We cannot calculate h(n) for any node n until the search traversal reaches any leaf node. Due to the exponential growth in search space, we use the depth-first search (DFS) with back tracking to save memory consumption. In the DFS, the initial traversal of nodes in Fig. 2 is 0 → 1 → 3 → 6 → 9 until we reach the first leaf node. After that, we find h(n) for nodes in the order of 9 → 10 → 6 → 7 → 8 → 3 → 4 → 5 → 1. Likewise, a similar procedure will take place down the node 2. As a numerical example of Fig. 1 and 2, we present formulae for getting h(n) in Table 1
                        
                        .

During the back tracking from the leaf nodes, we calculate the values for h(n) as follows:

                           
                              –
                              
                                 
                                    
                                       h
                                       (
                                       6
                                       )
                                       =
                                       0.5
                                       (
                                       1
                                       +
                                       0
                                       )
                                       =
                                       0.5
                                    
                                  because 
                                    
                                       h
                                       (
                                       9
                                       )
                                       =
                                       1
                                    
                                  and 
                                    
                                       h
                                       (
                                       10
                                       )
                                       =
                                       0
                                    
                                 .

It is trivial that 
                                    
                                       h
                                       (
                                       7
                                       )
                                       =
                                       0
                                    
                                 . Also, we note that the patterns for node 6 and node 8 are the same, therefore 
                                    
                                       h
                                       (
                                       8
                                       )
                                       =
                                       h
                                       (
                                       6
                                       )
                                       =
                                       0.5
                                    
                                 .


                                 
                                    
                                       h
                                       (
                                       3
                                       )
                                       =
                                       2
                                       +
                                       m
                                       i
                                       n
                                       (
                                       0.5
                                       ,
                                       0
                                       ,
                                       0.5
                                       )
                                       =
                                       2
                                    
                                 . It also confirms that the optimal decision at node 3 is to move to node 7.


                                 
                                    
                                       h
                                       (
                                       4
                                       )
                                       =
                                       1
                                    
                                 .


                                 
                                    
                                       h
                                       (
                                       5
                                       )
                                       =
                                       0.5
                                    
                                  because the patterns for node 5 and node 6 are the same if we remove container 1 from the layout at node 5.


                                 
                                    
                                       h
                                       (
                                       1
                                       )
                                       =
                                       2
                                       +
                                       m
                                       i
                                       n
                                       (
                                       2
                                       ,
                                       1
                                       ,
                                       0.5
                                       )
                                       =
                                       2.5
                                    
                                 . It also confirms that the optimal decision at node 1 is to move to node 5.


                                 
                                    
                                       h
                                       (
                                       0
                                       )
                                       =
                                       0.5
                                       [
                                       2.5
                                       +
                                       h
                                       (
                                       2
                                       )
                                       ]
                                    
                                 .

To get h(0), we need to calculate h(2) by traversing the decision tree down the node 2. By comparing the patterns of node 32 (the child of node 2) and node 3, however, we note that h(2) should be the same as h(3). Therefore, instead of computing h(2), we find the value for h(2) by mapping the value of h(3), i.e. 
                           
                              h
                              (
                              2
                              )
                              =
                              2
                           
                        . Hence, 
                           
                              h
                              (
                              0
                              )
                              =
                              0.5
                              (
                              2.5
                              +
                              2
                              )
                              =
                              2.25
                              ,
                           
                         which is the optimal solution we are seeking.

The reasoning behind the reduction of the search space here is the abstraction of states and the caching for nodes whose h(n) values have been calculated. In the next section we elaborate the abstraction heuristic applicable to the CRPTW.

The CRPTW does not allow the pruning by conventional branch-and-bound (B&B) methods when a search tree contains chance nodes. In order to estimate the expected future cost for an ancestor chance node, every descendant produced from the ancestor chance node should be fully explored for computing the future cost of each descendant. Without this step, no upper bound solution is available for using a B&B method. Also, the estimation of a lower bound at any node n is too limited when there is any chance node down the solution path. Since the essence of partial search methods is to avoid full enumeration, the limitation of not allowing the use of a B&B method makes the tree search very challenging especially when the growth of the search space is exponential in the depth of the tree, the phenomenon being called the curse of dimensionality in nearly all practical DP or SDP applications.

In Fig. 1, we observe that some layouts are similarly repeated in the different paths of the search tree, e.g. node 3 ≈ node 32 and node 6 ≈ node 8. This observation motivates us to improve the DFS by caching the solutions for visited nodes, which will let us avoid the re-computation along the visited nodes. Because the required amount of memory for caching will be enormous in the depth of the search, we consider a more memory-efficient caching strategy. One approach to this is by caching part of the search tree to avoid node regenerations (Miura & Ishida (1999)) or by using a transposition table to detect and avoid duplicate paths in graph search (Reinefeld & Marsland (1994)). In our caching strategy, we can reduce the cache size by projecting the original states to the corresponding abstract states. This abstraction method to reduce the search space for the CRP is first studied by the earlier work of the authors (Ku & Arthanari (2016)).
                     

The projection follows two steps: (i) remove all empty columns from the stack; (ii), reorder the columns in an ascending order of the pickup priorities from the bottom tier to the top tier. For this projection to be reasonably applicable, we need to make additional assumption:

                           
                              –
                              The cost for handling a container, such as the travelling cost or time, is indifferent among different columns.

After removing the empty column(s), the layout in Fig. 3a may be represented as [(1, 2, 0), (1, 2, 4), (2, 3, 0), (1, 0, 0), (2, 4, 0)] in a 2-D array. This array can be reordered to [(1, 0, 0), (1, 2, 0), (1, 2, 4), (2, 3, 0), (2, 4, 0)], the graphical representation of which is illustrated in Fig. 3d. Likewise, layouts in Fig. 3b and c can be projected into the same abstract layout as of Fig. 3d.

We cache the abstract states only after their h(n) values have been computed. As aforementioned, h(n) values are computed with the back tracking from the leaf nodes. In the example of Fig. 1 and 2, h(6) will be computed and cached after h(n) values for node 9 and node 10 are computed and cached; h(3) will be computed and cached after h(n) values for node 6, node 7 and node 8 are computed and cached (there is only one abstract state for both node 6 and node 8); h(1) will be computed and cached after h(n) values for node 3, node 4 and node 5 are computed and cached (but the children of node 4 and node 5 do not require the re-computation, but their solutions can be looked up from the cache); h(0) will be computed after h(n) values for node 1 and node 2 are computed and cached (but the child of node 2 does not require the re-computation, but its solution can be looked up from the cache).

Although the abstraction heuristic can improve the time performance several times that of the DFS with no caching, the exact methods presented in this paper still do not show reasonable time performance for a practical use. In the following section, we introduce index-based heuristics that can be used for the domain of the CRPTW.

In this section, we propose an index-based heuristic for choosing the target column for each container above the target container to be reshuffled in. The RI is the index indicating the number of containers in the column that departs earlier than the container being reshuffled to the column. It was first defined by Murty et al. (2005a). When a container above the target container should be reshuffled during the search of the CRP, the RI heuristic chooses the column to be reshuffled to by computing the lowest RI, and the tie is broken towards the taller column and arbitrarily afterwards. However, the RI heuristic cannot calculate the index of a column in the CRPTW where there exist containers, the precedence relationship among which is unknown.

As an application of the RI heuristic to the CRPTW, the ERI is defined as the expected number of containers that depart earlier than the container being reshuffled to the column. The ERI heuristic chooses the column with the lowest ERI as the target column for the container being reshuffled. In the computational experiment, the solution quality of the selection by the ERI is compared with that of the random selection. Below we introduce the notations for the calculation of the ERI.

                        
                           –
                           
                              n: number of the containers in the column where their time windows are the same as that of the container being reshuffled to


                              pn
                              (k): the probability of having k number of earlier departing containers below the container being reshuffled to


                              fn
                              (k): the marginal contribution of having k number of earlier departing containers to the ERI


                              fn
                              : the marginal ERI of the column.

Consider a column containing n containers with the same time window as the container being reshuffled. If the container being reshuffled is to be stacked in the column, the ERI for the column remains to be computed. With the arrival of such container, we now have 
                        
                           n
                           +
                           1
                        
                      containers with the same time window. Assume that every such container is equally likely to be the earliest departing container among them. Constructing a decision tree, the root at level 0 produces 
                        
                           n
                           +
                           1
                        
                      successors as in Fig. 4.

From left to right at level 1, each immediate successor of the root observes one container of the same sequence as the earliest departure in the order of top to bottom. That is, the far left successor observes the container at the top as the earliest departure while the far right successor observes the container at the bottom as the earliest departure. The far left successor does not branch out any successors because in terms of the ERI, there is no container departing earlier than the one that just arrived in the column. The remaining successors at level 1 branch out n successors each. Let’s traverse down the second from the left successor at level 1. We branch out n successors, the first successor of which clearly has one earlier departing container. The remaining successors branch out 
                        
                           n
                           −
                           1
                        
                      successors at level 2. Again down the second branch at level 2 as in Fig. 4, we find the first successor of clearly having two earlier departing containers, thus having no further successors from there. By constructing a decision tree like this, we find the following rule to calculate the ERI.

Let k be the number of the containers in the column whose time windows are the same as the time window of the container arriving in the column, but which are later observed to depart earlier than it. The probability of reaching each leaf node having k earlier departing container(s) is 
                        
                           1
                           /
                           
                              
                                 (
                                 n
                                 +
                                 1
                                 )
                              
                              ·
                              
                                 
                                 n
                              
                              
                                 P
                                 k
                              
                           
                           ,
                        
                      and the number of such leaf nodes is 
                        n
                     
                     Pk
                     . Since pn
                     (k) is the product of these two terms and fn
                     (k) is the product of k and pn
                     (k), we find Eq. (7) and Eq. (8), respectively.

                        
                           (7)
                           
                              
                                 
                                    p
                                    n
                                 
                                 
                                    (
                                    k
                                    )
                                 
                                 =
                                 
                                    1
                                    
                                       n
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    f
                                    n
                                 
                                 
                                    (
                                    k
                                    )
                                 
                                 =
                                 
                                    k
                                    
                                       n
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     
                  

Lastly, fn
                      is the sum of fn
                     (k) where k ranges from 1 to n. Hence, we get Eq. (9), which provides us with a simple heuristic to determine the then target column to be reshuffled to. Thus, the ERI for a column will be the sum of fn
                      for the column and the number of containers whose departure time window is earlier than that of the container arriving in the column.

                        
                           (9)
                           
                              
                                 
                                    f
                                    n
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    f
                                    n
                                 
                                 
                                    (
                                    k
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    k
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    1
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 
                                    
                                       n
                                       (
                                       n
                                       +
                                       1
                                       )
                                    
                                    2
                                 
                                 =
                                 
                                    n
                                    2
                                 
                              
                           
                        
                     
                  

Numerical experiments have been performed to evaluate the performance of the abstraction heuristic and the ERI heuristic proposed in this paper. We compare the time performance for the exact methods (the DFS and the abstraction heuristic), and the solution quality for the ERI heuristic and the random selection heuristic. Instead of ranking the index for each column as in the ERI heuristic, the target column to be reshuffled to is chosen randomly in the random selection heuristic. These tests are performed using Java programming language code developed by the first author. The experiments are performed on a desktop with Intel i5-2500 Quad 3.3 gigahertz CPU, 8 gigabyte of RAM, and 64-bit Windows 7 OS.

For our experiment, we impose the ratio of distinct time windows (the number of blocks divided by the number of time windows) be around 50 percent. It is because a too high ratio of this generates instances similar to those applicable to the (deterministic) CRP, and a too low ratio may not provide us with a meaningful interpretation for our model configuration. For the comparison between the exact methods, we focus on small-scale instances. The fill rate (the number of blocks divided by the capacity) is around 50 percent. For the comparison between the ERI heuristic and the random selection heuristic, we have prepared instances, in which columns range from five to ten and tiers range from three to six. There are two groups for fill rates, 50 percent and 67 percent.


                     Table 2 summarises test scenarios for our computational experiments. Each test scenario consists of thirty instances, which are randomly generated with the aforementioned settings. The test instances used in our experiments are available from http://crp-timewindow.blogspot.com , therefore interested readers may refer to them as their benchmarking sets.

The experiments for the exact methods have been run only once per instance because the expected outcome will always be the same in every run. For the ERI heuristic and the random selection heuristic, we have run random simulation experiments, repeating 5, 000 times per instance. The reason for such simulation experiments for the heuristics is because the revelation of the earliest departing container from any chance node is stochastic. It also means that the heuristic rules apply only to decision nodes. We take the average number of reshuffling moves as the performance indicator for the heuristics, and the time performance is not reported here because the computational time for the heuristics simulation is marginal only by from a few seconds to less than one minute.


                     Table 3
                      compares the time performance between the exact methods. With the time limit of eight hours’ run per instance, we could not find the optimal solutions from some instances in larger stacks. The comparison in the data shows that the time performance of the abstraction heuristic clearly outperforms the DFS by several times (referring to DFS/abstr. column in Table 3). Consider that in the abstraction heuristic, the computation time at each node is longer than that of the DFS due to the additional processing time required for the abstraction. Hence, it is conclusive that the reduction in the re-computation for the similar nodes visited before far outweighs the processing time for the abstraction on those nodes.


                     Table 4
                      compares the solution quality in terms of the average number of reshuffling moves between the ERI heuristic and the random selection heuristic. We find that the reduction in the average number of reshuffles in the ERI heuristic over the random selection heuristic is significant by 30–40 percent under the stack configurations of the test instances. From Fig. 5
                     , we see that the performance increase by the ERI over the random selection is greater in stack configurations with more columns. The fewer the average number of reshuffles in the ERI compared with that in the random selection, the lower the ratio is.

Lastly, when we compare optimal solutions in Table 3 with the average numbers of reshuffles in Table 4, we find that the average numbers of reshuffles by the ERI are very close to the optimal solutions by the exact solution. We are aware that there are relatively a small number of stack configurations that can be solved optimally within the time limit. Thus, we may extend the time limit to provide enough evidence for the judgment on the acceptability of the ERI heuristic. However, from the stack size of 8 × 4 or bigger with the fill rate being 50 percent, the exact methods frequently encounter into instances, the number of explored nodes in which exceeds billions of nodes. With an enormous number of states to evaluate for those instances, we draw our conjecture from the available set of benchmarking data, stating that the performance of the ERI is reasonable and is applicable to stacks of any practical size.

@&#CONCLUSION@&#

In this paper, we have considered departure time windows for the CRP, which is a classic combinatorial optimisation problem in container terminals. Hence, we term this problem the CRPTW, or the CRP with time windows. We formulate an SDP model and use a search-based algorithm (the DFS) to solve the model optimally. As an improvement for the search efficiency, we introduce the abstraction heuristic, i.e. the caching method by the abstraction of states in the search tree. To overcome the computational time restriction for the exact methods, we propose the ERI heuristic, which chooses the target column at each stage of the container reshuffling by ranking the candidate columns, and benchmark its average solution quality in comparison to that of the random selection method.

Salient points from the computational experiments are as follows: First, among the two exact methods discussed in this paper, the abstraction heuristic is at least several times faster than the DFS. This indicates that the reduction of the search space by the abstraction far outweighs the additional processing time required for the abstraction on each computed node. Second, the solution quality of the ERI heuristic is much better than that of the random selection method. We see that around 30–40 percent reduction in the average number of reshuffles can be achieved by the ERI heuristic as opposed to the random selection method. Also by analysing the relationship with the stack size, we find that there is a trend of further reduction as the number of columns increases. Lastly, we find that the average numbers of reshuffles by the ERI heuristic are very close to the optimal solutions by the exact solution. Our conjecture from this result is that the ERI is a reasonably acceptable heuristic for the CRPTW.

We suggest this way of predicting the expected number of reshuffles is useful to a real-time terminal system with the TAS. The ERI heuristic calculates the expected number of reshuffles fast and with near-optimal solutions. When the terminal system is able to make use of this information (the expected number of reshuffles per stack) in real-time, their stacking policy can be enhanced further. For instance, when choosing a stack to store import containers, the terminal systems will be able to consider the expected number of reshuffles per stack, thus be able to avoid stacks having more expected number of reshuffles.

For future research, developing more advanced heuristics to compare with the heuristics presented in this paper is desirable. We also note that the exact solution provided in this paper is very limited with respect to the size of the solvable instances. Although the problem falls into a difficult category, how to enlarge the exact solution approach could be requiring future research as well.

@&#ACKNOWLEDGEMENTS@&#

Support for this work was provided by the University of Auckland Doctoral Scholarship (Code No 43). The authors would like to thank Mr. Antony de Pont, Manager of Gate Operations and Documentation at Ports of Auckland, who shared with us essential information for the Vehicle Booking System implemented at Ports of Auckland. We also thank anonymous reviewers and the editor for their suggestions that led to the improvements of this paper.

@&#REFERENCES@&#

