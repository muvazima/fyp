@&#MAIN-TITLE@&#Improving assembly precedence constraint generation by utilizing motion planning and part interaction clusters

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Spatial clustering to automatically detect and manage assembly-level part interactions.


                        
                        
                           
                           Use of motion planning to assess motion feasibility.


                        
                        
                           
                           An algorithm to generate assembly precedence constraints.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Assembly sequence planning

Motion planning

Part interaction clusters

@&#ABSTRACT@&#


               
               
                  In this paper, we present a technique that combines motion planning and part interaction clusters to improve generation of assembly precedence constraints. In particular, this technique automatically finds, and clusters, parts that can mutually affect each other’s accessibility, and hence may impose assembly constraints. This enables the generation of accurate precedence constraints without needing to examine all possible assembly sequences. Given an assembly model, our technique generates potential disassembly layers: spatial clustering is used to generate part sets. Next, motion planning based on rapidly-exploring random trees (RRT) with multiple trees is used to evaluate the interaction between these part sets. Specifically, motion planning is used to determine which part sets can be removed from the assembly. These sets are added to the first disassembly layer and removed from the assembly. Part sets that can be removed from the simplified assembly are then added to the second layer. If the process gets stuck, parts in the parent set are regrouped, and the process continues until all disassembly layers are found. The resulting structure reveals precedence relationships among part sets, which can be used to generate feasible assembly sequences for each part set and the whole assembly. We present theoretical results related to the algorithms developed in the paper. Computational results from tests on a variety of assemblies are presented to illustrate our approach.
               
            

@&#INTRODUCTION@&#

Assembling a complex product requires careful planning [1–10]. Shapes and sizes of parts in the assembly impose restrictions on the order in which assembly operations can be performed. In order to generate a detailed assembly plan, we need to first understand precedence constraints among assembly operations and be able to generate feasible sequences that are consistent with precedence constraints.

Intuitively, assembly precedence can be determined by analyzing accessibility  [2–5,11,12]. Notions of semi-infinite accessibility and infinitesimal-motion are well understood. Unfortunately, requirement of semi-infinite accessibility leads to elimination of feasible operations. On the other hand, feasibility of infinitesimal-motion alone does not guarantee that the assembly operation will be feasible. So these notions are not very useful in assembly sequence determination. However, representing accessibility in finite space is computationally challenging. So we instead would like to rely on motion planning to ensure that a proposed assembly operation is feasible.

The goal of assembly sequence planning is to generate a sequence of operations to construct a product from its individual parts. The complexity of this problem is proportional to the number of parts in the assembly  [5,13]. However, a product may be composed of a hierarchical structure, in which parts that mutually affect each other’s accessibility belong to a common cluster that form a part set; in turn multiple part sets may mutually affect each other’s accessibility constraints in the next level of assembly. Parts in such sets can be separately assembled before the final assembly of the product. Hence, the main goal of sequencing the individual parts can be divided into several subgoals that will reduce the number of assembly operations involved in each subgoal. However, the information about the interaction between part sets is not known beforehand. Therefore, we introduce a methodology to automatically detect the part interaction clusters in a product so that the assembly sequencing problem can be applied to part sets at multiple levels of hierarchy.

We start by grouping individual parts into spatial clusters based on the proximity between the parts. Each cluster identified in this way is treated as an individual part set. Now, we consider the whole assembly and use motion planning to determine which part sets can be removed from the assembly. These sets are added to the first part set removal layer and removed from the assembly. We again determine which part sets can be removed from the simplified assembly. These are then added to the second layer and removed from the assembly. If the process gets stuck, parts in the parent set are regrouped, and the process is continued until all parts have been removed from the assembly. This information is used to impose precedence constraints among the part sets. Finally, we generate feasible assembly sequences using the precedence constraints for each part set and the whole assembly.

Recent advances in rapidly-exploring random trees (RRT) based motion planning  [14] enable efficient generation of motion plans in highly crowded scenes. However, parts in their final positions in the assembly have very limited amount of feasible motions. Hence, we need to ensure that moves being tried by the RRT-based motion planner are able to correctly assess motion feasibility. This requires us to create multiple trees to ensure that if a feasible path exists, then we can find it with a very high probability.

Implementing a system based on the above ideas requires tuning a large number of parameters to ensure reasonable system performance on moderately complex assemblies. This paper describes our approach for combining RRT-based motion planning and part interaction cluster detection for generating improved precedence constraints, which in turn can be used to generate feasible assembly sequences.

The input to the system is a 3D assembly comprising a set of parts that are described by their geometric models and relative positions. Our approach takes into account product characteristics such as component geometry, inter relationships between components, component material, and tolerances. We assume that the product is made of rigid parts and restrict ourselves to finding a feasible sequence of collision-free motions for each part (part set). We define each part (part set) as a free-flying object. Therefore, we do not consider grasping of the objects, the forces involved, or the stability of the part (part set) during motion. Additionally, we consider nonlinearity in the assembly operations: an assembly operation may involve more than two part sets at the same step. We assume only monotone assembly sequences: when an operation has assembled a part into a part set, that part may no longer be moved relative to that part set. Although restrictive in application, these assumptions are very common in assembly sequencing and can be applied to a majority of products.

The approach of assembly-by-disassembly relies on constructing a disassembly sequence and then reversing the entire sequence to obtain a feasible assembly sequence. In general, the steps involved in the sequences are not necessarily symmetric, for instance, when considering flexible parts which may undergo deformation during assembly. However, under our assumptions, these two operations are indeed symmetrical.

As mentioned earlier, the main challenges encountered in assembly sequence planning include sequence generation, combinatorial explosion, nonlinearity, and interaction between part sets. The main contributions of this paper that address these problems include the following: 
                        
                           1.
                           a spatial clustering based method to automatically detect the part interaction clusters in a product.

a technique that uses a variation of RRT-based motion planning in order to assess motion feasibility.

an algorithm to generate improved assembly precedence constraints by combining the part interaction cluster detection and the motion planning methods into an assembly-by-disassembly approach.

@&#LITERATURE REVIEW@&#

Research in automated assembly sequencing has rapidly increased over the past few decades  [1–4,15–21]. The problem of finding a valid assembly sequence for general cases that allow complex combination of motions was shown to be impractical, primarily owing to the issue of combinatorial explosion  [22,23,57,58]. This led to an increase in the number of assumptions made in order to address restricted cases of the assembly sequence planning. Examples include monotone assembly sequences (each assembly operation leads to a final subassembly), two-handed assembly sequences (each assembly operation merges exactly two assembly parts or components), and nonlinear assembly sequences (at least two components are assembled at the same time).

The assembly process starts from an initial configuration in which all the parts are in a completely disassembled state and finishes with a goal configuration corresponding to the final assembly. An assembly sequence plan specifies the order in which each part and/or subassembly must be inserted into an incrementally expanding subassembly that eventually leads to the final assembly. The components to be assembled may be quite different from each other in terms of component geometry, precedence, accessibility, and other types of constraints. Therefore, assembly sequence planning for a 3D assembly, with large number of parts and complex assembly relationships between its individual parts, is a large-scale combinatorial problem  [13,24]. Although the associated constraints play an important role in limiting the number of sequences  [57,58], there are numerous combinations of valid feasible assembly sequences  [15]. Among these, some sequences optimize the assembly process with respect to one or more criteria  [25–28].

Our literature survey presents several key approaches in the field and describes methods that are closely related to the techniques presented in this paper. Interested readers may refer to some of the survey papers  [6,9,10,29,30] for a more comprehensive coverage of the field.

Woo and Dutta  [31] used the “onion peeling” approach and introduced connection graphs for disassembly analysis. Later, this approach was used by Srinivasan and Gadh  [32] to derive optimal disassembly sequences. Chen et al.  [33] used the onion peeling approach for parallel disassembly of components. Most existing methods are based on the graph theory and involve additional information such as contact analysis, fastener matrix, disassembly precedence matrix, etc. [6,9,30]; standard graph search algorithms can be applied to graph representations of assembly structures in order to determine feasible or optimal assembly sequences  [34]. Wilson and Latombe  [5] introduced non-directional blocking graph, a compact data structure to represent a combinatorial set of part intersections for an assembly product, which implicitly contains the geometric constraints  [35]. Romney et al.  [36] extended this approach into their Stanford assembly analysis tool (STAAT). Romney’s work mainly focused on developing geometric assembly planning models rather than on optimization aspects. Khosla and Roy developed an assembly sequence method from a 3D CAD model and exact geometry representation based face adjacency graph. The method used data related to the instances of parts and subassemblies to generate assembly sequences [32]. A large number of parts in this representation leads to very expensive geometric tests with the costs of nearest neighbor function and the collision checking procedure representing the major bottle necks in performance  [37]. A method to reduce the spatial representation and computational time to perform assembly simulation was introduced by Iacob et al.  [38].

De Mello and Sanderson formulated the assembly sequence problem as a discrete search and optimization problem. They proposed AND/OR graphs to represent precedence relations between parts  [1,15]. Following this approach, a variety of artificial intelligence methods were proposed using genetic algorithms  [39–42], neural networks  [43,44], data mining  [45].

Preliminary motion planning approaches were developed for integrated assembly simulation systems  [7,8,46]; the goal was to perform assembly operation planning that includes assembly sequence planning, tool planning, and task planning. Motion planning based on randomized methods have became popular in path planning. Algorithms such as probabilistic roadmaps (PRM)  [47] and RRT  [14] have been used to solve high DOF motion planning problems. However, the current motion planners may not work well on part disassembly due to highly constrained environments that require the generation of a finer motion of the parts. Sundaram et al.  [48] described the disassembly planning problem as a repeated occurrence of “narrow” passages in the Configuration space that makes it impractical to use PRM for these problems. However, Le et al.  [49] performed assembly sequence analysis based on RRT by using collision models. They also showed the complexity of the domain  [50] and the possibility of improvements to the representation. In the same direction,  [51,52] proposed some strategies to improve the performance of motion planning methods to solve the assembly sequencing problem.

Dini and Santochi  [53] formulated one of the first approaches to detect subassemblies based on a mathematical model of the product. The model was a function of the product’s interference, contact, and connection matrices. Zhang et al.  [54] described a procedure to automatically derive the feasible assembly sequence and detect the subassemblies for automobile body assembly. The procedure is based on the definition of a connection matrix and a contracted matrix. These two matrices represent the precedence constraint knowledge among components and subassemblies. Wang and Chen  [55] constructed a hierarchical assembly system and used a matrix operation to generate assembly sequences. Later, Xing et al.  [56] extended this assembly modeling to completed types of subassemblies, and thus generated feasible assembly sequences automatically. However, in all these cases, a complete description of the assembly was needed.

On the one hand, assembly sequence planning is a large-scale combinatorial problem; however, on the other hand, the assembly precedence relationships between parts make it a highly constrained problem. The number of potential assembly sequences is given by 
                        n
                        !
                     , where 
                        n
                      is the number of parts in the assembly. This leads to a combinatorial explosion in the number of sequences. In addition, the linearity assumption of placing one part at a time may not be valid in complex assemblies where some parts cannot be singly added/removed (i.e., in isolation with respect to others) and the numbers of parts to be added/removed simultaneously is not always the same. These kind of nonlinearities in assembly sequences increase the size of the solution space to 
                        
                           
                              
                                 (
                                 2
                                 n
                                 −
                                 2
                                 )
                              
                              !
                           
                           
                              
                                 (
                                 n
                                 −
                                 1
                                 )
                              
                              !
                           
                        
                     . However, absolute constraints such as geometrical, precedence, and accessibility severely reduce the number of potential assembly sequences. Nevertheless, determining these constraints for an assembly problem dramatically increases the problem complexity. Assembly sequence planning was shown to be NP-complete  [23,57,58]. As a result, most of the past and present work in this area focus on restricted variants of the problem.

In our framework, we combine motion planning and part interaction clusters in order to derive precedence relationships that can be used to generate assembly sequences for complex assemblies. We consider a mechanical product as a hierarchical structure of part sets. Usually, parts in each set can be separately assembled before the final assembly of the product. Hence, the original goal of sequencing the individual parts can be divided into several smaller subgoals that will reduce the number of assembly operations involved in each subgoal. This, thereby, reduces the combinatorial explosion of the number of sequences that span the solution space. Since the structure of interaction between the part sets is not known beforehand, we introduce a methodology to automatically extract this information so that the assembly sequencing problem can be applied to part sets at multiple levels of hierarchy.

The input to the system is a 3D assembly model of a mechanical product, which is a geometrical representation of a set of individual parts (that constitute the product) in their assembled configuration. The output of the system is a set of precedence constraints that can be used to generate a feasible assembly sequence in which components are assembled to give rise to the desired product.

The CAD models used in this paper were obtained from the META team at Vanderbilt University. These models, originally created in SolidWorks, were converted into a stereolithography (.STL) format and used as inputs to the system. Given the assembly model in .STL format, the system automatically extracts the total number of individual parts 
                           n
                         and all the implicit geometrical information based on polygonal triangulation. An example of the polygonal triangulation generation of a simplified chassis assembly is shown in Fig. 1
                        (a). The assembly model must satisfy some consistency requirements in order to have a feasible 3D workspace. For this purpose, all the assembly parts must respect their shape and volume as a rigid body in every pose; no intersections of part models in the assembled configuration are allowed. An example of error in the CAD model of a complex chassis assembly, which is caused due to intersection between two of its parts is shown in Fig. 2
                        . These issues were resolved by manually adjusting the dimensions and positions of the part causing the intersection before using the assembled model as input to the system. For example, in Fig. 2, the CAD model of the spacer part (shown in red) was modified by changing its length and position in the assembly by trial-and-error until the part intersection was resolved. In addition, the position and orientation of each part in relative and absolute reference frames are automatically queried (refer to Fig. 1(b)) and used to compute the transformation between the two frames. All the input data analysis, except resolving part intersection errors, was carried out automatically.

Next, we formalize the problem by laying out the assumptions underlying the framework, some definitions, and the problem statement as follows:


                        
                           Assumption 1
                           All parts are rigid, all connections between parts are rigid, and once a connection or liaison is made, it remains in this way.


                        
                           Assumption 2
                           Screws and nuts are included as members of the assembly; therefore, they belong to the assembly as parts. Any fastening method other than screw/nut must be removed from the 3D assembly model before our approach can be applied.


                        
                           Assumption 3
                           The geometric disassembly and assembly precedence constraints are only based on the information present in the assembly model.


                        
                           Assumption 4
                           The disassembly sequence is completely reversible to turn it into an assembly sequence.

We make the Assumption 2 as we address only assemblies that use screws and nuts for fastening. Therefore, some modifications have to be made to our framework presented in the paper before it can be applied to assemblies that use other fastening methods. For example, if glue is used for fastening two parts, then this must be specified in the input data. Then, this additional information can be used in the precedence constraints analysis accordingly.


                        
                           Definition 1
                           Posture


                           The posture of a part 
                                 ω
                               is defined as 
                                 
                                    
                                       q
                                    
                                    
                                       ω
                                    
                                 
                                 =
                                 
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          ω
                                       
                                    
                                    ,
                                    
                                       
                                          θ
                                       
                                       
                                          ω
                                       
                                    
                                    )
                                 
                              , where 
                                 
                                    
                                       p
                                    
                                    
                                       ω
                                    
                                 
                                 ∈
                                 
                                    
                                       ℜ
                                    
                                    
                                       3
                                    
                                 
                               is the position 
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          ω
                                       
                                    
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          ω
                                       
                                    
                                    ,
                                    
                                       
                                          z
                                       
                                       
                                          ω
                                       
                                    
                                    )
                                 
                               in the Euclidean space and 
                                 
                                    
                                       θ
                                    
                                    
                                       ω
                                    
                                 
                                 ∈
                                 
                                    
                                       ℜ
                                    
                                    
                                       3
                                    
                                 
                               is the orientation 
                                 
                                    (
                                    
                                       
                                          α
                                       
                                       
                                          ω
                                       
                                    
                                    ,
                                    
                                       
                                          β
                                       
                                       
                                          ω
                                       
                                    
                                    ,
                                    
                                       
                                          γ
                                       
                                       
                                          ω
                                       
                                    
                                    )
                                 
                               in the Euclidean space.


                        
                           Definition 2
                           Assembly


                           We define the assembly as a set of parts 
                                 Ω
                                 =
                                 
                                    {
                                    
                                       
                                          ω
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          ω
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          ω
                                       
                                       
                                          n
                                       
                                    
                                    ∣
                                    ∀
                                    
                                    
                                       
                                          ω
                                       
                                       
                                          i
                                       
                                    
                                    :
                                    
                                       
                                          q
                                       
                                       
                                          
                                             
                                                ω
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    ∈
                                    
                                       
                                          ℜ
                                       
                                       
                                          6
                                       
                                    
                                    ,
                                    
                                       
                                          c
                                       
                                       
                                          
                                             
                                                ω
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    ∈
                                    
                                       
                                          ℜ
                                       
                                       
                                          3
                                       
                                    
                                    }
                                 
                              , where 
                                 
                                    
                                       q
                                    
                                    
                                       
                                          
                                             ω
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                               and 
                                 
                                    
                                       c
                                    
                                    
                                       
                                          
                                             ω
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                               represent the posture and the center of mass of the part 
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                              , respectively. The set 
                                 Ω
                               includes all the parts in the input assembly.


                        
                           Definition 3
                           Obstacles


                           We define a set of obstacles 
                                 O
                                 =
                                 
                                    {
                                    
                                       
                                          o
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          o
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          o
                                       
                                       
                                          n
                                       
                                    
                                    ∣
                                    ∀
                                    
                                    
                                       
                                          o
                                       
                                       
                                          i
                                       
                                    
                                    :
                                    
                                       
                                          q
                                       
                                       
                                          
                                             
                                                o
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    ∈
                                    
                                       
                                          ℜ
                                       
                                       
                                          6
                                       
                                    
                                    }
                                 
                              , where 
                                 
                                    
                                       q
                                    
                                    
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                               represents the posture of an obstacle 
                                 
                                    
                                       o
                                    
                                    
                                       i
                                    
                                 
                              . When we select a part to evaluate its motion feasibility, all the remaining parts of the assembly are considered as potential obstacles. Therefore, initially, the set 
                                 O
                               includes all the parts in the input assembly.


                        
                           Definition 4
                           Part Set


                           A part set is defined as a set of parts and/or part subsets. A part set is considered to be a parent 
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                               for a set of child sets 
                                 
                                    {
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                       
                                          c
                                       
                                    
                                    :
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    k
                                    }
                                 
                              ; in turn, each child set is a parent for subsequent child sets, recursively, until each child is a single part. Accordingly, it is clear that the root part set 
                                 
                                    
                                       C
                                    
                                    
                                       r
                                    
                                 
                               refers to the whole assembly 
                                 Ω
                              .


                        
                           Definition 5
                           Disassembly Structure


                           The disassembly structure for a given 
                                 n
                              -part assembly 
                                 Ω
                               is defined as a set of hierarchical layers 
                                 
                                    H
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          h
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          h
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          h
                                       
                                       
                                          
                                             |
                                             
                                                H
                                             
                                             |
                                          
                                       
                                    
                                    }
                                 
                              , where 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                               represents the 
                                 i
                              th disassembly layer and 
                                 
                                    |
                                    
                                       H
                                    
                                    |
                                 
                               is the number of layers. Every layer is composed of its part sets 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          
                                             |
                                             
                                                
                                                   h
                                                
                                                
                                                   i
                                                
                                             
                                             |
                                          
                                       
                                    
                                    }
                                 
                              , where every 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                               is defined according to Definition 4 and 
                                 2
                                 ≤
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       
                                          |
                                          
                                             H
                                          
                                          |
                                       
                                    
                                 
                                 
                                    |
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    |
                                 
                                 =
                                 n
                              .


                        
                           Definition 6
                           Disassembly Part Set Precedence 
                                 ≺
                              
                           


                           Let 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                                 ∈
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                              . If 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                               can be removed only after removing 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                              , then we say 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ≺
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                              .


                        
                           Definition 7
                           Disassembly Part Set Equivalence 
                                 ∼
                              
                           


                           Let 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                                 ∈
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                              . If 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                               can be removed before 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                               and 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                               can be removed before 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                              , then we say 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ∼
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                              .


                        
                           Definition 8
                           Disassembly Layer Precedence 
                                 ≺
                                 ≺
                              
                           


                           Let 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       h
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 
                                    H
                                 
                               such that 
                                 i
                                 <
                                 j
                               (i.e., layer 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                               is generated before layer 
                                 
                                    
                                       h
                                    
                                    
                                       j
                                    
                                 
                              ), then we say 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                                 ≺
                                 ≺
                                 
                                    
                                       h
                                    
                                    
                                       j
                                    
                                 
                              . Moreover, if 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                               and 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 
                                    
                                       h
                                    
                                    
                                       j
                                    
                                 
                               then 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ≺
                                 ≺
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                              .


                        
                           Definition 9
                           Disassembly Layer Equivalence 
                                 ≈
                              
                           


                           Let 
                                 h
                                 ∈
                                 
                                    H
                                 
                              . If 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 h
                              , then we say 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ≈
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                              .


                        
                           Definition 10
                           Assembly Precedence 
                                 ⇝
                              
                           


                           Let 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                                 ∈
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                              . If 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                               can be assembled only after assembling 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                              , then we say 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ⇝
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                              .


                        
                           Definition 11
                           Assembly Equivalence 
                                 ↭
                              
                           


                           Let 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                                 ∈
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                              . If 
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                               can be assembled either before or after assembling 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                              , then we say 
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 ↭
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                    
                                       c
                                    
                                 
                              .


                        Problem statement: given a 3D assembly model of a 
                        
                           n
                        -part mechanical assembly 
                        
                           Ω
                         (Definition 2), find a disassembly structure 
                        
                           
                              H
                           
                           =
                           
                              {
                              
                                 
                                    h
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    h
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    h
                                 
                                 
                                    
                                       |
                                       
                                          H
                                       
                                       |
                                    
                                 
                              
                              }
                           
                         (Definition 5) along with a set precedence relationships 
                        
                           
                              P
                           
                        
                        that can be used to generate feasible assembly sequences.
                     

Next, we describe our overall approach to find a solution to the above problem.

Initially, with the assumption that the largest part of the assembly is the driving part that guides the assembly process, we extract this part from the given CAD model and keep it aside. If there are multiple largest parts, then heuristic information (e.g., which of these parts has maximum surface contact with the ground) is used to pick one of them. When there is lack of such information, one of them is picked randomly.

Next, we group the remaining 
                           n
                           −
                           1
                         parts into 
                           k
                           
                           
                              (
                              =
                              2
                              )
                           
                         part sets using spatial 
                           k
                        -means clustering. Under this new arrangement, the assembly is composed of 
                           k
                           +
                           1
                         part sets–the largest part, part set 1, part set 
                           2
                           ,
                           …
                         part set 
                           k
                        –in the first step. Now, we verify the assembleability of this new assembly. For this purpose, we use motion planning to determine which part sets can be removed from the assembly (explained in Section  4). These part sets are added to the first disassembly layer and removed from the assembly. We again determine which part sets can be removed from the simplified assembly. These part sets are then added to the second layer and removed from the assembly. If the process gets stuck before all part sets have been removed, we go to the first step, in which parts are rearranged into a different grouping by increasing the number of clusters by one. This results in 
                           k
                           +
                           1
                         new clusters. The cycle is continued until all part sets have been removed from the assembly and all part set removal layers are found. The techniques and algorithms used to extract part interaction clusters are described in detail, using an illustrative example, in Section  5.

Note that until now, the disassembly layers have been generated for the whole assembly while considering the identified clusters as individual part sets. Therefore, the above procedure is applied recursively to generate disassembly layers for each cluster identified in the previous step. The information extracted during the above procedure is used to impose precedence constraints among the part sets. Finally, we generate feasible assembly sequences using the precedence constraints for each part set and the whole assembly. Some theoretical results related to the properties of the proposed algorithms are presented in Section  6. Computational results from tests on a variety of assemblies are reported in Section  7.

Based on the complexity of the assembly, we cannot reject some part sets that do not pass the assembleability test. This occurs when at least two parts must be moved into their final assembly locations simultaneously. Therefore, whenever there is a failure, we recheck the assembleability for the largest assembly part and a single set obtained by merging the part sets. If the assembly structure passes the test then a temporary assembly location is needed to generate a feasible assembly sequence. This process gives us the information about the existence of nonlinearity in the assembly. An example of this assembly scenario is explained in Section  7.5.

Next, we describe the principal techniques used to implement the above approach—motion planning, generation of disassembly layers, and spatial partitioning based part interaction cluster extraction.

The capability of sampling-based motion planners to perform assembly analysis of complex product models can be mainly attributed to their computational efficiency. For example, the Manhattan-like RRT based planner presented in  [52] can handle models with hundreds of degrees of freedom. Therefore, as mentioned earlier, we rely on motion planning to evaluate the feasibility of an assembly operation. In particular, we developed a multiple RRT based motion planning algorithm to compute a collision-free escape path to move a part set from its assembled configuration to a given location that lies outside of the assembly.

Considering that the parts are moved and disassembled one by one, an assembly admits a disassembly sequence if an escape path for disassembling each part 
                        
                           
                              ω
                           
                           
                              i
                           
                        
                        ∈
                        Ω
                      can be found. Given the initial assembled state configuration 
                        
                           {
                           
                              
                                 q
                              
                              
                                 i
                                 n
                                 i
                                 t
                                 i
                                 a
                                 l
                              
                              
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           :
                           i
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           n
                           }
                        
                     , the problem consists of computing a collision free escape path, from 
                        
                           
                              q
                           
                           
                              i
                              n
                              i
                              t
                              i
                              a
                              l
                           
                           
                              
                                 
                                    ω
                                 
                                 
                                    i
                                 
                              
                           
                        
                      to a disassembled configuration 
                        
                           
                              q
                           
                           
                              g
                              o
                              a
                              l
                           
                           
                              
                                 
                                    ω
                                 
                                 
                                    i
                                 
                              
                           
                        
                      for all 
                        
                           
                              ω
                           
                           
                              i
                           
                        
                        ∈
                        Ω
                     .

Rapidly-exploring random trees (RRT) based motion planning provides feasible solutions for part navigation in crowded scenes, a problem representative of searching non-convex, high-dimensional spaces. A RRT is constructed incrementally by randomly sampling valid configuration states and quickly computing the nearest neighbor to states that already belongs to the tree. This process quickly reduces the expected distance of a randomly-chosen point to the tree. However, RRT cannot be directly applied to complex assemblies that are composed of large number of parts, which often lead to scenes with high obstacle densities. The large number of obstacles generates a highly constrained environment with very narrow passages, resulting in the RRT’s failure to generate a valid state. This, thereby, increases the false negatives dramatically.

In order to assess the assembly feasibility, we used the RRT with multiple random trees based motion planning approach described in our earlier work  [59]. The approach performs a robust analysis of part motion feasibility. It uses multiple RRTs that dynamically modify the environment description in order to generate a valid escape path. It dynamically modifies the number of trees for each assembly part based on the environment constraints associated with the part. A highly constrained environment may require a large number of trees to find the escape path for an assembly part. Multiple RRTs provide greater robustness across narrow passages and crowded environments.

Strandberg  [60] proposed a multiple RRT algorithm, in which the number of trees is kept fixed. However, in our approach, the number of trees is changed on-the-fly; that is, a new tree is added only if it is required by merging the information about the “old” tree with the “new” tree instantaneously, thereby, increasing the probability of finding a valid state in the next step by using the knowledge of the previous trees.


                     
                        
                           
                        
                     
                  

The motion planning technique uses the geometric information extracted from the assembly model to find an escape path that allows a part to be completely separated from the assembly. This enables the system to determine which part movements are forbidden, which movements are feasible, and thereby, determine which part(s) can be removed at each stage of disassembly. Using Definition 5, we consider a hierarchical disassembly structure 
                           
                              H
                           
                           =
                           
                              {
                              
                                 
                                    h
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    h
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    h
                                 
                                 
                                    
                                       |
                                       
                                          H
                                       
                                       |
                                    
                                 
                              
                              }
                           
                        , such that 
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                           ≺
                           ≺
                           
                              
                                 h
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           ,
                           ∀
                           i
                           ≠
                           
                              |
                              
                                 H
                              
                              |
                           
                        . Therefore, each layer 
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                         represents a precedence constraint for the layer 
                           
                              
                                 h
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         for disassembly.

For simplicity, we first describe the generation of disassembly layers without grouping part into clusters and by applying motion planning only to individual parts. Specifically, the system considers each part and uses the motion planning algorithm to check if it is physically blocked by another part before it can be fully removed out of the assembly. Parts that can be removed in this manner during the first attempt fill the first layer 
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                        . This process is repeated to fill the second layer 
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                         and so on, until all the parts are disassembled. As a result, the process is bounded by a maximum of 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                         iterations. The resulting hierarchically layered structure comprising part groups that can be removed at each layer gives rise to disassembly precedence relations. Generation of such disassembly layers for a chassis assembly of 23 parts is shown in Fig. 3
                        .

The disassembly layers generated by the above process can be reversed and turned into a linear assembly sequence as shown in Algorithm 1. However, the above process does not fully represent the precedence relations between parts across different layers. For instance, 
                           H
                         provides precedence relation between layers 
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                           ≺
                           ≺
                           
                              
                                 h
                              
                              
                                 j
                              
                           
                         for disassembly. Therefore, if 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                           ∈
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 ω
                              
                              
                                 j
                              
                           
                           ∈
                           
                              
                                 h
                              
                              
                                 j
                              
                           
                        , then 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                           ≺
                           ≺
                           
                              
                                 ω
                              
                              
                                 j
                              
                           
                        . That is 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                         can be removed before 
                           
                              
                                 ω
                              
                              
                                 j
                              
                           
                        . However, this does not necessarily imply whether or not 
                           
                              
                                 ω
                              
                              
                                 j
                              
                           
                         can be removed before 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                        . Consequently, we do not know for sure if 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                           ⇝
                           
                              
                                 ω
                              
                              
                                 j
                              
                           
                         for assembly. Also, the precedence relations between the parts in the same layer are not evaluated by this method.

In the next subsection, we show how the assembly structure identified by our new approach reveals improved precedence relationships by reorganizing the parts in different layers into different part sets.

We developed a spatial partitioning algorithm based on 
                           k
                        -means clustering technique in order to generate part interaction clusters. 
                           K
                        -means clustering is a method commonly used to automatically partition a data set into 
                           k
                         groups. It proceeds by selecting 
                           k
                         initial cluster centers and then iteratively refining them as follows: (a) each instance 
                           
                              
                                 c
                              
                              
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                              
                           
                         is assigned to its closest cluster. (b) each cluster center 
                           
                              
                                 C
                              
                              
                                 j
                              
                           
                         is updated to be the mean of its constituent instances. The algorithm converges when there is no further change in the assignment of instances to clusters or alternatively, when there is no change in the location of the cluster centers. The pseudocode for spatial clustering is given in Algorithm 2.


                        
                           
                              
                           
                        
                     

We illustrate the part interaction cluster extraction technique using the example shown in Fig. 4
                        . We initialize the number of clusters 
                           K
                           =
                           2
                         and initialize the cluster centers using instances chosen at random from the assembly set 
                           Ω
                        . The data set is composed of 3D positions that represent the center of mass 
                           
                              
                                 c
                              
                              
                                 i
                              
                              
                                 ω
                              
                           
                         of each part 
                           
                              
                                 ω
                              
                              
                                 i
                              
                           
                        . We use the Euclidean distance metric to compute closeness of a data point to cluster centers. The cluster centers of the product affect the assembly feasibility in the sense that the resulting parts in one cluster may or may not be physically separated from the parts in other clusters. Therefore, whenever a part partitioning corresponding to a set of cluster centers is not assemblable, then 
                           K
                         is incremented by 1 and new cluster centers are identified. This process is repeated until cluster centers that lead to a successful partitioning are found.

Every time an assembly set is repartitioned into a set of 
                           K
                         clusters, we must test whether the new organization of the parts is feasible to assemble or not. For this purpose, we treat these clusters as individual part sets by merging all elements that belong to one cluster into one part set. Therefore, the reorganized assembly structure is composed of the set 
                           
                              
                                 Ω
                              
                              
                                 r
                                 e
                                 o
                                 r
                                 g
                              
                           
                           =
                           
                              {
                              
                                 
                                    ω
                                 
                                 
                                    r
                                    e
                                    s
                                    t
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    K
                                 
                              
                              }
                           
                        , where 
                           
                              
                                 ω
                              
                              
                                 r
                                 e
                                 s
                                 t
                              
                           
                         is either the largest part in the first iteration or the merged part set composed of all the assembly elements excluded from the current partitioning analysis. The pseudocode used to implement assembleability testing is shown in Algorithm 3. We introduce a parameter 
                           
                              
                                 c
                              
                              
                                 
                                    min
                                 
                              
                           
                        , which represents the minimum number of elements contained in a valid cluster. That is, whenever 
                           
                              |
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              |
                           
                           ≤
                           
                              
                                 c
                              
                              
                                 
                                    min
                                 
                              
                           
                        , 
                           
                              
                                 C
                              
                              
                                 i
                              
                           
                         is not partitioned further. In all our experiments 
                           
                              
                                 c
                              
                              
                                 
                                    min
                                 
                              
                           
                           =
                           6
                        .
                           1
                        
                        
                           1
                           A low value of 
                                 c
                                 min
                                 
                                 
                                    (
                                    =
                                    6
                                    )
                                 
                               for the cluster results in obtaining manageable part clusters at the leaf node of the assembly tree structure whenever possible. Similar results will be obtained if this value is changed to 5 or 7.
                        
                     

The first cycle of partitioning (
                           K
                           =
                           2
                        ) is shown in Fig. 5
                        . In this case, the reorganized assembly 
                           
                              
                                 Ω
                              
                              
                                 r
                                 e
                                 o
                                 r
                                 g
                              
                           
                         is composed of three part sets: part set 
                           A
                        , part set 
                           B
                        , and 
                           
                              
                                 ω
                              
                              
                                 r
                                 e
                                 s
                                 t
                              
                           
                        , which is equal to the largest part of the assembly 
                           
                              
                                 ω
                              
                              
                                 l
                                 a
                                 r
                                 g
                                 e
                                 s
                                 t
                              
                           
                         detected at the beginning of the algorithm. Symbolically, 
                           
                              
                                 Ω
                              
                              
                                 r
                                 e
                                 o
                                 r
                                 g
                              
                           
                           =
                           
                              {
                              
                                 
                                    ω
                                 
                                 
                                    l
                                    a
                                    r
                                    g
                                    e
                                    s
                                    t
                                 
                              
                              ,
                              A
                              ,
                              B
                              }
                           
                        . The motion planning module finds that the resulting assembly structure is assembleable. Therefore, the algorithm proceeds to the second cycle of partitioning. Note that 
                           
                              |
                              A
                              |
                           
                           =
                           4
                           
                           
                              (
                              <
                              
                                 
                                    c
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              )
                           
                        . Therefore, 
                           A
                         does not undergo further partitioning. However, note that 
                           
                              |
                              B
                              |
                           
                           =
                           18
                           
                           
                              (
                              >
                              
                                 
                                    c
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              )
                           
                        . Therefore, 
                           B
                         is further partitioned into 
                           C
                         and 
                           D
                         as shown in Fig. 6
                        . The new assembly is composed of three part sets 
                           C
                        , 
                           D
                        , and 
                           
                              
                                 ω
                              
                              
                                 r
                                 e
                                 s
                                 t
                              
                           
                        , where 
                           
                              
                                 ω
                              
                              
                                 r
                                 e
                                 s
                                 t
                              
                           
                         is a merged part set composed of 
                           
                              
                                 ω
                              
                              
                                 l
                                 a
                                 r
                                 g
                                 e
                                 s
                                 t
                              
                           
                         and 
                           A
                        . Therefore, 
                           
                              
                                 Ω
                              
                              
                                 r
                                 e
                                 o
                                 r
                                 g
                              
                           
                           =
                           
                              {
                              
                                 
                                    ω
                                 
                                 
                                    l
                                    a
                                    r
                                    g
                                    e
                                    s
                                    t
                                 
                              
                              ,
                              A
                              ,
                              
                                 (
                                 B
                                 →
                                 C
                                 +
                                 D
                                 )
                              
                              }
                           
                        . The updated assembly structure is verified to be assemblable. In the third cycle, 
                           C
                         does not undergo partitioning (
                           
                              |
                              C
                              |
                           
                           =
                           6
                        ) and 
                           D
                         is partitioned into 
                           E
                         and 
                           F
                           
                           
                              (
                              
                                 |
                                 D
                                 |
                              
                              =
                              12
                              )
                           
                         (Fig. 7
                        ). Similarly, 
                           F
                         is partitioned into 
                           G
                         and 
                           H
                         (Fig. 8
                        ). However, the motion planning module finds that the resulting partitioning is not feasible for assembly. We continue repartitioning of a invalid cluster only when at least one of its sub-clusters contains 
                           
                              
                                 c
                              
                              
                                 
                                    min
                                 
                              
                           
                         elements. Since 
                           
                              |
                              G
                              |
                           
                           <
                           6
                         and 
                           
                              |
                              H
                              |
                           
                           <
                           6
                        , the algorithm halts resulting in 
                           F
                         as a single part set. Therefore, we obtain the final assembly structure 
                           
                              
                                 Ω
                              
                              
                                 r
                                 e
                                 o
                                 r
                                 g
                              
                           
                           =
                           
                              {
                              
                                 
                                    ω
                                 
                                 
                                    l
                                    a
                                    r
                                    g
                                    e
                                    s
                                    t
                                 
                              
                              ,
                              A
                              ,
                              
                                 (
                                 B
                                 →
                                 
                                    (
                                    C
                                    +
                                    
                                       (
                                       D
                                       →
                                       E
                                       +
                                       F
                                       )
                                    
                                    )
                                 
                                 )
                              
                              }
                           
                        . The pseudocode to implement the spatial partitioning and motion planning based automated generation of assembly precedence constraints is given in Algorithm 4.


                        
                           
                              
                           
                        
                     


                        
                           
                              
                           
                        
                     

As mentioned earlier, a linear assembly sequence is one in which each operation places a single part into the assembly. Although not all products can be assembled linearly, such sequences are used in manufacturing owing to their simplicity. Here, we showed that our approach can be used to achieve more complex organizational levels in which assembly of part sets can be assigned to different stations and later, these part sets can be put together to form the final assembly.

In this section, we present some theoretical results related to the techniques and the associated algorithms developed in this paper. The notations and definitions used in the lemmas and theorems were described in Section  3.1.


                     
                        Lemma 1
                        Transitive Precedence


                        
                           If 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                            
                           and 
                           
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                              
                           
                           , then 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                              
                           
                           .
                        


                     
                        Proof
                        
                           
                              
                                 
                                    
                                       Let
                                       
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             k
                                          
                                       
                                       ∈
                                       
                                          H
                                       
                                       .
                                    
                                 
                                 
                                    (1)
                                    
                                       From Definition 6, we have
                                       
                                       
                                          
                                             C
                                          
                                          
                                             j
                                          
                                       
                                       ≺
                                       
                                          
                                             C
                                          
                                          
                                             k
                                          
                                       
                                       ⇒
                                       
                                          
                                             C
                                          
                                          
                                             k
                                          
                                       
                                         can be removed only after removing  
                                       
                                          
                                             C
                                          
                                          
                                             j
                                          
                                       
                                       .
                                    
                                 
                                 
                                    (2)
                                    
                                       However,  
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ≺
                                       
                                          
                                             C
                                          
                                          
                                             j
                                          
                                       
                                       ⇒
                                       
                                          
                                             C
                                          
                                          
                                             j
                                          
                                       
                                         can be removed only after removing  
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       .
                                    
                                 
                                 
                                    
                                       Therefore, from (1) and (2), we have
                                       
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ≺
                                       
                                          
                                             C
                                          
                                          
                                             k
                                          
                                       
                                       .
                                    
                                 
                              
                           
                           □

For example, in the 23-part assembly (Fig. 3), Part-23 
                        ≺
                      Part-4 and Part-4≺Part-5. Therefore, according to Lemma 1, Part-23 
                        ≺
                      Part-5. Also, from visual inspection of the exploded view of the part assembly (Fig. 3(b)), it can be verified that Part-23 must be removed before removing Part-5, which is consistent with the above lemma.


                     
                        Lemma 2
                        
                           Let 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ∈
                              H
                            
                           . Now, if 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≈
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           
                           then 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∼
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           
                           .
                        


                     
                        Proof
                        
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≈
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ⇒
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ∈
                              h
                            for some 
                              h
                              ∈
                              H
                           . That is, the part sets belong to the same layer. Therefore, from Definitions 5 and 6, we have 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∼
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           . □


                     
                        Remark 1
                        Note that the converse may or may not be true.

For example, in the 23-part assembly (Fig. 3), Part-16≈Part-17 (the two parts belong to the same layer). Therefore, Part-16∼Part-17 (Part-16 can be removed before Part-17 and vice-versa). Note that Part-6∼Part-4. However, the converse, Part-6≈Part-4, is not true.


                     
                        Lemma 3
                        
                           Let 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            
                           and 
                           
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                            
                           for some 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                              ∈
                              H
                           
                           , where 
                           
                              i
                              ≠
                              j
                            
                           . Now, if 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           
                           then 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           
                           .
                        


                     
                        Proof
                        Suppose 
                              ¬
                              
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ≺
                                 ≺
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           . This implies 
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                            or 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≈
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           .

If 
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           , from Definition 8
                           
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                           . This implies 
                              ¬
                              
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ≺
                                 
                                    
                                       C
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           , which is a contradiction.

If 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≈
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           , then from Lemma 2, we have 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∼
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           , which is also a contradiction. Therefore, we have the result. □


                     
                        Remark 2
                        Note that, the converse may or may not be true. In particular, the converse is true if, additionally, there is no 
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                              
                           , 
                              k
                              ≠
                              i
                            such that 
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           .

For example (Fig. 3), Part-4≺Part-5. From Lemma 3, Part-4≺≺Part-5. Note that the converse is also true as Part-3≺Part-5 is not true. Now, Part-4≺≺Part-6. However, the converse, Part-4≺Part-6, is not true.


                     
                        Theorem 1
                        
                           For any two adjacent layers 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            
                           and 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           
                           , a layer precedence relationship 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                            
                           is established if and only if, for every part set 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              ∃
                            
                           at least one part set 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            
                           such that 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           
                           .
                        


                     
                        Proof
                        First, we prove the “if” part: Let 
                              ℧
                              ⊆
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            such that 
                              
                                 |
                                 ℧
                                 |
                              
                              ≥
                              1
                            and 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              ∀
                              
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              ℧
                           . Using Lemma 3, we have 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              ∀
                              
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              ℧
                           . This implies 
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           . Hence, the “if part” is proved.

Next, we prove the “only if” part: 
                              
                                 (3)
                                 
                                    Given
                                    
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    ≺
                                    ≺
                                    
                                       
                                          h
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    .
                                 
                              
                            Suppose the result is untrue. That is, for some part set 
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           , 
                              ¬
                              
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 ≺
                                 
                                    
                                       C
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 )
                              
                            for every 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                           . 
                              
                                 
                                    (4)
                                    
                                       ⇒
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ∼
                                       
                                          
                                             C
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       ,
                                       
                                       ∀
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                    (5)
                                    
                                       or
                                       
                                       
                                          
                                             C
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       ≺
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       ∀
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 (4)
                              
                              ⇒
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                           . However, this is a contradiction, since 
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              ∩
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              =
                              0
                           .


                           
                              
                                 (5)
                              
                              ⇒
                              
                                 
                                    C
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                            (From Lemma 3). Equivalently, 
                              
                                 
                                    h
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                           , which is also a contradiction. Hence, we have the result. □

From Fig. 3(c), 
                        
                           
                              h
                           
                           
                              2
                           
                        
                        ≺
                        ≺
                        
                           
                              h
                           
                           
                              3
                           
                        
                     , where 
                        
                           
                              h
                           
                           
                              2
                           
                        
                        =
                        
                           {
                           Part-2, Part-11, Part-14
                           ,
                           Part-20
                           }
                        
                      and 
                        
                           
                              h
                           
                           
                              3
                           
                        
                        =
                        
                           {
                           Part-21, Part-22
                           }
                        
                     . Note that Part-2≺Part-21and Part-2≺Part-22. That is, for every Part-i 
                        ∈
                        
                           
                              h
                           
                           
                              3
                           
                        
                     , there exists at least one Part-j 
                        ∈
                        
                           
                              h
                           
                           
                              2
                           
                        
                      such that Part-j 
                        ≺
                      Part-i. This is consistent with Theorem 1. Note that Part-21 and Part-22 have no individual precedence relationships with the remaining parts in 
                        
                           
                              h
                           
                           
                              2
                           
                        
                      even though they fall in different layers.

From Theorem 1, we can state the following corollary.


                     
                        Corollary
                        
                           For any two layers 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            
                           and 
                           
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                           
                           , a layer precedence relationship 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              ≺
                              ≺
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                            
                           is established if and only if, for every part set 
                           
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    j
                                 
                              
                              ,
                              ∃
                            
                           at least one part set 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                            
                           such that 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                              ≺
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                              
                           
                           .
                        

From Fig. 3(c), 
                        
                           
                              h
                           
                           
                              1
                           
                        
                        ≺
                        ≺
                        
                           
                              h
                           
                           
                              3
                           
                        
                     , where 
                        
                           
                              h
                           
                           
                              1
                           
                        
                        =
                        
                           {
                        
                     Part-8, Part-9, Part-10, Part-12, Part-13, Part-15, Part-16, Part-17, Part-18
                        
                           }
                        
                     . Note that Part-12 
                        ≺
                      Part-21 and Part-13 
                        ≺
                      Part-22, which is consistent with the above corollary.


                     
                        Theorem 2
                        
                           Given the 
                           
                              n
                           
                           -part assembly 
                           
                              Ω
                           
                           , the part interaction clusters extracted by Algorithm  4  admit a tree structure 
                           
                              T
                            
                           with 
                           
                              Ω
                            
                           as its root part set and a monotonically decreasing bound on its branching factor. Further, the branching converges in a finite number of partition levels that is bounded by 
                           
                              n
                              −
                              2
                           
                           .
                        


                     
                        Proof
                        Let 
                              Ω
                              =
                              
                                 {
                                 
                                    
                                       ω
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       ω
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       ω
                                    
                                    
                                       n
                                    
                                 
                                 }
                              
                           . Applying Algorithm 4, we get 
                              Ω
                              =
                              
                                 
                                    C
                                 
                                 
                                    r
                                 
                              
                              =
                              
                                 {
                                 
                                    
                                       C
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       k
                                    
                                 
                                 ,
                                 
                                    
                                       ω
                                    
                                    
                                       l
                                       a
                                       r
                                       g
                                       e
                                       s
                                       t
                                    
                                 
                                 }
                              
                           , where each 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                            is a child part set of the parent part set 
                              
                                 
                                    C
                                 
                                 
                                    r
                                 
                              
                            according to the Definition 4 and 
                              
                                 
                                    ω
                                 
                                 
                                    l
                                    a
                                    r
                                    g
                                    e
                                    s
                                    t
                                 
                              
                            is the largest part. Algorithm 4 is applied recursively on each child part set until each part set is a single part. By considering each part set as a node and connecting each child part set to its parent by an edge, the resulting part sets can be represented by a tree structure 
                              T
                           , where 
                              Ω
                            is the root node.

Let 
                              
                                 
                                    C
                                 
                                 
                                    p
                                 
                              
                              =
                              
                                 {
                                 
                                    
                                       C
                                    
                                    
                                       1
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       2
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       r
                                    
                                    
                                       c
                                    
                                 
                                 }
                              
                            for some node 
                              
                                 
                                    C
                                 
                                 
                                    p
                                 
                              
                              ∈
                              T
                           . Note that the branching factor at 
                              
                                 
                                    C
                                 
                                 
                                    p
                                 
                              
                              =
                              r
                           . The corresponding bound on the branching factor is 
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                                 |
                              
                           . This implies 
                              2
                              ≤
                              r
                              ≤
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                                 |
                              
                           . Similarly, the bound on branching factor at each 
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                                 
                                    c
                                 
                              
                              ∈
                              
                                 
                                    C
                                 
                                 
                                    p
                                 
                              
                              =
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 |
                              
                           . However, 
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       c
                                    
                                 
                                 |
                              
                              <
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       p
                                    
                                 
                                 |
                              
                           , which implies a monotonically decreasing bound on the branching factor of the tree. Note that the maximum bound on the branching factor is 
                              n
                              −
                              1
                           , which occurs at the first partition level.

Consider a path from the root node to the leaf node. We note that the maximum number of partition levels is obtained by choosing a 
                              k
                              =
                              2
                            partition at each level 
                              i
                           , with 
                              
                                 |
                                 n
                                 −
                                 1
                                 −
                                 i
                                 |
                              
                            number of part sets in one partition and a single part in the other partition. This results in the following branching structure:
                              
                                 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             1
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                C
                                             
                                             
                                                2
                                             
                                          
                                          ,
                                          ω
                                          :
                                          
                                             |
                                             
                                                
                                                   C
                                                
                                                
                                                   2
                                                
                                             
                                             |
                                          
                                          =
                                          n
                                          −
                                          2
                                          ,
                                          ω
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                1
                                             
                                          
                                          −
                                          
                                             
                                                C
                                             
                                             
                                                2
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             2
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                C
                                             
                                             
                                                3
                                             
                                          
                                          ,
                                          ω
                                          :
                                          
                                             |
                                             
                                                
                                                   C
                                                
                                                
                                                   3
                                                
                                             
                                             |
                                          
                                          =
                                          n
                                          −
                                          3
                                          ,
                                          ω
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                2
                                             
                                          
                                          −
                                          
                                             
                                                C
                                             
                                             
                                                3
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       ⋮
                                    
                                 
                                 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                C
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                          ,
                                          ω
                                          :
                                          
                                             |
                                             
                                                
                                                   C
                                                
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             |
                                          
                                          =
                                          n
                                          −
                                          i
                                          −
                                          1
                                          ,
                                          ω
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                i
                                             
                                          
                                          −
                                          
                                             
                                                C
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       ⋮
                                    
                                 
                                 
                                    (6)
                                    
                                       
                                          
                                             C
                                          
                                          
                                             n
                                             −
                                             2
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                C
                                             
                                             
                                                n
                                                −
                                                1
                                             
                                          
                                          ,
                                          ω
                                          :
                                          
                                             |
                                             
                                                
                                                   C
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             |
                                          
                                          =
                                          1
                                          ,
                                          ω
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                n
                                                −
                                                2
                                             
                                          
                                          −
                                          
                                             
                                                C
                                             
                                             
                                                n
                                                −
                                                1
                                             
                                          
                                          }
                                       
                                       .
                                    
                                 
                              
                            From (6), 
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 |
                              
                              =
                              1
                           . This implies that the branching terminates since the minimum number of parts in a part set for it to be partitioned is two. Therefore, Algorithm 4 partitions 
                              Ω
                            into part sets in a finite number of partition levels, which is bounded by 
                              n
                              −
                              2
                           . □

The tree structures obtained for the 23-part chassis assembly, the 73-part chassis assembly, the crank shaft assembly, and the radial engine assembly are shown in Figs. 11, 14, 17 and 20, respectively. In all these examples, the branching converges in a finite number of partition levels.


                     
                        Theorem 3
                        
                           The number of possible assembly sequences 
                           
                              A
                              
                                 
                                    S
                                 
                                 
                                    n
                                 
                              
                            
                           of an 
                           
                              n
                           
                           -part assembly based on part interaction cluster structure extracted by Algorithm xmlrm 4 is 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    n
                                    −
                                    1
                                 
                              
                              S
                              
                                 
                                    A
                                 
                                 
                                    i
                                 
                              
                              ⋅
                           
                           
                              S
                              
                                 
                                    A
                                 
                                 
                                    n
                                    −
                                    i
                                 
                              
                           
                           , where 
                           
                              S
                              
                                 
                                    A
                                 
                                 
                                    i
                                 
                              
                            
                           is the number of possible assembly sequences for the parent part set with 
                           
                              i
                            
                           child part sets.
                        


                     
                        Proof
                        Let Algorithm 4 partition the parts into two part sets 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                           . Let 
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       1
                                    
                                 
                                 |
                              
                              =
                              u
                            and 
                              
                                 |
                                 
                                    
                                       C
                                    
                                    
                                       2
                                    
                                 
                                 |
                              
                              =
                              v
                            such that 
                              u
                              +
                              v
                              =
                              n
                           , for some 
                              u
                            and 
                              v
                              ∈
                              
                                 
                                    ℵ
                                 
                                 
                                    +
                                 
                              
                           . Accordingly, let us assume assembling 
                              u
                            parts and 
                              v
                            parts separately, and then combining the 
                              u
                           -part and 
                              v
                           -part sets to form the 
                              n
                           -part assembly. In this particular case, the total number of possible assembly sequences of an 
                              n
                           -part assembly is 
                              S
                              
                                 
                                    A
                                 
                                 
                                    u
                                 
                              
                              ⋅
                              S
                              
                                 
                                    A
                                 
                                 
                                    v
                                 
                              
                           . In the general case, 
                              S
                              
                                 
                                    A
                                 
                                 
                                    n
                                 
                              
                            is the sum of all such cases: 
                              
                                 
                                    A
                                    
                                       
                                          S
                                       
                                       
                                          n
                                       
                                    
                                    =
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                    ⋅
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    +
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          2
                                       
                                    
                                    ⋅
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          n
                                          −
                                          2
                                       
                                    
                                    +
                                    ⋯
                                    +
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    ⋅
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          i
                                       
                                    
                                    ⋅
                                    S
                                    
                                       
                                          A
                                       
                                       
                                          n
                                          −
                                          i
                                       
                                    
                                    .
                                 
                              
                           
                           □

We report the results from application of our technique to four different assemblies: (a) Chassis assembly (b) Crankshaft assembly (c) Radial crankshaft assembly, and (d) The five part puzzle.

In the previous section, we used the 23-part chassis assembly (Fig. 4(a)) in order to illustrate our approach of combining part interaction cluster extraction and motion planning to generate assembly sequences. Fig. 9
                        (a) shows the part sets identified by the system and Fig. 9(b) shows the corresponding assembly structure representing the precedence relations between different part sets and individual parts within each part set. Note that the algorithm identifies four part sets, in which 
                           F
                         precedes 
                           E
                           
                           
                              (
                              F
                              ≺
                              E
                              )
                           
                         and the rest of the part sets do not have any additional precedence constraints. This means that 
                           A
                        , 
                           C
                        , and 
                           F
                         can be fit into the assembly (part 1) in any order, but 
                           E
                         must be assembled after 
                           F
                        . Also, note that the individual parts in each set can be assembled in parallel at different locations without any precedence between parts across different part sets. However, note that individual parts admit precedence relations with each other within each part set. The disassembly layers generated by the approach used in our earlier work  [59] can be reversed and turned into a linear assembly sequence. However, they do not fully represent the precedence relations between parts across different layers. In contrast, the algorithm developed in this paper combines part cluster detection and disassembly layer extraction to generate precedence constraints for assembly. This distinction is illustrated in Fig. 10
                        . For instance, part 16 belongs to the first disassembly layer and part 7 belongs to the seventh disassembly layer (Fig. 10(a)). This implies that part 7 can be assembled before part 16. However, it is not clear if the converse is true. The assembly structure identified by the new approach (Fig. 10(b)) clarifies this precedence relation: Part 7 and part 16 have no precedence constraint with respect to each other. That is, the set of parts (
                           
                              {
                              2
                              ,
                              3
                              ,
                              4
                              ,
                              5
                              ,
                              6
                              ,
                              12
                              ,
                              13
                              ,
                              21
                              ,
                              22
                              ,
                              23
                              }
                           
                        ) that has to be removed before part 7 can be removed does not include part 16. The new assembly structure reveals these precedence relationships by reorganizing the parts in individual layers into interaction clusters, while maintaining the same hierarchy of layers found in Fig. 10(a). Fig. 11
                        (a) and (b) show the directed acyclic graph representation of the assembly structures obtained by the two techniques, respectively.

Now, we report results on a more complex assembly comprising 74 parts, which is obtained by augmenting the previous assembly with 51 new parts. Two views of this 74-part chassis assembly are shown in Fig. 12
                        . The disassembly layer generation and the directed acyclic graph representation of the assembly structure are shown in Figs. 13 and 14
                        
                        , respectively.

The crankshaft assembly, shown in Fig. 15
                        , consists of 41 assembly parts: one crank shaft, 4 shafts, 4 lower shafts, 4 inner bearings, 4 bearings, 8 pins, 12 rings, and 4 piston heads. The disassembly generation of a past-set identified by the algorithm is shown in Fig. 16
                        . Fig. 17
                         shows the directed acyclic graph representation of the assembly structure extracted by the algorithm. From this figure, it is clear that the algorithm correctly identifies a feasible nested configuration of part set.

The radial crankshaft assembly, shown in Fig. 18
                        , consists of 50 assembly parts: one master shaft, one radial bearing, 4 shafts, 4 bolts, 5 inner bearings, 5 bearings, 10 pins, 15 rings, and 5 piston heads. The disassembly generation of a part set identified by the algorithm is shown in Fig. 19
                        . Fig. 20
                         shows the directed acyclic graph representation of the assembly structure extracted by the algorithm. From this figure, it is clear that the algorithm correctly identifies a feasible nested configuration of part set.

The five-part puzzle (Fig. 21
                        ) is used to illustrate the ability of the algorithm to deal with the issue of nonlinearity. In particular, this assembly example is representative of a scenario in which some parts cannot be assembled one by one in a linear order; rather, they must be simultaneously moved to their final assembly locations. The algorithm implementation can be explained in the following steps:


                        
                           
                              1.
                              find part sets to test feasibility with 
                                    
                                       
                                          C
                                       
                                       
                                          
                                             min
                                          
                                       
                                    
                                    =
                                    1
                                 . No feasible partition is found with 
                                    k
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    3
                                  and 4.

test feasibility with the largest part + a single part containing the four remaining parts. The assembly structure passes the test. The result of this step is that the set of four parts must be assembled before placing in the final position.

recursively partition the four-part set and test feasibility. This results in two part sets 
                                    A
                                  and 
                                    B
                                 .

The resulting assembly sequence is given below: 
                           
                              1.
                              assemble the two parts in part set 
                                    A
                                 .

assemble the two parts in part set 
                                    B
                                 .

assemble the previous two part sets into one single part set.

assemble the resulting part set into its final position inside the largest part.

@&#CONCLUSIONS@&#

We presented a framework that combined motion planning techniques and part interaction cluster extraction to guide the generation of feasible assembly sequences for complex mechanical assemblies. These assembly sequences can be used to generate instructions for assembly operations performed by humans  [61]. We showed that our approach can be used to achieve complex organizational levels of an assembly in which assembly of part sets can be assigned to different stations and later, these part sets can be put together to form the final assembly. We also showed how our approach addresses the issue of nonlinearity in assemblies. The system generated the assembly precedence constraints directly from 3D assembly models as it used only information about geometric and physical constraints. In situations where part assembly involves a single translation and a single rotation, methods without using path planning are computationally more efficient than our approach. However, our approach performs better when applied to more complex assemblies that involve multiple translations and rotations. Our approach explores many different feasible assembly directions. Our approach checks for feasibility in a given assembly state. So it can handle situations where different directions become feasible based on the state of the assembly. For example, if the left direction is blocked in a given assembly state, and the right direction is checked for feasibility and selected (if appropriate).

Our approach presented in the paper considered each part as a free-flying object. However, in a realistic scenario, as tools and human hand operations will be used during assembly, some of the precedence constraints generated by our approach may become infeasible. In order to address this issue, our approach must be augmented by incorporating motion planning for human-hand and tool models into the formulation. This will result in the generation of modified precedence constraints that cater to the spatial constraints imposed by the tools and the hands. Our technique was proposed for mechanical assemblies that are composed of finite numbers of non deformable parts. Hence, assemblies that contain flexible parts, where the flexible property of a part is exploited to fit it into the assembly, were out of the current scope of our current approach. In addition, an analysis beyond pure geometric reasoning is required for assemblies that contain parts requiring force for placement.

@&#ACKNOWLEDGMENTS@&#

This work was partially supported by DARPA AVM iFab Project (Contract # FA8650-11-C-7128). This project was a large collaborative effort involving Carnegie Mellon University, Lockheed Martin, Pratt and Miller, University of Maryland, and University of Michigan. We acknowledge and thank all members of our team for their valuable input. We especially would like to thank David Bourne from Carnegie Mellon University for sharing his valuable insights and feedback. We are also thankful to META team at Vanderbilt University for providing the chassis assembly used in this paper.

@&#REFERENCES@&#

