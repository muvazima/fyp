@&#MAIN-TITLE@&#Mobility assisted data gathering with solar irradiance awareness in heterogeneous energy replenishable wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Consider a joint design of mobile data gathering and energy replenishment.


                        
                        
                           
                           Propose a novel two layer heterogeneous architecture for wireless sensor networks.


                        
                        
                           
                           Present a mobility assisted data gathering scheme with solar irradiance awareness.


                        
                        
                           
                           Simulation results show that MADG-SIA provides significant improvement in terms of balancing energy consumption and the amount data gathered compared to previous work.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless rechargeable sensor networks

Mobile energy replenishment

Clusters

Solar irradiance awareness

@&#ABSTRACT@&#


               
               
                  Wireless sensor networks adopting static data gathering may suffer from unbalanced energy consumption due to non-uniform packet relay. Although mobile data gathering provides a reasonable approach to solving this problem, it inevitably introduces longer data collection latency due to the use of mobile data collectors. In the meanwhile, energy harvesting has been considered as a promising solution to relieve energy limitation in wireless sensor networks. In this paper, we consider a joint design of these two schemes and propose a novel two layer heterogeneous architecture for wireless sensor networks, which consists of two types of nodes: sensor nodes which are static and powered by solar panels, and cluster heads that have limited mobility and can be wirelessly recharged by power transporters. Based on this network architecture, we present a data gathering scheme, called mobility assisted data gathering with solar irradiance awareness (MADG-SIA), where sensor nodes are clustered around cluster heads that adaptively change their positions according to solar irradiance, and the sensing data are forwarded to the data sink by these cluster heads working as data aggregation points. We evaluate the performance of the proposed scheme by extensive simulations and the results show that MADG-SIA provides significant improvement in terms of balancing energy consumption and the amount data gathered compared to previous work.
               
            

@&#INTRODUCTION@&#

Wireless sensor networks (WSNs) have been deployed for a variety of applications ranging from health, agriculture, industry to military. WSNs consist of a large number of randomly distributed sensor nodes that sense the environment and send the sensing data to the data collector in an ad hoc manner. These sensor nodes usually have limited energy supply, e.g., from batteries, which makes energy efficiency a critical issue in sensor network design and deployment. Much effort has been devoted to reduce energy consumption by employing power efficient hardware and software architectures, wireless communications and networking techniques [1–6]. Research shows that wireless communications is the dominant energy consumer on sensor nodes, thus how to gather data from sensor nodes is an important issue for energy consumption optimization in sensor networks.

One of the most important problems in data gathering in WSNs is to balance the energy consumption among sensor nodes. Unbalanced energy consumption caused by packet relay leads to energy holes in the network, which may disable the packet forwarding toward the data collector, and eventually results in degraded network performance, such as short network lifetime and low data throughput. In a conventional homogeneous wireless sensor network, a statically deployed data collector, referred to as data sink, is used to gather data from the network. Since data packets converge toward the data sink, the nodes that are closer to the data sink have to relay much more data than the nodes that are farther away from the data sink, and they consume energy much faster than other nodes. When these nodes deplete their energy, the data sink becomes unreachable to the rest of the nodes, thus the entire network can no longer operate.

Hierarchical WSNs have been proposed to relieve the unbalanced energy consumption problem, in which sensor nodes are organized into clusters [7–13]. Instead of sending all the data to the single data sink in a multi-hop manner, sensors upload data to the aggregation nodes of the cluster they belong to, which are referred to as cluster heads. These data are then relayed to the data sink by cluster heads which are built with stronger wireless communications capability and more energy supply. Such a hierarchical architecture can mitigate energy unbalance to some extent, however, since cluster heads are statically deployed, network lifetime is limited by the nodes around these cluster heads.

Mobility has been introduced into WSNs due to its benefits, such as guaranteeing network connectivity, reducing network cost, increasing reliability, and improving energy efficiency [14]. Mobile data gathering uses a mobile data collector to sojourn at different positions in a sensor network to gather data from surrounding sensor nodes. By moving the data aggregation points across the entire network, energy consumption tends to be balanced in the whole network [15,16]. However, a challenge of mobile data gathering is that such a scheme inevitably introduces long data collection latency because the mobile data collector has to visit all the selected positions before it can upload data to the data sink. The positions of data aggregation points also need to be carefully selected depending on multiple factors, such as network topology, energy levels of all the sensor nodes, and the amount of sensing data generated in each sensor node. The computation inevitably increases overhead and operational complexity of the network.

Energy harvesting techniques have been recently employed as a solution to prolong network operating time from another aspect. Such a scheme captures energy from the ambient environment, e.g., mechanical, thermal, photovoltaic or electromagnetic energy, to charge sensor nodes. However, the main drawback of energy harvesting techniques is the low efficiency of recharging, since the power output of energy harvesting devices is relatively low compared to the power consumption of the node for sensing and communications [17], especially for the sensor nodes around the data aggregation points.

In order to overcome the aforementioned problems, it is desirable to find a novel approach to balancing energy consumption to improve network performance in WSNs. By taking advantage of mobility and renewable energy while shortening data collection latency, we propose a mobility assisted data gathering with solar irradiance awareness scheme, abbreviated as MADG-SIA, to achieve balanced energy consumption in WSNs and prolong network lifetime. We construct an MADG-SIA enabled network with three types of devices: the static sensor nodes that are powered by solar panels, the mobile cluster heads that can be wirelessly recharged, and the power transporters (referred to as PowCars). Different from sensor nodes, the discharge rates of cluster heads are much higher than the charge rate provided by solar panels due to the large amount of data forwarding and movement. We use PowCars to charge cluster heads more efficiently when their energy levels are low. The network has a hierarchical architecture where sensor nodes are clustered and send data to their corresponding cluster heads. The cluster heads sojourn at different positions, referred to as anchor points, in each data gathering period, to collect data from surrounding sensor nodes in a one-hop or multi-hop manner. By carefully moving cluster heads to some positions for data gathering, the energy-consuming data forwarding tasks are shared among all the sensor nodes to balance their energy consumption. On the other hand, as the moving distance of cluster heads is limited, and they communicate with the data sink directly once settled down, the data collection latency in the proposed network is much shorter than that in mobile data gathering. Based on this network architecture, we will find optimal positions for anchor points and moving paths for cluster heads, and develop a clustering approach and determine the routes for sensor nodes to upload data to cluster heads.

The rest of the paper is organized as follows. The related work is discussed in Section 2. Section 3 describes the framework of the proposed scheme. In Section 4, the system model and the proposed algorithm are presented for WSNs with regular and random topologies. Section 5 evaluates the impact of various parameters on network performance. Finally, the paper is concluded in Section 6.

@&#RELATED WORK@&#

In this section, we briefly review some related work in the literature, which includes the work on data gathering with clustering and energy replenishment in WSNs.

An energy-efficient framework for clustering-based data collection in WSNs was proposed in [7]. By adaptively enabling/disabling prediction operations and updating clustering as well as accommodating in-network aggregation and the sleep/awake scheduling, the framework achieves energy efficiency when sensor data are spatially and temporally correlated. Clustering sensor nodes was also considered in [8]. By periodically selecting cluster heads according to the combination of residual energy and a secondary parameter, such as node proximity to its neighbors or node degree, this clustering method outperforms weighted clustering protocols in terms of several cluster characteristics. Heterogeneous ad hoc sensor networks were studied in [9] which focused on energy and link heterogeneity. The impact of the number and placement of heterogeneous resources on the performance of networks of different sizes and densities was evaluated. It was shown that it requires only a modest number of reliable, long-range backhaul links and line-powered nodes to have a significant impact. Employing mobile cluster heads in hybrid sensor networks was explored in [10]. A heuristic algorithm for positioning cluster heads and balancing traffic load in the network was proposed and shown to be able to increase network lifetime after only a few rounds of adjustments. An energy-balanced dominating set based clustering scheme was proposed in [12], where normal nodes broadcast the number of cluster head candidates around it. Each candidate calculates the median of such numbers received from its neighbors, and becomes a final cluster head with a probability inversely proportional to the median. Employment of distributed load balanced clustering (LBC) and MIMO uploading techniques in WSNs was studied in [13], in which the sensors are organized into clusters by executing a distributed LBC algorithm, which also generates multiple cluster heads in each cluster to balance the work load and facilitate MIMO data uploading.

The above schemes can greatly save energy by utilizing clustering compared to conventional relay routing in networks. However, since they are based on conventional sensor nodes and do not consider energy harvesting, the network lifetime is limited by the battery life. Alternatively, our work in this paper jointly considers energy replenishment and cluster head movement with the goal to extend operation time of WSNs.

A general target coverage problem for a solar-powered active sensor network with a controllable sensing range was investigated in [18], where a near-optimal approximate solution was provided with a 60X improvement in speed at the cost of 8% reduction in the quality of coverage. A joint study of energy management and resource allocation problem for energy-harvesting sensors was presented in [19], in which the optimal sampling rate was explored based on the average energy replenishment rate, and a local algorithm was presented for each sensor to adapt the sampling rate according to short term fluctuations in recharging, with the objective of maintaining the battery at a target level. A dynamic energy-oriented scheduling method (DEOS) was proposed in [20] for multiple tasks allocation with a time-varying and limited energy constraint in energy harvesting WSNs. Simulation results indicated that DEOS is extremely lightweight and it effectively schedules tasks to utilize the dynamically available energy. RF radiation based energy replenishment for sensor networks was studied in [21], where a wireless charging system was developed and implemented so that sensor nodes get charged by a mobile charger. However, experiment reveals that energy replenishment with this technique is of low efficiency and difficult to be used in large scale WSNs with perpetual operation. The application of wireless energy replenishment through resonant magnetic coupling for WSNs has also been studied in literatures. A framework of joint mobile energy replenishment and data gathering was proposed in [22], in which a single vehicle is employed to perform the two functions together. The vehicle charges the sensors with the least residual energy, and simultaneously collects data from the network with specific routing and data rates for all the sensors so that network utility is maximized. Wireless recharge with single vehicle was also considered in [23], in which the ratio of the vehicle’s vacation time over the cycle time is maximized. A multi-vehicle coordination mechanism for wireless rechargeable sensor networks was studied in [24–26]. The vehicles collect real-time energy information using an NDN-based energy monitoring protocol and choose the sensors to be charged to minimize the total traveling cost for all vehicles while ensuring no node failure.

The above works provide promising methodologies to relieve the energy constraint from the perspective of power supply. In [18–20] authors focus on prolonging the lifetime of an energy harvesting sensor network, but do not consider mobility. As a result, the network lifetime is still fairly short due to unbalanced energy consumption in the network. In [21–26], all the sensors in the networks are charged by the mobile vehicles. Since the capability for a vehicle to deliver energy to the sensor is limited, large scale networks that consist of thousands of sensors may demand a large numbers of vehicles to maintain perpetual operation, which ultimately leads to high cost for network operation. In contrast, our work takes advantage of controlled mobility, data rate allocation and heterogeneity of energy replenishment, to provide perpetual network operation and maximize data throughput.

In this section, we provide an overview of MADG-SIA. The structure of a MADG-SIA enabled WSN is illustrated in Fig. 1
                     . The entire network consists of three types of devices: conventional sensor nodes, cluster heads and PowCars. All the sensor nodes are equipped with solar panels that harvest energy from solar irradiance, while the cluster heads can be wirelessly recharged by PowCars. Such wireless energy replenishment is made possible by recent breakthroughs in high efficiency non-radiative wireless power transmission over midrange (Midrange refers to the distance between the transmitter and the receiver that is larger than the size of the devices by a factor of at least 2–3 [27]). Different from RF radiation based wireless energy transmission, this technique transfers energy through strongly coupled magnetic resonances, and the efficiency of transferring 60 W of power over 2 m is as high as 40% [27]. Intel also demonstrated that 60 W of power can be transferred over a distance of up to 2–3 ft with efficiency of 75% [28]. This technique makes it possible to use energy transporters to recharge the sensor nodes that have low energy level so as to achieve perpetual operation. However, this application is constrained by the slow charging problem for conventional batteries, such as Nickel-Metal Hydride (NiMH) and Lithium-ion (Li-ion) batteries which are widely used as energy storage devices for energy replenishable sensor nodes. Both NiMH and Li-ion batteries have such a problem as the optimal charging rate for Li-ion batteries that achieves the best performance is less than 1C, while for NiMH batteries, the optimal charging rate is even lower (C is determined by the nominal capacity of the battery). Under such restriction, it will take long time to fully charge a battery, which is unrealistic for large scale WSNs, thus we choose to charge the cluster heads only.

Wireless energy replenishing systems are installed on the PowCars and cluster heads. Each PowCar is equipped with a high capacity rechargeable battery, an oscillator that converts the direct current (DC) from the battery into high frequency alternating current (AC) and a resonant coil as the transmitter. The battery can provide sufficient energy for the operation of the PowCar as well as fully charging the cluster heads. Each cluster head is equipped with a receiver coil which is tuned to resonate at exactly the same frequency as the transmitting coil on PowCar, an AC/DC converter which is controlled by the battery charger and a rechargeable battery. When a PowCar moves close to a cluster head, DC current is fed to the oscillator and converted to high frequency AC current. Driven by this AC current, an oscillating magnetic field is induced around the transmitter coil. This magnetic field then induces an AC current in the receiver coil of the sensor node placed at the anchor point. The AC/DC converter generates DC current and regulates it to properly charge the rechargeable battery of the cluster head. In this way, the wireless energy replenishing system works periodically to provide sufficient energy for the operation of cluster heads. Note that the charging process can be performed any time when necessary.

A WSN with MADG-SIA works as follows. The area where the sensor nodes are deployed is divided into several regions (the method of division is presented in Section 4), and a mobile cluster head is employed in each region for data gathering. To be more specific, the cluster head visits all the anchor points in the region once in a given time duration, which is denoted as a data gathering cycle. It sojourns at each anchor point for a period, which is denoted as a data gathering period, to collect data from the sensor nodes near this anchor point. An example of the operating timing diagram of a WSN with MADG-SIA in a data gathering cycle is shown in Fig. 2
                     . The red dotted curve plots solar irradiance from real measurement. At the beginning of each data gathering period except for the first one of each data gathering cycle, all cluster heads move to next anchor points, and initiate clustering and routing operations. With the positions of the cluster heads, all the sensor nodes organize into clusters and find the routes to send data to the corresponding cluster heads. After that, data from sensor nodes are aggregated by cluster heads and then forwarded to the data sink via paths consisting of one or more cluster heads. It is possible that the energy levels of the nodes in a cluster increase due to the high output from solar panels. In such a scenario, the cluster head stays at the current anchor point until the batteries of the nodes begin to discharge. Then the cluster head recalculate the data gathering period for the rest anchor points, and move to these anchor points to collect sensory data. When a cluster head detects that its battery level is below a threshold, it reports its energy status to the base station and request energy replenishment. A PowCar is dispatched to recharge the cluster head upon the request.

Having outlined how the network works for energy replenishment and data gathering, in this section, we present an efficient implementation of MADG-SIA in WSNs in a distributed manner. The objective is to balance energy consumption during data gathering determine the positions of anchor points for cluster heads where they sojourn in each data gathering period to collect sensing data from their surrounding sensor nodes and forward these data to the data sink, the moving pattern of cluster heads among the anchor points, and the clustering and routing schemes of sensor nodes so as to guarantee perpetual network operation. This can be achieved in two steps: first, cluster heads find the anchor points they should move to for data collection; then sensor nodes calculate the clustering and routing according to the positions of anchor points. The notations and their semantics used for the following discussion are listed in Table 1
                     .

We first select the anchor points for cluster heads to visit in each data gathering cycle. Consider a WSN consisting of n nodes randomly deployed in a L
                        1 × L
                        2 area 
                           S
                        . Without loss of generality, we consider the case that sensor nodes follow uniform distribution, and each node is connected with at least one neighbor, which means that the distance between the two nodes is less than transmission range R.

An ideal solution to balance energy consumption for data transmission among sensor nodes in a given period is that each node transmits the same amount of data. In a large sensor network with random distribution, this can be approximately achieved by moving cluster heads to the anchor points where each node has an equal probability to be an i-hop neighbor of a cluster head (
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                           
                        ). Since a sensor node can only communicate with a cluster head when the distance between them is no more than R, to achieve this objective with high efficiency, we cover the area with the fewest number of disks whose radius is R. It was proved in [29] that the solution to the problem of covering an area with the minimum number of disks is to place disks so that the centers of disks are located at the vertices of equilateral triangles with side length equal to 
                           
                              
                                 3
                              
                              R
                           
                        .

It is easy to see that as long as the four boundaries of 
                           S
                         are covered by disks placed in this way, it is guaranteed that 
                           S
                         can be covered entirely. Based on this observation, we can derive a method of placing disks to cover 
                           S
                         by considering the coverage of its boundaries.

In Fig. 3
                        , 
                           S
                         is defined by boundaries 
                           
                              x
                              =
                              0
                              ,
                           
                        
                        
                           
                              x
                              =
                              
                                 L
                                 1
                              
                              ,
                           
                        
                        
                           
                              y
                              =
                              0
                           
                         and 
                           
                              y
                              =
                              
                                 L
                                 2
                              
                           
                         in a two dimensional Cartesian coordinate system. We first find the y-coordinates for the centers of disks. Assume that there are M rows of disks we intend to place. The centers of disks in the first row which is the closest to 
                           
                              y
                              =
                              0
                           
                         are placed on straight line 
                           
                              y
                              =
                              
                                 R
                                 2
                              
                           
                        . This ensures that the bottom boundary 
                           
                              y
                              =
                              0
                           
                         is fully covered as ab⊥o
                        1
                        o
                        2 and 
                           
                              a
                              b
                              =
                              
                                 R
                                 2
                              
                           
                        . The centers of disks in the successive rows are placed 
                           
                              
                                 3
                                 R
                              
                              2
                           
                         away, i.e., the y-coordinates of the centers of disks in the ith row is 
                           
                              
                                 (
                                 i
                                 −
                                 1
                                 )
                              
                              
                                 
                                    3
                                    R
                                 
                                 2
                              
                              +
                              
                                 R
                                 2
                              
                              ,
                           
                         where 
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              M
                           
                        . Let the centers of disks in the mth row be the closest to 
                           
                              y
                              =
                              
                                 L
                                 2
                              
                           
                         from beneath. In order to fully cover top boundary 
                           
                              y
                              =
                              
                                 L
                                 2
                              
                              ,
                           
                         the number of rows M should satisfy that

                           
                              (1)
                              
                                 
                                    M
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   m
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         L
                                                         2
                                                      
                                                      −
                                                      
                                                         (
                                                         
                                                            
                                                               (
                                                               m
                                                               −
                                                               1
                                                               )
                                                            
                                                            
                                                               
                                                                  3
                                                                  R
                                                               
                                                               2
                                                            
                                                            +
                                                            
                                                               R
                                                               2
                                                            
                                                         
                                                         )
                                                      
                                                      ≤
                                                      
                                                         R
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   m
                                                   +
                                                   1
                                                   ,
                                                
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Then we calculate the 
                        x-coordinates for the centers of disks. The distance between the centers of two neighbor disks in the same row is 
                           
                              
                                 3
                              
                              R
                           
                        . Assume that there are N
                        odd disks in odd rows and N
                        even disks in even rows. The x-coordinate of the center of the jth disk in odd rows is 
                           
                              
                                 3
                              
                              
                                 (
                                 j
                                 −
                                 1
                                 )
                              
                              R
                              ,
                           
                         where 
                           
                              j
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              
                                 N
                                 odd
                              
                              ,
                           
                         and the x-coordinate of the center of the kth disk in even rows is 
                           
                              
                                 3
                              
                              
                                 (
                                 k
                                 −
                                 1
                                 )
                              
                              R
                              +
                              
                                 
                                    
                                       3
                                    
                                    R
                                 
                                 2
                              
                              ,
                           
                         where 
                           
                              k
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              
                                 N
                                 even
                              
                           
                        . Such placement ensures full coverage of left boundary 
                           
                              x
                              =
                              0
                              ,
                           
                         which can be proved as follows.

                           Proof
                           Denote the circle whose center locates at point A as circle of A. Let d and e be the two intersection points of circle of o
                              1 and circle of o
                              4. Extend o
                              1
                              d so that it intersects with o
                              4
                              h at c, where o
                              4
                              h is the radius of circle of o
                              4 and o
                              4
                              h⊥o
                              1
                              c. It is easy to see that 
                                 
                                    ∠
                                    d
                                    
                                       o
                                       1
                                    
                                    
                                       o
                                       4
                                    
                                    =
                                    
                                       π
                                       6
                                    
                                 
                               and 
                                 
                                    ∠
                                    
                                       o
                                       1
                                    
                                    d
                                    e
                                    =
                                    
                                       π
                                       3
                                    
                                 
                              . Since de⊥o
                              1
                              o
                              4, 
                                 
                                    ∠
                                    
                                       o
                                       1
                                    
                                    
                                       o
                                       4
                                    
                                    h
                                    =
                                    
                                       π
                                       3
                                    
                                 
                              . We can see that 
                                 
                                    ∠
                                    h
                                    
                                       o
                                       4
                                    
                                    
                                       o
                                       5
                                    
                                    =
                                    π
                                 
                              . Let f and g be the two intersection points of circle of o
                              4 and circle of o
                              6. We have 
                                 
                                    ∠
                                    
                                       o
                                       4
                                    
                                    
                                       o
                                       6
                                    
                                    f
                                    =
                                    
                                       π
                                       6
                                    
                                 
                               and 
                                 
                                    ∠
                                    
                                       o
                                       6
                                    
                                    f
                                    g
                                    =
                                    ∠
                                    h
                                    
                                       o
                                       4
                                    
                                    
                                       o
                                       6
                                    
                                    =
                                    
                                       π
                                       3
                                    
                                 
                              . Extend o
                              6
                              f so that it intersects with o
                              4
                              h at c′. Since o
                              4
                              o
                              6⊥fg, o
                              6
                              c′⊥o
                              4
                              h. As 
                                 
                                    
                                       o
                                       1
                                    
                                    
                                       o
                                       4
                                    
                                    =
                                    
                                       o
                                       4
                                    
                                    
                                       o
                                       6
                                    
                                 
                               and 
                                 
                                    ∠
                                    
                                       o
                                       1
                                    
                                    
                                       o
                                       4
                                    
                                    h
                                    =
                                    h
                                    
                                       o
                                       4
                                    
                                    
                                       o
                                       6
                                    
                                    =
                                    
                                       π
                                       3
                                    
                                    ,
                                 
                              
                              
                                 
                                    c
                                    
                                       o
                                       4
                                    
                                    =
                                    
                                       c
                                       ′
                                    
                                    
                                       o
                                       4
                                    
                                    =
                                    
                                       
                                          
                                             3
                                          
                                          R
                                       
                                       2
                                    
                                 
                              . Thus c and c′ overlap with each other. We can see that o
                              1, d, f and o
                              6 are on the same straight line. Since o
                              1 and o
                              6 are placed on 
                                 
                                    x
                                    =
                                    0
                                    ,
                                 
                               
                              d and f are also on 
                                 
                                    x
                                    =
                                    0
                                 
                              . This means that o
                              1
                              o
                              6 which is a segment of left boundary 
                                 
                                    x
                                    =
                                    0
                                 
                               is covered by circle of o
                              1, circle of o
                              4 and circle of o
                              6. When M is sufficiently large, the entire left boundary 
                                 
                                    x
                                    =
                                    0
                                 
                               can be fully covered.□

We now determine the numbers of circles in each row. Let the N
                        1th disk be the right-most disk in row i, and denote the x-coordinate of the center of this disk as 
                           
                              x
                              
                                 N
                                 1
                              
                           
                        . Let the N
                        2th disk be the right-most disk in an adjacent row, and denote the x-coordinate of the center of this disk as 
                           
                              x
                              
                                 N
                                 2
                              
                           
                        . In order to fully cover the right boundary of 
                           
                              S
                              ,
                           
                        
                        
                           
                              x
                              
                                 N
                                 1
                              
                           
                         and 
                           
                              x
                              
                                 N
                                 2
                              
                           
                         should satisfy that

                           
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                |
                                             
                                             
                                                x
                                                
                                                   N
                                                   1
                                                
                                             
                                             −
                                             
                                                x
                                                
                                                   N
                                                   2
                                                
                                             
                                             
                                                |
                                                =
                                             
                                             
                                                3
                                             
                                             R
                                             /
                                             2
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             max
                                             
                                                {
                                                
                                                   x
                                                   
                                                      N
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   x
                                                   
                                                      N
                                                      2
                                                   
                                                
                                                }
                                             
                                             ≥
                                             
                                                L
                                                1
                                             
                                             ,
                                             min
                                             
                                                {
                                                
                                                   x
                                                   
                                                      N
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   x
                                                   
                                                      N
                                                      2
                                                   
                                                
                                                }
                                             
                                             <
                                             
                                                L
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Next, using the centers of disks as anchor points, we can determine the movement of the cluster heads. We first divide 
                           S
                         into regions according to the number of cluster heads, so that each of the regions contains the same number of anchor points. To be more specific, each region has the same number of rows of anchor points, and each row has the same number of anchor points. In Fig. 4, e.g., 
                           S
                         is covered by 36 anchor points which are organized into six rows, and each row contains six anchor points. Since we have four cluster heads, we divide 
                           S
                         into four regions, each of which consists of three rows and each row contains three anchor points.

The moving paths for the cluster heads are planned with the objective of maximizing the data collected from each sensor node in a data gathering period, which is calculated as

                           
                              (2)
                              
                                 
                                    
                                       sum
                                       _
                                       of
                                       _
                                       data
                                    
                                    =
                                    
                                       (
                                       τ
                                       −
                                       
                                          d
                                          v
                                       
                                       −
                                       
                                          t
                                          rc
                                       
                                       )
                                    
                                    r
                                 
                              
                           
                        where τ is the duration of a data gathering period, d is the moving distance of the cluster head in the data gathering period, i.e., the distance between the two anchor points selected in two successive data gathering periods, v is the moving velocity of the cluster head, t
                        rc is the time for routing and clustering of sensor nodes after the cluster heads arrive at the selected anchor points, and r is the data rate of the sensor node. Clearly, the total amount of collected data increases when the moving distance is shorter, thus we plan zig-zag moving paths for cluster heads so that between two successive data gathering periods, each cluster head moves to an unvisited anchor point in the region which is 
                           
                              
                                 3
                              
                              R
                           
                         away. After reaching the end of the path, the cluster head turns back and moves along the path in the reverse direction at the beginning of the next data gathering cycle.

In order to ensure that every sensor node can be a one-hop neighbor of a cluster head during a data gathering cycle, the cluster head should move fast enough to visit all the anchor points in the network. The number of anchor points in a large network may be too large for cluster heads to visit all of them in such a period. There are two solutions for solving this problem. The first solution is to employ more cluster heads and to divide the area into more regions, so that the number of anchor points in each region is reduced. For the network shown in Fig. 4, each region contains nine anchor points. In Fig. 5
                        (a), the number of cluster heads increases to nine, so the network is divided into nine regions, thus the number of anchor points in each region is reduced from nine to four. The second solution is that, instead of calculating the positions of the anchor points by using the method of no-gap covering, the anchor points are picked based on geographical symmetry. A region is divided into several sub-regions, and the center of the sub-region is selected as the anchor points of the cluster head in the region. Fig. 5(b) shows an example of such anchor point selection method. For the network in Fig. 4 which is divided into four regions, in Fig. 5(b), each region is further divided into four sub-regions, and the centers of the four sub-regions are chosen as the anchor points of the cluster head for this region. This method may lead to less effective energy balancing as the task of data forwarding is no longer shared by all the sensor nodes, and more energy consumption on the sensor nodes around anchor points due to that a large amount of data forwarding may cause energy holes in these areas. However, the advantage of this solution is that it has lower overhead for routing and clustering which is performed every time after cluster heads change their positions. Since the number of anchor points in each region is much smaller than that in the first solution above, routing and clustering will be calculated less frequently, thus the overhead is reduced. In Fig. 5(b), the number of anchor points in each region is four, so the frequency of routing and clustering calculation is 
                           
                              4
                              9
                           
                         of that in Fig. 4 where each anchor point changes its position nine times in a data gathering cycle.

In Section 4.1, we propose that a cluster head traverses all the anchor points along a zig-zag path, so that the total amount of collected data can be potentially maximized. Given such a moving path, another parameter that impact the moving pattern of a cluster head is the data gathering period, which is the time a cluster head sojourns at an anchor point for data collection. For fairness, the data gathering period for each anchor point should be potentially the same, i.e., 
                           
                              τ
                              =
                              
                                 T
                                 
                                    number
                                    _
                                    of
                                    _
                                    cluster
                                    _
                                    heads
                                 
                              
                           
                        . It is noticeable that when solar irradiance is high enough, the output of a solar panel could be larger than the rate of energy consumption caused by wireless communication, thus the energy levels of the nodes increase and the batteries could get fully recharged. In such a scenario, changing the position of a cluster head may not benefit the balancing of energy consumption among the nodes, which is one of the major concern of MADG-SIA. Thus we propose a method to adaptively adjust data gathering period according to solar irradiance.

In order to control the data gathering period at each anchor point to adapt to solar irradiance, it is necessary to accurately model the energy changes in sensor nodes. In general, the energy status of a node is determined by the energy consumption rate and energy replenishing rate of the node. For node i, the receiving rate equals the sum of the data rates of its descendants, while the transmission rate equals the receiving rate plus its own data rate, thus the energy consumption rate can be calculated as

                              
                                 (3)
                                 
                                    
                                       
                                          π
                                          i
                                          d
                                       
                                       =
                                       
                                          e
                                          r
                                       
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             
                                                D
                                                i
                                             
                                          
                                       
                                       
                                          r
                                          j
                                       
                                       +
                                       
                                          e
                                          t
                                       
                                       
                                          (
                                          
                                             r
                                             i
                                          
                                          +
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                
                                                   D
                                                   i
                                                
                                             
                                          
                                          
                                             r
                                             j
                                          
                                          )
                                       
                                    
                                 
                              
                           where 
                              
                                 π
                                 i
                                 d
                              
                            is the rate of battery discharging, e is the energy consumed for transmitting a unit data, and 
                              
                                 D
                                 i
                              
                            is the set of active descendants of node i. The recharging profile of solar harvesting sensor nodes is modeled as

                              
                                 (4)
                                 
                                    
                                       
                                          π
                                          r
                                       
                                       =
                                       I
                                       ·
                                       
                                          η
                                          p
                                       
                                       ·
                                       
                                          ρ
                                          e
                                       
                                       ·
                                       A
                                    
                                 
                              
                           where πr
                            is the rate of battery charging, I represents the solar irradiance arrived at the solar panel, ηp
                            is the efficiency of the solar panel to convert solar irradiance to electrical power, ρe
                            is the electrical regulating and charging efficiency, and A is the size of solar panel. The energy status of node i after Δt time can be updated as follows

                              
                                 (5)
                                 
                                    
                                       
                                          b
                                          
                                             i
                                          
                                          
                                             t
                                             +
                                             Δ
                                             t
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   B
                                                
                                                
                                                   
                                                      
                                                         
                                                            b
                                                            ˇ
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            t
                                                            +
                                                            Δ
                                                            t
                                                         
                                                      
                                                      >
                                                      B
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      
                                                         
                                                            b
                                                            ˇ
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            t
                                                            +
                                                            Δ
                                                            t
                                                         
                                                      
                                                      <
                                                      0
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         b
                                                         ˇ
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         t
                                                         +
                                                         Δ
                                                         t
                                                      
                                                   
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          
                                             b
                                             ˇ
                                          
                                          
                                             i
                                          
                                          
                                             t
                                             +
                                             Δ
                                             t
                                          
                                       
                                       =
                                       
                                          b
                                          
                                             i
                                          
                                          t
                                       
                                       +
                                       Δ
                                       t
                                       ·
                                       I
                                       ·
                                       
                                          η
                                          p
                                       
                                       ·
                                       
                                          ρ
                                          e
                                       
                                       ·
                                       A
                                       −
                                       Δ
                                       t
                                       
                                          (
                                          
                                             e
                                             r
                                          
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                
                                                   D
                                                   i
                                                
                                             
                                          
                                          
                                             r
                                             j
                                          
                                          +
                                          
                                             e
                                             t
                                          
                                          
                                             (
                                             
                                                r
                                                i
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   
                                                      D
                                                      i
                                                   
                                                
                                             
                                             
                                                r
                                                j
                                             
                                             )
                                          
                                          )
                                       
                                    
                                 
                              
                           where 
                              
                                 b
                                 
                                    i
                                 
                                 
                                    t
                                    +
                                    Δ
                                    t
                                 
                              
                            is the energy level of node i at time 
                              
                                 t
                                 +
                                 Δ
                                 t
                                 ,
                              
                            
                           B is the capacity of the battery, and 
                              
                                 
                                    b
                                    ˇ
                                 
                                 
                                    i
                                 
                                 
                                    t
                                    +
                                    Δ
                                    t
                                 
                              
                            is the estimated energy level of node i at time 
                              
                                 t
                                 +
                                 Δ
                                 t
                              
                           . This energy model reveals that a battery can neither store energy more than its capacity nor provide energy more than the sum of its remaining energy and the energy harvested by the solar panel.

According to the energy model established in Section 4.2.1, the battery of a node is recharged when the energy provided by the solar panel is higher than consumed for wireless communications, i.e., 
                              
                                 
                                    π
                                    i
                                    d
                                 
                                 <
                                 
                                    π
                                    r
                                 
                              
                           . Due to the limitation of battery capacity, the energy of nodes whose batteries have been fully charged do not increase any more, while the energy of the nodes whose batteries are not full keeps increasing. As a result, the differences of energy levels among the nodes decline, and energy distribution tends to be uniform. Based on such fact, changing the position of cluster head when the nodes are being charged does not benefit balancing the energy distribution among the nodes. Furthermore, changing the position of cluster heads during such time reduces the number of nodes whose energy consumption can be balanced through the movement of cluster heads when solar irradiance is low (
                              
                                 
                                    π
                                    i
                                    d
                                 
                                 >
                                 
                                    π
                                    r
                                 
                              
                           ). To address the impact of change of solar irradiance, we propose a mobility control method which is illustrated as follows.

                              
                                 1.
                                 A data gathering cycle starts when solar irradiance is available. A cluster head sojourns at each anchor point for 
                                       
                                          τ
                                          =
                                          
                                             T
                                             
                                                number
                                                _
                                                of
                                                _
                                                cluster
                                                _
                                                heads
                                             
                                          
                                       
                                     before moving to the next anchor point.
                                       1
                                    
                                    
                                       1
                                       It is noticeable that T changes year round as sunrise and sunset times change. However, the change is slight between two successive days, thus T can be easily adjusted to address the change.
                                     This ensures only a few anchor points are visited before the solar irradiance becomes high enough to charge the nodes, thus the effort for balancing energy consumption by moving cluster heads in the regions can be improved.

Each node monitors its energy status change when uploading data to the cluster head. When the residual increases, the node on the edge of the cluster send a “Recharging” indicator to its next-hop neighbor. Each intermediate node, being aware of all the one-hop neighbor nodes for whom it relays data during cluster and routing operation, records the “RECHARGING” indicators from these neighbors. If all these neighbors send “RECHARGING” indicator, and its own battery is being recharged, the node sends a “RECHARGING” indicator to its next-hop neighbor. If a cluster head receives “RECHARGING” indicators from all its one-hop indicator, it enters “QUIESCENT” state, suspends future movement and collects data at current anchor point until it quits “QUIESCENT” state.

If a node detects decrease of residual energy and it has previously sent a “RECHARGING” indicator, it sends a “DISCHARGING” indicator to its next-hop neighbor. Upon receiving a “DISCHARGING” indicator, the node remove the “RECHARGING” indicator of the corresponding neighbor from its record, and send a “DISCHARGING” indicator to its next-hop neighbor. When the cluster head in “QUIESCENT” state receives such an indicator, it quits “QUIESCENT” state immediately. If the time that the cluster head has sojourned at current anchor point, denoted as ts
                                    , is less than τ, it waits at the current anchor point until 
                                       
                                          
                                             t
                                             s
                                          
                                          =
                                          τ
                                       
                                    ; otherwise it recalculate data gathering period for the rest of the tour, which is 
                                       
                                          
                                             τ
                                             ^
                                          
                                          =
                                          
                                             
                                                T
                                                −
                                                
                                                   elasped
                                                   _
                                                   time
                                                   _
                                                   in
                                                   _
                                                   current
                                                   _
                                                   data
                                                   _
                                                   gathering
                                                   _
                                                   cycle
                                                
                                             
                                             
                                                number
                                                _
                                                of
                                                _
                                                unvisited
                                                _
                                                cluster
                                                _
                                                heads
                                             
                                          
                                       
                                     .

In MADG-SIA, after the cluster heads have moved to anchor points, the next step is to organize the sensor nodes around cluster heads and find the routes for each node to send data to the cluster head. We present a distributed algorithm, named weighted clustering and routing (WCR), for MADG-SIA sensor networks. The basic idea of WCR is to evaluate the cost of data transmission between a transmitter and a receiver by their energy levels. Data should always be sent along the route that has the lowest cost, and a sensor node should only send data to the cluster head to which the cost of the route is minimum. Next we describe WCR in detail.

With the energy levels obtained for all sensor nodes, we can draw the connections among sensor nodes and cluster heads. We represent these connections by a directed graph G(V, E), where V is the set of vertices denoting sensors and cluster heads, and E is the set of arcs denoting the connections between the ordered pairs of vertices. The weight of arc (i, j) w
                        
                           i, j
                        , which represents the cost of data transmission over link (i, j), is defined as the reciprocal of the minimum of the energy level of node i and node j if they are inside the transmission range of each other, i.e., 
                           
                              
                                 w
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              =
                              
                                 w
                                 
                                    j
                                    ,
                                    i
                                 
                              
                              =
                              
                                 1
                                 
                                    min
                                    {
                                    
                                       b
                                       i
                                    
                                    ,
                                    
                                       b
                                       j
                                    
                                    }
                                 
                              
                           
                        . The energy levels of cluster heads are considered as 
                           
                              +
                              ∞
                           
                        . If node i and node j are outside the transmission range of each other, or if one or both of them have no energy left, w
                        
                           i, j
                         and w
                        
                           j, i
                         are set to 
                           
                              +
                              ∞
                           
                        .

The weighted routing and clustering algorithm works as follows. At the beginning of the process, each cluster head initiates a ROUTE-REQUEST (RREQ) message, which includes the following domains: the address of the cluster head, route weight w that is set to zero and a sequence number (SN) that is increased by one each time the cluster head moves to a new anchor point. In order to avoid flooding RREQ from each cluster head in the entire area 
                           
                              S
                              ,
                           
                         a domain containing time-to-live information (TTL) is also defined in RREQ.

Each node keeps a record of the maximal accumulated weight of the route to cluster head k. When node i receives an RREQ message originated from cluster head k from its neighbor node j, it calculates the accumulated route weight 
                           
                              w
                              
                                 i
                                 −
                                 j
                                 −
                                 
                                    CH
                                    k
                                 
                              
                           
                         by adding w
                        
                           i, j
                         to w in RREQ, and compares it with its record. If the new 
                           
                              w
                              
                                 i
                                 −
                                 j
                                 −
                                 
                                    CH
                                    k
                                 
                              
                           
                         is smaller than the record 
                           
                              
                                 w
                                 
                                    i
                                    −
                                    
                                       CH
                                       k
                                    
                                 
                              
                              ,
                           
                         node i saves 
                           
                              w
                              
                                 i
                                 −
                                 j
                                 −
                                 
                                    CH
                                    k
                                 
                              
                           
                         as 
                           
                              w
                              
                                 i
                                 −
                                 
                                    CH
                                    k
                                 
                              
                           
                        . When a route with smaller accumulated weight is found, the node also decreases TTL in RREQ by one and broadcasts the message if TTL is greater than one, otherwise, the message is discarded.

It is noticeable that such a procedure may cause a lot of message passing since multiple routes may exist between a node and the cluster head. A timed-updating mechanism is adopted to avoid this problem, in which the update message for a new route is not sent immediately, but after a period which is proportional to the accumulated route weight. This way, a route with larger weight could be discovered by a node before it updates its neighbors with smaller route weight. For example, when node i finds route a with efficiency being 50 which is the highest among the existing routes, it waits for 10s before updating its neighbors. Route b with efficiency being 100 is found before the timer expires, then sending RREQ message which updates route a information is avoided.

By flooding RREQ messages in the network, routing information is received by all sensor nodes. Clustering is also accomplished as each sensor node selects the cluster head to which the route has the largest accumulated route weight. For example, when node i receives RREQ message from two different cluster heads, CH
                           a
                         and CH
                           b
                        , it compares the accumulated weights of the routes to the two cluster heads. If 
                           
                              
                                 w
                                 
                                    i
                                    −
                                    
                                       CH
                                       a
                                    
                                 
                              
                              <
                              
                                 w
                                 
                                    i
                                    −
                                    
                                       CH
                                       b
                                    
                                 
                              
                              ,
                           
                         node i considers itself to be in the cluster associated with CH
                           a
                        . The WCR algorithm on node i is described in Algorithm 1
                        .

@&#PERFORMANCE EVALUATION@&#

In this section, we evaluate the effectiveness of MADG-SIA with different parameter setups through extensive simulations in MATLAB, and compare it with two static data gathering schemes of solar harvesting sensor network. One of them has have all the sensor nodes send data to the data sink directly, which is denoted as DSDG, while the other one has hierarchical structure with fixed cluster heads deployed and is denoted as CHDG. In the simulation, we generate a network consisting of 500 wireless sensor nodes randomly distributed in a 200 m × 180 m area for demonstration purpose.

The cluster heads are placed at
                     
                      the bottom-left anchor point of the each region at the beginning of the simulation, and they move to other anchor points along the designed path at the beginning of each data gathering period. We assume that all the sensor nodes wait until a route to the cluster head is found before they start data transmission. In a data gathering period, each node stops sending data when the route selected for uploading is broken due to depletion of energy in some of their ancestors. We use real solar irradiation measurements collected by the Baseline Measurement System (Global 40-South PSP) at National Renewable Energy Laboratory in 2011. The default values of the parameters used in the simulations are listed in Table. 2
                     . The simulation is run for 24 consecutive hours.

There are several critical parameters in MADG-SIA that affect the performance, including the number of cluster heads N and the data rate of the sensor nodes r. Fig. 6 demonstrates the residual battery energy of sensor nodes after a data gathering cycle (24 h, starting when solar irradiance is available) when the numbers of cluster heads are 4, 9 and 16, respectively. From the figures, we can see that the scenario with less cluster heads result in more balanced residual battery energy. This is reasonable since with fewer available cluster heads, there are more anchor points in each region, thus each cluster head has to move more frequently to go through all these anchor points in a data gathering cycle. As a result, the cluster heads sojourn for shorter time at each anchor point and less data are forwarded by each node which consumes less energy. Fig. 7 exhibits the amount of collected data in each hour when different number of cluster heads are. During the daytime when solar irradiance is strong, the output of the solar panels is sufficient to support transmission of data from most of the sensor nodes, thus all the three scenarios have similar data output. When solar irradiance becomes unavailable, the sensor nodes in the scenarios with more cluster heads have more aggregation points, but shorter transmission time due to limited energy supply from batteries. Thus all the three scenarios collect similar amount of data from the network.


                        Fig. 8 presents residual battery energy of the sensor nodes after a data gathering cycle in the scenarios where the sensor nodes have different data rates. A higher data rate results in heavier traffic going through sensor nodes, which consumes energy much faster on the sensor nodes around the cluster heads than the sensor nodes in the scenario with lower data rate. After energy holes are formed around the cluster heads,
                         all the related nodes disconnected from the cluster heads and stop consuming energy. Fig. 9 compares the amount of data collected from the network in a data gathering cycle when the data rate of sensor nodes increases. It can be observed that when solar irradiance is strong enough during the daytime, the network with higher data rate yields more data output. However, when solar irradiance is no longer available, the data output of such network drops rapidly and less data are collected.

In this subsection, we compare MADG-SIA with DSDG and CHDG in solar harvesting sensor system. Using the Cartesian coordinate system shown in Fig. 3, DSDG has a data sink placed at 
                           
                              (
                              
                                 L
                                 1
                              
                              ,
                              
                                 
                                    L
                                    2
                                 
                                 2
                              
                              )
                              ,
                           
                         and CHDG has four cluster heads placed at 
                           
                              (
                              
                                 
                                    L
                                    1
                                 
                                 4
                              
                              ,
                              
                                 
                                    L
                                    2
                                 
                                 4
                              
                              )
                              ,
                           
                        
                        
                           
                              (
                              
                                 
                                    3
                                    
                                       L
                                       1
                                    
                                 
                                 4
                              
                              ,
                              
                                 
                                    L
                                    2
                                 
                                 4
                              
                              )
                              ,
                           
                        
                        
                           
                              (
                              
                                 
                                    L
                                    1
                                 
                                 4
                              
                              ,
                              
                                 
                                    3
                                    
                                       L
                                       2
                                    
                                 
                                 4
                              
                              )
                           
                         and 
                           
                              (
                              
                                 
                                    3
                                    
                                       L
                                       1
                                    
                                 
                                 4
                              
                              ,
                              
                                 
                                    3
                                    
                                       L
                                       2
                                    
                                 
                                 4
                              
                              )
                           
                         separately. Fig. 10(a) and (b) show the residual battery energy at the end of a data gathering cycle (residual battery energy of MADG-SIA is shown in Fig. 6). Energy hole is observed in DSDG as the sensor nodes around the data sink have no energy left, while the energy levels of the sensor nodes in other positions are relatively high. The same thing happens to CHDG as the sensor nodes around the cluster heads have depleted their energy while others still alive. In comparison, with the assistance of mobile cluster heads, energy consumption in MADG-SIA is more balanced in the entire network. Fig. 11 compares MADG-SIA with DSDG and CHDG-fixed in consecutive 24 h in terms of the amount of gathered data. Although they yield similar amount of data output when there is strong solar irradiance during the daytime, the output of DSDG and CHDG drops more rapidly than MADG-SIA when solar irradiance gets weakened. Once the data output drops to zero, DSDG and CHDG no longer have data output since the sensor nodes around the data sink or the cluster heads have depleted their energy, while MADG-SIA is still able to collect data from some nodes that have energy left as the cluster heads move to different anchor points.

The simulation results in Figs. 6–9 provide some insights for system parameter selections. For the input settings used in the simulation (Table 2), a network with four cluster heads outperforms the networks with 9 or 16 cluster heads in terms of residual energy distribution and the amount of collected data, and a network in which sensors send data at 10 Kbps outperforms a network with the data rate being 100 Kbps with respect to these two metrics. When designing such a network for a specific application, however, these inputs may change (e.g., the size of the network, number of sensors and transmission range), thus the optimal value of the number of cluster heads and data rate may vary. Evaluation with inputs precisely modeling all the related physical factors should be performed to derive the optimal values of the parameters. The simulation results in Figs. 10 and 11 demonstrate that MADG-SIA is less sensitive to solar irradiance variance in solar harvesting WSNs. Compared with data gathering schemes with a single data sink or fixed cluster heads in which energy holes are observed around the data sink or cluster heads when solar irradiance turns to be low, MADG-SIA has more balanced energy distribution over the whole network, which consequently improves data output and extends network operating time.

@&#CONCLUSIONS@&#

Balancing energy consumption is a challenging task in designing a WSN as data collection is usually restricted by the sensor nodes that have depleted their energy, even for sensor nodes with energy replenishment. In this paper, we have proposed a novel mobility assisted data gathering mechanism (MADG-SIA) which balances the energy consumption for data transmission among the sensor nodes to extend the operating time of a heterogeneous energy replenishable WSN. The area is divided into several regions, and a cluster head moves around in each region, sojourns at different anchor points to gather data from surrounding sensor nodes in a pattern with respect to solar irradiance. By employing such mobile cluster heads, the energy distribution in the solar harvesting WSN is balanced, thus data output is increased and the network operating time is prolonged. We present a low-complexity method to find moving patterns for each cluster head. We also present a weighted algorithm for node clustering and routing. We demonstrate that MADG-SIA is efficient in prolonging network operating time and enhancing data output. We provide guidance on parameter selection for designing and deploying such WSNs by evaluating the performance of MADG-SIA with different parameter setups, and we also demonstrate the effectiveness of MADG-SIA in extending network operating time and increasing data output by comparing with the scenarios of data gathering with single data sink (DSDG) and data gathering with statically deployed cluster heads (CHDG-Fixed) in energy harvesting WSNs.

@&#ACKNOWLEDGMENT@&#

The work in this paper was supported in part by the grant from US National Science Foundation under grant number ECCS-1307576.

@&#REFERENCES@&#

