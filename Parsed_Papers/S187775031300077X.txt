@&#MAIN-TITLE@&#Open-source tools for dynamical analysis of Liley's mean-field cortex model

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A parallel open-source implementation of Liley's mean-field cortex model, in PETSc.


                        
                        
                           
                           We implement fully implicit time integration of nonlinear and variational equations.


                        
                        
                           
                           We perform equilibrium continuation, with computation of inhomogeneous eigenmodes.


                        
                        
                           
                           We compute periodic solutions with Newton–Krylov iteration.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mean-field modelling

Hyperbolic partial differential equations

Numerical partial differential equations

35Q92

65Y05

@&#ABSTRACT@&#


               
               
                  Mean-field models of the mammalian cortex treat this part of the brain as a two-dimensional excitable medium. The electrical potentials, generated by the excitatory and inhibitory neuron populations, are described by nonlinear, coupled, partial differential equations that are known to generate complicated spatio-temporal behaviour. We focus on the model by Liley et al. (Network: Computation in Neural Systems 13 (2002) 67–113). Several reductions of this model have been studied in detail, but a direct analysis of its spatio-temporal dynamics has, to the best of our knowledge, never been attempted before. Here, we describe the implementation of implicit time-stepping of the model and the tangent linear model, and solving for equilibria and time-periodic solutions, using the open-source library PETSc. By using domain decomposition for parallelization, and iterative solving of linear problems, the code is capable of parsing some dynamics of a macroscopic slice of cortical tissue with a sub-millimetre resolution.
               
            

@&#INTRODUCTION@&#

Models of cortical dynamics come in two main families: neuronal network models and mean-field models. The former describe many interacting neurons, each with their own dynamical rules, while the latter describe electrical potentials, generated collectively by many neurons, as continuous in space and time. These potentials can be thought of as averages over a number of macrocolumns, groups of hundreds of thousands of neurons in columnar structures at the surface of the cortex. Both of these modelling approaches can be classified as forward: they attempt to predict the future state of the cortex, given the current state and a set of physiological parameter values. A complementary approach, that can be called backward, is to divide the cortex into interacting components that can be regarded as functional units, and compute the strength of coupling between these units. The backward approach is often based on functional Magnetic Resonance Imaging (fMRI) experiments. A promising modelling strategy is to describe each functional component with a neuronal network or mean-field model, and then have them interact according to empirically determined coupling, thus combining the forward and backward approaches [1].

When considering the forward modelling of a macroscopic piece of cortical tissue, a fundamental difference between the neuronal network and mean-field families is apparent. A model of the former kind should describe billions of neurons, and many times more connections between them. As demonstrated by recent publications, such as by Izhikevich and Edelman [2] or by the Blue Brain team [3], progress in super computing allows for the simulation of ever larger neuronal networks, that reflect actual brain dynamics. However, it is hard to see how the output of such models can be analyzed, other than by purely statistical techniques. Models of the latter kind, in contrast, can be analyzed as smooth, infinite-dimensional dynamical systems.

An added advantage of the mean-field approach is that the electrical potentials, which appear as dependent variables, are observable, macroscopic quantities. An indirect measurement of these fields is provided by the electroencephalograph (EEG) [4]. The EEG is usually measured with electrodes on the scalp or, in exceptional circumstances, directly on the surface of the brain. In either case, the measured signal is not that of individual neurons, but that of many neurons, spread out over a few square centimetres or millimetres. Thus, the way the signals of individual neurons are smeared out by the spatial averaging of mean-field modelling is similar to the way they are mixed up in EEG measurements. Because of the link between the local mean potential and the EEG, mean-field models are sometimes called EEG models (e.g. [5,6]). The geometry of the cortical surface, however, is not taken into consideration in doing so. This surface is folded, and electrocortical activity will result in different EEG signals depending on the location and orientation of the generating tissue. A more direct link between the model variables and measurements may be given by the Local Field Potential (LFP), which is typically measured in vitro or under anaesthesia.

The origin of mean-field modelling lies in the 1970s, when pioneers like Freeman [7], Wilson and Cowan [8] and Lopes da Silva et al. [9] started to model components of the human cortex with continuous fields. Over the past four decades, mean-field models have been used to study a range of open questions in neuroscience, such as the generation of the alpha rhythm, 8–13Hz oscillations in the EEG (see, e.g., [9,5]), epilepsy (see, e.g., [10–12]) and anaesthesia [6]. In a different context, they are used in models for sensorimotor control, pattern discrimination and target tracking [13]. As discussed above, mean-field models also appear as components of combined forward-backward models that aim to capture the functioning of the cortex as a whole, such as in Honey et al. [14].

Although mean-field models have been used in all these settings, little analysis has been done on their behaviour as spatially extended dynamical systems. In part, this is due to their staggering complexity. The Liley model [15] considered here, for instance, consists of fourteen coupled Partial Differential Equations (PDEs) with strong nonlinearities, imposed by coupling between the mean membrane potentials and the mean synaptic inputs. The model can be reduced to a system of Ordinary Differential Equations (ODEs) by considering only spatially homogeneous solutions, and the resulting system has been examined in detail using numerical bifurcation analysis (see [16] and references therein). In order to compute equilibria, periodic orbits and such objects for the PDE model, we need a flexible, stable simulation code for the model and its linearization that can run in parallel to scale up to a domain size of about 2500cm2, the size of a full-grown human cortex. We also need efficient, iterative solvers for linear problems with large, sparse matrices. In this paper, we will show that all this can be accomplished in the open-source software package PETSc [17]. Our implementation consists of a number of functions in C that are available publicly [18].

The goal of this computational work is to parse the spatio-temporal dynamics of a full-fledged mean-field model. We will present the numerical implementation of algorithms for the computation of equilibria and time-periodic solutions and study their stability and parameter dependence. Thus, our goal is similar to that of Coombes et al., who analyzed “spots”: rotationally symmetric, localized solutions in a model of a single neuron population in two dimensions [19]. The challenge lies in giving up the restriction to a single population, a single space dimension, or solutions with a fixed spatial symmetry.

The model we use was first proposed by Liley et al. [15]. The dependent variables are the mean inhibitory and excitatory membrane potential, h
                        
                           i
                         and h
                        
                           e
                        , the four mean synaptic inputs, originating from either population and connecting to either, I
                        
                           ee
                        , I
                        
                           ei
                        , I
                        
                           ie
                         and I
                        
                           ii
                        , and the excitatory axonal activity in long-range fibres, connecting to either population, ϕ
                        
                           ee
                         and ϕ
                        
                           ei
                        . The model equations are:
                           
                              (1)
                              
                                 
                                    τ
                                    k
                                 
                                 
                                    
                                       ∂
                                       
                                          h
                                          k
                                       
                                       (
                                       
                                          
                                             x
                                             →
                                          
                                       
                                       ,
                                       t
                                       )
                                    
                                    
                                       ∂
                                       t
                                    
                                 
                                 =
                                 
                                    h
                                    k
                                    r
                                 
                                 −
                                 
                                    h
                                    k
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 +
                                 
                                    
                                       
                                          h
                                          ek
                                          eq
                                       
                                       −
                                       
                                          h
                                          k
                                       
                                       (
                                       
                                          
                                             x
                                             →
                                          
                                       
                                       ,
                                       t
                                       )
                                    
                                    
                                       
                                          
                                             
                                                h
                                                ek
                                                eq
                                             
                                             −
                                             
                                                h
                                                k
                                                r
                                             
                                          
                                       
                                    
                                 
                                 
                                    I
                                    ek
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 +
                                 
                                    
                                       
                                          h
                                          ik
                                          eq
                                       
                                       −
                                       
                                          h
                                          k
                                       
                                       (
                                       
                                          
                                             x
                                             →
                                          
                                       
                                       ,
                                       t
                                       )
                                    
                                    
                                       
                                          
                                             
                                                h
                                                ik
                                                eq
                                             
                                             −
                                             
                                                h
                                                k
                                                r
                                             
                                          
                                       
                                    
                                 
                                 
                                    I
                                    ik
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∂
                                                
                                                   ∂
                                                   t
                                                
                                             
                                             +
                                             
                                                γ
                                                ek
                                             
                                          
                                       
                                    
                                    2
                                 
                                 
                                    I
                                    ek
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 =
                                 e
                                 
                                    Γ
                                    ek
                                 
                                 
                                    γ
                                    ek
                                 
                                 {
                                 
                                    N
                                    ek
                                    β
                                 
                                 
                                    S
                                    e
                                 
                                 [
                                 
                                    h
                                    e
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 ]
                                 +
                                 
                                    p
                                    ek
                                 
                                 +
                                 
                                    ϕ
                                    ek
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 }
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∂
                                                
                                                   ∂
                                                   t
                                                
                                             
                                             +
                                             
                                                γ
                                                ik
                                             
                                          
                                       
                                    
                                    2
                                 
                                 
                                    I
                                    ik
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 =
                                 e
                                 
                                    Γ
                                    ik
                                 
                                 
                                    γ
                                    ik
                                 
                                 {
                                 
                                    N
                                    ik
                                    β
                                 
                                 
                                    S
                                    i
                                 
                                 [
                                 
                                    h
                                    i
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 ]
                                 +
                                 
                                    p
                                    ik
                                 
                                 }
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∂
                                                         
                                                            ∂
                                                            t
                                                         
                                                      
                                                      +
                                                      v
                                                      Λ
                                                   
                                                
                                             
                                             2
                                          
                                          −
                                          
                                             3
                                             2
                                          
                                          
                                             v
                                             2
                                          
                                          
                                             ∇
                                             2
                                          
                                       
                                    
                                 
                                 
                                    ϕ
                                    ek
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 =
                                 
                                    N
                                    ek
                                    α
                                 
                                 
                                    v
                                    2
                                 
                                 
                                    Λ
                                    2
                                 
                                 
                                    S
                                    e
                                 
                                 [
                                 
                                    h
                                    e
                                 
                                 (
                                 
                                    
                                       x
                                       →
                                    
                                 
                                 ,
                                 t
                                 )
                                 ]
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    S
                                    k
                                 
                                 [
                                 
                                    h
                                    k
                                 
                                 ]
                                 =
                                 
                                    S
                                    k
                                    max
                                 
                                 
                                    
                                       
                                          
                                             1
                                             +
                                             exp
                                             
                                                
                                                   
                                                      −
                                                      
                                                         2
                                                      
                                                      
                                                         
                                                            
                                                               h
                                                               k
                                                            
                                                            −
                                                            
                                                               μ
                                                               k
                                                            
                                                         
                                                         
                                                            
                                                               σ
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       −
                                       1
                                    
                                 
                              
                           
                        where index k
                        ={e, i} denotes excitatory or inhibitory. The meaning of the parameters, along with some physiological bounds and the values used in our tests, are given in Table 1
                        . A detailed description of these equations can be found in Refs. [15,16]. Here, we will focus on the aspects of the model most relevant for the numerical implementation.

There are two sources of nonlinearity, related to the coupling of the synaptic inputs to the membrane potential and vice versa. The former connection is quadratically nonlinear, while the latter is given by the sigmoidal function S
                        
                           k
                        , which describes the onset of firing as the potential exceeds the threshold value μ
                        
                           k
                        . These nonlinearities tend to form sharp transitions of the potentials across the domain. That is one reason why we opted for a finite-difference discretization over a pseudo-spectral approach. Spectral accuracy would be of limited value in the presence of steep gradients and the finite-difference scheme can be parallelized much more efficiently. The second reason is that we would like to be able to change the geometry of the domain and the boundary conditions in future work. The finite-difference scheme is more flexible in that respect.

The only spatial derivatives in the model are those in the equations for the long-range connections. These are damped wave equations. We will discretize the Laplacian using a five-point stencil on a rectangular grid. In previous work, Bojak and Liley chose a second-order centred difference scheme for the time derivatives [6]. A disadvantage of this approach is that the stability condition of this scheme dictates that we set the time step inversely proportional to the grid spacing. In practice, they used a time step of 0.05ms. To avoid this obstacle, we want to use implicit timestepping, and have currently implemented the unconditionally stable implicit Euler method, as described in Section 3.

Following earlier work on this model (e.g. [6,20]), we adopt periodic boundary conditions in both dimensions. This is a common choice in the study of mean-field models, and is partially justified by the observation, that each part of the cortex is connected to each other part. A discussion of this argument can be found in chapter 11 of Nunez and Srinivasan [4]. A result of this choice is that the model PDEs will be equivariant under translations and reflections. This equivariance has consequences for the behaviour of the model. An in-depth discussion of these consequences is beyond the scope of the current paper, but in Section 6 we will decribe how to compute periodic solutions for the equivariant system.

Other authors have used this model with an additional diffusive term in the equations for the membrane potentials to model gap junctions [21]. Inclusion of these terms can drastically change the bifurcation behaviour, as they can cause Turing transitions to space-dependent equilibria. Without the additional terms, a Hopf bifurcation from a spatially homogeneous equilibrium to a space dependent periodic orbit or a saddle-node bifurcation of the equilibrium often appear to be the primary instability. The gap junction terms can readily be included in our implementation, and in Section 5 we will describe how to solve for equilibrium states that may depend on space.

We will test our implementation by comparing to, and extending, the computations of oscillations with a 40Hz component by Bojak and Liley [20]. Oscillations with this frequency are called gamma oscillations, and have been hypothesized to aid in the communication between groups of neurons [22]. Both simulations and experiments indicate that gamma oscillations occur in subjects performing cognitive tasks (see, e.g. [23] and references therein). Gamma band activity was found in the Liley model despite the fact that it was in no way tuned or formulated to produce this behaviour.

The parameter values for this experiment are listed in Table 1. The 40Hz oscillations arise spontaneously if the number of local inhibitory-to-inhibitory connections is changed slightly. We introduce a scaling parameter r by replacing 
                           
                              N
                              ii
                              β
                           
                           →
                           r
                           
                              N
                              ii
                              β
                           
                        . This is the only parameter that will be varied in our tests.

Rather than creating our code from scratch, we opted to work with the Portable, Extensible Toolkit for Scientific Computation (PETSc): an open-source, object oriented library that is designed for the scalable solution and analysis of PDEs [24,17]. PETSc is written in the C language, and is usable from C/C++ as well as Fortran and Python. We use PETSc in conjunction with the Scalable Library for Eigenvalue Problem Computations (SLEPc) [25], for the computation of eigenspectra of equilibrium and periodic solutions. Since our implementation uses some features of PETSc that are recent additions and are still being modified, we use the development version of both projects.

PETSc is split up into multiple components to address the various problems associated with solving PDEs numerically. For our purposes, we treat the DM component, which handles the topology of the discretization, as the most fundamental, from which we can easily derive memory allocation and communication for distributed vectors (Vec) and matrices (Mat). With vectors and matrices, we can now solve linear systems, such as those that arise in Newton iteration for implicit time-stepping and the computation of equilibria and periodic orbits. PETSc's component for this is called KSP, and it has numerous iterative solvers implemented, as well as preconditioners, (PC), to increase convergence rates. For implicit time-stepping, for example, we use GMRES, preconditioned with incomplete LU (ILU) factorization, combined with the block Jacobi method [26,27]. On top of the linear solvers come the nonlinear solvers, PETSc's SNES component, which implements a few different methods, such as globally convergent Newton iteration with line search [28]. Finally, PETSc provides a timestepping component, TS, to obtain time dependent solutions. Implemented here are numerous explicit and implicit schemes such as adaptive stepsize Runge–Kutta and implicit Euler. The implicit schemes make use of the SNES component. A schematic of the hierarchy discussed here can be found in Fig. 1
                        .

For our dynamical systems calculations we will frequently need to compute specific eigenvalues and eigenvectors for system-sized matrices. For this end, we use SLEPc, which implements iterative eigenvalue solvers using PETSc Vec and Mat distributed data structures. The component of SLEPc that we use is EPS, which has a few algorithms for iteratively solving eigenproblems. Its default algorithm is Krylov–Schur iteration.

Following earlier work by Bojak and Liley (e.g. [6,20]) we consider the PDEs on a rectangular domain with periodic boundary conditions. On this domain, we use a rectangular grid of N
                        
                           x
                         by N
                        
                           y
                         points. In the tests presented in Section 7, the domain and the grid are square. PETSc allows for more complicated domain shapes and grids, that can be encoded in the DM component, independent of the higher-level components. This choice of periodic boundary conditions is one of computational convenience. As we have no formulation of boundary conditions that come from the physiology, we adopt periodic boundaries and look at phenomena that are on length scales below that of the system size. A brief demonstration of this can be seen in Fig. 2
                         and its caption.

Within DM, PETSc provides a simpler subcomponent, DMDA, for working with finite differences on structured grids such as our rectangle. If we specify a stencil to use for the spatial derivatives in the DMDA, PETSc will automatically handle numerous things for parallel execution, such as memory allocation and the communication setup for distributed vectors and for the distributed Jacobian matrix.

To make use of PETSc's solvers, the model must be written as a system of equations that is first order in time. This we achieve by introducing new states J
                        
                           jk
                         and ψ
                        
                           ek
                         according to
                           
                              (6)
                              
                                 
                                    
                                       ∂
                                       
                                          I
                                          jk
                                       
                                    
                                    
                                       ∂
                                       t
                                    
                                 
                                 =
                                 
                                    J
                                    jk
                                 
                                 −
                                 
                                    γ
                                    jk
                                 
                                 
                                    I
                                    jk
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       ∂
                                       
                                          J
                                          jk
                                       
                                    
                                    
                                       ∂
                                       t
                                    
                                 
                                 =
                                 e
                                 
                                    Γ
                                    jk
                                 
                                 
                                    γ
                                    jk
                                 
                                 {
                                 
                                    N
                                    jk
                                    β
                                 
                                 
                                    S
                                    j
                                 
                                 [
                                 
                                    h
                                    j
                                 
                                 ]
                                 +
                                 
                                    ϕ
                                    jk
                                 
                                 +
                                 
                                    p
                                    jk
                                 
                                 }
                                 −
                                 
                                    γ
                                    jk
                                 
                                 
                                    J
                                    jk
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       ∂
                                       
                                          ϕ
                                          ek
                                       
                                    
                                    
                                       ∂
                                       t
                                    
                                 
                                 =
                                 
                                    ψ
                                    ek
                                 
                                 −
                                 
                                    v
                                    2
                                 
                                 
                                    Λ
                                    2
                                 
                                 
                                    ϕ
                                    ek
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       ∂
                                       
                                          ψ
                                          ek
                                       
                                    
                                    
                                       ∂
                                       t
                                    
                                 
                                 =
                                 
                                    v
                                    2
                                 
                                 
                                    Λ
                                    2
                                 
                                 
                                    N
                                    ek
                                    α
                                 
                                 
                                    S
                                    e
                                 
                                 [
                                 
                                    h
                                    e
                                 
                                 ]
                                 +
                                 
                                    3
                                    2
                                 
                                 
                                    v
                                    2
                                 
                                 
                                    ∇
                                    2
                                 
                                 
                                    ϕ
                                    ek
                                 
                                 −
                                 
                                    v
                                    2
                                 
                                 
                                    Λ
                                    2
                                 
                                 
                                    ψ
                                    ek
                                 
                                 ,
                              
                           
                        with indices j, k
                        ={e, i}.

We opted to use a struct, seen in Code 2.1, to store the fields, rather than a triply indexed array.
                           Code 2.1
                           Struct for the fields. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                typedef struct _Field{
                                             
                                          
                                          
                                             
                                                  PetscReal h_e, h_i,
                                             
                                          
                                          
                                             
                                                    I_ee, J_ee,
                                             
                                          
                                          
                                             
                                                    I_ie, J_ie,
                                             
                                          
                                          
                                             
                                                    I_ei, J_ei,
                                             
                                          
                                          
                                             
                                                    I_ii, J_ii,
                                             
                                          
                                          
                                             
                                                    phi_ee, psi_ee,
                                             
                                          
                                          
                                             
                                                    phi_ei, psi_ei;
                                             
                                          
                                          
                                             
                                                } Field;
                                             
                                          
                                       
                                    
                                 
                              
                           

All of the model parameters are stored in a struct designated as the application context. The application context is how PETSc gets problem related parameters into the user-defined functions needed by its solvers.
                           Code 2.2
                           Application context struct with the model parameters. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                typedef struct _AppCtx{
                                             
                                          
                                          
                                             
                                                  PassiveReal hr_e, hr_i,
                                             
                                          
                                          
                                             
                                                    tau_e, tau_i,
                                             
                                          
                                          
                                             
                                                    heq_ee, heq_ie,
                                             
                                          
                                          
                                             
                                                    heq_ei, heq_ii,
                                             
                                          
                                          
                                             
                                                    Gamma_ee, Gamma_ie,
                                             
                                          
                                          
                                             
                                                    Gamma_ei, Gamma_ii,
                                             
                                          
                                          
                                             
                                                    gamma_ee, gamma_ie,
                                             
                                          
                                          
                                             
                                                    gamma_ei, gamma_ii,
                                             
                                          
                                          
                                             
                                                    Nalpha_ee, Nalpha_ei,
                                             
                                          
                                          
                                             
                                                    Nbeta_ee, Nbeta_ie,
                                             
                                          
                                          
                                             
                                                    Nbeta_ei, Nbeta_ii,
                                             
                                          
                                          
                                             
                                                    v, Lambda,
                                             
                                          
                                          
                                             
                                                    Smax_e, Smax_i,
                                             
                                          
                                          
                                             
                                                    mu_e, mu_i,
                                             
                                          
                                          
                                             
                                                    sigma_e, sigma_i,
                                             
                                          
                                          
                                             
                                                    p_ee, p_ei,
                                             
                                          
                                          
                                             
                                                    p_ie, p_ii;
                                             
                                          
                                          
                                             
                                                  …
                                          
                                          
                                             
                                                } AppCtx;
                                             
                                          
                                       
                                    
                                 
                              
                           

Similar to the fields, this allows readable code for the parameters. For example, one accesses the Γ
                           ie
                         parameter as user->Gamma_ie, if user is defined as the pointer AppCtx *user;. How the parameters show up in our struct for the application context is shown in Code 2.2.

In addition to the structs listed above, we need to provide PETSc with (at least) a C function that computes the vector field for a given state. We call this function FormFunction, and from this PETSc is capable of approximating the Jacobian with various finite difference methods. However, we also supply a C function to explicitly compute the Jacobian, named FormJacobian, because this allows for more efficient calculations, especially when looking at stepping the variational equations in Section 4.

We currently use the implicit Euler method to time-step the discretized equations. As mentioned in Section 1.1, this allows us to take larger time steps than feasible with explicit methods. Since we are aiming to compute periodic orbits, rather than to generate long time series, the first order accuracy of the method is not an issue. Once a periodic orbit is computed, the time-step size can be reduced to increase accuracy. Another option is to use Richardson extrapolation to increase the order of accuracy, using the same nonlinear solving as described below.

We symbolically write the dynamical system as
                           
                              (10)
                              
                                 
                                    
                                       u
                                       ˙
                                    
                                 
                                 =
                                 f
                                 (
                                 u
                                 )
                                 ,
                                 
                                 f
                                 :
                                 
                                    
                                       
                                          ℝ
                                       
                                    
                                    N
                                 
                                 →
                                 
                                    
                                       
                                          ℝ
                                       
                                    
                                    N
                                 
                              
                           
                        where N is the total number of unknowns after discretization, in our case 14×
                        N
                        
                           x
                        
                        ×
                        N
                        
                           y
                        . The implicit Euler scheme for time integration is given by
                           
                              (11)
                              
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    u
                                    n
                                 
                                 +
                                 d
                                 t
                                 
                                 f
                                 (
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 )
                              
                           
                        where the subscript represents the step number, dt the step size, and u
                        0 the initial conditions. This nonlinear equation is solved by Newton iteration:
                           
                              (12)
                              
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                    k
                                 
                                 +
                                 d
                                 
                                    u
                                    k
                                 
                                 ,
                              
                           
                        where the superscript denotes the Newton iterate, and du
                        
                           k
                         is the solution to the linear system
                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             
                                                I
                                             
                                          
                                          −
                                          d
                                          t
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∂
                                                            f
                                                         
                                                         
                                                            ∂
                                                            u
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   u
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                   k
                                                
                                             
                                          
                                       
                                    
                                 
                                 d
                                 
                                    u
                                    k
                                 
                                 =
                                 d
                                 t
                                 
                                 f
                                 (
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                    k
                                 
                                 )
                                 −
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                    k
                                 
                                 +
                                 
                                    u
                                    n
                                    k
                                 
                                 ,
                              
                           
                        where ∂f/∂u denotes the N
                        ×
                        N Jacobian matrix. Provided that the initial approximation, 
                           
                              u
                              
                                 n
                                 +
                                 1
                              
                              0
                           
                        , is close enough to the actual solution of Eq. (11), this iteration should converge quadratically. This is achieved by making the initial approximation the result of an explicit Euler step
                           
                              (14)
                              
                                 
                                    u
                                    
                                       n
                                       +
                                       1
                                    
                                    0
                                 
                                 =
                                 
                                    u
                                    n
                                 
                                 +
                                 d
                                 t
                                 
                                 f
                                 (
                                 
                                    u
                                    n
                                 
                                 )
                                 .
                              
                           
                        
                     

As we scale up the size of our problems, it becomes the linear solve in Eq. (13) that takes most of the time. This problem is handled by using GMRES to solve the linear system. For large time steps, the spectrum of the matrix in Eq. (13) is spread out, and we need to precondition it for iterative solving. We make use ILU, which has shown to be reliable for this type of problem [29,30]. If we use more than one processor, PETSc uses distributed storage for the matrix, and combines ILU with block Jacobi preconditioning.

@&#IMPLEMENTATION@&#

PETSc provides a simple interface for timestepping in its TS component. The basic code required to set up a TS is given in Code 3.1. With a TS set up like this, the timestepping parameters are set from command line arguments at run time. For example, to do implicit Euler timestepping for 40.67ms with a time step of 0.1ms, one needs to provide the arguments


                        -ts_type beuler -ts_dt 0.1 -ts_final_time 40.67.

In this specific case, since the final time is not an integer number of timesteps, PETSc will step past it, and interpolate at the desired time.
                           Code 3.1
                           PETSc code for setting up and running the timestepping. FormFunctionTS and FormJacobianTS are user provided functions that compute the rhs of Eq. (10), and its Jacobian respectively. J is an appropriately allocated matrix to hold the Jacobian, and u a vector to hold the solutions. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                TS   ts;
                                             
                                          
                                          
                                             
                                                TSCreate(PETSC_COMM_WORLD,&ts);
                                             
                                          
                                          
                                             
                                                TSSetProblemType(ts,TS_NONLINEAR);
                                             
                                          
                                          
                                             
                                                TSSetExactFinalTime(ts);
                                             
                                          
                                          
                                             
                                                TSSetRHSFunction(ts,PETSC_NULL,FormFunctionTS,&user);
                                             
                                          
                                          
                                             
                                                TSSetRHSJacobian(ts,J,J,FormJacobianTS,&user);
                                             
                                          
                                          
                                             
                                                TSSetFromOptions(ts);
                                             
                                          
                                          
                                             
                                                TSSolve(ts,u);
                                             
                                          
                                       
                                    
                                 
                              
                           

The variational equations for the dynamical system are written as
                           
                              (15)
                              
                                 
                                    
                                       v
                                       ˙
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   f
                                                
                                                
                                                   ∂
                                                   u
                                                
                                             
                                          
                                       
                                    
                                    u
                                 
                                 v
                                 ,
                                 
                                 v
                                 ∈
                                 
                                    
                                       
                                          ℝ
                                       
                                    
                                    N
                                 
                              
                           
                        and must be integrated simultaneously with the dynamical system (10). Solving the variational equations allow us to compute the stability of solutions, and is also an essential ingredient for the treatment of boundary value problems such as those that arise in the computation of periodic orbits.

Performing implicit Euler timestepping on the variational Eq. (15) requires solutions of the linear problems
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             
                                                I
                                             
                                          
                                          −
                                          d
                                          t
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∂
                                                            f
                                                         
                                                         
                                                            ∂
                                                            u
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   u
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    v
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    v
                                    n
                                 
                                 .
                              
                           
                        Since we already have the Jacobian of the dynamical system at timestep n
                        +1, stepping the variational equations requires only one additional N
                        ×
                        N linear solve per time step.

@&#IMPLEMENTATION@&#

In PETSc, we implement the timestepping of the variational equations as a MATSHELL, effectively viewing it as a matrix-free multiplication. Within a MATSHELL, one needs to provide a context for storing the relevant data and write functions for the desired matrix operation(s). For example, we point the operation MATOP_MULT to a function that takes the initial state of the variational system 
                           v
                           (
                           0
                           )
                         as input, and outputs the result 
                           v
                           (
                           T
                           )
                         at the end of the timestepping. The context we use for the time stepping of the variational equations is shown in Code 4.1. The function we provide for MATOP_MULT works by first taking a step of the TS, then loading the Jacobian computed from that step and solving Eq. (16). This is repeated until the TS reaches its end.
                           Code 4.1
                           The MATSHELL context for timestepping of the variational equations. The TS holds the relevant info for stepping the dynamical system. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                typedef struct _PeriodIntegrationCtx{
                                             
                                          
                                          
                                             
                                                  // timestepping of the original eqn
                                             
                                          
                                          
                                             
                                                  TS   ts;
                                             
                                          
                                          
                                             
                                                  Mat   tsJac;
                                             
                                          
                                          
                                             
                                                  Vec   initState,endState,fullSol;
                                             
                                          
                                          
                                             
                                                  // additional requirements for variational eqn
                                             
                                          
                                          
                                             
                                                  Mat   J,eye;
                                             
                                          
                                          
                                             
                                                  KSP   ksp;
                                             
                                          
                                          
                                             
                                                } PeriodIntegrationCtx;
                                             
                                          
                                       
                                    
                                 
                              
                           

The MATSHELL thus defined can be used by SLEPc for the iterative computation of eigenpairs. In particular, we will use this approach to compute the Floquet multipliers of periodic orbits.

Having set up the function FormFunction for the right hand side of the dynamical system, and its Jacobian computation FormJacobian, also used for time integration, we can set up equilibrium calculations using PETSc's SNES component with very little effort.

Equilibrium solutions to the dynamical system (10) are solutions that satisfy
                           
                              (17)
                              
                                 f
                                 (
                                 u
                                 )
                                 =
                                 0
                                 .
                              
                           
                        To solve this, we can set up a Newton iteration scheme
                           
                              (18)
                              
                                 
                                    u
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    u
                                    k
                                 
                                 +
                                 d
                                 
                                    u
                                    k
                                 
                              
                           
                        with du coming from the solution of the linear system
                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   f
                                                
                                                
                                                   ∂
                                                   u
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          u
                                          k
                                       
                                    
                                 
                                 d
                                 
                                    u
                                    k
                                 
                                 =
                                 −
                                 f
                                 (
                                 
                                    u
                                    k
                                 
                                 )
                                 .
                              
                           
                        As with the timestepping, if the initial guess is good enough this will converge quadratically provided that 
                           (
                           ∂
                           f
                           /
                           ∂
                           u
                           )
                           
                              |
                              
                                 
                                    u
                                    k
                                 
                              
                           
                         is nonsingular. Unlike the case of time stepping, though, we do not always have a way to produce an initial approximation that is good enough. For stable equilibrium solutions, we can use timestepping to get close to an equilibrium, but this will not work for unstable equilibria. One possible solution is using globally convergent Newton methods. Using such methods we can find equilibria from very coarse initial data, at the cost of computing many iterations. The line search algorithm and the trust region approach (see, e.g. [28]) are implemented in the SNES component.

Stability of equilibrium solutions follows from the spectrum of the Jacobian. Due to discrete symmetries of a domain, these can appear in groups. On a square domain, for instance, a single eigenvalue will be associated with up to eight eigenvectors, with wavenumbers (±
                        k
                        
                           x
                        , ±
                        k
                        
                           y
                        ) and (±
                        k
                        
                           y
                        , ±
                        k
                        
                           x
                        ).

As discussed in Section 1.1, the model is also equivariant under translatations in both dimensions. In the presence of this symmetry, it is more natural to search for relative equilibria, also called travelling waves. This leads to the introduction of two extra unknowns, that can be thought of as the wave velocities, into system (17), and an extension by two equations of the associated linear system (19). However, since we have so far only observed spatially homogeneous equilibrium states, we will discuss this adjustment in Section 6 on periodic solutions.

@&#IMPLEMENTATION@&#

Setting up and using a nonlinear solver within PETSc is straightforward, as shown in Code 5.1. The default algorithm used by SNES is Newton's method with line search.


                        
                           Code 5.1
                           Code snippet for solving for equilibria. Vectors r and u are preallocated, with u being the initial approximation, and J a preallocated matrix for the Jacobian. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                SNES   snes;
                                             
                                          
                                          
                                             
                                                SNESCreate(PETSC_COMM_WORLD,&snes);
                                             
                                          
                                          
                                             
                                                SNESSetFunction(snes,r,FormFunctionSNES,&user);
                                             
                                          
                                          
                                             
                                                SNESSetJacobian(snes,J,J,FormJacobianSNES,&user);
                                             
                                          
                                          
                                             
                                                SNESSetFromOptions(snes);
                                             
                                          
                                          
                                             
                                                SNESSolve(snes,PETSC_NULL,u);
                                             
                                          
                                       
                                    
                                 
                              
                           

The primary instability in the Liley model is often a Hopf bifurcation, and periodic orbits have been shown to play an important role in the dynamics of ODE reductions of the model (e.g. [16,31]). However, space dependent periodic orbits have not previously been computed and studied. Using PETSc data structures for bordered matrices, in conjunction with a MATSHELL, we can solve for periodic orbits based on the time stepping described in Sections 3 and 4.

Relative periodic orbits solve the boundary value problem
                           
                              (20)
                              
                                 F
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 =
                                 ϕ
                                 (
                                 t
                                 ,
                                 u
                                 )
                                 −
                                 
                                    T
                                    ab
                                 
                                 u
                                 =
                                 0
                                 ,
                              
                           
                        where ϕ is the flow of the dynamical system (10), t is the period, and T
                        
                           ab
                        
                        u(x, y)=
                        u(x
                        −
                        a, y
                        −
                        b) the translation operator. Our strategy for solving this equation is essentially that of Sanchez et al. [32], namely Newton iterations combined with unconditioned GMRES iteration. Linearizing Eq. (20) gives
                           
                              (21)
                              
                                 (
                                 
                                    D
                                    u
                                 
                                 ϕ
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 −
                                 
                                    
                                       I
                                    
                                 
                                 )
                                 d
                                 u
                                 +
                                 f
                                 (
                                 ϕ
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 )
                                 d
                                 t
                                 +
                                 
                                    T
                                    ab
                                 
                                 
                                    
                                       
                                          ∂
                                          
                                       
                                       u
                                    
                                    
                                       ∂
                                       
                                          x
                                          
                                       
                                    
                                 
                                 d
                                 a
                                 +
                                 
                                    T
                                    ab
                                 
                                 
                                    
                                       
                                          ∂
                                          
                                       
                                       u
                                    
                                    
                                       ∂
                                       
                                          y
                                          
                                       
                                    
                                 
                                 d
                                 b
                                 =
                                 −
                                 F
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 ,
                              
                           
                        where D
                        
                           u
                        
                        ϕ is a matrix of derivatives of the flow with respect to its initial condition. Upon convergence, this is the monodromy matrix of the periodic orbit. The result is N equations in N
                        +3 unknowns, which must be closed by phase conditions. For the temporal phase, we opted to handle this with a one dimensional Poincaré section, which gives a constraint on the Newton update step:
                           
                              (22)
                              
                                 
                                    
                                       [
                                       
                                          D
                                          u
                                       
                                       ϕ
                                       (
                                       u
                                       ,
                                       t
                                       )
                                       ]
                                    
                                    
                                       k
                                       ,
                                       .
                                    
                                 
                                 d
                                 u
                                 +
                                 
                                    f
                                    k
                                 
                                 (
                                 ϕ
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 )
                                 d
                                 t
                                 =
                                 C
                                 −
                                 
                                    ϕ
                                    k
                                 
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 ,
                              
                           
                        where 
                           
                              
                                 [
                                 
                                    D
                                    u
                                 
                                 ϕ
                                 (
                                 u
                                 ,
                                 t
                                 )
                                 ]
                              
                              
                                 k
                                 ,
                                 .
                              
                           
                         denotes the kth row of the matrix D
                        
                           u
                        
                        ϕ, and C the desired value of the flow on the Poincaré section. For the spatial phase, we restrict the update step to be orthogonal to the generators of spatial translations:


                        
                           
                              (23)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   
                                                
                                                u
                                             
                                             
                                                ∂
                                                
                                                   x
                                                   
                                                
                                             
                                          
                                          d
                                          u
                                       
                                       
                                          =
                                          0
                                          ,
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   
                                                
                                                u
                                             
                                             
                                                ∂
                                                
                                                   y
                                                   
                                                
                                             
                                          
                                          d
                                          u
                                       
                                       
                                          =
                                          0
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

These choices give the bordered system
                           
                              (24)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      D
                                                      u
                                                   
                                                   ϕ
                                                   (
                                                   u
                                                   ,
                                                   t
                                                   )
                                                   −
                                                   
                                                      T
                                                      ab
                                                   
                                                   )
                                                
                                                
                                                   f
                                                   (
                                                   ϕ
                                                   (
                                                   u
                                                   ,
                                                   t
                                                   )
                                                   )
                                                
                                                
                                                   
                                                      T
                                                      ab
                                                   
                                                   
                                                      
                                                         
                                                            ∂
                                                            
                                                         
                                                         u
                                                      
                                                      
                                                         ∂
                                                         
                                                            x
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      T
                                                      ab
                                                   
                                                   
                                                      
                                                         
                                                            ∂
                                                            
                                                         
                                                         u
                                                      
                                                      
                                                         ∂
                                                         
                                                            y
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         [
                                                         
                                                            D
                                                            u
                                                         
                                                         ϕ
                                                         (
                                                         u
                                                         ,
                                                         t
                                                         )
                                                         ]
                                                      
                                                      
                                                         k
                                                         ,
                                                         .
                                                      
                                                   
                                                
                                                
                                                   
                                                      f
                                                      k
                                                   
                                                   (
                                                   ϕ
                                                   (
                                                   u
                                                   ,
                                                   t
                                                   )
                                                   )
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∂
                                                            
                                                         
                                                         u
                                                      
                                                      
                                                         ∂
                                                         
                                                            x
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∂
                                                            
                                                         
                                                         u
                                                      
                                                      
                                                         ∂
                                                         
                                                            y
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   d
                                                   u
                                                
                                             
                                             
                                                
                                                   d
                                                   t
                                                
                                             
                                             
                                                
                                                   d
                                                   a
                                                
                                             
                                             
                                                
                                                   d
                                                   b
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   −
                                                   F
                                                   (
                                                   u
                                                   ,
                                                   t
                                                   )
                                                
                                             
                                             
                                                
                                                   C
                                                   −
                                                   
                                                      ϕ
                                                      k
                                                   
                                                   (
                                                   u
                                                   ,
                                                   t
                                                   )
                                                
                                             
                                             
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        the solution to which can be used to update the approximate solution
                           
                              (25)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      u
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      t
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      a
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      b
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      u
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      t
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      a
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      b
                                                      n
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             
                                                
                                                   d
                                                   u
                                                
                                             
                                             
                                                
                                                   d
                                                   t
                                                
                                             
                                             
                                                
                                                   d
                                                   a
                                                
                                             
                                             
                                                
                                                   d
                                                   b
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The matrix D
                        
                           u
                        
                        ϕ is dense, so we should avoid calculating and storing it explicitly. Iterative solving of the linear problem, (24), requires the computation of matrix-vector products, which are constructed from the integration of the variational Eq. (15) with 
                           v
                           (
                           0
                           )
                           =
                           d
                           u
                         and the vector field f(ϕ(u, t)) at the end point of the approximately periodic orbit. Since the governing PDE is dissipative, most of the eigenvalues of the monodromy matrix are clustered around zero. This aids the convergence of GMRES, without any preconditioning. Sanchez et al. [32] provide bounds for the number of GMRES iterations for the Navier–Stokes equation, and the convergence we observe for the Liley model is qualitatively similar.

@&#IMPLEMENTATION@&#

The problem of creating a bordered matrix system in a distributed environment is not a trivial one. The specific case that we have is one vector, u, that is sparsely connected and distributed among processors, and three parameters t, a, and b that must exist and be synchronized across all processors.

PETSc's DM module has some recently introduced functionality that allows us to handle this in a straightforward way, letting us make use of the DMDA already used in the other types of calculations.


                        DMRedundant can be used for the a, b, t components of our extended system, as it has the precise behaviour that we require. Next, we use a DMComposite to join together the DMDA of the grid with the DMRedundant of the period and translations. We can then derive vectors from this DMComposite, and use these vectors for PETSc's iterative linear solvers. PETSc code that illustrates this idea is shown in Code 6.1.


                        
                           Code 6.1
                           Additional DM pieces for extended vectors as in Eq. (25), assuming that da is the DM associated with the grid structure. The numerical arguments in DMRedundantCreate represent the processor where the redundant entries live (in global vectors), and the number of redundant entries respectively. Note that the spatial and the time symmetries are taken to be in separate DMRedundant entries, this is just a matter of preference. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                DM packer, redT, redC;
                                             
                                          
                                          
                                             
                                                DMCompositeCreate(PETSC_COMM_WORLD,&packer);
                                             
                                          
                                          
                                             
                                                DMRedundantCreate(PETSC_COMM_WORLD,0,1,&redT);
                                             
                                          
                                          
                                             
                                                DMRedundantCreate(PETSC_COMM_WORLD,0,2,&redC);
                                             
                                          
                                          
                                             
                                                DMCompositeAddDM(packer,da);
                                             
                                          
                                          
                                             
                                                DMCompositeAddDM(packer,redT);
                                             
                                          
                                          
                                             
                                                DMCompositeAddDM(packer,redC);
                                             
                                          
                                       
                                    
                                 
                              
                           

The matrix multiplication is done through a MATSHELL, and the struct that holds the relevant data is found in Code 6.2.


                        
                           Code 6.2
                           For finding periodic solution, we need a method for integrating the variational equations (the MATSHELL discussed in Section 4), additional DMs, and space for holding f evaluated at the state at the end of the integration. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                typedef struct _PeriodFindCtx{
                                             
                                          
                                          
                                             
                                                  Mat   *linTimeIntegration;
                                             
                                          
                                          
                                             
                                                  DM     packer,redT,redC;
                                             
                                          
                                          
                                             
                                                  Vec   endState,f_at_endState;
                                             
                                          
                                          
                                             
                                                } PeriodFindCtx;
                                             
                                          
                                       
                                    
                                 
                              
                           

In this section, we present some computations that serve to validate our implementation and to investigate its efficiency. All tests are based on the parameter set in Table 1, and the scaling of the number of local inhibitory-to-inhibitory connections, r, is varied around the first bifurcation from an equilibrium to more complicated, spatio-temporal behaviour.


                     Fig. 2 shows the neutral stability curve for the spatially homogeneous equilibrium, which is the unique attractor of the model at small values of r. The primary transition is a Hopf bifurcation with spatial wave numbers that depend on the system size. For systems smaller than 2×2cm2, the emerging periodic orbit is spatially homogeneous. For larger systems, space dependent orbits emerge, and their typical length scale converges to about 9.3cm for large system sizes. These stability curves were computed by solving small eigenvalue problems for each combination of wavenumbers, independent from the PETSc implementation. The eigenvalues computed by Krylov–Schur iteration in SLEPc, presented in Section 7.2, are in good agreement.

A partial bifurcation diagram, for spatially homogeneous solutions only, is shown in Fig. 3
                     . In this diagram, the Hopf bifurcation is subcritical, and time series analysis indicates that the Hopf bifurcations associated with nonzero wave numbers are, too. The time series presented in Section 7.1 was generated by starting from the equilibrium at r
                     =1 and adding a finite-size perturbation in the least stable direction, with wave number |k
                     
                        x
                     |=|k
                     
                        y
                     |=1.

For the timestepping demonstration, we used a system size of 12.8×12.8cm2 with 0.5mm resolution, resulting in a 256×256 grid, and N
                        =917,504 unknowns in total. Setting the parameter r
                        =1.0, we initialize with the stable equilibrium solution perturbed by its least stable eigenmode, shown in Fig. 7. Since the equilibrium solution is stable, small perturbations just decay, but sufficiently large perturbations grow. The snapshots of Fig. 4
                         were taken after a transient time of 600ms. The membrane potentials show behaviour that is nearly periodic, with a dominant period of 40Hz, as demonstrated by the power spectrum shown in the last panel. The power spectrum is computed from a spatial average over the black box in the other panels, which was done to mimic the smearing of the signal observed from the scalp. Averaging over other regions of the same size produces qualitatively similar power spectra.

Since the time-stepping code lies at the core of the periodic orbit solver, we also investigated its scaling with an increasing number of processors. Doubling the domain size, while keeping the grid spacing fixed, gives a dynamical system with N
                        =3,670,016 degrees of freedom. We time-stepped this system on varying numbers of Intel Xeon processors with Infiniband interconnects (saw.sharcnet.ca) and the results are displayed in Fig. 5
                        . Scaling for few processors is slightly hindered by the change in preconditioner that is used, namely ILU on a single processor versus block Jacobi plus ILU in parallel. Except for this irregularity, the scaling is shown to be linear up to 256 processors.

At 256 processors, we are at 14,336 unknowns per process. As per PETSc's recommendations of not going below 10,000 unknowns per process [24], we do not expect efficient scaling to many more processors.

We computed the whole equilibrium curve of Fig. 3 through parameter continuation, which is a trivial extension of the algorithm for computing equilibria, presented in Section 5. For each computed equilibrium solution, we took the Jacobian and used SLEPc to compute the eigenvalues with the largest real parts. The result is shown in Fig. 6
                        . As predicted by the neutral stability curve computation, the (1, 1) mode turns unstable first, immediately followed by the (1, 0) mode. Around r
                        =1.08, the (0, 2) mode crosses the (0, 1) mode and proceeds to become the most unstable mode for larger values of r. The least stable eigenmode for r
                        =1.046, just after its eigenvalue has crossed zero, is shown in Fig. 7
                        .

We tested the computation of periodic orbits on a smaller grid, namely 16×16 points, still with 0.5mm resolution, and with r
                        =1.2. The primary Hopf bifurcation is sub critical, so there is no easy way to compute the branch of space-dependent periodic solutions. Instead, we computed one of the spatially homogeneous orbits, for which an approximate solution can readily be obtained from analysis of the ODE reduction of the model. In fact, the upper part of the branch of periodic orbits shown in Fig. 3 is stable to all spatially homogeneous perturbations.

Starting from a coarse initial approximation, the Newton iterations converged faster than linear, and each Newton step took between 8 and 12 GMRES iterations, out of a maximum of N
                        +3=3587. The nonlinear and linear residuals are shown in Fig. 8
                        . Subsequently, we computed the most unstable multipliers, using SLEPC with the MATSHELL for stepping the variational system as described in Section 4.2. The most unstable multiplier is μ
                        1
                        =1.111 and corresponds to a wave number (1, 1) perturbation.

In the current paper, we have presented the basic implementation of the model and example computations to validate it and test its performance. The code will be available publicly [18]. As it is built on top of PETSc, the user has access to a range of nonlinear and linear solvers and preconditioners, which can be used to solve the boundary value problems that typically arise in dynamical systems analysis. The periodic orbit computation, presented in Section 7.3, is a simple example of such a boundary value problem, that has all the ingredients: a module for time-stepping the system and perturbations and a representation of user-specified, bordered matrices.

The next step in the development of the code is the implementation of pseudo-arclength continuation of periodic orbits. This will enable us, for instance, to complement the bifurcation diagram of the current test case, Fig. 3, with the branches of space-dependent periodic solutions that actually regulate the observed dynamics, in contrast to the highly unstable spatially homogeneous periodic orbits computed from the ODE reduction of the model.

We finish with emphasizing that there are some propagating modes within the cortex that can be described without considering its coupling to, say, the thalamus, as seen in Muller and Destexhe [34]. Although we did not attempt to tune the model parameters or initial conditions for the purpose, a comparison of the model output in Fig. 4 to the voltage sensitive dye experiments presented in [34] (see their Fig. 3) shows qualitative agreement with respect to the spatial extent of the patterns.

This implementation will be useful to studying such dynamics within the Liley model, and is easily modified to similar mean-field models of the cortex; examples being those that include the effects of gap junctions [21], and models that incorporate different properties for the long range connections.

@&#ACKNOWLEDGEMENTS@&#

L.v.V. was supported by NSERC Grant no. 355849-2008. Some of the computations were made possible by the facilities of the Shared Hierarchical Academic Research Computing Network (SHARCNET: www.sharcnet.ca) and Compute/Calcul Canada.

@&#REFERENCES@&#

