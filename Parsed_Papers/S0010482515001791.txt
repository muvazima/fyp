@&#MAIN-TITLE@&#Combining conceptual graphs and argumentation for aiding in the teleexpertise

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Improving the reasoning in conceptual graphs for better knowledge representation.


                        
                        
                           
                           Incorporation of argumentation algorithms for medical decision making processes.


                        
                        
                           
                           Structuring of reasoning procedures to guarantee traceability in the telemedicine.


                        
                        
                           
                           Elucidation of the mechanisms underlying some ethical problems in telemedicine.


                        
                        
                           
                           Effective benefits for both medical professionals and patients in the remote sites.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Argumentation

Collaboration

Conceptual graphs

Decision making

Ethical problems

Telemedicine

Traceability

@&#ABSTRACT@&#


               
               
                  Current medical information systems are too complex to be meaningfully exploited. Hence there is a need to develop new strategies for maximising the exploitation of medical data to the benefit of medical professionals. It is against this backdrop that we want to propose a tangible contribution by providing a tool which combines conceptual graphs and Dung׳s argumentation system in order to assist medical professionals in their decision making process. The proposed tool allows medical professionals to easily manipulate and visualise queries and answers for making decisions during the practice of teleexpertise. The knowledge modelling is made using an open application programming interface (API) called CoGui, which offers the means for building structured knowledge bases with the dedicated functionalities of graph-based reasoning via retrieved data from different institutions (hospitals, national security centre, and nursing homes). The tool that we have described in this study supports a formal traceable structure of the reasoning with acceptable arguments to elucidate some ethical problems that occur very often in the telemedicine domain.
               
            

@&#INTRODUCTION@&#

Telemedicine is a component of the health telematics that focuses on health actions requiring Information and Communication Technologies (ICTs) to deliver information across considerable physical distance. Telemedicine can be categorised into five principal groups [13]: teleconsultation, teleexpertise, telemonitoring, teleassistance, and medical response. In this paper, we are interested in the teleexpertise practice in which a physician benefits from professional advices provided by other physicians via ICTs to improve a patient׳s clinical health status [16].

Teleexpertise is a medical practice that involves at least two medical professionals who collaborate by sharing patients׳ information and experiences aimed at treating the patient. Communication between the professionals is bidirectional, where one may request for information or advice and feedback or advice is provided. It is the responsibility of each stakeholder to manage the information efficiently. It is in this light that we propose a frameworkor tool that could help to identify the different actors involved in any given teleexpertise process and their advices. Thus in the case of a legal proceeding challenge the proposed tool can potentially facilitate the identification of actors or medical professionals together with their different roles involved in a teleexpertise process. Furthermore, the proposed tool can also serve as a learning or knowledge elicitation for the medical professionals. In other words when confronted with an unforeseen diagnostic or therapeutic problem, a medical professional would have the possibility to search the knowledge base of previous cases to find the most appropriate analysis and solution to a specified problem. If the medical professional does not receive satisfactory responses from the knowledge base, he may engage in a teleexpertise procedure. For the implementation of the proposed framework, we use a Dung [15] argumentation system called also abstract argumentation system combined with conceptual graphs [36]. We propose some algorithms to build some semantic extensions [6] such as conflict-free, admissible and preferred extensions. These proposed algorithms form the component often called argumentative logic that will highlight the arguments or the accepted advices in a given act of teleexpertise.

The novelty of this work is the extension of Dung׳s argumentation system [15] to combine with conceptual graphs to clarify decisions that are made in a given process of teleexpertise. The conceptual graph component can be very useful for guaranteeing the visualisation of the reasoning traceability that leads to how a decision was arrived at and to solve some ethical problems [7] (e.g. informed consent, privacy, liability consideration [29] and Autonomy, Beneficence, Non-maleficence, Justice [19]).

The remainder of the paper is divided into the 5 sections. Section 2 presents a state-of-the-art review of the domain telemedicine; Section 3 provides background information on the conceptual graph formalism as well as its extensions, reasoning operations and formal semantics for each one. Section 4 presents the methods adopted, which are based on conceptual graphs approach and Dung׳s argumentation theory under the context of telemedicine. In Section 5 the results of the proposed study or system that makes it possible to ensure a good structured traceability of the medical professionals׳ reasoning are presented. The paper ends by a way on conclusion in Section 6.

Several studies [27,28,21,22] have been conducted in the domain of telemedicine. Nowadays the practice of telemedecine is changing the physician–patient relationship and has an impact on the responsibility of doctors to patients and how to treat patients [12]. In fact, not only does the exchange of data between medical professionals facilitates clear decision-making, but also the responsibilities of the professionals involved are engaged.

In this regard, Chopard et al. [12] proposed to store the discussion and make them traceable so that the stored information can be retrieved later on and potentially used to solve some ethical problems.

Xiao et al. [39] proposed a new approach to support data transfer and decision making process using ontologies in diagnosis and treatment of human brain tumour. In the proposed new approach by [39], conceptual graphs for unifying local views that can give an interface to local data for reasoning and managing knowledge were used. Similar to our work Xiao et al. [39] used conceptual graphs to manage medical records, but with a focus mainly on security policies while we are interested in the traceability of the decisions taken.

In emergency cases, the response time factor can be overcome by using virtual telemedicine in which a Clinical Decision Support System (CDSS) is deployed at rural stations [4]. This CDSS is an intelligent system that can make diagnosis and treatment (such as medication prescription [5]) for the patient. When no answer is available for a query, the system sends automatically an e-mail to an expert located elsewhere. After the response/feedback from the expert the knowledge base is updated. The general principle behind this CDSS is particularly similar to ours in the way its toolbox includes a teleexpertise system to get the answers of remote medical experts. Nevertheless in detail the operational functioning of a CDSS, only one medical professional (expert) can be contacted at a time while in our proposed tool, several medical professionals can be contacted in a collaborative manner in order to take the right decision. Furthermore, by using ontological approaches we guarantee semantic interoperability, decision support, flexibility of data management and integration [30].

Kamsu-Foguem [18] utilises the conceptual graphs to facilitate the systemic modelling and formal analysis of the requirements of information systems in telemedicine. As our work, he is also interested in ethical problems. However the author does not provide any information on how the proposed framework can be used in the act of teleexpertise to help medical professionals in their decision making process.

Conceptual graphs have also been used by [26,25,20] to represent medical information in order to ensure visual representations in the decision making process. This has been very useful for users because graphs make the information and knowledge modelling more user-friendly [24,25]. However, traceability of the reasoning has not been considered or dealt with in [24,25].

Many other works [20,23] deal with information visualisation applied in medical domain but not in telemedicine domain. Furthermore, [20] does not emphasise on the argumentation of the reasoning while in [23] the underlying reasoning steps are hidden from the user.

Conceptual graphs introduced by Sowa 
                     [36] meet the expectations of representational frameworks for argumentation. Indeed this representation support includes taxonomic principles and formal semantic to support the reasoning processes (e.g. mapping, deductive inference and constraints checking).

For the ease of understanding, the basic definitions and detailed explanations of conceptual graph models are examined in the ensuing section.


                        
                           Definition 1
                           Basic graphs support


                           BG support is a tuple 
                                 S
                                 =
                                 (
                                 
                                    
                                       T
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 
                                    
                                       T
                                    
                                    
                                       R
                                    
                                 
                                 ,
                                 I
                                 ,
                                 σ
                                 )
                               such that
                                 
                                    •
                                    
                                       T
                                       
                                          C
                                        and T
                                       
                                          R
                                        are finite disjoint sets of types.


                                       T
                                       
                                          C
                                        is a set of concept types partially ordered by the relation 
                                          ≤
                                       , in which there is a universal element (called superconcept of all elements), denoted ⊤.


                                       T
                                       
                                          R
                                        is a set of relation types partially ordered by the relation 
                                          ≤
                                       , and partitioned in subsets 
                                          
                                             
                                                T
                                             
                                             
                                                R
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                T
                                             
                                             
                                                R
                                             
                                             
                                                k
                                             
                                          
                                        of relation types respectively with arity 
                                          1
                                          ,
                                          …
                                          ,
                                          k
                                       , and wherein the eventual universal elements are denoted by 
                                          
                                             
                                                ⊤
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                ⊤
                                             
                                             
                                                k
                                             
                                          
                                       . The arity of a relation r is denoted as arity(r). Two relations with different arities are not comparable by 
                                          ≤
                                       .


                                       I is a set of individual markers disjointed from T
                                       
                                          C
                                        and T
                                       
                                          R
                                       . In addition we denote by ⁎, the generic marker. The set of markers is denoted 
                                          M
                                          =
                                          I
                                          ∪
                                          {
                                          ⁎
                                          }
                                       . This set is provided in the following partial order 
                                          ≤
                                       : the elements of I are pairwise incomparable, and 
                                          ∀
                                          m
                                          ∈
                                          I
                                          ,
                                          m
                                          ≤
                                          ⁎
                                       . Each element of I can be assigned to several types and to all super-types thereof.


                                       σ associates to each j-ary relation (
                                          r
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                R
                                             
                                             
                                                j
                                             
                                          
                                       ) a signature namely a j-tuple of concept types (
                                          σ
                                          (
                                          r
                                          )
                                          ∈
                                          
                                             
                                                (
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      C
                                                   
                                                
                                                )
                                             
                                             
                                                j
                                             
                                          
                                       ), where the i-th concept is the maximal type for the i-th argument of the relation. The signatures comply with the orders defined in T
                                       
                                          C
                                        and T
                                       
                                          R
                                        namely: 
                                          ∀
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                r
                                             
                                             
                                                2
                                             
                                          
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                R
                                             
                                             
                                                j
                                             
                                          
                                          ,
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                          ≤
                                          
                                             
                                                r
                                             
                                             
                                                2
                                             
                                          
                                          ⇒
                                          σ
                                          (
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                          )
                                          ≤
                                          σ
                                          (
                                          
                                             
                                                r
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       , i.e. for all 
                                          1
                                          ≤
                                          i
                                          ≤
                                          j
                                       , the i-th argument of 
                                          σ
                                          (
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                          )
                                        is more specific than the i-th argument of 
                                          σ
                                          (
                                          
                                             
                                                r
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       .

The support defined above represents the vocabulary. The ontological knowledge is defined in the vocabulary. This vocabulary helps to support the expression of basic graphs and also the fundamental operation for reasoning called projection, which is a graph homomorphism (i.e. a mapping with respect to the semantic structure of graphs). The facts are represented by basic graphs [9].

A basic graph is in normal form if each of its individual marker appears exactly once. This basic formalism has a semantic in first-order logic through a transformation denoted Φ 
                        [36]. The fundamental notion for reasoning on basic graphs is graphs’ homomorphism, also called projection 
                        [11]. The definition of this fundamental notion is depicted in Definition 2: 
                           Definition 2
                           Projection


                           Let 
                                 F
                                 =
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       F
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       F
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       F
                                    
                                 
                                 ,
                                 
                                    
                                       label
                                    
                                    
                                       F
                                    
                                 
                                 )
                               and 
                                 T
                                 =
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       T
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       T
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       T
                                    
                                 
                                 ,
                                 
                                    
                                       label
                                    
                                    
                                       T
                                    
                                 
                                 )
                              , two basic graphs defined on a same support. A projection Π from F to T is an application from C
                              
                                 F
                               to C
                              
                                 T
                               and from R
                              
                                 F
                               to R
                              
                                 T
                              , maintaining edges and may specialise concepts and relations labels, namely
                                 
                                    •
                                    
                                       
                                          ∀
                                          (
                                          r
                                          ,
                                          i
                                          ,
                                          c
                                          )
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                F
                                             
                                          
                                          ,
                                          (
                                          Π
                                          (
                                          r
                                          )
                                          ,
                                          i
                                          ,
                                          Π
                                          (
                                          c
                                          )
                                          )
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                F
                                             
                                          
                                       ,


                                       
                                          ∀
                                          e
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                F
                                             
                                          
                                          ∪
                                          
                                             
                                                R
                                             
                                             
                                                F
                                             
                                          
                                          ,
                                          
                                             
                                                label
                                             
                                             
                                                T
                                             
                                          
                                          (
                                          Π
                                          (
                                          e
                                          )
                                          )
                                          ≤
                                          
                                             
                                                label
                                             
                                             
                                                F
                                             
                                          
                                          (
                                          e
                                          )
                                       .

The projection is a kind of interrogation mechanism. Often the projection provides the means to make some requests on conceptual graphs. However, to refine these requests we need to include some rules. These rules make it possible to add additional ontological information.

The nested graphs allow knowledge representation in hierarchic manner for reasoning under several levels. In a typed nested graph, a node can be described by one or several graphs called nesting [11].
                           Definition 3
                           (Typed nested graph). Formally we define recursively a typed nested graph as follows:
                                 
                                    •
                                    A typed nested graph 
                                          
                                             
                                                G
                                             
                                             
                                                ′
                                             
                                          
                                        is obtained from a basic graph G by adding to each concept node c a third field, denoted by Desc(c), equals to 
                                          ⁎
                                          ⁎
                                        an empty description. The depth of this graph is 
                                          depth
                                          (
                                          
                                             
                                                G
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          =
                                          0
                                       .

Let G a typed nested graph and c a concept node of G, 
                                          
                                             
                                                n
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                n
                                             
                                             
                                                2
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                n
                                             
                                             
                                                k
                                             
                                          
                                        nesting types and 
                                          
                                             
                                                G
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                G
                                             
                                             
                                                k
                                             
                                          
                                        typed nested graphs. The graph obtained by substituting the set 
                                          {
                                          (
                                          
                                             
                                                n
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                G
                                             
                                             
                                                1
                                             
                                          
                                          )
                                          ,
                                          …
                                          ,
                                          (
                                          
                                             
                                                n
                                             
                                             
                                                k
                                             
                                          
                                          ,
                                          
                                             
                                                G
                                             
                                             
                                                k
                                             
                                          
                                          )
                                          }
                                        to the third argument 
                                          ⁎
                                          ⁎
                                        of c is a typed nested graph 
                                          
                                             
                                                G
                                             
                                             
                                                ′
                                             
                                          
                                        with the following features: 
                                          depth
                                          (
                                          
                                             
                                                G
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          =
                                          max
                                          (
                                          1
                                          +
                                          
                                             
                                                max
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                k
                                             
                                          
                                          depth
                                          (
                                          
                                             
                                                G
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                          depth
                                          (
                                          G
                                          )
                                          )
                                       .

In this section, we represent an argumentation system by using conceptual graphs. To make the process of representation clearer, we will focus on a case study where different medical professionals provide various subjective advices and recommendations according to a given action and goal. These conceptual graphs will facilitate the visualisation of the different arguments and the decision making process. First of all we will give in the ensuing section the conceptual architecture of our proposed tool.


                        Fig. 1
                         depicts the conceptual architecture of our proposed tool. In this architecture the main component is the knowledge base built from data provided by the Patient Medical Record (PMR) with the necessary precautions with regard to free and informed consent procedure and also data from hospitals and social security centres. The knowledge base is represented in conceptual graph form to support queries, rules and constraints. Thus the medical professionals could use the proposed tool as a learning one. Then in a case of a diagnosis where a medical professional cannot make a decision, he can make a teleexpertise request to remote medical professionals for advices.

In this case study, we are interested in geriatric medicine and its subspecialty of geriatric endocrinology dealing with chronic diseases such as Diabetes, Thyroid disease, and Androgen excess. There are previous works [37,38] in Elderly with chronic diseases [40], but they all focused on telemonitoring combining various information technologies for the observation of one or several medical parameters at distance [32].


                        Application case: Demonstration of a 75 years old overweight woman (Body Mass Index (BMI): 
                           35
                           
                           kg
                           /
                           
                              
                                 m
                              
                              
                                 2
                              
                           
                           )
                         
                        with 20 years history of type 2 Diabetes who complaints of visual disorders disclosing diabetic macular oedema, retinal vein occlusion, and small eye׳s diabetic.

The different stakeholders and their argument are illustrated in Table 1
                        .

We first define the description of the support based on graphs. The description of the support consists of concept types illustrated in Fig. 2
                         and relation types depicted in Fig. 3
                        .

The five concepts of the first level of the concepts types are described in the ensuing paragraphs:
                           
                              •
                              
                                 PMR represents the Personal Medical Record of the patient. Also, PMR is used by health professionals who support the patient to share information useful for a proper coordination of health care for the patient [3]. The PMR is built based on information exploited from Table 2
                                  representing the patient chart (from the actual French clinical information) allowing health professionals to gather and share medical data and information. In addition to the element contained in the Table 2 we added the following elements: Incidents and Health National Identity to form the whole PMR. The Incidents represent the problem that occurred in the previous medical acts and protocols on the patient, while the Health National Identity represents, as its name suggests, the unique identifier of the patient.


                                 Advices are the proposal of a medical professional to treat a specific pathology of the patient.


                                 Entity represents argument and set which will permit to build extensions and the graph of attack.


                                 Procedure represents the different option that a medical professional could have for a patient׳s treatment. So according to Chalumeau et al. [10] there exits two main medical procedures:
                                    
                                       ○
                                       
                                          Maximise procedure(
                                             ↗
                                             Proc
                                          ): It reduces the risk of missing out on the early detection of serious diseases (minimal bacterial infection which could spread, e.g. appendicitis,which could lead to diffuse peritonitis or septicemia), but increases costs, individual and collective risks. Medical decisions are thus the result of opposing constraints suffered more or less consciously by the medical professional.


                                          Minimise procedure(
                                             ↘
                                             Proc
                                          ): It reduces the invasiveness of care, risks (selection of resistant bacteria, nosocomial infections, the vagaries of interventions) and their costs, individual and collective risks; but exposed to diagnostic and therapeutic delays which ethical and medico-legal consequences that can be severe.


                                 Patient Consent shows if there is an informed consent of the patient or his legal representative.

It is possible to represent a graph of attack based on concepts and relations types [9]. The notion of attack relation (denoted by an arc between nodes) is depicted in [15,6,14]. The attack relation is thus generated according to Algorithm 1 depicted below (Π represents here a projection):
                           Definition 4
                           An attack graph based on concepts and relations, denoted G
                              
                                 AF
                               is a nested conceptual graph such that for a given depth, 
                                 depth
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       AF
                                    
                                 
                                 )
                                 =
                                 0
                              :
                                 
                                    •
                                    The label of a concept vertex c is 
                                          label
                                          (
                                          c
                                          )
                                          =
                                          (
                                          Arg
                                          ,
                                          i
                                          )
                                       , we say that i is an argument.

The label of a relation concept r is 
                                          label
                                          (
                                          r
                                          )
                                          =
                                          (
                                          R
                                          )
                                       . The vertices represent the attack relation.

An argument node c such that 
                                 label
                                 (
                                 c
                                 )
                                 =
                                 (
                                 Arg
                                 ,
                                 i
                                 )
                               has three nesting types:
                                 
                                    •
                                    The graph Actor(c), called “Actor graph of the argument i”.

The graph Goal(c), called “Goal graph of the argument i”.

The graph Action(c) or Option(c), called “Action graph or Option graph of the arguement i”.

In conceptual graph terms, the attack of an argument α on an argument β is generated when the action graph of α does not project itself on β׳s action graph [9]. Even our approach is based on abstract argumentation given that we use some definitions and properties provided in [15,6,14] to build some extensions. Also, we used the notion of structured argument in the sense that the arguments in this work have an internal structure [8]. The description of an argument (represented as a nested graph) is depicted in Fig. 4
                        : 
                           Algorithm 1
                           Generation of the attack relation [9]. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         AF
                                                      
                                                   
                                                   is
                                                   
                                                   initialised
                                                   
                                                   with
                                                   
                                                   {
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         n
                                                      
                                                   
                                                   }
                                                   
                                                   such
                                                   
                                                   that
                                                   
                                                   label
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   =
                                                   (
                                                   Arg
                                                   ,
                                                   i
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                for 
                                                
                                                   i
                                                   =
                                                   1
                                                   →
                                                   n
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                for 
                                                
                                                   j
                                                   =
                                                   1
                                                   →
                                                   n
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                
                                                   ∄
                                                   
                                                   Π
                                                   (
                                                   Projection
                                                   )
                                                   
                                                   of
                                                   
                                                   Action
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   
                                                   in
                                                   
                                                   Action
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   add
                                                   
                                                   to
                                                   
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         AF
                                                      
                                                   
                                                   
                                                   a
                                                   
                                                   vertex
                                                   
                                                   relation
                                                   
                                                   r
                                                   
                                                   with
                                                   
                                                   label
                                                   (
                                                   r
                                                   )
                                                   =
                                                   (
                                                   R
                                                   )
                                                   
                                                   and
                                                   
                                                   the
                                                   
                                                   edges
                                                   
                                                   (
                                                   r
                                                   ,
                                                   1
                                                   ,
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   
                                                   and
                                                   
                                                   (
                                                   r
                                                   ,
                                                   2
                                                   ,
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                end for
                                             
                                          
                                       
                                    
                                 
                              
                           

After applying the algorithm above the resulted graph of attacks is depicted in Fig. 5
                        . In this conceptual graph, the different elements of the nested concept type argument are represented with conceptual graphs.

The interaction of the users with the proposed information system can be described in a chronological order by a sequence diagram. In the sequence diagram of Fig. 6
                        , there are three main types of actors involved in the teleexpertise process. There are the requesting physician, the information system and the requested physicians. In this case study, the requesting physician is the attending physician of the patient and the requested physicians are the remote experts including an Ophthalmologist, a Diabetologist and a Geriatrician. In the following we describe the information flow of the sequence diagram with meaning of the associated methods:
                           
                              •
                              
                                 AskForExpertise: In this method the attending physician who is the requesting physician provides all information concerning the patient (with the informed consent of the patient), and the needed remote experts. At the same time, according to his skills and experiences, he can provide a preliminary opinion or assessment.


                                 ProcessExpertiseRequest: When the information system receives the expertise request, it computes the input request to know the available physicians by relying on their specialities. This request is transmitted to the available specialists by the method TransmitInformation (which is a kind of multicast) and if they accept to participate in this teleexpertise process, then the useful medical information (including patients׳ medical information) is communicated to them.


                                 GiveAdvices: The remote physicians give their expert advices according to the parameters (Stakeholders, Reasons, Options, Concerns and Goals) described in the argumentation table. This method should include some additional parameters to know the relevant physician who has provided the received answer.


                                 BuildAttackGraphsAndExecuteArgumentativeLogic: This method creates the visual graph of attacks on which will be applied the different reasoning of the argumentative logic to check the potential acceptable arguments.

The extensions are used in argumentation theory based on Dung׳s theory [15] to aid in decision making process. They represent certain semantics of acceptability which facilitates the evaluation of the arguments. Here, we are interested here in naive, admissible and preferred extensions. In fact this latter will permit us to build our framework called argumentative logic. In the literature, some algorithms to build extensions have been proposed (for example in [31]). However, they do not respond to our outcome-oriented objectives for the remote collaborations in telemedicine. It is against this backdrop, the proposed system with new algorithms based on conceptual graphs was developed to build in an automated manner these extensions. Algorithm 2 generates conflict-free sets which are nothing more than conflict-free extensions. These conflict-free extensions are used in Algorithm 3 to build admissible extensions that are themselves used in Algorithm 4 to compute the preferred extension.

The goal we want to achieve is that starting with a knowledge base obtained by semantics modelling; the different proposed algorithms will compute the extensions in accordance with a graph of attacks. The originality of this framework lies in the algorithms that can be coupled with a software designed for semantic modelling namely CoGui software for visualising the reasoning, the answers of queries made by medical professionals to know what decisions have been taken for a particular disease treatment according to a specified action or option. The definitions and properties on which are based on these algorithms below can be found in our previous work [14].

In this section, we provide an algorithm to generate automatically conflict-free extensions. Algorithm 2 is provided based on the graph of attacks above. 
                              Algorithm 2
                              Generation of conflict-free set. 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      AS
                                                      :
                                                      
                                                      initialised
                                                      
                                                      with
                                                      
                                                      the
                                                      
                                                      set
                                                      
                                                      of
                                                      
                                                      all
                                                      
                                                      possible
                                                      
                                                      sets
                                                      
                                                      (
                                                      size
                                                      =
                                                      n
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      CFS
                                                      :
                                                      
                                                      (
                                                      conflict
                                                      −
                                                      free
                                                      
                                                      set
                                                      )
                                                      
                                                      initialised
                                                      
                                                      to
                                                      
                                                      null
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      quit
                                                      
                                                      :
                                                      
                                                      boolean
                                                      
                                                      initialised
                                                      
                                                      to
                                                    
                                                   false
                                                
                                             
                                             
                                                
                                                   for 
                                                   
                                                      i
                                                      =
                                                      1
                                                      →
                                                      n
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      
                                                      isEmpty
                                                      (
                                                      )
                                                      
                                                      ∥
                                                      size
                                                      
                                                      of
                                                      (
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      )
                                                      ==
                                                      1
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                      Add
                                                      
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      
                                                      to
                                                      
                                                      CFS
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   else
                                                
                                             
                                             
                                                
                                                   
                                                   for 
                                                   
                                                      j
                                                      =
                                                      1
                                                      →
                                                      sizeof
                                                      (
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      )
                                                      −
                                                      1
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                      quit
                                                      =
                                                      false
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   for
                                                   
                                                   
                                                      k
                                                      =
                                                      j
                                                      +
                                                      1
                                                      →
                                                      size
                                                      
                                                      of
                                                      
                                                      (
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      )
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   if 
                                                   
                                                      ∃
                                                      
                                                      attack
                                                      
                                                      relation
                                                      
                                                      between
                                                      
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      (
                                                      j
                                                      )
                                                      
                                                      and
                                                      
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      (
                                                      k
                                                      )
                                                   
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                      quit
                                                      =
                                                      true
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   break
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   end for
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   if
                                                   
                                                   quit 
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   continue
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                      Add
                                                      
                                                      AS
                                                      (
                                                      i
                                                      )
                                                      
                                                      to
                                                      
                                                      CFS
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   end for
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   end for
                                                
                                             
                                             
                                                
                                                   return 
                                                   CFS
                                                
                                             
                                          
                                       
                                    
                                 
                              

Hypothesis: An argument does not attack itself. Precondition: Let us consider AS the set of all possible sets of the argumentation system.


                           Postcondition: Returns the set composed of the conflict free sets (CFS).

Two nested loops are used: the first one loops on the set AS and the second one on each element (argument) of the current set of AS:
                              
                                 •
                                 If the current set is an empty one, it is necessarily a conflict free set. Then it is added to CFS.

If the current set is a singleton, it is necessarily a conflict free set (refer to the hypothesis).

If the size of the current set is greater than or equal to 2:
                                       
                                          –
                                          Then for each of these sets, it is checked if there is an attack relation between every two arguments of the current set. If yes it means that this current set is not a conflict free one. We quit the nested loop and continue to next iteration i.e. the next element of the set AS. If there is not attack relation between any two elements of the current set, this one is added to CFS.

At the end, CFS will contain only conflict free sets.


                           Algorithm 2 is based on the definition of the conflict-free sets [6,14]. Its originality is that it can be used to build conflict-free set from conceptual graphs. In other words it looks in a conceptual graph if there is an attack relation between two arguments of a given set. If for all arguments of this set, the algorithm does not find an attacks relation between them, it considers then this set is conflict-free. At the end of the algorithm, it returns the computed conflict-free sets that will be used to generate others extensions in the following.


                           Algorithm 3 below generates admissible extensions. According to the definition given in [6,14], an extension is admissible if and only if it is conflict-free and defends any of its elements. Thus in this algorithm, the input is the previous computed conflict-free sets and the output is the generated admissible extensions. The condition defends any element is depicted in Algorithm 5. 
                              Algorithm 3
                              Generation of admissible extensions. 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      CFS
                                                      :
                                                      
                                                      (
                                                      conflict
                                                      −
                                                      free
                                                      
                                                      set
                                                      )
                                                      
                                                      returned
                                                      
                                                      by
                                                      
                                                      the
                                                      
                                                      previous
                                                      
                                                      algorithm
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      AE
                                                      :
                                                      
                                                      (
                                                      Admissible
                                                      
                                                      Extensions
                                                      )
                                                      
                                                      initialized
                                                      
                                                      to
                                                      
                                                      null
                                                   
                                                
                                             
                                             
                                                
                                                   for 
                                                   
                                                      i
                                                      =
                                                      1
                                                      →
                                                      sizeof
                                                      (
                                                      CFS
                                                      )
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   
                                                      CFS
                                                      (
                                                      i
                                                      )
                                                      
                                                      isEmpty
                                                      (
                                                      )
                                                      
                                                      ∥
                                                      CFS
                                                      (
                                                      i
                                                      )
                                                      
                                                      defends
                                                      
                                                      any
                                                      
                                                      element
                                                      
                                                      in
                                                      
                                                      CFS
                                                      (
                                                      i
                                                      )
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      add
                                                      
                                                      CFS
                                                      (
                                                      i
                                                      )
                                                      
                                                      to
                                                      
                                                      AE
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   end for
                                                
                                             
                                             
                                                
                                                   return AE
                                             
                                          
                                       
                                    
                                 
                              

Precondition: Hypothesis the empty set defends all its elements, CFS: the set of conflict-free sets.

Postcondition: Returns AE: the set of admissible extensions.

For each element of CFS, in the iteration if the current element is empty then it is added to AE, or if the current element defends all its element (refer Algorithm 5), it is also added to AE. Thus at the end of the iteration, the set AE will contain the admissible extensions which will returned.□


                           Algorithm 4 makes it possible to determine the preferred extensions. The preferred extension is the maximum set included in the admissible extensions. So that it takes the admissible extensions as input and returns the preferred extensions. The returned extension is the one on which, the final decision could be made. 
                              Algorithm 4
                              Generation of preferred extensions. 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      AE
                                                      :
                                                      
                                                      previous
                                                      
                                                      returned
                                                      
                                                      (
                                                      Admissible
                                                      
                                                      Extensions
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      PE
                                                      :
                                                      
                                                      (
                                                      Preferred
                                                      
                                                      Extension
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   for 
                                                   
                                                      i
                                                      =
                                                      1
                                                      →
                                                      sizeof
                                                      (
                                                      AE
                                                      )
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   if 
                                                   
                                                      sizeof
                                                      (
                                                      AE
                                                      (
                                                      i
                                                      )
                                                      )
                                                      >
                                                      0
                                                      
                                                      &
                                                      &
                                                      
                                                      AE
                                                      (
                                                      i
                                                      )
                                                      
                                                      is
                                                      
                                                      the
                                                      
                                                      maximum
                                                      
                                                      set
                                                      
                                                      of
                                                      
                                                      AE
                                                      
                                                      that
                                                      
                                                      contains
                                                      
                                                      AE
                                                      (
                                                      i
                                                      )
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      Add
                                                      
                                                      AE
                                                      (
                                                      i
                                                      )
                                                      
                                                      to
                                                      
                                                      PE
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   return
                                                   
                                                   PE
                                                
                                             
                                             
                                                
                                                   end for
                                                
                                             
                                          
                                       
                                    
                                 
                              

Precondition: AE: the set of admissible extensions.

Postcondition: Returns PE: the set of preferred extensions.

For each element of the set AE, it is checked if the size of the current set of AE is greater than 1 and if there is no another greater set in AE such that this set includes the current set of AE. If the condition is verified then current set is added to PE, else we go to the next iteration and verify the previous condition. At the end of the loop we return PE that contains the preferred extensions.□


                           Algorithm 5 as said above permits to know if a set defends all its elements or not. Thus it takes as an input a given set and the set of all arguments in the knowledge base and return a boolean as an output. It is built according to the definition given in [6]. The algorithm uses projection in CoGui software to know if there is an attack relation between two arguments. 
                              Algorithm 5
                              Verifying if a set defends all its elements. 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      B
                                                      :
                                                      
                                                      set
                                                      
                                                      to
                                                      
                                                      check
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      SARG
                                                      :
                                                      
                                                      set
                                                      
                                                      of
                                                      
                                                      all
                                                      
                                                      arguments
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      k
                                                      :
                                                      
                                                      integer
                                                   
                                                
                                             
                                             
                                                
                                                   for 
                                                   
                                                      i
                                                      =
                                                      1
                                                      →
                                                      sizeof
                                                      (
                                                      B
                                                      )
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   for 
                                                   
                                                      j
                                                      =
                                                      1
                                                      →
                                                      sizeof
                                                      (
                                                      SARG
                                                      )
                                                    
                                                   do
                                                
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   
                                                      SARG
                                                      (
                                                      j
                                                      )
                                                      
                                                      attacks
                                                      
                                                      B
                                                      (
                                                      i
                                                      )
                                                      
                                                      &
                                                      &
                                                      
                                                      ∃
                                                      
                                                      γ
                                                      
                                                      ∈
                                                      B
                                                      
                                                      such
                                                      
                                                      that
                                                      
                                                      γ
                                                      
                                                      attacks
                                                      
                                                      SARG
                                                      (
                                                      j
                                                      )
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                      k
                                                      =
                                                      k
                                                      +
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   break
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   end for
                                                
                                             
                                             
                                                
                                                   end for
                                                
                                             
                                             
                                                
                                                   if 
                                                   
                                                      k
                                                      ==
                                                      sizeof
                                                      (
                                                      B
                                                      )
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   
                                                   return true
                                                
                                             
                                             
                                                
                                                   else
                                                
                                             
                                             
                                                
                                                   
                                                   return false
                                                
                                             
                                             
                                                
                                                   end if
                                                
                                             
                                          
                                       
                                    
                                 
                              

Precondition: B: the set to check and SARG: the set of all arguments.

Postcondition: Returns a boolean:
                              
                                 •
                                 
                                    true if B defends all its elements.


                                    false otherwise.

The main goal of this work is to provide a rigorous framework based on argumentation for decision support systems in order to ensure the traceability of the potential generated decisions. In fact, from the knowledge base Algorithm 1 builds, in first instance, the graph of attacks on which the other algorithms will focus. When the graph of attacks is obtained, the previous algorithms make it possible to compute the conflict-free extensions, admissible extensions and preferred extensions. So, only the arguments that will appear in the preferred extensions will be used for the decisions. Thus for a medical professional this framework will allow him in the teleexpertise process to know what decision has been taken for a special treatment of a disease since CoGui software supports queries. Based on these decisions, the medical professional can make his own opinion about the treatment to give for this disease. Finally, we can conclude that the provided framework guarantees the traceability of the reasoning and by using the CoGui software, which facilitates the visualisation of the queries and the answers, this framework is clearly a relevant means for the identification of arguments used by medical professional who are involved in a given act of teleexpertise.

In this section, we describe our proposed architecture (see Fig. 7
                        ). With the tool we want to develop, the physician responsible for the care of the patient can have a clear vision of the clinical presentation and potential medical strategies. Indeed, according to the achieved diagnostic, the physician could know by means of queries which decisions have already been made about a patient with the same pathologies. When the doctor cannot find any response and he is not able to take a suitable decision then he sends a request to a remote expert whom has ability and skills to make a suitable decision and give advices. The remote expert uses the same tool to visualise the patient medical record. Our architecture includes semantic modelling coupled to Dung semantics of acceptability [15]. Here the Dung semantics of acceptability are extended by the proposed new Algorithms 2– 4. These algorithms aid to extract the already taken decisions from a knowledge base and through the semantic modelling software (CoGui) to visualise these decisions.

This work is a continuation of the research undertaken in [13] in which the authors proposed a teleexpertise system using heterogeneous devices in the practice of the act of teleexpertise in order to guarantee syntactic interoperability. Here we introduce in the architecture an ontology modelling and an argumentation system to ensure reasoning traceability and in the same occasion this tool can be a learning tool for medical professionals. Fig. 7 depicts our proposed architecture. It is composed of six main parts:
                           
                              •
                              
                                 User Interface: This component allows users namely medical professionals to log on the system, edit patient׳s PMR, view decisions already taken for a particular disease for a patient׳s treatment in conceptual graph form and print the decision in natural language.


                                 Argumentative logic: The argumentative logic is the fundamental component of this architecture. In fact, it performs algorithms based on Dung׳s argumentation theory in order to compute extensions.


                                 CoGui Core: This component is an API,
                                    1
                                 
                                 
                                    1
                                    Application Programming Interface.
                                  which makes it possible to create and to handle conceptual graphs knowledge base. The knowledge base is serialised in COGXML which is a kind of XML format and can be also imported or exported in RDFS format. In this architecture we only use the core of CoGui Software 
                                 [1] above in which we implement the argumentative logic.


                                 Knowledge base: It includes the formal vocabulary supporting a conceptual graph-based knowledge representation. An example of such a vocabulary (with categorization of concepts and relations) is depicted in Figs. 2 and 3. This knowledge base is built automatically by CoGui core from the information received remotely.


                                 Intermediate Institution: This could be a single server located or an existing entire institution which handle patient׳s PMR in order to make them understood with the clarification of its semantic content.


                                 Third Institutions: These institutions are where we can find information concerning patient medical record.

For the knowledge base building, we propose to use the CoGui Core 
                        [1] API which includes all the functionalities to create and handle a knowledge base. The first step consists of creating the knowledge base (concept types, relation types, individuals and nested types). The most part of the knowledge base (concept types) comes from the PMR
                           2
                        
                        
                           2
                           Personal Medical Record.
                         of the patient that can be retrieved from remote sites such as hospitals, social security centre and also maybe from a dedicated centre allowed to store patient׳s PMR. The individuals are accurately represented in accordance with the content of the PMR. For example for the concept type HNI,
                           3
                        
                        
                           3
                           Health National Identity.
                         its individual will be the HNI of the patient in his PMR. Concerning the concept Entity, it will allow us to generate the graph of attack thanks to the advices (concept Advices in the hierarchy) given by the medical professionals and also to the option (maximise the procedure or minimise the procedure) that they will choose in the decision making process. The concept Patient_consent represents, as its name indicates the patient׳s consent i.e. it makes it possible to know if the patient or his legal representative authorises or not his medical data sharing among medical professionals. In the knowledge base an instance (ontological individual) of Patient_consent will be yes or no according to value retrieved remotely.

@&#RESULTS AND DISCUSSION@&#

The originality of our work is the fact that it combines conceptual graphs and Dung׳s argumentation system which provides suitable extensions for reliable decision making process, all applied to telemedicine generally and teleexpertise particularly. Given that the medical information system is very complex [33], the proposed tool with its automated algorithms for building extensions and the CoGui Core will allow us to structure data retrieved remotely from different medical information systems. This will make it possible to visualise and understand easily the already taken decisions since all is represented in conceptual graphs, which can be manipulated with little or no effort.

From the ethical problems [7] point of view the proposed tool tries to solve the problems below:
                        
                           •
                           
                              Insufficient clinical information transfer to the opposite side: The clinical information transfer here is sufficient since only the needed information is retrieved remotely in order to be used in teleexpertise practice.


                              Broken communication between doctor and patient: The communication between the doctor and the patient is not broken because the doctor has to explain comprehensively to the patient how and for what his data will be used. A simple, straightforward explanation will satisfy patients and clear up any misconception about medical information management.


                              Inaccurate and unclear reporting: Here the proposed tool makes it possible to generate a clear report based on the reasoning since the CoGui core generates an XML files which can be formatted into a human readable language.


                              Security of personal health information maintained in electronic form: This problem is overcome in our proposal since any access to medical information gathered and transferred requires the consent of the person concerned or that of his legal representative.

The proposed tool is beneficial for both patients and medical professionals [2]:
                        
                           •
                           For the patients׳ point of view:
                                 
                                    ○
                                    Appropriate care, reducing delays in healthcare (The authors of [37] demonstrate the practice of telemedicine applied to the geriatrics with chronic diseases among older people. The geriatric medicine is an important and growing specialty of healthcare systems and thus enhanced collaborations with argumentative reasoning processes will permit to guarantee a better quality of care for these older patients).

For the medical professionals׳ point of view:
                                 
                                    ○
                                    Better coordination between general and specialized medical services operating in the public or private health institutions

End the isolation of professionals working in areas that are sparely populated.

If such tools existed, we could have avoided the problem of the side-effects of treatments affecting a large number of persons, which often causes serious damages or possibly leading to death [35,17]. This is partly because the interrogation of computerised data could provide clues to accelerate the process of confirming a suspected link between clinical manifestation and exposure to a substance [17] which can potential save a life. In our proposed system we can ensure the historical context of a treatment and ontological properties for establishing semantic links between problems.

The user testing of the proposed system is conducted using verbal protocols that can contribute to analyse problem-solving approaches in the provision of medical care for the elderly population. Sixteen participants took part in the evaluation process of the initial user testing activities of the technology with practitioners from French interested hospitals. The practice of diagnostic plans, reasoning strategies, and control processes by each participant is studied (see Table 3
                     ). The specific information of these elements are inseparable from the level of complexity of diseases (mono-pathologies or poly-pathologies) and the patient׳s general state (overall health) facing the practitioners geriatricians according to their level of expertise. Results revealed that with the proposed system of teleexpertise there are substantial increases in the number of collaborative processes and answers, percentage of accurate diagnoses, application of reasoning strategies, and reduction of errors. This initial user testing provides a promising preliminary evaluation of the proposed system of teleexpertise with suggestions for the design of collaborative information system environments aimed to support medical professionals to manage complex medical situations.

These findings suggest that the provided tool will ensure a good structured traceability of the medical professionals’ reasoning. Furthermore, the tool guided them to make good decisions in a patient׳s treatment while ensuring semantic and syntactic interoperability between the communicating systems and also solving some ethical problems.

@&#CONCLUSION@&#

In general, the results indicate that the proposed tool is relevant to help medical professionals in the practice of the act of teleexpertise. This tool has mathematical foundations since it is based on Dung׳s argumentation system [15]. It guarantees the structuring of the traceability of the reasoning while ensuring a learning tool for medical professionals.

By the usage of CoGui core based on conceptual graphs approach and a semantic interpretation [1] on which we have built our component called argumentative logic to generate automatically the extensions, we guaranteed a reasoning with visualisation, semantic and syntactic interoperability [13].

The novelty of this work is the combination of conceptual graphs approach and Dung׳s argumentation system applied to telemedicine in general and teleexpertise in particular and with ambition to elucidate some ethical problems [7] encountered very often in telemedicine domain.

The proposed system confers many advantages on the decision-making of the medical professionals. It permits them to have access to a rich knowledge base containing past teleexpertise practices in order to improve their decision-making process. They can access the knowledge bases by querying the system about similar cases (through the appropriate methods for case retrieval according to the similarity determination [34]) when participating in a teleexpertise process or by using the system as a learning tool. The system facilitates collaboration for better decision-making provided by specialists with better skills and experiences.

None declared.

@&#ACKNOWLEDGMENTS@&#

The authors are grateful to Dr. Fonbeyin Henry Abanda (Oxford Brookes University) for his proofreading and editing service. We also thank some anonymous reviewers for their helpful feedback and observations on previous version of the paper.

@&#REFERENCES@&#

