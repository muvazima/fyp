@&#MAIN-TITLE@&#3D shape descriptor for object recognition based on Kinect-like depth image

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We model the common 3D shape descriptor from Kinect-like depth image.


                        
                        
                           
                           We evaluate the 3D shape descriptor in object recognition.


                        
                        
                           
                           We introduce 3D shape descriptor performance frameworks.


                        
                        
                           
                           Shape distribution and local spin image outperformed other 3D shape descriptors.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Inter-class

Intra-class

Instance

Kinect-like depth image

3D object retrieval

3D shape descriptors

@&#ABSTRACT@&#


               
               
                  3D shape descriptor has been used widely in the field of 3D object retrieval. However, the performance of object retrieval greatly depends on the shape descriptor used. The aims of this study is to review and compare the common 3D shape descriptors proposed in 3D object retrieval literature for object recognition and classification based on Kinect-like depth image obtained from RGB-D object dataset. In this paper, we introduce (1) inter-class; and (2) intra-class evaluation in order to study the feasibility of such descriptors in object recognition. Based on these evaluations, local spin image outperforms the rest in discriminating different classes when several depth images from an instance per class are used in inter-class evaluation. This might be due to the slightly consistent local shape property of such images and due to the proposed local similarity measurement that manages to extract the local based descriptor. However, shape distribution performs excellent for intra-class evaluation (that involves several instances per class) may be due to the global shape from different instances per class is slightly unchanged. These results indicate a remarkable feasibility analysis of the 3D shape descriptor in object recognition that can be potentially used for Kinect-like sensor.
               
            

@&#INTRODUCTION@&#

3D objects have been used widely in computer graphics and computer aided design. A 3D object surface is normally represented in three main forms: 3D primitives, depth map or point cloud and meshes [1]. 3D primitives are based on basic shapes such as line, plane and cube while meshes consist of vertices and edges connected together to form a 3D object. On the other hand, point clouds consist of 3D points of the raw information obtained from a stereo camera, range or laser sensor. Among these three forms, the most commonly used representation for 3D shape is meshes; due to the less data storage required compared to point clouds and also due to its capability to represent a complex 3D shape easily compared to using 3D primitives.

Recently, many works were proposed on how to extract a 3D shape descriptor from meshes especially for the aim of 3D object retrieval and 3D content based indexing. Such applications are popular in the area of industrial part designing, biology, chemistry, anthropology and archeology [2]. 3D object retrieval was reviewed by many researchers especially on generalizing the feature extraction approach and finding the direction of such application [3–7]. The recent progress on the development of advanced scanning, 3D modeling technologies and large number of 3D objects in database has resulted in the need to have a fast searching mechanism with high discriminating power [8]. Recently, the Microsoft Kinect sensor was launched [9] and this opened up the investigation of 3D shape descriptors to object recognition or classification. This is due to the capability of such technology to obtain depth and color information in almost real-time which is beneficial to object recognition and classification based applications.

Previous researches in object recognition and classification using 3D shape descriptors that were based on Microsoft Kinect were designed solely for the interest of the robotic community [10,11]. The main goal of those studies was to investigate the object color and depth properties obtained from such sensor for autonomous robot application [12]. By proving that the combination between the RGB information and depth information outperforms the RGB based sensor (conventional camera) for object recognition, those studies have opened a new perspective in computer vision for object recognition and classification. However, a few studies have been done to analyze the feasibility of the existing 3D shape descriptors (previously, designed for 3D object retrieval) obtained from depth information from Kinect-like sensor.

In this present study, we review and compare the common 3D shape descriptors (according to [13]) proposed in 3D object retrieval literature for object recognition based on depth information obtained from Kinect-like sensor. These 3D descriptors are: (1) shape distribution 
                     [14,15], (2) local spin image 
                     [16], global spin image 
                     [13] 
                     and shape histogram 
                     [17]. In this study, an RGB-D object dataset from [10] has been used which consists of 300 objects or instances taken from multiple views with a Kinect-like 3D camera and generalized into 51 classes. RGB image and depth image pairs of each object are taken in 3 different height angle views of 30, 45 and 60° with respect to horizon (see Fig. 1
                     ). In this work, we propose two different evaluations; (1) inter-class evaluation; and (2) intra-class evaluation and the performance of the shape descriptors. For inter-class evaluation, one instance was selected randomly for each class in the dataset and N depth images per class were selected randomly in the dataset before the 3D shape descriptors were obtained and a self-similarity matrix was produced. This matrix is compared with a ground truth matrix in order to generate the Receiver Operating Characteristic (ROC) curve showing the trade-offs of true positive rate and false positive rate. The similar comparing mechanism was used in intra-class evaluation except that a set of input depth images was built by selecting I instances randomly for each class and N depth images are selected randomly for each instance.

In our study, the intensive 3D shape descriptor analysis and extensive analysis of previous works in [10,11] including our previous work in [18] have been done in order to determine the feasibility of 3D shape descriptors in object recognition or classification based on Kinect-like depth image. This study has been carried out in terms of discriminating power (based on ROC curve) and efficiency (based on similarity measurement function complexity) in three different aforementioned evaluation mechanisms called inter-class and intra-class evaluations.

The coordination of this paper is as follows. In Section 2, several related works are summarized including the 3D shape descriptor literature in 3D object retrieval and the constraints in implementing 3D shape descriptors in object recognition or classification based on Kinect-like depth image. After that, common 3D shape descriptors used in this work are reviewed in Section 3 before our two proposed evaluations; (1) inter-class; and (2) intra-class evaluation are discussed in Section 4. Section 5 presents and discusses the results from all evaluations before the conclusion is made in Section 6.

@&#RELATED WORK@&#

Most of the 3D shape descriptors were designed for 3D object retrieval. In this section, the 3D shape descriptor for 3D object retrieval is discussed by mentioning the general criteria of the 3D shape descriptor and generalizing the descriptor into several classes. Then, several constraints of implementing the object retrieval based descriptor in object recognition and classification are presented.

Generally, in order to develop new 3D shape descriptor for object retrieval; there are several criteria that needs to be fulfilled. These criteria are the following [19]:
                           
                              1)
                              Descriptive power—The similarity measure of the descriptor or the capability of the descriptor to discriminate dissimilar shape.

Robustness—The descriptor should be insusceptible to noise and small information losses during the information acquisition process.

Invariance under transformations—The descriptor should provide stable information even in invariant rotational, translational and scaling transformation.

Conciseness and ease of indexing—In dealing with huge data, the descriptor should have a small amount of features to represent the 3D object in order to reduce the memory space required and the searching time.

Ability to perform partial matching [7]—Recently, the study of developing descriptor that fulfill this criteria is still in an open issue; matching object in database given the query object is in form of partial shape instead of full shape.

Previously, most of the 3D object retrieval literature focuses on developing the global-to-global object retrieval. Thus, the descriptor must fulfill the first four aforementioned criteria before the fifth criterion was added in order to fulfill the partial-to-global object retrieval. Commonly, the global to global descriptor can be categorized into four distinct mechanisms namely; (1) global based descriptor; (2) local based descriptor; (3) view based descriptor; and (4) graph-based descriptor.

A descriptor is known as a global based descriptor on the condition that the descriptor is extracted from the whole 3D points representing the whole surface of the 3D object. For example, Cha and Tsuhan [20] extracted the volume, moment and Fourier Transform coefficients directly from the 3D object surface. The absence of the aforementioned third criterion (invariant under transformation) in this descriptor may cause such descriptor incapable of dealing with invariant rotational object matching. In order to overcome this problem, Principal Component Analysis (PCA) was applied to align the object before extracting the descriptor. Another primitive global based method to represent the 3D shape is by using the convex-hull concept [21]; that is extracting the hull crumpliness, hull packing and compactness. Meanwhile, Osada et al. [14,15] introduced shape distribution which is the probability distribution function of distance between two randomly selected points that reside on the 3D object surface. Since shape distribution is one of the simplest descriptors, it is appropriate to be used as a pre-classifier before real classification is executed. In some work [22], shape distribution was improved by adding the ‘addition’ attribute instead of distance measurement such as the dot product between the normal vectors of two selected points. However shape distribution was not the only approach that utilizes the probability distribution function or histogram as 3D shape representation. Ankerst et al. [17] suggested that the 3D shape histogram showing the number of 3D points residing in each cell is divided by the radius and angle bin. This is followed by Kazhdan et al. [23] that demonstrated an almost similar concept as the 3D shape histogram but extracted the harmonic component of each cell called the Spherical Harmonic Shape Descriptor. After that, 3D Zernike [2] was investigated which is an extended version of the Harmonic Shape Descriptor as a 3D shape descriptor.

While the global based descriptors manage to provide solely the 3D shape information globally, there were several attempts to introduce descriptors that are able to extract the local properties of a 3D object. Spin Image [16] is one of the common local based 3D shape descriptors generated by spinning the axis from a single 3D point or vertices (with respect to the normal vector) into surrounding and finding the position of neighbor points in the form of cylindrical coordinates. These coordinates are discretized to produce the 2D histogram as a 3D shape descriptor. Another popular approach is the curvature based [24,25] descriptor. In [24], histogram of the local curvature distribution was generated while the histogram from [25] was produced from the shape index distribution obtained from local geometric characterization based on curvature. Körtgen [19] extended the 2D Shape Context originally applied for 2D image to a 3D object called 3D Shape Context.

Graph-based descriptors represent the 3D object by transforming the complex shaped object into a simple structured line or skeleton. For instance, the Boundary Representation [26] was introduced solely for the CAD community. The skeletonization based method was suggested in [27] which transforms the volumetric object into a structured skeleton. However, it is essential to have a very good registration process to match between two entities for similarity measurement. This kind of method was extended into another type of graph-based descriptor called Medial Scaffold in [28]. Hilaga et al. [29] proposed a descriptor called Reeb Graphs; obtained by connecting the critical points from the cross-sectional contour of the object. The drawbacks in graph-based descriptors are the complexity of the feature extraction mechanism and the ambiguity in characterization of discrimination properties among different objects.

View-based descriptor is obtained by observing the 3D object as a combination of several 2D projected images at different views. Light-field Descriptor [30] is extracted from a silhouette image from different view angles of the 3D object; consisting of several coefficients from Zernike moments and Fourier Descriptors. Another method that uses the 2D silhouette image was proposed by Mahmoudi S. and Daoudi M. [31], called the Characteristic View Descriptor. In this method, seven images from three principals and four secondary views were used and the curvature scale space was extracted from the contour of corresponding silhouette images. This work was further studied in [32] which improved the previous study by introducing the optimal number of characteristic views to represent a 3D object. The method was based on adaptive K-means and statistical model distribution scores. While most of the studies [30–32] were focused on extracting the silhouette image (binary image) from multiple views, [33] proposed the Elevation Descriptor which is based on the six gray-level depth image of different views. The resulting descriptor is the histogram that represents the intensity level that resides inside the cell of a concentric circle.

The constraints that should be considered in developing view-based descriptor are the determination of sufficient number of image views required to represent the 3D object and the optimization mechanism which is necessary to match between multiple view images in order to find the similarity among the 3D objects.

Generally, 3D shape descriptor in object retrieval suffers from missing data due to the poor quality of the acquisition process. Therefore, losses in some part of the object reduce the descriptive information to represent the object. For 3D object in the form of meshes, the shape information suffers from disjoint polygons, intersecting polygons and degenerated 3D surface [27]. Recently, 3D object retrieval literatures have been focusing on partial-to-global object matching instead of global-to-global object matching. Few researchers have addressed the problem of improving the current descriptors to be feasible in partial-to-global based retrieval [8,34]. These kinds of work are generally considered to be open research topics that may require more analysis and investigation. Table 1
                         shows some studies on the partial-to-global object retrieval.

Typically, partially to global object retrieval consists of two common mechanisms (see Table 1); the types of descriptor used and the types of descriptor quantization. It seems that most of the researchers extend the 3D shape descriptor designed for global to global object retrieval and use the same descriptor for partially to global object retrieval such as spin image [8,35], shape histogram [36],spherical harmonic [34] and curvature based descriptor [37]. However, these descriptors do not represent the whole 3D object surface. Decomposition was done to the object in order to segment the object into primitive parts before the descriptor was extracted from these primitive parts [34,36,37]. The purpose of descriptor quantization is to reduce the descriptor dimensionality to represent the 3D object. Most of the studies [8,34,36] on partial-to-global object retrieval used the bag-of-words (BOW) method while Gal.R and Cohen-Or D. [37] used the Geometric Hashing Table as descriptor quantization. Since the object was decomposed into several entities, it is necessary to have descriptor quantization especially when dealing with a huge space of database and at the same time optimize the searching process.

One of the main issues in implementing the 3D shape descriptor in object recognition based on Kinect-like depth image is that the obtained 3D information from a particular image only illustrates part or half of the whole object surface limited within the Kinect's field of view; the rest is self-occluded. The constraint of partial view in depth image is in line with partial-to-global object retrieval that faces similar obstacles in matching different partial view shapes of the same object or entity.

In this section, we review the aforementioned four common 3D shape descriptors (according to [13]); (1) shape distribution; (2) local spin image; (3) global spin image and (4) shape histogram; and present the mechanisms of these 3D descriptors based on depth image in our work.


                        Shape distribution is one of the global based 3D shape descriptors for object retrieval and was introduced by Osada et al. [14,15]. Shape distribution extracts the geometric properties of 3D object such as angle, distance, areas and volumes which are obtained from several randomly selected 3D points in 3D object surface named A3, D1, D2, D3 and D4. Due to its simplicity, D2 was used in our work for obtaining shape distribution. In D2, shape distribution is defined as a probability distribution function of distances between several pairs of 3D points randomly selected within the 3D object's surface. However, shape distribution was initially designed for 3D object in the form of mesh (triangulation mesh). Therefore, random selection of 3D point within randomly selected triangle surface was executed in order to obtain a pair of 3D points. A novel step in our work is to remove such mechanism from depth image as input and shape distribution was obtained directly from 3D points which were selected randomly within a set of 3D points that represents the 3D object. Fig. 2
                         depicts the mechanism of shape distribution formulated from depth image of an apple instance; a set of distances between pairs of 3D points was obtained before the probability distribution function was generated.

Originally, spin image 
                        [16] (as one of the common local shape descriptors) extracts the local geometric relation of 3D object; obtains the relationship between an oriented basis point O and its neighbor points G. Based on oriented basis point O, spin image So is developed by mapping neighbor points G (in 3D space) into a cylindrical 2D coordinate (α,β) with respect to O. The mapping mechanism is defined as,
                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             S
                                             o
                                          
                                          :
                                          
                                             ℝ
                                             3
                                          
                                          →
                                          
                                             ℝ
                                             2
                                          
                                       
                                    
                                    
                                       
                                          
                                             S
                                             o
                                          
                                          
                                             x
                                          
                                          →
                                          
                                             α
                                             β
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                               −
                                                               p
                                                            
                                                         
                                                         2
                                                      
                                                      −
                                                      
                                                         
                                                            
                                                               n
                                                               ⋅
                                                               
                                                                  
                                                                     x
                                                                     −
                                                                     p
                                                                  
                                                               
                                                            
                                                         
                                                         2
                                                      
                                                   
                                                
                                                ,
                                                n
                                                ⋅
                                                
                                                   
                                                      x
                                                      −
                                                      p
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where x is the 3D coordinate of point G, p is the 3D coordinate of point O while n is the surface normal vector with respect to point O as cylindrical coordinate orientation indicator. In this study, a single spin image was formulated by assigning a point in depth image as oriented basis point O before Eq. (1) was formulated to obtain 2D coordinate (α,β) mapping. The final product of this approach is the 2D histogram generated as quantization of (α,β) coordinates to indicate the number of neighbor points G that reside in each bin as can be seen in Fig. 3
                         (γ is the number of neighbor points that reside in each (w,h) bin). We divide the spin image into two types; (1) local spin image: where each point in depth image was assigned as O and a set of spin image is obtained from every depth point; and (2) global spin image: where spin image was developed by assigning a center depth point with respect to the principal component axis of the 3D object as oriented basis point O.

Shape histogram is defined as the number of 3D points that resides in partitioned subspaces. These subspaces were obtained by decomposing a space that contains whole 3D points that represents the object with respect to the centroid of the 3D object according to three different separation models: (1) a shell model; (2) a sector model; and (3) a combination between shell and sector model. Among these models, the shell model was chosen in our work because it is a rotation invariant of the 3D object. Fig. 4
                         shows the implementation of the shape histogram that was computed from depth image where the object was divided into P number of shells with respect to centroid O before the number of 3D points in each shell was calculated to generate the histogram.

We proposed two types of evaluation mechanisms; (1) inter-class evaluation; and (2) intra-class evaluation in order to measure the performance among 3D shape descriptors for object recognition based on Kinect-like depth image. In these evaluations, we use the aforementioned RGB-D object dataset [10] that consists of 51 classes of household objects such as apple, ball, scissor and coffee mug (see Fig. 1(a)–(d)). Almost 300 instances with 3 sets of RGB-D images from different height angle views (30, 45 and 60°) per instance; whereby a set of RGB-D images consists of almost 200 RGB-D images in different rotational angle views to complete one full rotation. Fig. 1(f) depicts an example of depth images in the dataset and the corresponding RGB image is shown in Fig. 1(e).


                        Inter-class evaluation was designed to analyze the descriptive power of the 3D shape descriptor among different classes based on single instance that represents each class while intra-class evaluation was developed to study the consistency of a descriptor to represent several different instances within the same class. Due to the large number of depth images in the RGB-D object dataset, computing the inter-class and intra-class evaluations is computationally not feasible and will consume too much time. Thus, both inter-class and intra-class evaluations were carried out using several set of depth images A
                        ={a
                        i},i={1,2,3….NIC}; and each set was built based on the N number of depth images per instance and I number of instances per class among C=51 number of classes as total classes in RGB-D object dataset. Table 2
                         shows a significant difference between inter-class and intra-class evaluations; different Is and Ns were used to generate a set of depth image A with three different situations for each evaluation. Afterwards, a set of shape descriptor A′
                        
                        ={a
                        ′
                        i},i={1,2,3….NIC} (using the 3D shape descriptor mentioned in Section 3) was formulated based on a set of depth image A
                        ={a
                        i}. Then the similarity matrix S was established from A
                        ′
                        ={a
                        ′
                        i} using the following equation,
                           
                              (2)
                              
                                 
                                    S
                                    
                                       i
                                       j
                                    
                                    =
                                    s
                                    
                                       
                                          a
                                          i
                                          ′
                                       
                                       
                                          a
                                          j
                                          ′
                                       
                                    
                                    ,
                                    
                                    i
                                    ,
                                    j
                                    =
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          .
                                          NIC
                                       
                                    
                                 
                              
                           
                        where A
                        ′
                        ={a
                        ′
                        i} was arranged such that,
                           
                              (3)
                              
                                 
                                    
                                       a
                                       i
                                       ′
                                    
                                    =
                                    
                                       
                                          a
                                          n
                                          ′
                                       
                                    
                                    ,
                                    
                                    n
                                    =
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          3
                                          …
                                          .
                                          N
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       a
                                       c
                                       ′
                                    
                                    =
                                    
                                       
                                          a
                                          i
                                          ′
                                       
                                    
                                    ,
                                    i
                                    =
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          3
                                          …
                                          .
                                          I
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       A
                                       ′
                                    
                                    =
                                    
                                       
                                          a
                                          c
                                          ′
                                       
                                    
                                    ,
                                    
                                    c
                                    =
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          3
                                          …
                                          .
                                          C
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

An example of implementing Eqs. (3), (4) and (5) is shown in Fig. 5(a) with the similarity matrix 
                           S
                         (partially shown) for I=2 number of instances per class. s(a
                        ′
                        i,
                        a
                        ′
                        j) is the similarity measurement function which is based on types of 3D shape descriptor of either local based or global based descriptor that will be discussed in Section 4.3.

In order to plot the Receiver-Operator-Characteristic (ROC) curve as the final result to represent the 3D shape descriptor's performance, the ground-truth similarity matrix SGT
                         was created to compare with the similarity matrix, 
                           S
                        . 
                           S
                           GT
                         (i,j)∈{1,0} is indicated as 1 for similar class and 0 for dissimilar class object; formulated as a white block (N×I)×(N×I) pixels reproduced in a diagonal direction within the (N×I×C)2 matrix. Fig. 5(b) indicates the 
                           S
                           GT
                         for the corresponding similarity matrix S in Fig. 5(a). The comparison between S and 
                           S
                           GT
                         was calculated using the following equations (adapted from [13]),
                           
                              (6)
                              
                                 
                                    
                                       t
                                       s
                                    
                                    =
                                    
                                       
                                          ∑
                                          i
                                          NIC
                                       
                                    
                                    
                                       
                                          ∑
                                          j
                                          NIC
                                       
                                    
                                    
                                       
                                          
                                             S
                                             GT
                                          
                                          
                                             i
                                             j
                                          
                                          
                                             S
                                             ¯
                                          
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       t
                                       d
                                    
                                    =
                                    
                                       
                                          ∑
                                          i
                                          NIC
                                       
                                    
                                    
                                       
                                          ∑
                                          j
                                          NIC
                                       
                                    
                                    
                                       
                                          
                                             
                                                1
                                                −
                                                
                                                   S
                                                   GT
                                                
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                1
                                                −
                                                
                                                   S
                                                   ¯
                                                
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       f
                                       s
                                    
                                    =
                                    
                                       
                                          ∑
                                          i
                                          NIC
                                       
                                    
                                    
                                       
                                          ∑
                                          j
                                          NIC
                                       
                                    
                                    
                                       
                                          
                                             
                                                1
                                                −
                                                
                                                   S
                                                   GT
                                                
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                          ×
                                          
                                             S
                                             ¯
                                          
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       f
                                       d
                                    
                                    =
                                    
                                       
                                          ∑
                                          i
                                          NIC
                                       
                                    
                                    
                                       
                                          ∑
                                          j
                                          NIC
                                       
                                    
                                    
                                       
                                          
                                             S
                                             GT
                                          
                                          
                                             i
                                             j
                                          
                                          ×
                                          
                                             
                                                1
                                                −
                                                
                                                   S
                                                   ¯
                                                
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        in order to compute true similar ts, true dissimilar td, false similar fs and false dissimilar fd before obtaining the true positive rate (TPR) and false positive rate (FPR) as two components in the ROC curve (Eqs. (10) and (11)).
                           
                              (10)
                              
                                 
                                    TPR
                                    =
                                    
                                       
                                          t
                                          s
                                       
                                       
                                          
                                             t
                                             s
                                          
                                          +
                                          
                                             f
                                             d
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    FPR
                                    =
                                    
                                       
                                          f
                                          s
                                       
                                       
                                          
                                             f
                                             s
                                          
                                          +
                                          
                                             t
                                             d
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     


                        
                           
                              
                                 S
                                 ¯
                              
                              ∈
                              
                                 1
                                 0
                              
                           
                         in Eqs. (6)–(9) is a binary matrix produced by thresholding the similarity matrix S with threshold value ε and defining expected similar class as 1 (if 
                           S
                        (i,j)<ε) while expected dissimilar class as 0 (otherwise). Finally the ROC curve was plotted based on TPR(ε) and EPR(ε) by varying the threshold value ε∈[0,1] In order to produce more realistic results, this mechanism was repeated thrice for each situation using different sets of depth images A
                        ={a
                        i},i={1,2,3….NIC} which is randomly selected from the dataset before the average ROC curve representing each descriptor in each situation was generated.

Similarity measurement function s(a
                        ′
                        i,
                        a
                        ′
                        j) where a
                        ′
                        i and a
                        ′
                        j are the 3D shape descriptor of two different depth images that was applied in this work was divided into; (1) global similarity measurement; and (2) Local similarity measurement. Global similarity measurement is expressed as,
                           
                              (12)
                              
                                 
                                    s
                                    
                                       
                                          a
                                          i
                                          ′
                                       
                                       
                                          a
                                          j
                                          ′
                                       
                                    
                                    =
                                    d
                                    
                                       
                                          a
                                          i
                                          ′
                                       
                                       
                                          a
                                          j
                                          ′
                                       
                                    
                                 
                              
                           
                        where function d(a
                        ′
                        i,
                        a
                        ′
                        j) is the Euclidean distance between a
                        ′
                        i and a
                        ′
                        j. This similarity function was applied to all aforementioned 3D descriptors; (1) shape distribution; (2) local spin image; (3) global spin image; and (4) shape histogram. However, local similarity measurement was introduced for local spin image because such measurement is essential for fair comparison of 3D shape descriptors' performance. Local based descriptor contains different characteristic compared to global based descriptor. Local similarity measurement was formulated as,
                           
                              (13)
                              
                                 
                                    s
                                    
                                       
                                          a
                                          i
                                          ′
                                       
                                       
                                          a
                                          j
                                          ′
                                       
                                    
                                    =
                                    
                                       1
                                       E
                                    
                                    
                                       
                                          ∑
                                          
                                             e
                                             =
                                             1
                                          
                                          E
                                       
                                    
                                    
                                       min
                                       f
                                    
                                    d
                                    
                                       
                                          a
                                          
                                             i
                                             e
                                          
                                          ′
                                       
                                       
                                          a
                                          
                                             j
                                             f
                                          
                                          ′
                                       
                                    
                                 
                              
                           
                        where a
                        ′
                        je
                         is a spin image extracted based on oriented basis point e in depth image a
                        i and a
                        ′
                        jf
                         is a spin image extracted based on oriented basis point f in depth image a
                        j.

@&#RESULTS AND DISCUSSION@&#

Our intention is to carry out the intensive and extensive analyses of 3D descriptor feasibility in object classification based on Kinect-like depth image. As discussed previously, two different evaluations were introduced; (1) inter-class; and (2) intra-class evaluations for comparing four different 3D descriptors; (1) shape distribution; (2) local spin image (either using global similarity measurement or local similarity measurement); (3) global spin image and (4) shape histogram. Thus, the results of each evaluation are discussed in this section.

It was suggested in Section 4.1 that inter-class and intra-class evaluations were designed to evaluate the 3D shape descriptor performance in different situations where the number of depth images per instance and the number of instances per class used were varied. Fig. 6(a)–(c) show the results for the aforementioned 3D shape descriptors in three different situations according to Table 2 for inter-class evaluation while Fig. 8(a)–(c) illustrate the same results for intra-class evaluation. Figs. 7(a)–(b) and 9(a)–(b) depict the shape distribution and local spin image (using local similarity measurement) performance which is displayed individually among different situations for both inter-class and intra-class evaluations.

From these results, local spin image (using local similarity measurement) and shape distribution show excellent performance compared to other 3D shape descriptors. The performance degradation occurs in all 3D shape descriptors for inter-class evaluation through situations 1 to 3 (see Figs. 6 and 7) and can be interpreted as a result of the variety of formed shapes among different depth images that represents an instance. However, in some cases (see Fig. 6(c)) the local spin image (using local similarity measurement) significantly outperforms the shape distribution even when a variety of formed shapes represent an instance was increased (N was increased). It is logical that the local spin image as a local based 3D descriptor manages to provide local shape properties from different depth image of an instance which has a high degree of similarity while other 3D shape descriptors suffer from performance degradation due to the global shape variations among different depth images per instance. Moreover, the excellent performance shown by local spin image was also due to the proposed local similarity measurement used in the evaluation mechanism. This is to investigate the capability of local spin image as a local based 3D descriptor among other global based 3D descriptors as well as developing a fair comparison between local and global based descriptors.

On the other hand, the challenge began in intra-class evaluation when both the number of depth images per instance, N and the number of instances per class, I used in three different situations were varied together (see Table 2). Almost all 3D descriptors suffer with significant performance degradation (see Figs. 8 and 9
                     
                     ) compared to previous evaluation (inter-class evaluation). By focusing on the shape distribution and local spin image (using local similarity measurement) that can be observed in Fig. 9(a) and (b), it could be inferred that the sudden performance degradation of local spin image compared to shape distribution through situations 1 to 3 is perhaps due to the dissimilar local shape properties of different instances per class while the global shape properties within different instances were still slightly consistent.

@&#CONCLUSION@&#

We have demonstrated the intensive and extensive 3D shape descriptor of previous works in [10,11] and its applicability in object recognition or classification based on Kinect-like depth image. We have also introduced two different evaluation mechanisms called (1) inter-class; and (2) intra-class evaluation. Based on the inter-class and intra-class evaluation results, it can be concluded that the shape distribution is comparable with local spin image as an excellent 3D shape descriptor among the rest. Local spin image outperformed shape distribution when only an instance per class is used in inter-class evaluation; and this is due to the local shape properties which are slightly similar in several depth images of the same instance provided by local spin image. Moreover, our proposed local similarity measurement manages to carry out the capability of local spin image as local based 3D shape descriptor. On the other hand, shape distribution provides excellent performance when several instances per class are used in intra-class evaluation compared to the local spin image. This is due to the local spin image suffering from invariant local shape properties within different instances per class that was used in intra-class evaluation while global shape properties extracted by shape distribution is slightly retained.


                     Inter-class and intra-class evaluations are designed to be compatible and cater to class level recognition and instance level recognition that is defined by [10] as well as extend the implementation of 3D shape descriptor in object recognition or classification. These preliminary results demonstrate a remarkable feasibility analysis of the several common 3D shape descriptors initially designed for retrieval in object recognition or classification obtained from Kinect-like depth image. Future work should focus on enhancing the local spin image as one of the striking 3D shape descriptors which provides beneficial local shape properties especially in reducing computational complexity. It should be possible, therefore, to integrate all these 3D shape descriptors with any supervised learning approaches in order to establish object recognition or classification system.

@&#ACKNOWLEDGMENT@&#

The authors would like to express their gratitude to Universiti Teknologi Malaysia (UTM) and the Minister of Higher Education (MOHE), Malaysia for supporting this research work under Research Grant No. Q.J130000.2623.08J89.

@&#REFERENCES@&#

