@&#MAIN-TITLE@&#On service consistency in multi-period vehicle routing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Investigated the multi-period VRP with time windows and limited visited quota constraints.


                        
                        
                           
                           Designed a customized meta-heuristic to solve the problem.


                        
                        
                           
                           Experimental results show that our approach outperforms the existing algorithm.


                        
                        
                           
                           Analyzed the tradeoff between the service consistency and the demand fluctuation.


                        
                        
                           
                           Provided managerial insights for the industry.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Heuristics

Vehicle routing

Service consistency

Demand fluctuation

@&#ABSTRACT@&#


               
               
                  In this paper, we investigate a new variant of the vehicle routing problem (VRP), termed the multi-period vehicle routing problem with time windows and limited visiting quota (MVRPTW-LVQ), which requires that any customer can be served by at most a certain number of different vehicles over the planning horizon. We first formulate this problem as a mixed integer programming model and then devise a three-stage heuristic approach to solve the problem. Extensive computational experiments demonstrate the effectiveness of our approach. Moreover, we empirically analyze the impacts of varying the levels of service consistency and demand fluctuation on the operational cost. The analysis results show that when demand fluctuation is relatively small compared to vehicle capacity, enforcing consistent service can increase customer satisfaction with only a slight increase in the operational cost. However, when a vehicle can only serve a small number of customers due to its capacity limit, relaxing the service consistency requirement by increasing the value of the visiting quota could be considered.
               
            

@&#INTRODUCTION@&#

In delivery services, significant emphasis has been placed on service consistency such that deliveries to regular customers are made at approximately the same time of the day, and by the same deliveryman or deliverymen. Punctually keeping a regular schedule increases customer satisfaction since it allows the customer to plan for deliveries during their working day with confidence. Furthermore, having the same person or persons performing the deliveries can help develop customer relationships, and this familiarity can also increase the efficiency of the service.

However, delivery schedules with high service consistency would incur additional operational costs when there is a significant demand fluctuation for the services (i.e., the amount of goods to be delivered changes substantially each day) compared with the vehicle capacity. Due to vehicle capacity limitation, a deliveryman might be unable to fulfill the delivery requests of all customers on his regular route if the amount of goods demanded is particularly large on that day. In general, there are two ways to handle this situation. One is to reduce the number of customers on the regular route of each deliveryman so that the maximum demand can always be handled by a single vehicle, but this is likely to increase manpower requirements. The other is to allow a few different deliverymen to service each customer, which dilutes the benefits of service consistency.

In this paper, we consider the multi-period vehicle routing problem with time windows and limited visiting quota (MVRPTW-LVQ). Given a set of customers with requests for the delivery of goods within time windows over a period of D days, the task is to find a set of vehicle routes that fulfill all requests using the minimum number of vehicles and with the minimum total travel distance; this is a combination of the multi-period vehicle routing problem (MVRP) and the vehicle routing problem with time windows (VRPTW). Service consistency is controlled by the limited visiting quota (LVQ), which states that any particular customer can only be serviced by at most R different vehicles over the entire planning horizon. This problem was first introduced by Zhu, Zhu, Che, and Lim (2008), who build an application for the problem for one of the largest food and restaurant chains in Hong Kong and proposed a decomposition approach which first iteratively solves a series of VRPTWs with a state-of-the-art VRPTW solver proposed by Lim and Zhang (2007) and then combines the resulted VRPTW solutions into an MVRPTW-LVQ solution. The MVRPTW-LVQ is also related to the consistent vehicle routing problem (ConVRP) proposed by Groër, Golden, and Wasil (2009), which requires that each customer may only be visited by one vehicle (i.e., R = 1) and also includes some additional constraints.

We propose a three-stage approach to solve the MVRPTW-LVQ. Stage one involves finding high-quality initial solutions fast using the decomposition algorithm proposed by Zhu et al. (2008) with a much simpler but faster VRPTW solver. Stage two attempts to reduce the number of vehicles in the solution by employing a repair procedure in a tree search algorithm. Stage three performs a tabu search post-optimization procedure that focuses on reducing the total travel distance. Computational experiments on benchmark data show that our Decomposition, Repair and Distance Reduction (DRDR) approach outperforms the approach proposed by Zhu et al. (2008) on five out of the six benchmark data sets. We also modify our approach to handle the ConVRP; this resulting algorithm outperforms two existing ConVRP approaches on average on benchmark data. These experiments demonstrate the ability and robustness of our approach in handling consistency service in the VRP with multiple periods.

We obtained several interesting findings from experiments using the DRDR approach to analyze the effects of demand fluctuation on operational cost given different service consistency requirements. A maximally consistent routing plan can be generated by setting the LVQ value to 1, i.e., R = 1. Our experimental results show that when the vehicle capacities are small in relation to the amount of goods demanded, the benefit of relaxing the service consistency requirement (e.g., setting R = 2) results in a significant reduction to the operational cost. This finding suggests that in applications where the demand fluctuation is relatively large compared to the vehicle capacity, such as the delivery of inventory restocks to retail chain outlets, demand fluctuation can significantly increase the operational cost of a rigidly consistent routing plan. Managers should therefore consider relaxing the service consistency requirements in order to balance the trade-off between service level and operational cost. In contrast, when the vehicle capacities are relatively large (thereby reducing the impact of demand fluctuation), a deliveryman can be assigned to serve relatively more customers on his regular route, and there is little impact on the total operational cost when enforcing stronger service consistency requirements. Applications of this type, such as the small package shipping industry, can therefore place more emphasis on service consistency to increase operational efficiency from familiarity and facilitate cooperation between deliverymen and customers.

The main contributions of this paper are as follows. First, we provide a strong mixed integer programming model for the MVRPTW-LVQ for the first time. Second, we propose a three-stage approach to solve the problem, whose effectiveness can be demonstrated by a set of computational results. Third, we analyze the trade-off between service consistency and operational cost under different scenarios, which provides managerial insights for the industry.

The remainder of the paper is organized as follows. In Section 2, we provide an overview of the related existing literature. We then present a formal description of our problem in Section 3, as well as a mixed integer programming (MIP) model. Our three-stage solution approach is described in Section 4. We present our computational results in Section 5, which includes experiments for parameter tuning, component tests and the instances of both the MVRPTW-LVQ and the ConVRP. Section 6 provides an analysis of the trade-off between service consistency and demand fluctuation on operational cost. Finally, we conclude our article in Section 7 with some closing remarks.

@&#LITERATURE REVIEW@&#

The periodic vehicle routing problem (PVRP), also known as the period vehicle routing problem, is a variant of the classical vehicle routing problem (VRP) in which delivery routes are constructed over a period of time (e.g., multiple days). It occurs in many practical applications, such as food distribution (Zhu et al., 2008) and the soft drink industry (Golden and Wasil, 1987). Consequently, the PVRP and its variants have received considerable attention from the research community, where the use of meta-heuristics has been shown to be an effective solution approach, e.g., tabu search (Cordeau, Gendreau, and Laporte, 1997) and variable neighborhood search (VNS) (Hemmelmayr, Doerner, and Hartl, 2009). We refer the reader to Francis, Smilowitz, and Tzur (2008) for an extensive overview of the PVRP and its variants.

In certain practical PVRP applications, service consistency is a significant factor. The use of time windows, where vehicles must arrive at each customer location within a specified time range, can indirectly influence the service consistency of a routing plan. The VRP variant that considers time windows has been widely studied in literature. Various meta-heuristic approaches have been developed to tackle the VRPTW, such as evolutionary algorithms (Nagata, Bräysy, and Dullaert, 2010) and local searches (Lim and Zhang, 2007). Although only a single period is considered in the VRPTW, solution approaches for the VRPTW with slight modifications can also be applied to the multi-period vehicle routing problem with time windows (MVRPTW), e.g., the solution approaches proposed by Cordeau, Laporte, and Mercier (2001); 2004).

Various other methods have also been tried in existing literature to include service consistency into the route planning process. For example, Zhong, Hall, and Dessouky (2007) investigated a problem where drivers should be consistently assigned to the same territories so as to improve driver performance due to familiarity; for simplicity, time windows and vehicle capacities were not considered. The authors proposed a two-stage learning/forgetting model, where service consistency is set as a soft constraint, to construct core service territories in the strategic level and allocate customers in the non-core territories each day. Another example is the periodic vehicle routing problem with service choice (PVRP-SC) proposed by Francis, Smilowitz, and Tzur (2006), where the service frequency of customers and delivery demand are decision variables and the objective function balances travel time and service benefit. Francis and Smilowitz (2006) presented a continuous approximation model for the PVRP-SC and Francis, Smilowitz, and Tzur (2007) analyzed the trade-offs between operational complexity and flexibility in both the PVRP and the PVRP-SC. Operational complexity is defined as the difficulty of implementing a solution to the problem and is quantified using three measures, namely driver coverage, arrival span and crew size. Although the crew size is similar to the LVQ, it was simply analyzed in two cases, i.e., consistent planning and non-consistent planning. Recently, Coelho, Cordeau, and Laporte (2012) considered in a multi-vehicle inventory routing problem six different inconsistency features, which are quantity consistency, vehicle filling rate, order-up-to policy, driver consistency, driver partial consistency and visit spacing. Moreover, Smilowitz, Nowak, and Jiang (2013) incorporated workforce management into periodic delivery operations, where two measures, namely customer familiarity and region familiarity, are used to evaluate the consistency of workforce management.

The problem investigated in this study presents a more direct method of including service consistency into the planning process. The service consistency is ensured by a limited visiting quota (LVQ) hard constraint requiring that each customer can only be visited by at most R different vehicles over the entire planning horizon. The LVQ constraint was first introduced by Zhu et al. (2008) for an application that schedules food delivery to stores for one of the largest food and restaurant chains in Hong Kong. Service consistency is particularly important for this application not only to facilitate effective communication and coordination between the deliverymen and store employees, but also because most of the retail stores are located in subway stations and shopping malls, so finding parking spaces and store locations can be a challenge if the deliveryman is unfamiliar with the environs. The LVQ constraint explicitly addresses this issue by specifying the value of R, i.e., the necessary level of service consistency.

When the LVQ value is set to R = 1, the resultant problem is similar to the consistent vehicle routing problem (ConVRP) proposed by Groër et al. (2009). The ConVRP models a situation found in the small package shipping industry, where the fostering of customer relations by couriers is of major importance. The authors developed a two-stage algorithm called ConVRP Record-to-Record travel (ConRTR), which first constructs a template and then generates daily schedules by omitting absent customers and inserting new customers. Sungur, Ren, Ordonez, Dessouky, and Zhong (2010) formulated a two-phase technique to solve a stochastic programming model for a VRPTW with uncertain customer and service time; this technique was also adapted to solve the ConVRP. In the first phase, an insertion-based heuristic is used to generate a master plan and daily schedules. The daily schedule is then improved in the second phase with a tabu search heuristic. After that, two heuristic approaches were employed for the ConVRP, namely the generic template-based solution framework by Tarantilis, Stavropoulou, and Repoussis (2012) and the template-based adaptive large neighborhood search by Kovacs, Parragh, Hartl, and Parragh (2014), which significantly improved the previous results.

The MVRPTW-LVQ is defined on a complete undirected graph G = (V, E), where V = {0, 1, …, N} is the set of vertices (nodes) and E = {(i, j): i, j ∈ V} is the set of edges. The node 0 represents the depot, while the remaining nodes C = {1, …, N} correspond to the set of customers. Each edge (i, j) ∈ E has a non-negative cost c
                     
                        i, j
                      and a travel distance t
                     
                        i, j
                     , where we assume c
                     
                        i, j
                      = t
                     
                        i, j
                      for all edges (i, j) ∈ E. We are given an unlimited number of homogeneous vehicles with capacity Q; all vehicles are initially located at the depot. For each customer i ∈ C, there is a time window [ei, li
                     ] within which service can be started, and si
                      is the amount of time required to perform the service for customer i. Depot 0 also has a time window [e
                     0, l
                     0] which is the working time of the vehicle. The service period (or planning horizon) consists of D days. On day d, d = 1, …, D, each customer i has a service demand q
                     
                        i, d
                     , i.e., a vehicle must deliver q
                     
                        i, d
                      units of goods to customer i on day d; we assume that q
                     
                        i, d
                      > 0. Finally, the limited visiting quota (LVQ) for each customer is denoted by R.

The task is to find a set of vehicle routes, each starting and ending at the depot, that fulfills all customer service demands over the entire planning horizon given the vehicle capacity, customer time windows, depot time window and LVQ constraints. Furthermore, each customer must be visited by exactly one vehicle on any given day. The main objective of the problem is to minimize the number of vehicles required. Given multiple solutions with the same number of vehicles, the secondary objective is to minimize the total travel distance.

We introduce a three-index arc-flow MIP model for the MVRPTW-LVQ. Let K be an upper bound of the number of vehicles that are needed to fulfill the tasks. We modify graph G by replacing depot 0 by a set of nodes {N + 1, …, N + 2K} which have the same location as depot 0, leading to a new graph G′ = (V′, E′) where V′ = C∪{N + 1, …, N + 2K} and E′ = {(i, j)|i, j ∈ C, i ≠ j}∪{(N + k, i), (i, N + K + k)|i ∈ C, k = 1, …, K}. The nodes N + k and N + K + k (k = 1, …, K) represent the two nodes where vehicle k starts and terminates respectively. Letting M be a sufficiently large positive number, the MVRPTW-LVQ can be modeled as follows:


                     Decision variables:
                     
                        
                           •
                           
                              x
                              
                                 i, j, d
                               = 1 if arc (i, j) ((i, j) ∈ E′) is used on day d and x
                              
                                 i, j, d
                               = 0 otherwise.


                              y
                              
                                 i, k, d
                               = 1 if vehicle k (k = 1, …, K) visits node i (i ∈ V′) on day d (d = 1, …, D) and y
                              
                                 i, k, d
                               = 0 otherwise.


                              z
                              
                                 i, k
                               = 1 if vehicle k (k = 1, …, K) visits node i (i ∈ V′) and z
                              
                                 i, k
                               = 0 otherwise.


                              wk
                               = 1 if vehicle k is used and wk
                               = 0 otherwise.


                              a
                              
                                 i, d
                              : the vehicle arrival time at node i (i ∈ V′) on day d.


                     Model formulation:
                     
                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          min
                                          
                                          
                                       
                                    
                                    
                                       
                                          M
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             w
                                             k
                                          
                                          +
                                          
                                             ∑
                                             
                                                d
                                                =
                                                1
                                             
                                             D
                                          
                                          
                                             ∑
                                             
                                                
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                
                                                ∈
                                                
                                                   E
                                                   ′
                                                
                                             
                                          
                                          
                                             c
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                d
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          s.t.
                                          
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                
                                                ∈
                                                
                                                   E
                                                   ′
                                                
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                d
                                             
                                          
                                          =
                                          
                                             ∑
                                             
                                                
                                                   (
                                                   j
                                                   ,
                                                   i
                                                   )
                                                
                                                ∈
                                                
                                                   E
                                                   ′
                                                
                                             
                                          
                                          
                                             x
                                             
                                                j
                                                ,
                                                i
                                                ,
                                                d
                                             
                                          
                                          =
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          C
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                C
                                             
                                          
                                          
                                             x
                                             
                                                N
                                                +
                                                k
                                                ,
                                                i
                                                ,
                                                d
                                             
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                C
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                ,
                                                N
                                                +
                                                K
                                                +
                                                k
                                                ,
                                                d
                                             
                                          
                                          ≤
                                          1
                                          ,
                                          
                                          
                                          ∀
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   C
                                                
                                             
                                             
                                                x
                                                
                                                   N
                                                   +
                                                   k
                                                   ,
                                                   i
                                                   ,
                                                   d
                                                
                                             
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   C
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   ,
                                                   N
                                                   +
                                                   K
                                                   +
                                                   k
                                                   ,
                                                   d
                                                
                                             
                                             ≤
                                             1
                                             ,
                                             ∀
                                             
                                          
                                          
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             y
                                             
                                                N
                                                +
                                                k
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          =
                                          
                                             y
                                             
                                                N
                                                +
                                                K
                                                +
                                                k
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          =
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             y
                                             
                                                j
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          ≥
                                          
                                             y
                                             
                                                i
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          +
                                          
                                             x
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                d
                                             
                                          
                                          −
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             E
                                             ′
                                          
                                          ,
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                C
                                             
                                          
                                          
                                             q
                                             
                                                i
                                                ,
                                                d
                                             
                                          
                                          
                                             y
                                             
                                                i
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          ≤
                                          Q
                                          ,
                                          
                                          ∀
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             a
                                             
                                                j
                                                ,
                                                d
                                             
                                          
                                          ≥
                                          
                                             a
                                             
                                                i
                                                ,
                                                d
                                             
                                          
                                          +
                                          
                                             t
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          −
                                          
                                             (
                                             1
                                             −
                                             
                                                x
                                                
                                                   i
                                                   ,
                                                   j
                                                   ,
                                                   d
                                                
                                             
                                             )
                                          
                                          M
                                          ,
                                          
                                          ∀
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             E
                                             ′
                                          
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             e
                                             i
                                          
                                          ≤
                                          
                                             a
                                             
                                                i
                                                ,
                                                d
                                             
                                          
                                          ≤
                                          
                                             l
                                             i
                                          
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          
                                             V
                                             ′
                                          
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             z
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                          ≥
                                          
                                             y
                                             
                                                i
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          C
                                          ,
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             z
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                          ≤
                                          R
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          C
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             w
                                             k
                                          
                                          ≥
                                          
                                             z
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          C
                                          ,
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (12)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                S
                                                ,
                                                j
                                                ∈
                                                C
                                                ∖
                                                S
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                d
                                             
                                          
                                          ≥
                                          
                                             ⌈
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         S
                                                      
                                                   
                                                   
                                                      q
                                                      
                                                         i
                                                         ,
                                                         d
                                                      
                                                   
                                                
                                                Q
                                             
                                             ⌉
                                          
                                          ,
                                          
                                          ∀
                                          
                                          S
                                          ⊆
                                          C
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             x
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                d
                                             
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          
                                          ∀
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          
                                             E
                                             ′
                                          
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             y
                                             
                                                i
                                                ,
                                                k
                                                ,
                                                d
                                             
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          
                                             V
                                             ′
                                          
                                          ,
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (15)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             z
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          C
                                          ,
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (16)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             w
                                             k
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          
                                          ∀
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (17)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             a
                                             
                                                i
                                                ,
                                                d
                                             
                                          
                                          ≥
                                          0
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          ∈
                                          
                                             V
                                             ′
                                          
                                          ,
                                          
                                          d
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          D
                                       
                                    
                                 
                              
                           
                        
                     
                  

The objective (1) is to minimize the number of vehicles first and then the total travel time. Constraints (2) are the flow conservation constraints for the customer nodes which at the same time enforce that each customer must be visited by exactly once each day. Constraints (3) are the flow conservation constraints for the depot nodes which also enforce that at most one vehicle can be related to depot node pair (N + k, N + K + k). Constraints (4) and (5) guarantee that the customers served by the same vehicle are marked with the same identity. The vehicle capacity constraints are given by constraints (6). Constraints (7) ensure that the arrival time at the next location is later than the sum of the arrival time at the current location, the service time and the travel time. The time windows are implemented using constraints (8). Constraints (9) are the allocation constraints, where a vehicle k can visit customer i in the planning horizon only if vehicle k is assigned to customer i. Constraints (10) are the LVQ constraints for each customer. Constraints (11) identify the set of vehicles that are used over the planning horizon. Constraints (12) are the generalized capacity constraints that can strengthen the lower bound provided by the linear relaxation model. Finally, the integrality and non-negativity requirements of the solution are guaranteed by constraints (13)–(17).

We can apply the branch-and-cut search scheme implemented by some commercial optimization software, e.g., ILOG CPLEX, to handle the formulation (1)–(17), where the inequalities (12) are dynamically identified and added. Our computational experiments proved that this formulation is useful only for small-size instances, which motivated us to develop heuristic approach to deal with the instances of practical size.

Our proposed solution approach consists of three stages. In the first stage, we generate a feasible initial MVRPTW-LVQ solution using a decomposition strategy, which constructs the solution by solving up to R VRPTW instances and combining the results. The second stage focuses on reducing the number of vehicles by applying an iterative tree search with a repair mechanism. In the third stage, we apply a unified tabu search to reduce the total travel distance of the solution obtained from the second stage. We call this the Decomposition, Repair and Distance Reduction (DRDR) approach.

We generate an initial solution using a simplified version of the decomposition framework proposed by Zhu et al. (2008). The main idea is to first solve a VRPTW instance, which returns a set of vehicle routes. Given an MVRPTW-LVQ instance, a VRPTW instance is created as follows. The input graph G, edge costs, time windows, vehicle capacities and service durations are unchanged. The customer demands in the VRPTW instance are designed using some strategies according to the customer demands in the MVRPTW-LVQ instance. So when the actual demands are assigned to these routes, some of them may become infeasible. For these infeasible routes, we remove customer requests (i.e., a node with non-zero demand on a particular day) using a greedy approach until they are feasible. The removed customer requests form a new VRPTW instance, and we repeat this process at most R times. If all routes are feasible at the end of this process, then we have produced a feasible MVRPTW-LVQ solution.


                        Algorithm 1
                         provides an overview of the initial solution construction procedure. The decomposition framework consists of three components: (1) how the demand in the VRPTW instance is set in each iteration; (2) how the VRPTW is solved; and (3) which customer requests are removed when making the infeasible routes feasible. Zhu et al. (2008) proposed two strategies to set the demands in the VRPTW instance, and two strategies to remove customer requests from infeasible routes. Our approach is similar to that of Zhu et al. (2008) except that we use only one demand setting strategy and one customer request removing strategy, as well as a different VRPTW solver. Zhu et al. (2008) used a sophisticated VRPTW solver by Lim and Zhang (2007), which takes a long time to generate a high-quality solution. Instead, we use a greedy heuristic combined with squeaky-wheel optimization (SWO) for this purpose, which is significantly faster. So our initial solution construction method can be viewed as a simplification from that of Zhu et al. (2008), which provides a good starting point for the optimization in the next two stages.

Let qi
                         denote the demand of customer i in the VRPTW instance. Then it is calculated using the following equation:

                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             
                                                q
                                                i
                                             
                                             =
                                             
                                                q
                                                
                                                   i
                                                
                                                min
                                             
                                             +
                                             γ
                                             
                                                (
                                                
                                                   q
                                                   
                                                      i
                                                   
                                                   max
                                                
                                                −
                                                
                                                   q
                                                   
                                                      i
                                                   
                                                   min
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 q
                                 
                                    i
                                 
                                 min
                              
                              =
                              
                                 min
                                 
                                    d
                                    ∈
                                    D
                                 
                              
                              
                                 {
                                 
                                    q
                                    
                                       i
                                       d
                                    
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 q
                                 
                                    i
                                 
                                 max
                              
                              =
                              
                                 max
                                 
                                    d
                                    ∈
                                    D
                                 
                              
                              
                                 {
                                 
                                    q
                                    
                                       i
                                       d
                                    
                                 
                                 }
                              
                           
                         are the lowest and highest demands of customer i within the planning horizon, respectively, and γ, 0 ≤ γ ≤ 1, is a controlling parameter. Note that when γ = 1, then 
                           
                              
                                 q
                                 i
                              
                              =
                              
                                 q
                                 
                                    i
                                 
                                 max
                              
                              ,
                           
                         whereupon a feasible solution to this VRPTW instance that is replicated over D days is also a feasible solution to the MVRPTW-LVQ; this would ensure that a feasible MVRPTW-LVQ solution is produced. However, a lower γ value could potentially improve the quality of the solution since fewer vehicles may be required when the demand is lower. As a general rule of thumb, a γ value of approximately 1/R is reasonable. In our experiments, we set γ = 1 when R = 1 and γ = 0.4 when R = 2 after some preliminary testing.

We solve this VRPTW instance by first directly applying the Solomon-I1 greedy heuristic (Solomon and Marius, 1987) to find a feasible VRPTW solution. The Solomon-I1 heuristic begins by randomly selecting a customer as the “seed” customer of a route. Customers are then inserted into this route one by one until no further feasible insertion is possible. The process is repeated with a new empty route until all customers are served. For precise details, we refer the reader to the articles by Solomon and Marius (1987) and Bräysy and Gendreau (2005). In particular, the various parameters for the Solomon-I1 heuristic for our implementation were set to the values that produced the best results for Solomon’s test sets (i.e., α
                        1 = 0.83, α
                        2 = 0.17, μ = 0.93 and λ = 0.90).

We then refine this solution by means of the squeaky-wheel optimization (SWO) strategy (Joslin and Clements, 1999). The SWO framework is a variant of multi-restart framework in which a greedy heuristic is applied to construct a solution. In the SWO framework, each customer is assigned a priority factor, which is initially set to 1. In each iteration, the priority factor for each customer is updated, such that the customers in the routes that involve less service demand are penalized more. These priority factors then determine the order in which the Solomon-I1 heuristic selects the next customer to insert. In effect, the “difficult” customers will be handled sooner in the solution construction. We repeat this process SWO_iter = 100 times. For the full details, we refer the reader to Lim and Zhang (2007).

The resulting VRPTW solution can be considered as a set of template routes for the MVRPTW-LVQ, which we call a base solutionS
                        base. Due to demand fluctuations (i.e., different demand for the same customers on different days), some routes in S
                        base may be infeasible because they violate the vehicle capacity constraint on some days. For such routes, we make them feasible by repeatedly removing (“kicking out”) the customer requests with the greatest average demand, which we place into a kick list. Fig. 1
                         shows an example of this process. Let r = (2, 1, 3) ∈ S
                        base be a route in the base solution, and suppose the vehicle capacity Q = 5. If the demand for each customer is as given in the table, then route r is infeasible because it violates the capacity constraint on days 1 and 3. To make r feasible, we repeatedly kick out the request from the customer with highest average demand on days where the route is infeasible. Hence, customer 3 is kicked out on day 1, and customers 3 and 1 are kicked out on day 3. This results in routes r
                        1 = (2, 1), r
                        2 = (2, 1, 3) and r
                        3 = (2) for days 1, 2 and 3, respectively.

The routes after this kicking out process form a feasible sub-solution to the MVRPTW-LVQ; note that all customers are served by only one driver in this partial solution. We repeat the entire procedure on the customer requests in the kick list to generate further feasible sub-solutions. If all customer requests are fulfilled after at most R iterations of this process, then we have found a feasible MVRPTW-LVQ solution (composed of all feasible sub-solutions) where each customer is serviced by at most R vehicles. Note that using the value γ = 1 when setting the demand for the VRPTW instance in Eq. (18) guarantees a feasible solution.

The second stage of our approach involves reducing the number of vehicles in the feasible solution produced after the first stage, beginning with the depth-first tree search (DFS) given in Algorithm 2
                        . The root node of the search tree represents the initial feasible solution. In each iteration, we consider the B vehicles in the current solution S whose routes involve the fewest customers as candidates for removal (ties are broken arbitrarily). For the chosen vehicle v, we remove all customers that it serves from all routes, and place these customers into a set known as an ejection pool 
                        (Glover, 1996). We then attempt to construct a feasible MVRPTW-LVQ solution involving only the remaining vehicles using a reinsertion procedure. If this is successful, we continue the search by considering the removal of another B vehicles; otherwise, we backtrack and examine the removal of the other candidate vehicles.


                        Algorithm 3
                         describes our reinsertion procedure. This procedure is based on the ejection chain operation (line 9, Algorithm 3) proposed by Glover (1996), which is a well-known operation for minimizing the number of vehicles in the VRPTW (e.g., see Lim and Zhang, 2007; Nagata and Bräysy, 2009). Initially, the ejection pool EP containing the set of unserved customers and the partial solution S are given. We begin by randomly selecting an unserved customer u ∈ EP. Next, we find the vehicle v that has the largest number of routes where the customer requests from u can be feasibly inserted in the planning horizon. The customer requests from u are then inserted into the routes of v in turn. For each route, the request will be directly inserted at the lowest cost position if there is a feasible position available. Otherwise, a request from another customer u′ will be ejected from the route such that the request from u can be feasibly inserted. The ejected request from u′ is then inserted into another route within the same period, which might in turn eject a customer request from that route, and so on. The number of attempts is limited by the length of the chain ECL, which is a user-defined parameter. If ECL consecutive eject-and-insert operations are unable to insert the current customer request into the route without requiring an ejection, we return S to its original state (line 12, Algorithm 3) and try the next vehicle v ∈ S.

The reinsertion procedure continues to allocate customers to vehicles until either the EP is empty or all attempts to insert a current customer u into S have failed. A feasible solution will be obtained if all customers in EP can be assigned to the set of available vehicles. Otherwise, a partial solution with a set of unserved customers will be obtained. Over the course of the DFS algorithm, we record the best feasible solution S
                        best and the partial solution 
                           
                              S
                              best
                              ′
                           
                         with the fewest unserved customers. After the DFS algorithm is complete, we attempt to convert 
                           
                              S
                              best
                              ′
                           
                         into a feasible solution using a repair procedure.

The repair procedure works as follows. We first create an infeasible solution S′ from 
                           
                              S
                              best
                              ′
                           
                         by assigning the unserved customers to the existing vehicles using the reinsertion operation without considering the LVQ and capacity constraints, i.e., no ejections will be done. We then use the repair tabu search (RTS) algorithm given in Algorithm 4
                         to attempt to make S′ feasible. This tabu search framework was proposed by Cordeau et al. (2001); it has the advantage of being able to explore infeasible solutions during the search.

At the beginning of the process, we record S* ← S as the best solution found so far. There are two operators embedded in the RTS algorithm, namely the relocate operator and the exchange operator. The relocate operator moves a customer from the current route to another route, while the exchange operator involves exchanging two customers between two routes. Since these operators work on particular customers, we call them customer-wise operators. Given a solution S, let N(S) denote the time window feasible neighborhood of S, i.e., all possible solutions as the result of one of the two operators where the resultant routes satisfy the time window constraints. In each iteration, we evaluate all solutions from N(S) using the evaluation function f(S) + p(S), which consists of two components. The first component f(S) is the cost function, defined as:

                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             f
                                             
                                                (
                                                S
                                                )
                                             
                                             =
                                             β
                                             
                                                ∑
                                                
                                                   c
                                                   ∈
                                                   C
                                                
                                             
                                             max
                                             
                                                (
                                                0
                                                ,
                                                V
                                                
                                                   (
                                                   c
                                                   )
                                                
                                                −
                                                R
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   r
                                                   ∈
                                                   S
                                                
                                             
                                             max
                                             
                                                (
                                                0
                                                ,
                                                q
                                                
                                                   (
                                                   r
                                                   )
                                                
                                                −
                                                Q
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where V(c) is the number of vehicles serving customer c, and q(r) is the total demand fulfilled by route r. The left part of the cost function is the penalty cost of violating the LVQ constraint, while the right part denotes the penalty cost of violating the capacity constraint. The value β controls the relative weights of these two factors in the evaluation function. Hence, the cost function f(S) measures the “distance from feasibility” of the solution. In our experiments, we initially set β = 5.

The second component p(S) is the penalty function. Let ρ
                        cust(c, r, t) be the number of times customer request c has been previously removed from route r in period t using a customer-wise operator (i.e., relocate or exchange). If the solution was as a result of relocating request c from route r in period t, then the penalty function p
                        relocate(S) is:

                           
                              (20)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                relocate
                                             
                                             
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                λ
                                                cust
                                             
                                             ·
                                             
                                                ρ
                                                cust
                                             
                                             
                                                (
                                                c
                                                ,
                                                r
                                                ,
                                                t
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

If the solution was created by exchanging customer request c
                        1 from route r
                        1 with request c
                        2 from route r
                        2, then the penalty function p
                        exchange(S) is:

                           
                              (21)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                exchange
                                             
                                             
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                λ
                                                cust
                                             
                                             ·
                                             
                                                [
                                                
                                                   ρ
                                                   cust
                                                
                                                
                                                   (
                                                   
                                                      c
                                                      1
                                                   
                                                   ,
                                                   
                                                      r
                                                      1
                                                   
                                                   ,
                                                   t
                                                   )
                                                
                                                +
                                                
                                                   ρ
                                                   cust
                                                
                                                
                                                   (
                                                   
                                                      c
                                                      2
                                                   
                                                   ,
                                                   
                                                      r
                                                      2
                                                   
                                                   ,
                                                   t
                                                   )
                                                
                                                ]
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The value λ
                        cust is a user-defined parameter that affects the relative weight of the penalty function compared to the cost function for customer-wise operations. For our experiments, we set λ
                        cust = 3. The penalty function directs the search to avoid removing the same customer request from the same route multiple times.

In each iteration, the current solution S is updated to be the solution 
                           
                              
                                 S
                                 ¯
                              
                              ∈
                              N
                              
                                 (
                                 S
                                 )
                              
                           
                         with the minimal evaluation function value provided that it is not tabu; however, S is also updated to be 
                           
                              S
                              ¯
                           
                         if 
                           
                              S
                              ¯
                           
                         is tabu but is superior to S* (this is known as the aspiration criterion). The operation that produces 
                           
                              S
                              ¯
                           
                         is marked as tabu for θ
                        cust = 10 iterations (the value θ
                        cust is known as the tabu tenure). We then update the β value in the cost function f(S) (line 6, Algorithm 4) as follows: if the cost of the LVQ constraint (the left part of Eq. (19)) is less than the cost of the capacity constraint (the right part), then β is multiplied by (1 + δ), where δ is a user-defined parameter; in our implementation, we set δ = 0.001. Otherwise, β is divided by (1 + δ) to put less emphasis on the LVQ constraint and guide the search toward a solution that satisfies the capacity constraint.

The RTS procedure is performed 
                           
                              RTS
                              _
                              iters
                              =
                              1000
                           
                         iterations. If the resultant solution S after the RTS procedure is feasible and superior to the best feasible solution S
                        best found after the DFS procedure, then we repeat the entire process starting with DFS(S). Otherwise, we continue with stage three.

The aim of this stage is to reduce the total travel distance of the feasible solution found by stage two. We make use of a tabu search procedure that is similar to the RTS procedure given in Algorithm 4, except for three main differences: (1) the input solution S is feasible; (2) we use different neighborhood operators; and (3) we use a different evaluation function. To distinguish between the two tabu search procedures, we call the stage three version the post-optimization tabu search (PTS).

We apply three operators in this procedure, namely relocate, cross and 3-opt; all of these operators only consider moves where the resultant routes are feasible (i.e., they satisfy the time window, LVQ and capacity constraints). The relocate operator is identical to the one used for RTS in stage two, except that the resultant solutions must also satisfy the LVQ and capacity constraints. The cross operator selects a sub-route from two different routes and swaps them. The 3-opt operator is an intra-route operator, which swaps two disjoint sub-routes within a route. Note that for the 3-opt operator, we need not check for compliance with the LVQ and capacity constraints. Since the cross and 3-opt operators move sub-routes, we call them route-wise operators. We use the tabu tenure value of θ
                        cust = 2 × K for the customer-wise relocate operator, where K is the number of vehicles used in the incumbent solution, and a separate tabu tenure value of θ
                        route = 3 × K for the route-wise operators 3-opt and cross; separate tabu tenures for customer-wise and route-wise operators were also used successfully by Cordeau et al. (2001). The aspiration criterion is also active in the PTS, where a tabu solution is still accepted if it is superior to the best solution found so far.

There is an important difference between our implementation of PTS when the LVQ value R = 1 compared to when R ≥ 2. When R ≥ 2, the operators are performed on each day independently. For example, a request by customer c can be relocated from route r
                        1 to route r
                        2 on day 1, but this relocation will not apply to other days. However, when R = 1, all operators will move customers as a whole. For example, if customer c is relocated from r
                        1 to r
                        2 on day 1, then it will also be relocated from r
                        1 to r
                        2 on all days.

The evaluation function of the PTS is different from that of the RTS. The cost function f(S) for PTS is the total travel distance of all routes over the planning horizon. The penalty function is divided into three cases corresponding to the three operators. The penalty function p
                        relocate(S) is identical to the RTS version given in Eq. (20). The other two cases are:

                           
                              (22)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                3-opt
                                             
                                             
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                λ
                                                route
                                             
                                             ·
                                             
                                                ρ
                                                route
                                             
                                             
                                                (
                                                r
                                                ,
                                                t
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                cross
                                             
                                             
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                λ
                                                route
                                             
                                             ·
                                             
                                                [
                                                
                                                   ρ
                                                   route
                                                
                                                
                                                   (
                                                   
                                                      r
                                                      1
                                                   
                                                   ,
                                                   t
                                                   )
                                                
                                                +
                                                
                                                   ρ
                                                   route
                                                
                                                
                                                   (
                                                   
                                                      r
                                                      2
                                                   
                                                   ,
                                                   t
                                                   )
                                                
                                                ]
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where λ
                        route = 10 is the user-defined coefficient parameter for route-wise operators, and ρ
                        route(r, t) is the number of times the corresponding route-wise operator has been applied to route r in period t. This process is executed 
                           
                              P
                              T
                              S
                              _
                              i
                              t
                              e
                              r
                              s
                              =
                              1000
                           
                         times (see Section 5.1.3 for an explanation of how this value was chosen).

According to our preliminary computational experience, the ISC, DFS and RTS procedures run much more quickly than the PTS procedure, which motivates us to run the ISC, DFS and RTS procedures many times to produce solutions with fewer vehicles. Besides, the PTS procedure converges very quickly at the first 100 iterations. So after the number of vehicles is reduced, we run the PTS procedure for 100 iterations to shorten the travel distance and add it to the solution pool. After that, we choose the best two solutions from the solution pool and apply the PTS procedure to reduce their travel distances extensively (PTS_iters = 1000). Algorithm 5
                         describes the DRDR implementation in detail.

We performed five sets of computational experiments using our Decomposition, Repair and Distance Reduction (DRDR) approach. The first set of experiments involves a number of instances derived from a benchmark VRPTW test set, which we used to discover appropriate values for the various algorithm parameters and evaluate the sensitivity of the DRDR approach. The second set of experiments analyzed the contributions of different components in the DRDR approach. The third set of experiments consists of 56 small MVRPTW-LVQ instances involving 10 customers; a large proportion of these instances can be optimally solved by the commercial solver CPLEX 12.5 using the mathematical programming model in Section 3. We present the results obtained by DRDR as an indication of the performance of the approach when compared to the optimal solutions. In the fourth set of experiments, we compared the performance of DRDR on a set of MVRPTW-LVQ instances with the technique proposed by Zhu et al. (2008). Finally, we modified DRDR to handle the ConVRP instances and tested it under different levels of service consistency. We first set the LVQ to be R = 1 and compared DRDR with the ConRTR approach (Groër et al., 2009), the MADS approach (Sungur et al., 2010), two versions of the template-based tabu search approach (i.e., TTS-L and TTS-F, see Tarantilis et al., 2012) and the TANLS approach (Kovacs et al., 2014) based on a set of ConVRP benchmark instances. Then, we relaxed the service consistency requirement by setting R = 2 and compared it with the RTR approach (Li, Golden, and Wasil, 2005) on the same set of ConVRP benchmark instances.

All experiments were performed on a virtual machine with 2 gigabyte RAM running Windows XP where the physical server is a 2.27 gigahertz Intel Xeon processor with 8 gigabyte RAM running CentOS 5.4. All solutions presented in this section were obtained by DRDR within an hour of CPU time.

Our DRDR approach involves several parameters. To determine appropriate values for these parameters, we performed a series of experiments on a set of instances derived from the 56 VRPTW benchmark instances by Solomon and Marius (1987). Each instance in the original test set consists of 100 customers and a single depot. The instances are divided into six classes. Classes R1 and R2 have randomly distributed customers; the customers in classes C1 and C2 are distributed in clusters; and classes RC1 and RC2 consist of a mix of both random and clustered customers. All instances in the same class have the same customer locations and the same vehicle capacities, but the time windows are different. Classes R1, C1 and RC1 have narrow time windows and small vehicle capacities, so the number of customers served by a single vehicle is small. Classes R2, C2 and RC2 have wide time windows over longer scheduling horizons and large vehicle capacities, so the solutions have comparatively fewer vehicles.

We converted these VRPTW instances into MVRPTW-LVQ instances as follows. We preserve the customer locations and time windows of the original instances. The planning horizon for all instances was set to be D = 7 days. Each customer has a fluctuant demand on each of the 7 days within the range of [d
                        0 × (1 − μ), min {d
                        0 × (1 + μ), 0.8Q}], where d
                        0 is the demand of the original instance and μ is the level of demand fluctuation. For the purposes of parameter tuning, we set μ = 50 percent.


                        Table 1
                         lists the values of the various parameters in our implementation of the DRDR approach. For the remainder of this section, we describe our experiments that determine three important parameters, namely the length of the ejection chain ECL, the branching factor B in the DFS algorithm and the number of iterations PTS_iters of the post-optimization tabu search PTS executed in stage three. The first two parameters affect the amount of search efforts expended on reducing the number of vehicles in the solution, which is the primary objective of the MVRPTW-LVQ. The latter parameter controls the amount of search efforts spent on reducing the secondary objective of the total travel time. In order to test the performance under various levels of service consistency, we set R = 2 in the experiments.

The length of the ejection chain ECL determines the number of insertion–ejection operations performed by the ejection-chain operator in the reinsertion procedure (see Algorithm 3) when attempting to reduce the number of vehicles in stage two. While a longer ejection chain allows the algorithm to explore the search space more thoroughly, this comes at the expense of additional computation time. We therefore performed a number of experiments to choose the best ejection chain length. For each value of ECL = 1, …, 6, we conducted 10 independent runs on each test instance. Each run consisted of stage one and the DFS of stage two (the RTS procedure was not included). The branching factor B for the DFS was set to 2.

The results are summarized in Table 2
                           . For each value of the ejection chain length, we provide the average computation time in CPU seconds required to solve all instances along with the average number of vehicles in the solutions obtained by the 10 runs for each class of instances. The right-most column gives the difference in the sum of the averages for the six classes, divided by the increase in time required when the ejection chain length is increased by one. We see that as the value of ECL increases, the number of vehicles in the solutions decreases but more time is required. However, there are diminishing returns in terms of solution improvement per unit time to increasing the length of the ejection chain beyond 4. An appropriate ejection chain length value should maximize vehicle reduction while still using a reasonable amount of computation time. Ultimately, we selected the value of ECL = 5 since for values greater than 5, there is no additional vehicle reduction for most instances.

The branching factor B of the DFS algorithm determines the number of different vehicles whose removal will be examined in each state of the search. Given the depth d of the search tree, the number of states examined is O(Bd
                           ), so the branching factor has a significant effect on both the number of states searched and the computation time. Note that the number of vehicles in the solution will be reduced by exactly d − 1 after the DFS algorithm. For each value of B = 1, 2, 3, we conducted 10 independent runs on each test instance; once again, each run consisted of stage one and the DFS of stage two. The ejection chain length ECL was set to 5.


                           Table 3
                            gives the average number of vehicles in the solutions obtained for each test set over the 10 runs along with the computation time required in CPU seconds. The last column gives the improvement in the total of the average number of vehicles per second when the branching factor is increased by one. As expected, a larger branching factor results in solutions with fewer vehicles, but there is a dramatic increase in computation time. In particular, the average running time for B = 3 is 53.48 seconds, which is significantly slower than the 13.44 seconds required for B = 2, but the amount of improvement in solution quality is minimal. Hence, we set B = 2 in our final implementation.

The number of iterations PTS_iters of the PTS algorithm in stage three controls the amount of search efforts spent to reduce the total travel distance of the solution. Stage three turned out to be the most time-consuming stage in our DRDR approach.

To find an appropriate value for PTS_iters, we executed our approach on six instances (one from each class) with 10,000 iterations of PTS and two different levels of service consistency R = 1 and R = 2. Fig. 2
                            shows the convergence of the algorithm over the first 5000 iterations under the two levels of service consistency; the remaining 5000 iterations followed a similar trend and produced minimal improvements. The vertical axis is the percentage difference between the average travel distance of the current solution and the travel distance found after 10,000 iterations. We find that although the majority of the improvement is obtained early in the process, PTS is able to find small improvements up to the entire 10,000 iterations. Table 4
                            shows the average computation times for different numbers of iterations, where the row labeled Gap (percent) is the percentage difference in distance between the solutions found after the given number of iterations and after 10,000 iterations. We eventually decided to set PTS_iters = 1000 since this value allowed DRDR to find solutions that are 0.93 percent on average away from the solutions found after 10,000 iterations in 38.2 seconds, which represents a good balance between solution quality and computation time.

Our DRDR approach consists of four components, i.e. initial solution construction procedure (ISC), depth-first search procedure (DFS), repair tabu search procedure (RTS) and post-optimization tabu search procedure (PTS). Among them, ISC, DFS and PTS are necessary for a complete algorithm in order to minimize the vehicle number and the total travel distance. In this section, we will first examine the contribution of the RTS procedure and then address the evolution of a solution after different components.

To examine the contribution of the RTS procedure, we constructed a comparison experiment using the same test data used in Section 5.1. In this experiment, we designed two algorithms: the first algorithm (called WITH-RTS) consists of the ISC, DFS and RTS procedures, while the second one (called NO-RTS) consists of only the ISC and DFS procedures. We ran each of these two algorithms once with the same random seed. The computational results are summarized in Table 5
                           . The second column gives the computation times of these two algorithms. The average numbers of vehicles for different data sets are presented in columns three to eight. The last column shows the improvement incurred by the RTS procedure. The RTS procedure is able to reduce the vehicle numbers for three data sets and improved the solution quality by 2.01 percent on average. So it is beneficial to incorporate the RTS procedure into the DRDR approach.

Basically, the DRDR approach takes three stages to generate high quality solutions. In the first stage, the ISC procedure constructs an initial solution. Then the DFS and RTS procedures reduce the number of vehicles. Finally, the PTS procedure optimizes the total travel distance. We ran an algorithm consisting of ICS, DFS&RTS, and PTS on the test data of Section 5.1 one time.


                           Table 6
                            gives for each test data set the average numbers of vehicles and the average travel distances generated after different components of the DRDR approach. The average computation times are presented in the second column, and the average improvements of the vehicle numbers and travel distances with respect to the DFS&RTS and PTS procedures are given in the last column. These improvement percentages were computed based on the initial solutions generated by the ICS procedure and the solutions after performing the DFS&RTS (or PTS) procedure. Note that the DFS&RTS reduced the vehicle numbers at the expense of increasing the travel distance and thus the corresponding average distance improvement is a negative value, namely − 1.80 percent. The ICS procedure consumed the least amount of computation time, followed by the DFS&RTS procedure; the PTS is the most time-consuming procedure, accounting for over 93 percent of the total running time. This observation motivates us to run the ICS and DFS&RTS procedures many times to select a set of good solutions for the PTS procedure.

To evaluate the effectiveness of DRDR, we compared the solutions obtained by DRDR with the optimal solutions generated by CPLEX 12.5 with a time limit of 1 hour. We used the same test instances in Section 5.1 but only considered the first 10 customers of each instance for the sake of creating small-size instances. The generalized capacity constraints (12) are identified by the separation algorithms proposed by Augerat, Belenguer, Benavent, Corbéran, and Naddef (1998).

We tested LVQ values of R = 1 and R = 2, for a total of 56 × 2 = 112 instances. Table 7
                         gives the comparison results only based on 92 test instances that were optimally solved by CPLEX. The columns N and N* give the total number of instances in each data set and the number of instances optimally solved by CPLEX, respectively. The columns # Vehicle and Dist. report the average numbers of vehicles and the average travel distances of the solutions obtained by the corresponding approaches (these two average values are only related to the instances optimally solved by CPLEX). The right-most column ΔDist. (percent) shows the gaps of the average travel distances obtained by these two approaches. Fig. 3
                         pictorially shows an optimal solution to instance rc101 with the first 10 customers, R = 2 and D = 7, which was obtained by CPLEX.

CPLEX optimally solved 42 instances with R = 1 and 50 instances with R = 2 within 1 hour. Table 7 shows that the vehicle numbers generated by the DRDR approach is the same as those in the optimal solutions. This suggests that the DRDR approach is very effective in minimizing the vehicle number. Among the total six data sets, DRDR is able to obtain the same average travel distances as those in the optimal solutions for three data sets when R = 1 and for two data sets when R = 2. Moreover, the gap from the minimal travel distance is quiet small for the instance sets that were failed to be optimally solved by DRDR. This demonstrates the ability of the DRDR approach in minimizing the total travel distance.

In this section, we evaluate the performance of the DRDR approach on the MVRPTW-LVQ instances used by Zhu et al. (2008), which were generated from the Solomon’s 56 VRPTW instances. The generation procedure for these instances is similar to the procedure described in Section 5.1, except that the amount of demand for each customer was determined as follows. Let d
                        1 denote the amount of demand on the first day for a customer in an MVRPTW-LVQ instance; this value was calculated as d
                        1 = d
                        0 × m, where d
                        0 is the demand of this customer in the corresponding VRPTW instance and m is a scaling variable. The remaining demands in the planning horizon were then randomly and uniformly selected from the range [0.5d
                        1, 1.5d
                        1]. These instances can be found at: http://www.computational-logistics.org/orlib/mvrptwlvq.

For ease of discourse, we shall refer to the approach by Zhu et al. (2008) as ZZCL. Table 8
                         provides the comparison between DRDR and ZZCL on these instances with R = 2. For each data set, we report the average number of vehicles (column # Vehicle) and the average travel distance (column Dist.). The column Δ# Vehicle (percent) (respectively, ΔDist. (percent)) gives the percentage difference between the average numbers of vehicles (respectively, the average travel distances) obtained by DRDR and ZZCL. We also provide the average computation times consumed by DRDR in the column CPU (s). Since the computation times of ZZCL were not revealed in Zhu et al. (2008), we cannot present them in this table. Under the block DRDR (R = +∞), we present the results when there are no consistency constraints.

The numbers in bold indicate that DRDR achieved the same or better results than ZZCL with regard to the average number of vehicles. Apparently, DRDR can find solutions with smaller average number of vehicles than ZZCL for five out of six data sets. The exception is class RC2, where DRDR obtained the same average number of vehicles as ZZCL but with significantly longer average travel distance (11.68 percent longer on average). An inspection of the solutions generated by ZZCL reveals that each customer is visited by only one driver in the planning horizon. This means that a VRPTW solution can be applied in each day of the planning horizon without any change. The instances in class RC2 are characterized by wide time windows and large vehicle capacities, which reduce the impact of demand fluctuation on the consistency of the routing plan. Since ZZCL uses a powerful VRPTW solver in the decomposition framework, it is able to achieve high-quality VRPTW solutions and thus high-quality MVRPTW-LVQ solutions. Note that in our implementation of PTS, the operators are performed on each day independently when R ≥ 2 while the operators move customers as a whole when R = 1. So the search space of PTS when R ≥ 2 is significantly larger than that when R = 1. Moreover, since the demand fluctuation is small in the RC2 instances, many good solutions have the property that the routing plans of all days are almost the same. Obviously, the operators in the implementation when R = 1 can locate these solutions more easily. Consequently, we retested DRDR on the RC2 instances with R = 1 and report the results in the row RC2* (i.e., the last row) in Table 8. We can see that when R = 1, the average difference in the travel distances achieved by DRDR and ZZCL is only 1.55 percent.

The column Diff. (percent) gives the percentage difference of the average number of vehicles found by DRDR with R = +∞ and with R = 2. We can see that for classes R1, C1 and RC1, where the instances have narrow time windows and small vehicle capacities, the removal of the service consistency requirement does lead to vehicle number reduction. For classes R2, C2 and RC2, which have wide time windows and large vehicle capacities, the average number of vehicles used remain unchanged while the average travel distances are slightly reduced.

We applied the DRDR approach to solve the 12 benchmark ConVRP instances used in Groër et al. (2009), which were derived from the VRP instances generated by Christofides and Eilon (1969). These instances can be found at: http://www.rhsmith.umd.edu/faculty/bgolden/vrp_data.htm.

The objective of the ConVRP is to generate a consistent routing plan to maintain customer relationships and provide high quality service. The ConVRP requires that each customer must be visited by the same vehicle (equivalent to specifying R = 1), and defines service consistency in terms of a maximum arrival time difference for any customer over the entire planning horizon. The ConVRP differs from the MVRPTW-LVQ in the following aspects: (1) time windows are not considered; (2) there is a hard precedence constraint that if a customer a is visited before customer b by a particular vehicle on any day, then this must be true on all days when both customers a and b require services; (3) the maximum service arrival time difference for any customer can be at most a given value L; (4) the maximum travel distance for any vehicle cannot exceed a given value T; (5) not all customers require service everyday; and (6) the objective is to minimize the total travel time (rather than the total number of vehicles used).

In order to handle the ConVRP, we made the following adjustments to our DRDR implementation. Firstly, the time window for each customer is set to [0, T], which guarantees that all vehicles satisfy the maximum travel distance constraint. Secondly, we do not perform stage two since reducing vehicle number is not the primary objective any more. Note that when R = 1, all operators in the PTS procedure move customers as a whole, so the precedence constraint is automatically respected.

In the benchmark problems, each instance contains 5 days of data. The demand of each customer is identical on all days, but each customer has only a probability of 0.7 of requiring service on any particular day, so some customers do not require service on some days. For such cases, we set the demand for the corresponding customer to 0 on the days where service is not required. However, these customers are still visited by vehicles in the solution found by DRDR. Therefore, as a final step we remove these “virtual” customer requests with zero demand from the final solution; this is similar to recourse actions, which is a common technique for handling the VRP with stochastic demand (for example, see Bertsimas, 1992; Sungur et al., 2010). Furthermore, the maximum permitted service arrival time difference L was not given in the benchmark test data, so we do not explicitly consider this constraint.

There are various notions of service consistency in existing literature that are appropriate for different applications. To show the effectiveness of the DRDR approach, we conducted two sets of experiments, one with R = 1 and the other with R = 2. For the first set, we compared DRDR with the ConRTR approach (Groër et al., 2009), the MADS approach (Sungur et al., 2010), two versions of the TTS approach (i.e., TTS-L and TTS-F, see Tarantilis et al., 2012) and the TANLS approach (Kovacs et al., 2014) on the maximum arrival time difference for any customer, the total travel time and the computational time. For the second set, we compared DRDR with the RTR approach (Groër et al., 2009) on the proportion of customers receiving fully consistent service (i.e., the customer is only visited by one vehicle). We call this measure the fully consistent customer proportion (FCCP).

When R = 1, we executed the DRDR approach (i.e., stage one followed by stage three) 10 times for each ConVRP instance, and report the solution with the smallest maximum arrival time difference and the average results. The ConRTR and MADS approaches are both deterministic and were performed only once for each instance in their corresponding literature articles. The TTS-L, TTS-F and TANLS were applied to minimize the total travel time of each instance, where for TTS-L and TANLS the maximum arrival time difference of each instance cannot exceed the value produced by Groër et al. (2009) and for TTS-F no limitation was imposed on the maximum arrival time difference. The TTS-L and TTS-F were performed five times for each instance and the best results were reported in Tarantilis et al. (2012). Kovacs et al. (2014) executed the TANLS 10 times for each instance, and reported the average result over 10 runs and the best result of five randomly chosen runs. All results are summarized in Table 9
                        , where the total number of customers (# Customers), the best total travel time (TTT), the smallest maximum arrival time difference (Max), the total computational time (CPU (s)), the average total computational time (Avg. CPU (s)), the average total travel time ( Avg. TTT) and the average maximum arrival time difference (Avg. Max) are provided. We mark the best values of TTT and Max in bold. Since the total computational times of ConRTR and MADS were not reported by their corresponding literature articles, we cannot present them in this table.

In terms of the total travel time, DRDR performs better than ConRTR and MADS but worse than TTS-L, TTS-F and TANLS on average. However, DRDR outperforms all other approaches in terms of the maximum arrival time difference on average, which is the consistency measure defined for the ConVRP. This demonstrates the ability of DRDR in handling consistency service requirement. In other words, DRDR is able to achieve a good tradeoff between the service consistency and the total travel time.

In the second set of experiments, we first executed the DRDR approach (i.e., stage one followed by stage three) for R = 1, and then performed stage three on the resultant solution for R = 2. This was done 10 times for each ConVRP instance, and we selected the solution with the highest FCCP as the output of the DRDR. Note that the RTR approach is an algorithm for the CVRP. Groër et al. (2009) first applied the RTR approach to solve the corresponding CVRP in each day of the planing horizon. Then, they assigned the generated routes to drivers by solving a separate MIP model whose objective is to maximize the FCCP. All relative results are reported in Table 10
                        , where the results related to RTR were obtained from Groër et al. (2009). In Table 10, we provide for each instance the total travel time (column TTT), the number of vehicles generated by DRDR (column V), the mean number of vehicles used over the entire planning horizon generated by RTR (column 
                           
                              V
                              ¯
                           
                        ), the proportion of the customers fully receiving consistent service (column FCCP), the average arrival time difference for each customer (column Avg.) and the maximum arrival time difference for each customer (column Max). We also give the computational time consumed by DRDR to find the solution with the highest FCCP (column CPU (s)). The right-most column ΔTTT (percent) gives the percentage difference in the travel times found by DRDR and RTR. The best FCCP, Avg. and Max values for each instance are highlighted in bold. According to Groër et al. (2009), the results under the block RTR were obtained within 1 hour of computational time. Since the MIP models could not be solved within this time limit for instances 5, 9 and 10, we filled the corresponding cells with “–”.

The results show that DRDR outperforms RTR in terms of the proportion of the customers fully receiving consistent service for all 12 instances (see columns FCCP), and also in terms of the maximum arrival time difference for 11 out of the 12 instances (see columns Max). This comes at a cost of a small increase in the total travel time of around 3.4 percent on average. In addition, the average Avg. value of DRDR is greater than that of RTR.

The above experiments illustrate the generality and flexibility of the LVQ constraint in the DRDR approach as a tool to manage the level of service consistency. When the LVQ value is set to R = 1, the DRDR approach can generate a fully consistent plan with lower operational cost. When R = 2, the DRDR approach can also find solutions in which 58 percent of the customers receive fully consistent service at the cost of a slight increase in the total travel time, compared with RTR.

One possible reason why the majority of route planning applications do not consider service consistency may be the lack of a powerful solution procedure to handle the complexity of this requirement. We believe the DRDR approach is an efficient and effective method to handle this constraint. Our method enables fleet managers to take service consistency into account with low operational cost when creating schedules for delivery services.

One of the purposes of this study is to understand the relationship between demand fluctuation and service consistency. Intuitively, if customer demands fluctuate remarkably across the planning horizon, then increasing crew flexibility using a large R value (thereby reducing the service consistency) is likely to reduce the number of vehicles required, meanwhile decreasing the operational cost.

In some situations, increasing crew flexibility may not achieve actual cost savings since a more flexible routing plan may incur additional overhead due to the operational complexity. Previously, Francis et al. (2007) analyzed the trade-offs between cost and crew flexibility in the PVRP and the PVRP-SC by numerical analyses. They discussed the effect of having consistent planning, and showed that introducing flexibility (such as crew flexibility) can simultaneously increase the cost efficiency and the complexity of operation. If considering additional overheads, such as driver training, the total operational cost might be ultimately increased.

If all customer demands are largely consistent over the planning horizon, additional crew flexibility might only serve to increase the operational complexity for little or even no benefit. In fact, the results on the existing MVRPTW-LVQ instances reported in Section 5.4 show that the performance of DRDR might suffer due to the large search space caused by setting R to a large value. However, the previous MVRPTW-LVQ experiments do not reveal the relationship between the crew flexibility and the level of demand fluctuation. Thus, to evaluate DRDR under a number of different scenarios, we applied the approach described in Section 5.1 to generate different sets of instances with various levels of demand fluctuations (by setting μ to 10 percent, 30 percent, 50 percent, 70 percent and 90 percent). We assume that service is instantaneous, i.e., si
                      = 0 for all customers i. We divide all instances into two groups based on the vehicle capacity. In group 1 (containing classes R1, C1 and RC1), the vehicle capacity is small, so the number of vehicles used in the final solution is more sensitive to demand fluctuation. On the contrary, for group 2 instances (consisting of classes R2, C2 and RC2), demand fluctuation is likely to have less impact on the number of vehicles required since the vehicle capacity is large. In terms of demand and capacity, the group 1 instances are similar to the apparition of the chain store delivery described in Zhu et al. (2008) as a vehicle will only service a few chain stores. On the other hand, the group 2 instances are similar to the situations encountered in the small package shipping service (Golden, Raghavan, and Wasil, 2008; Sungur et al., 2010), where the demand of each customer is significantly smaller than the vehicle capacity.


                     Fig. 4
                      depicts the results by group and the LVQ value for various levels of demand fluctuations. We tested four levels of service consistency, i.e., R = {1, 2, 3, 4}. Given a demand fluctuation level μ, we compare the average number of vehicles required under different LVQ requirements for each group. From this figure, we can see when R increases from 1 to 2, the number of required vehicles decreases considerably. However, when R continues to increase, the number of required vehicles remains almost unchanged. This suggests that increasing R to 2 is sufficient to reduce the operational cost. In addition, for the group 1 instances, the difference of the numbers of vehicles required when R = 1 and R = 2 increases as the demand fluctuation, implying that service consistency has a significant impact on the instances with small vehicle capacities. On the contrary, such increase tendency is not evident for the group 2 instances, which shows that increasing R is less effective in saving operational cost when the vehicle capacities are comparatively large.

The above observations tell us that if the vehicle capacity is relatively small (i.e., a single vehicle can only serve a small number of customers), then decreasing service consistency may be worthwhile. Otherwise, enforcing consistent service is likely to be effective in reducing operational cost and increasing customer satisfaction. Although Francis et al. (2007) have already addressed the influence of crew flexibility, our analyses are different from theirs in the following aspects. First, we analyze the influence of increasing crew flexibility using a different objective. The objective in Francis et al. (2007) involves both vehicle travel distance and vehicle stopping time, while we mainly focus on the number of vehicles influenced by the crew flexibility. Second, we have different conclusions under different problem setups. In Francis et al. (2007), the authors concluded that increasing crew flexibility has a limited influence on the objective value but greatly increases the operational complexity. However, our results reveal that crew flexibility has a considerable influence on the vehicle number when demand fluctuation is remarkable compared to the vehicle capacity.


                     Table 11
                      reports the fully consistent customer proportion (FCCP) for various levels of demand fluctuation when R = 2. For the group 1 instances, this measure is highly sensitive to demand fluctuation, with values varying from 58.9 percent to 88.2 percent when μ = 10 percent but being around 30 percent when μ = 90 percent. However, the FCCP fluctuation of the group 2 instances is more dramatically. Furthermore, the geographic distribution of the customers also affects this measure. The FCCP values of classes R1 and R2 are smallest and the FCCP values of classes C1 and C2 are the largest. This implies that it is easier to produce solutions that have big FCCP values for the clustered customers than for the randomly distributed customers.

@&#CONCLUSIONS@&#

This paper studies the impact of service consistency in the multi-period vehicle routing problem with time windows (MVRPTW). We modeled the service consistency using a limited visiting quota (LVQ) constraint, which specifies that each customer can be served by at most R vehicles over the entire planning horizon. Introducing this service consistency constraint into the MVRPTW creates a new VRP variant called the multi-period vehicle routing problem with time windows and limited visiting quota (MVRPTW-LVQ). We devised a three-stage approach called decomposition, repair and distance reduction (DRDR) approach to solve this problem. The first stage uses a decomposition strategy to find a feasible solution; the second stage attempts to reduce the number of vehicles in the solution using a repair procedure; and the third stage tries to reduce the total travel distance using a post-optimization procedure. The DRDR approach outperforms the only existing approach for the MVRPTW-LVQ problem. The capability of our DRDR approach in handling the service consistency in ConVRP has also been demonstrated by a set of numerical experiments. Moreover, we applied the DRDR approach to analyze the impact of demand fluctuation and crew flexibility on the operational cost of the problem.

Our results provide some managerial insights on the applications of consistent service. Undoubtedly, the service consistency is able to increase customer satisfaction as well as the operational cost. The cost of consistent service is affected by demand fluctuation. If demand fluctuation is small, enforcing service consistency can maximize customer satisfaction at the expense of only a small increase in operational cost. When a vehicle can only serve a small number of customers, the cost of service consistency is significantly increased. In such situations, we can consider relaxing the service consistency requirement to reduce the number of vehicles required. The DRDR approach provides us with an intelligent method to control service consistency levels with different LVQ values. Furthermore, we can specify different LVQ values for different customers, which is a possible research direction in the future.

@&#ACKNOWLEDGMENTS@&#

This research was partially supported by the Fundamental Research Funds for the Central Universities, HUST (Grant no. 2014QN206) and the National Natural Science Foundation of China (Grant no. 71201065).

@&#REFERENCES@&#

