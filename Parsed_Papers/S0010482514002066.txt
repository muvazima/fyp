@&#MAIN-TITLE@&#Mining approximate temporal functional dependencies with pure temporal grouping in clinical databases

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We focus on dependencies over facts (e.g. diagnosis vs therapy) stored in a database.


                        
                        
                           
                           Dependencies may generally hold: deviating facts set up an approximate dependency.


                        
                        
                           
                           We group data in sets, either by temporal granules or by fixed-length sliding windows


                        
                        
                           
                           Within every set, we look for temporal approximate dependencies.


                        
                        
                           
                           We mine psychiatry and pharmacovigilance data sets and derive new knowledge.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Approximate temporal functional dependency

Temporal granule

Sliding window

Grouping

Psychiatric patients

Pharmacovigilance

@&#ABSTRACT@&#


               
                  Graphical abstract
                  
                     
                        
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

Current clinical database systems enable us to store huger and huger quantities of data, and data mining techniques help in extracting relevant knowledge from these data. Analyzing temporal evolution of data, time series, changes of information over time, may lead to additional temporal knowledge. Temporal data mining is the research field in this direction, working on structured [1] and, occasionally, on semi-structured data [2].

Knowledge on (clinical) databases may be expressed in two ways: on one hand, it can be represented through suitable constraints on data; on the other hand, it can be derived through the analysis of data by discovering patterns, regularities, and so on.

According to the first point of view and considering data stored in a plain relational database, we may express constraints by identifying functional dependencies (FD). Let us consider, for example, a simple database table describing the reference areas for emergency admissions in a region. We typically specify that patients have a single reference hospital for emergencies, depending on their address (considering the neighborhood of the admitting reference hospital). We can thus specify a functional data dependency between the home address of the patient and the location of the hospital: all patients with the same address must refer to the same hospital. Leveraging the definition of functional dependencies as a way of expressing constraints on data, the research community focused also on extending FDs to deal with data temporalities [3–7]: as example, a temporal functional dependency (TFD) may be used to express the constraint that the reference hospital for emergencies depends on the patient home address, but this dependency may change according to the season of the year.

On the other hand, a different approach has to be taken if we consider, for example, a database table collecting data on patients who were admitted for emergencies to hospitals. In this case, we cannot constrain patient addresses to hospitals in a strict way, but we could discover on the collected data that the dependency between patient addresses and hospitals hold on most tuples of the database, but not on all the tuples of that database. We call this an approximate functional dependency (AFD): patients with the same home address usually go to the same hospital (not always the reference one) when they are at home, but, as an example, some patients on holiday could have been admitted to an hospital which is not the closest one to their home address. The issue of discovering approximate functional dependencies from data has been largely studied in the literature [8–11].

As final consideration, we may also experience that over some periods of the year we generally observe an approximate functional dependency, while in some other periods we observe a different approximate dependency: for example, it could occur that patients go to different hospitals for emergencies even according to some specific skills of hospitals in managing seasonal pathologies. In this case, it still holds that we can discover approximate dependencies between patient addresses and hospitals for emergencies, but only if we group data according to the season and the year of the emergency admission. We call this an approximate, temporal functional dependency (ATFD). At the best of our knowledge, studies on approximate temporal functional dependencies still lack.

According to the depicted scenario, the aim of this paper is to propose a first step, focusing on a specific type of ATFD, of a general framework for temporal data mining of clinical data. In particular, we adopt a framework for temporal functional dependencies recently proposed by Combi et al. [7]: the framework subsumes all the previous proposals dealing with temporal functional dependencies for relational databases and introduces some new kinds of temporal functional dependencies. According to this framework, we then focus on the issue of mining (approximate) temporal functional dependencies based on a temporal grouping of tuples. We introduce the concept of approximate temporal functional dependency with temporal grouping, and discuss through some examples both the case when grouping is induced by granularities (i.e. time units) and the case when sliding windows are used. Then, we propose efficient algorithms for this kind of temporal data mining. Finally, we discuss the application of our algorithms to real world clinical data from the psychiatric and pharmacovigilance domains.

Besides the technical performances, we discuss the clinical meaning and the most relevant mined temporal dependencies; in this regard, it is worth noting that the mined temporal functional dependencies are a relatively new kind of clinical knowledge on data, which deserves further efforts to become clearly interpretable by physicians in a daily clinical setting. Indeed, while association rules and temporal association rules have been considered in clinical domains for years and their role in the clinical decision-support process has been widely acknowledged [12,13], approximate temporal functional dependencies represent a new piece of knowledge that has to be properly integrated in clinical decision-support processes. As an example, temporal association rules may allow one to derive knowledge as “most patients presenting a symptom of chest pain overlapping nausea receive, within few days, a therapy with acetylsalicylic acid”. On the other side, approximate temporal functional dependencies provide knowledge at a higher abstraction level, as “in most cases, patients with the same symptoms are given the same drug (i.e. active principle), considering a time window of 10days”. Such kind of knowledge refers to a general relationship between some features of a patient, in this case symptoms and therapies: the relationship holds for any specific values of such features. Such a valuable kind of knowledge requires physicians to merge it with more specific knowledge, such as that one coming from temporal association rules, in the whole decision making process.

The main novelty aspects of this paper can be summarized as in the following, even with a specific reference to the preliminary work in [14], where the main focus was on the proposal of ATFDs and on some preliminary experiments on a reduced set of psychiatry data with some first prototypal algorithms:
                        
                           •
                           we discuss in detail the proposed approach for ATFDs and introduce completely new algorithms both for granularity-based temporal mining and for mining through sliding windows;

we present and discuss two important clinical domains, i.e. psychiatry and pharmacovigilance, where temporal data mining is highly required. As the mined temporal dependencies are sometime completely new and unexpected even to expert physicians, we discuss here some possible interpretations of the discovered knowledge;

the new experimental results, with a new and extended setting considering two different data sets from psychiatry and pharmacovigilance, consist of both a detailed performance analysis and an evaluation and discussion of the mined ATFDs from a clinical point of view.

In the following, we describe the background and the related work (Section 2) and discuss the two clinical domains we considered for temporal data mining, namely psychiatry and pharmacovigilance (Section 3); we introduce the concept of approximate temporal functional dependency (ATFD), providing some examples on the application scenario (Section 4); then we describe how to mine minimal ATFDs (Section 5) and deploy the proposed techniques in clinical domains; we describe the experimental results obtained by considering data in the two mentioned domains (Section 6), and finally (Section 7) we draw some conclusions and sketch out some possible directions for future research.

We recall here the definition of functional dependency (FD), and then introduce its extensions: approximate functional dependency (AFD) and temporal functional dependency (TFD). Such concepts will lead to the definition of approximate temporal functional dependency (ATFD) of Section 4, where ATFD inherits the properties both from AFD and from TFD.

The concept of functional dependency (FD) comes from the database theory and is defined as follows [15]:
                        Definition 2.1
                        Functional dependency


                        Let r be a relationship over the relational schema R: let 
                              X
                              ,
                              Y
                              ⊆
                              R
                            be attributes of R. We assert that r fulfills the functional dependency 
                              X
                              →
                              Y
                            (written as 
                              r
                              ⊨
                              X
                              →
                              Y
                           ) if the following condition holds: 
                              ∀
                              t
                              ,
                              t
                              ′
                              ∈
                              r
                              (
                              t
                              [
                              X
                              ]
                              =
                              t
                              ′
                              [
                              X
                              ]
                              ⇒
                              t
                              [
                              Y
                              ]
                              =
                              t
                              ′
                              [
                              Y
                              ]
                              )
                           
                        

Informally, for all the couples of tuples t and 
                              t
                              ′
                            showing the same value(s) on X, the corresponding value(s) on Y for those tuples are identical.

Moving closer to the main kind of temporal features we shall consider here, several kinds of temporal functional dependencies (TFDs) have been proposed in the literature, usually as temporal extensions of the widely known (atemporal) functional dependencies [16]. As an example, we may consider that patients affected by a common pathology p
                        1 may assume a common therapy t
                        1 during some month M
                        1, while in other month M
                        2 the same patients affected by the same pathology p
                        1 as above, do follow the another common therapy t
                        2.

Recently, Combi et al. proposed a framework for TFDs that subsumes and extends the considered previous proposals [7]. The proposed framework is based on a simple temporal relational data model based on the notion of temporal relation, i.e. a relation extended with a timestamping temporal attribute VT, representing the valid time temporal dimension, i.e. the time when the fact is true in the real world [17].

Two temporal views have been introduced: they allow one to join tuples that represent relevant cases of (temporal) evolution. On the base of the introduced data model, and leveraging the introduced temporal views, TFDs may be expressed by the syntax 
                           [
                           E
                           -
                           Exp
                           (
                           R
                           )
                           ,
                           t
                           -
                           Group
                           ]
                           X
                           →
                           Y
                         where 
                           E
                           -
                           Exp
                           (
                           R
                           )
                         is a relational expression on R, called evolution expression, 
                           t
                           -
                           Group
                         is a mapping 
                           N
                           →
                           
                              
                                 2
                              
                              
                                 N
                              
                           
                        , called temporal grouping, and 
                           X
                           →
                           Y
                         is a functional dependency.

As for the semantics, similar to the case of standard FDs, a TFD is a statement about admissible temporal relations on a temporal relation schema R with attributes 
                           U
                           ∪
                           {
                           VT
                           }
                        . A temporal relation r on the temporal relation schema R satisfies a TFD 
                        
                           [
                           E
                           -
                           Exp
                           (
                           R
                           )
                           ,
                           t
                           -
                           Group
                           ]
                           X
                           →
                           Y
                         if it is not possible that the relation obtained from r by applying the expression 
                           E
                           -
                           Exp
                           (
                           R
                           )
                         features two tuples 
                           t
                           ,
                           t
                           ′
                         such that (i) 
                           t
                           [
                           X
                           ]
                           =
                           t
                           ′
                           [
                           X
                           ]
                        , (ii) 
                           t
                           [
                           VT
                           ]
                         and 
                           t
                           ′
                           [
                           VT
                           ]
                         (and the valid times of their evolutions, if present) belong to the same temporal group, according to the mapping 
                           t
                           -
                           Group
                        , and (iii) 
                           t
                           [
                           Y
                           ]
                           ≠
                           t
                           ′
                           [
                           Y
                           ]
                        . In other words, FD 
                           X
                           →
                           Y
                         must be satisfied by each relation obtained from the evolution relation by selecting those tuples whose valid times belong to the same temporal group.

Temporal grouping enables us to group tuples together over a set of temporal granules, based on one temporal dimension. We focus here on the VT temporal dimension.

Four different classes of TFD have been identified in the following [7]:
                           
                              •
                              
                                 Pure temporally grouping 
                                 
                                    TFD
                                 : 
                                    E
                                    -
                                    Exp
                                    (
                                    R
                                    )
                                  returns the original temporal relation r. Rules of this class force the FD 
                                 
                                    X
                                    →
                                    Y
                                 , where 
                                    X
                                    ,
                                    Y
                                    ⊆
                                    U
                                 , to hold over all the maximal sets which include all the tuples whose VT belongs to the same temporal grouping.


                                 Pure temporally evolving 
                                 
                                    TFD
                                 : 
                                    E
                                    -
                                    Exp
                                    (
                                    R
                                    )
                                  collects all the tuples modelling the evolution of an object. No temporal grouping exists, that is, the temporal grouping collects all the tuples of r in one unique set.


                                 Temporally mixed 
                                 
                                    TFD
                                 : The expression 
                                    E
                                    -
                                    Exp
                                    (
                                    R
                                    )
                                  collects all the tuples modelling the evolution of the object. The temporal grouping is applied to the set of tuples generated by 
                                    E
                                    -
                                    Exp
                                    (
                                    R
                                    )
                                 .


                                 Temporally hybrid 
                                 
                                    TFD
                                 
                                 s: First, the evolution expression 
                                    E
                                    -
                                    Exp
                                    (
                                    R
                                    )
                                  selects those tuples of the given temporal relation that contribute to the modelling of the evolution of a real-world object (that is, it removes isolated tuples); then, temporal grouping is applied to the resulting set of tuples.

In the remainder of the paper, we shall focus only on pure temporally grouping TFDs.

The concept of approximate functional dependency (AFD) derives from the concept of plain FD. Given a relation r where a FD holds for most of the tuples in r, we may identify some tuples for which that FD does not hold. Consequently, we define some measurements over the error we make in considering the FD to hold on r. One measurement [8] is known as G
                        1 and considers the number of violating couples of tuples. Another measurement [8], known as G
                        2, considers the number of tuples which violate the functional dependency. The most common measurement [8], known as G
                        3, considers the minimum number of tuples in r to be deleted for the FD to hold. Formally, 
                           
                              
                                 G
                              
                              
                                 3
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           r
                           )
                           =
                           |
                           r
                           |
                           −
                           max
                           {
                           |
                           s
                           |
                           ∣
                           s
                           ⊆
                           r
                           ∧
                           s
                           ⊨
                           X
                           →
                           Y
                           }
                        
                     

The related scaled measurement g
                        3 is defined as 
                           
                              
                                 g
                              
                              
                                 3
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           r
                           )
                           =
                           
                              
                                 G
                              
                              
                                 3
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           r
                           )
                           /
                           |
                           r
                           |
                        
                     

We can now introduce here the definition of approximate functional dependency AFD as follows:
                           Definition 2.2
                           Approximate functional dependency


                           Let r be a relation over the relational schema R: let 
                                 X
                                 ,
                                 Y
                                 ⊆
                                 R
                               be attributes of R. Relation r fulfills an approximate functional dependency 
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               (written as 
                                 r
                                 ⊨
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              ) if 
                                 
                                    
                                       g
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 X
                                 →
                                 Y
                                 ,
                                 r
                                 )
                                 ≤
                                 ε
                              , where ε is the maximum acceptable error defined by the user.

Among the several AFDs that can be identified over a relation r, the minimal AFD is of particular interest, as many other AFDs can then be derived from the minimal one. We thus define the minimal AFD as follows:
                           Definition 2.3
                           Minimal AFD
                           


                           Given an AFD over r, we define 
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               to be minimal for r if 
                                 r
                                 ⊨
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               and 
                                 ∀
                                 X
                                 ′
                                 ⊂
                                 X
                               we have that 
                                 r
                                 ⊭
                                 X
                                 ′
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              .

In order to motivate and validate our approach, we consider two clinical domains: the first one refers to psychiatry, collecting data about contacts between patients and psychiatrists, psychologists, and social workers; the second one refers to pharmacovigilance, collecting data about drug administrations and adverse reactions.

The first application domain (see Section 3.3 for further examples) refers to the Verona Psychiatric Case Register (PCR). The Verona Health District serves about 460,000 inhabitants. The National Health Service in trust with the University of Verona offers a public Community-based Psychiatric Service (CPS), providing psychiatric care to mentally ill as well as psychological care and responses to social needs. Data about patients are collected in the information system PCR, which has recorded information about patients׳ accesses to this service since 1979. At the first contact with the psychiatric service, socio-demographic information, past psychiatric history, and clinical data are routinely collected for patients aged 14 and over. Recorded contacts with psychiatrists, psychologists, social workers and psychiatric nurses including home visits, telephone calls, and day cares. Data on some 28,700 patients and more than 1,500,000 psychiatric contacts have been recorded. Besides patients׳ personal data (e.g., birth information, health insurance card number, gender, nationality, and previous contacts), patients׳ medical record, and contact information (contact duration, involved professionals, referrals, contact type, and conclusions), PCR also records education, employment, professional status, type of accommodation, and marital status of patients.


                        PCR is used as a basis to evaluate the direct management costs for groups of patients, and to monitor the effects coming from changes in resources, organization, and needs. The clinical purposes include monitoring of patients to plan future contacts at regular time intervals, and providing clinicians with reports about admissions and contacts for every patient in a given time period.


                        PCR stores several temporal data: a patient׳s contact is temporally qualified by its occurrence timestamp, while other personal information are qualified by their respective valid time. These temporal data can then be used by epidemiologists, e.g. to identify the number of contacts in different time periods with respect to different factors such as age, diagnosis.

Pharmacovigilance (PhV) collects, analyzes, and prevents adverse reactions induced by drugs (ADR) [18]. In fact, also because of the limitations of pre-marketing trials (e.g. short duration of the study, highly selected test population), adverse reactions often go undetected, and become evident when the drug is put on the market, only [19]. Therefore a continuous monitoring of the effects is needed.

The spontaneous reporting of ADRs identifies unexpected reactions and informs the regulating authority about them. This practice is valuable, provides early warnings, and requires limited economic and organizational resources [20]. It also has the advantage of covering every drug on the market and every category of patient.


                        PhV considers possible relationships between one or more adverse reactions and one or more drugs, mainly focusing on unknown or completely undocumented relationships. Reports suggest a cause-effect link among ADRs and drugs: the link can be classified as “suspected” or “concomitant’. Reports are submitted by a physician, a chemists, or a private citizen.

Each report includes patient׳s information (age, nationality, gender, weight, outcome of reactions, and so on), drug(s) involved in the suspected reaction(s) (identified by their Anatomical Therapeutic Chemical – ATC – classification, brand name, dosage), and the description of the occurred adverse reaction(s) encoded by means of the MedDRA classification [21]: MedDRA is a standard medical terminology used to classify adverse event information associated with the use of bio-pharmaceuticals and other medical products (e.g. medical devices and vaccines).

Temporal data refer to entry date, drug name, exposure period, and adverse reaction. These temporal data are used to investigate any cause-effect relationship among drugs and reaction(s) in different time periods, or according to the time frame of the exposure.

Throughout the paper we will refer to examples from the Verona Psychiatric Case Register (PCR). Table 1
                         graphically depicts a simplified excerpt of database table Contact: VT (valid time, i.e., the date of the contact), ContactNumber (internal identifier of the contact), Patient (patient׳s name), Duration (of the contact), Area (location of the patient at contact time), and Professional (name of the operator responsible of the contact).

We can start making some comments. Generally, one Patient refers to the same Professional: but this may not be always true. In the example of Table 1, we have Professional=“Mike” for all the tuples but Tuple#=2 and Tuple#=6. Thus, FD 
                        
                           Patient
                           →
                           Professional
                         does not hold: that FD holds if we delete those two tuples out of the six tuples we have in Table 1. Consequently, according to the measurement of Definition 2.2, 
                           
                              
                                 G
                              
                              
                                 3
                              
                           
                           (
                           Patient
                           →
                           Professional
                           ,
                           Contact
                           )
                           =
                           2
                        .

Moreover, AFD 
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.5
                              
                           
                           Professional
                         holds because 
                           
                              
                                 g
                              
                              
                                 3
                              
                           
                           (
                           Patient
                           →
                           Professional
                           ,
                           Contact
                           )
                           ≤
                           0.5
                        . Thus, accepting an error of 0.5 (50% of error), we can assert the AFD 
                        
                           Patient
                           →
                           Professional
                        . Instead, the AFD 
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.1
                              
                           
                           Professional
                         does not hold, because 
                           
                              
                                 g
                              
                              
                                 3
                              
                           
                           (
                           Patient
                           →
                           Professional
                           ,
                           Contact
                           )
                           >
                           0.1
                        .

Obviously, the plain FD 
                        
                           X
                           →
                           Y
                         equals the AFD 
                        
                           X
                           
                              
                                 →
                              
                              
                                 0.0
                              
                           
                           Y
                        , where 
                           
                              
                                 g
                              
                              
                                 3
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           r
                           )
                           =
                           0.0
                        .

Besides plain AFDs, clinicians could be interested in discovering some temporal properties, relevant even from the clinical point of view. For example, according to the content of Table 1, it could be important to discover that some (approximate) dependencies hold month by month. The dependency from Patient to Duration holds month by month and it could be related to seasonal conditions influencing the overall state of the patient and requiring different durations of the contact. On the other hand, further dependencies could be observed when corresponding tuples are within a fixed time span. For example, an approximate dependency holds from Patient to Duration, considering a time span of three months (i.e., by deleting Tuple#=2 and Tuple#=6): such an approximate dependency could be related to the fact that the same patient usually has contacts of the same duration within some given time span, as the possible changes of a psychiatric state are slow with respect to the frequency of the contacts. As we shall see in the following sections, such dependencies require to group data in different ways, either according to non-overlapping time granules or according to (overlapping) time windows. We observe here that discovering this kind of temporal dependency over clinical data could help physicians to have a better and deeper understanding and management of some temporal behaviors of their patients.

Moving from the definitions of FD, TFD, and AFD, we now introduce the concept of ATFD. In the following, we consider the basic temporal extension of the relational model proposed in [7]: we consider relations of a generic relational schema R with attributes 
                        U
                        ∪
                        {
                        VT
                        }
                     , where the set U is that of atemporal attributes, while VT represents the valid time. Moreover, according the taxonomy proposed in [7] and described in Section 2, we consider here pure temporal grouping TFDs of the form 
                        [
                        r
                        ,
                        t
                        -
                        Group
                        ]
                        X
                        →
                        Y
                     , where 
                        t
                        -
                        Group
                      consists only of granularity (Gran) or sliding window (SW) grouping:
                        
                           1.
                           Grouping on granules (granularity grouping, or Gran grouping): A temporal granularity is a partition of a temporal domain in indivisible non-overlapping groups, i.e., granules, of time points: minutes, hours, days, months, years as well as working days are granularities 
                              [22].

Two tuples 
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              ∈
                              r
                            belong to the same temporal group Gran(i) iff 
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              [
                              VT
                              ]
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              [
                              VT
                              ]
                              ∈
                              Gran
                              (
                              i
                              )
                            where Gran(i) is the ith granule of granularity Gran.

Grouping on sliding windows (SW): A sliding window
                                 1
                              
                              
                                 1
                                 Actually a sliding window comes with three parameters, granularity, beginning timestamp, and size, as the number of time points inside the window.
                               
                              
                                 SW
                                 (
                                 i
                                 ,
                                 k
                                 )
                               includes all the time points in interval 
                                 [
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 ]
                              . Thus, once we fix the length of the SW over relation r (i.e. k in the example), every SW over r will feature that length, and will - at most - include k elements (if relation r has tuples for all the time points of interval 
                                 [
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 ]
                              ).

Two tuples 
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              ∈
                              r
                            belong to the same sliding window 
                              SW
                              (
                              i
                              ,
                              k
                              )
                            iff 
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              [
                              VT
                              ]
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              [
                              VT
                              ]
                              ∈
                              [
                              i
                              …
                              i
                              +
                              k
                              −
                              1
                              ]
                           .

Before introducing ATFD, let us consider a new error measure, namely G
                     4, we shall use for approximate temporal functional dependencies. G
                     4 considers the minimum number of tuples in r which must be modified for the plain TFD to hold on all the tuples of r. In the following, if looking for an FD such as 
                        X
                        →
                        Y
                     , we assume to modify only values for the Y attributes. The ε parameter is user-defined and it states the maximum error acceptable by that user: 
                        
                           
                              
                                 
                                    G
                                 
                                 
                                    4
                                 
                              
                              (
                              [
                              r
                              ,
                              t
                              -
                              Group
                              ]
                              X
                              →
                              Y
                              ,
                              r
                              )
                              =
                              min
                              {
                              |
                              s
                              |
                              ∣
                              s
                              ⊆
                              r
                              ,
                              (
                              (
                              r
                              −
                              s
                              )
                              ∪
                              w
                              )
                              ⊨
                              [
                              r
                              ,
                              t
                              -
                              Group
                              ]
                              X
                              →
                              Y
                              }
                           
                        
                     where the set w is the minimal one for which the following formula holds 
                        
                           
                              ∀
                              t
                              ∈
                              s
                              
                              (
                              ∃
                              t
                              ′
                              ∈
                              w
                              (
                              t
                              [
                              U
                              −
                              Y
                              ]
                              =
                              t
                              ′
                              [
                              U
                              −
                              Y
                              ]
                              ∧
                              t
                              [
                              VT
                              ]
                              =
                              t
                              ′
                              [
                              VT
                              ]
                              )
                              )
                           
                        
                     
                  

The related scaled measurement g
                     4 is defined as 
                        
                           
                              g
                           
                           
                              4
                           
                        
                        (
                        X
                        →
                        Y
                        ,
                        r
                        )
                        =
                        
                           
                              G
                           
                           
                              4
                           
                        
                        (
                        X
                        →
                        Y
                        ,
                        r
                        )
                        /
                        |
                        r
                        |
                     
                  

We anticipate here that, if we consider the Gran grouping, the two measurements g
                     3 and g
                     4 do not differ. However, as we shall describe in the following, g
                     3 and g
                     4 may differ when the SW grouping is considered.

We define the ATFD with granularity grouping as
                           Definition 4.3
                           
                              ATFD with Gran grouping


                           Let r be a relation over the relational schema R with attributes 
                                 U
                                 ∪
                                 {
                                 VT
                                 }
                              : let 
                                 X
                                 ,
                                 Y
                                 ⊆
                                 U
                               be attributes of R. Let Gran be the reference granularity. Relation r fulfills an approximate temporal functional dependency (written as 
                                 r
                                 ⊨
                                 [
                                 r
                                 ,
                                 Gran
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              ) iff 
                                 
                                    
                                       g
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 [
                                 r
                                 ,
                                 Gran
                                 ]
                                 X
                                 →
                                 Y
                                 ,
                                 r
                                 )
                                 ≤
                                 ε
                              .

That is, the percentage of tuples in the entire relation r to be deleted for a ATFD to hold on all the tuples of r is less than ε; tuples of r are then grouped according to the granule of Gran their VT value belongs to, to evaluate the considered ATFD. We recall that the count of tuples in r to be deleted refers to the entire relation r, and not to the group – and one tuple may belong to one group only, if we use a Gran grouping.

As an example, let us consider the fragment of the database table Contact, as depicted by Table 1, and Definition 4.3 based on the measurement G
                        3.


                        ATFD 
                        
                           [
                           Contact
                           ,
                           Year
                           (
                           i
                           )
                           ]
                         
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.4
                              
                           
                           Duration
                         holds, as tuples for which the rule does not hold, i.e. the tuples Tuple#=3 or Tuple#=6 in the specific example, and which need to be deleted for the rule to hold on all the tuples are less than the 40% in the entire table (Table 1).

In fact, if we group the tuples according to granularity Year granularity, we can identify groups 
                           Year
                           (
                           2007
                           )
                        , 
                           Year
                           (
                           2008
                           )
                        . For the first group (
                           Year
                           (
                           2007
                           )
                        ), two tuples (Tuple#=1 and Tuple#=2) out of three in the group confirm the FD 
                        
                           Patient
                           →
                           Duration
                         for a Duration of 10. For the second group (
                           Year
                           (
                           2008
                           )
                        ), two tuples (Tuple#=4 and Tuple#=5) out of three in the group confirm the FD 
                        
                           Patient
                           →
                           Duration
                         for a Duration of 35. As a consequence, the overall error is 2/6, or 
                           1
                           /
                           3
                        , and it is smaller than 40%, and the required ATFD 
                        
                           [
                           Contact
                           ,
                           Year
                           (
                           i
                           )
                           ]
                           
                           Patient
                           
                              
                                 →
                              
                              
                                 0.40
                              
                           
                           Duration
                         holds on the fragment of Table 1.

If we again consider the fragment of Table 1 and group tuples according to granularity Year, as we did before, we can check ATFD 
                        
                           [
                           Contact
                           ,
                           Year
                           (
                           i
                           )
                           ]
                           
                           Patient
                           
                              
                                 →
                              
                              
                                 0.1
                              
                           
                           Area
                        , accepting an error of 10%. While FD 
                        
                           Patient
                           →
                           Area
                         holds on all the tuples of group of 
                           Year
                           (
                           2007
                           )
                         (where Area=“North”), inside the group of 
                           Year
                           (
                           2008
                           )
                         the FD (where Area=“South”) fails on one tuple (Tuple#=5) out of the three we have. The overall error is 1/6 or 16.66%, which is greater that the allowed 10%. Thus, ATFD 
                        
                           [
                           Contact
                           ,
                           Year
                           (
                           i
                           )
                           ]
                           
                           Patient
                           
                              
                                 →
                              
                              
                                 0.1
                              
                           
                           Area
                         with an error of 0.1 does not hold on the fragment of Table 1.

As for plain AFD, we can introduce the concept of minimality also for ATFD.
                           Definition 4.4
                           Minimal ATFD with Gran grouping


                           An ATFD 
                              
                                 [
                                 r
                                 ,
                                 Gran
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               is said to be minimal for r iff 
                                 r
                                 ⊨
                                 [
                                 r
                                 ,
                                 Gran
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               and 
                                 ∀
                                 X
                                 ′
                                 ⊂
                                 X
                               we have that 
                                 r
                                 ⊭
                                 [
                                 r
                                 ,
                                 Gran
                                 ]
                                 X
                                 ′
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              .

We define the ATFD with sliding window (SW) grouping as follows:
                           Definition 4.5
                           
                              ATFD with SW grouping


                           Let r be a relation over the relational schema R with attributes 
                                 U
                                 ∪
                                 {
                                 VT
                                 }
                              : let 
                                 X
                                 ,
                                 Y
                                 ⊆
                                 U
                               be attributes of R. Let 
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                               be a sliding window (SW) of length k. The relation r fulfills an approximate temporal functional dependency (written as 
                                 r
                                 ⊨
                                 [
                                 r
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              ) iff 
                                 
                                    
                                       g
                                    
                                    
                                       4
                                    
                                 
                                 (
                                 [
                                 r
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                                 ]
                                 X
                                 →
                                 Y
                                 ,
                                 r
                                 )
                                 ≤
                                 ε
                              .

A similar definition can be derived from Definition 4.5 by replacing g
                        4 with g
                        3, as we shall discuss in Section 4.3.

We consider as many SWs as possible, every SW sizing k elements: thus, the first considered sliding window is 
                           i
                           …
                           i
                           +
                           k
                           −
                           1
                        , the second considered sliding window is 
                           i
                           +
                           1
                           …
                           i
                           +
                           k
                        , the third considered sliding window is 
                           i
                           +
                           2
                           …
                           i
                           +
                           k
                           +
                           1
                        , and so on. Every SW sets up a group (or chain) over which the ATFD is checked. The ATFD must hold, with an acceptable amount of error smaller than ε, over the entire database: we recall that, if we delete (as for measurement g
                        3) or modify (as for the measurement g
                        4) a tuple inside a SW, that tuple will remain deleted or modified in all the SWs (either preceding or following the current SW) which include that tuple.

As an example, let us consider the fragment of the database table Contact, as depicted by Table 2
                        , where the attribute VT refers to the valid time of the tuple at the day granularity. If we fix the length of the SW to 5, i.e. every sliding window includes a group (or chain) of five days, the first SW will formally include time points {2009-04-11, 2009-04-12, 2009-04-13, 2009-04-14, 2009-04-15}: since relation r in Table 2 has tuples for VT=2009-04-11 or VT=2009-04-14 or VT=2009-04-15, the first SW includes 3 tuples having VT values 2009-04-11, 2009-04-14, 2009-04-15. Thus, the following 6 SWs consider all the possible VT value groups {2009-04-11, 2009-04-14, 2009-04-15}, {2009-04-14, 2009-04-15}, {2009-04-15}, {2009-04-26, 2009-04-27, 2009-04-28}, {2009-04-27, 2009-04-28}, and {2009-04-28}.


                        ATFD 
                        
                           [
                           Contact
                           ,
                           {
                           i
                           …
                           i
                           +
                           4
                           }
                           ]
                         
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.4
                              
                           
                           Duration
                         holds. Indeed, tuples for which the dependency does not hold, i.e. Tuple# 3 and Tuple# 6 in the specific example, are those which need to be modified according to the measurement g
                        4 of Definition 4.5. More precisely, the value of attribute Duration for Tuple# 3 has to be changed to 20; the value of attribute Duration for Tuple# 6 has to be changed to 40. Should we modify these two tuples, we shall obtain a plain TFD, holding on all the six SWs. The tuples we modified are less then the 40% of the entire fragment (Table 2), thus proving that the ATFD holds even with a threshold ε of 2/6 (i.e. 1/3), which is smaller than 0.4.

If we again consider the fragment of Table 2 and group tuples according to the same six SWs as we did before, we can now check the ATFD 
                        
                           [
                           Contact
                           ,
                           {
                           i
                           …
                           i
                           +
                           4
                           }
                           ]
                         
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.1
                              
                           
                           Area
                        , accepting an error of 10%. The TFD fails on one tuple (Tuple# 5, i.e. 1/6 of the entire relation), which needs to be modified according to measurement g
                        4 of Definition 4.5: thus, the ATFD does not hold with a ε of 0.1.

Analogous to Definition 4.4, we can introduce the concept of minimality also for ATFD with SW grouping.
                           Definition 4.6
                           Minimal ATFD with SW grouping


                           Given an ATFD over 
                                 [
                                 r
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                                 ]
                              , we define 
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               to be minimal for r iff 
                                 r
                                 ⊨
                                 [
                                 r
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               and ∀
                                 X
                                 ′
                                 ⊂
                                 X
                               we have that 
                                 r
                                 ⊭
                                 [
                                 r
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 k
                                 −
                                 1
                                 }
                                 ]
                                 X
                                 ′
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              .

When using a SW grouping, and only when using this grouping, measurements g
                        3 and g
                        4 (and the related G
                        3 and G
                        4) may differ: on the other side, when using granularity grouping, measurements g
                        3 and g
                        4 do not differ. In fact, in the SW grouping, according to the measurement g
                        3 we delete one or more tuples: this may modify the temporal relationships among the tuples, the number of tuples inside every SW, and – occasionally – the total number of SWs to consider. Instead, according to the measurement g
                        4, we modify one or more tuples, leaving unchanged the temporal relationships among tuples, the number of tuples inside every SW, and the total number of SWs to consider.

As an example, let us consider the fragment of Contact in Table 3
                        , assuming a length 2 for the SW (i.e.we consider 
                           i
                           …
                           i
                           +
                           1
                        ). We shall then have the following SWs, {2010-06-11, 2010-06-12}, {2010-06-12, 2010-06-13}, {2010-06-13, 2010-06-14}, {2010-06-14, 2010-06-15}, and {2010-06-15}, for a grand total of 5 SWs. We are interested in the ATFD 
                        
                           [
                           Contact
                           ,
                           {
                           i
                           …
                           i
                           +
                           1
                           }
                           ]
                         
                        
                           Patient
                           
                              
                                 →
                              
                              
                                 0.25
                              
                           
                           Professional
                        .

For the measurement G
                        3, the FD 
                        
                           Patient
                           →
                           Professional
                         holds in the SWs {2010-06-11, 2010-06-12}, {2010-06-13, 2010-06-14}, {2010-06-14, 2010-06-15}, {2010-06-15}: the FD does not hold in the SW {2010-06-12, 2010-06-13}. Consequently, if we delete from Table 3 
                        Tuple# 3, the remaining SWs are {2010-06-11, 2010-06-12}, {2010-06-12}, {2010-06-14, 2010-06-15}, {2010-06-15}. The FD holds on all the SWs remaining after the deletion of Tuple# 3. Thus, the measurement G
                        3 is 1, as we only deleted one tuple (Tuple# 3), obtaining the ATFD with an error of 
                           1
                           /
                           5
                         (i.e. 20.00%), which is smaller than the maximum acceptable error of 0.25. The ATFD holds, and the measurement G
                        3 returns 
                           
                              
                                 G
                              
                              
                                 3
                              
                           
                           (
                           [
                           Contact
                           ,
                           {
                           i
                           …
                           i
                           +
                           1
                           }
                           ]
                           Patient
                           →
                           Op
                           ,
                           Contact
                           )
                           =
                           1
                        .

For the measurement G
                        4, if we update in Table 3 
                        Tuple# 1 and Tuple# 2, setting the value of the attribute Professional to “Romina”, the ATFD will hold in the SWs {2010-06-11, 2010-06-12}, {2010-06-12, 2010-06-13}, {2010-06-13, 2010-06-14}, {2010-06-14, 2010-06-15], and {2010-06-15}, that is in 5 out of the 5 SWs. Thus, the measurement G
                        4 is 2, as we modified two tuples (Tuple# 1 and Tuple# 2) to obtain the ATFD. Changing one tuple only, whatever the tuple is, does not suffice to obtain the required TFD: 
                           
                              
                                 
                                    
                                       G
                                    
                                    
                                       4
                                    
                                 
                                 (
                                 [
                                 Contact
                                 ,
                                 {
                                 i
                                 …
                                 i
                                 +
                                 1
                                 }
                                 ]
                                 Patient
                                 →
                                 Op
                                 ,
                                 Contact
                                 )
                                 =
                                 2
                              
                           
                        
                     

We obtain the ATFD with an error of 
                           2
                           /
                           5
                         (i.e. 40%), which is greater than the maximum acceptable error of 0.25: as a consequence, according to G
                        4 the ATFD does not hold with the required threshold of 25%.

We now consider how to mine minimal ATFDs both with granularity and sliding window groupings. While mining Gran grouping ATFDs can be mapped to mine corresponding suitable AFDs, mining SW grouping ATFDs requires ad hoc algorithms. The approach we propose here differs from the one in [14], where we performed both Gran and SW grouping ATFDs through an AFD analysis by the TANE 
                     [10] tool.

Let us now consider how we can reduce the evaluation of minimal Granularity-based ATFDs to the evaluation of corresponding minimal AFDs: such approach allows us to use well-known algorithms for AFD and to characterize the complexity of mining minimal ATFD. In general, we proceed in three different steps: in the first one (PreAFD), the given relation is pre-processed to represent, by a suitable attribute, the granule/window each tuple belongs to. Next, we have an (atemporal) relation to consider for the usual AFD extraction (AFD phase). Finally, a suitable post-processing phase (PostAFD) is needed to properly identify and represent the mined ATFDs.

As the temporal grouping of a granularity Gran is a bijective function, we may conclude that the set E of tuples not satisfying the considered granularity-based ATFD, may be partitioned in subsets 
                           
                              
                                 E
                              
                              
                                 G
                                 (
                                 i
                                 )
                              
                           
                        , where 
                           
                              
                                 E
                              
                              
                                 G
                                 (
                                 i
                                 )
                              
                           
                         is the set of tuples of E having their valid time contained in the granule G(i). Thus, it holds 
                           |
                           E
                           |
                           =
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           →
                           Y
                           ,
                           r
                           )
                        .

Given an instance r with schema 
                           R
                           =
                           U
                           ∪
                           {
                           VT
                           }
                        , a granularity Gran and a threshold ε, the preprocessing phase (see Algorithm 1 PreAFD-G(r,G)) builds up the relation preAFD with schema 
                           R
                           ′
                           =
                           U
                           ∪
                           {
                           codGran
                           }
                        : the attribute VT is replaced by the attribute codGran. The tuples of preAFD have the same value for codGran if and only if they belong to the same temporal granule of the given granularity Gran. More formally, for each tuple t of r, we apply the function 
                           f
                           (
                           Gran
                           ,
                           t
                           )
                           :
                           r
                           ↦
                           preAFD
                        , where 
                           f
                           (
                           t
                           )
                           [
                           U
                           ]
                           =
                           t
                           [
                           U
                           ]
                         and 
                           f
                           (
                           t
                           )
                           [
                           codGran
                           ]
                           =
                           i
                        , with 
                           t
                           [
                           VT
                           ]
                           ∈
                           Gran
                           (
                           i
                           )
                        . Algorithm 1 shows the pseudo-code of the preprocessing phase, having complexity 
                           O
                           (
                           |
                           r
                           |
                           )
                        . 
                           Algorithm 1
                           PreAFD-G(r,G). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: r,G
                                             
                                          
                                          
                                             
                                                Output: preAFD
                                             
                                          
                                          
                                             
                                                1
                                                
                                                
                                                   preAFD
                                                   ←
                                                   ∅
                                                ; /⁎ preAFD 
                                                has schema 
                                                
                                                   U
                                                   ∪
                                                   codGran
                                                 ⁎/
                                          
                                          
                                             
                                                2
                                                
                                                forall
                                                
                                                the 
                                                
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ∈
                                                   r
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            3
                                                         
                                                      
                                                      
                                                         
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            5
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               t
                                                               ′
                                                               [
                                                               U
                                                               ]
                                                               ←
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               U
                                                               ]
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               t
                                                               ′
                                                               [
                                                               codGran
                                                               ]
                                                               ←
                                                               f
                                                               (
                                                               G
                                                               ,
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               )
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               preAFD
                                                               ←
                                                               preAFD
                                                               ∪
                                                               t
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                6
                                                
                                                end forall
                                             
                                          
                                          
                                             
                                                7
                                                
                                                return 
                                                preAFD
                                             
                                          
                                       
                                    
                                 
                              
                           

On the obtained relation preAFD, the next phase derives the minimal AFDs, according to the threshold ε. Let outAFD be the set of the found AFDs. As discussed in [10], the complexity of the corresponding algorithm is 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 |
                                 R
                                 |
                              
                           
                           )
                        , since the number of attributes of preAFD is that of R.

The error tuples of the ATFD 
                        
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           →
                           Y
                         are, through the correspondence function f, the same as those of the AFD 
                        
                           codGran
                           ,
                           X
                           →
                           Y
                         on preAFD. As preAFD and r have the same cardinality (f is total and injective), we have 
                           
                              
                                 g
                              
                              
                                 4
                              
                           
                           (
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           →
                           Y
                           ,
                           r
                           )
                           =
                           
                              
                                 g
                              
                              
                                 4
                              
                           
                           (
                           codGran
                           ,
                           X
                           →
                           Y
                           ,
                           preAFD
                           )
                        . Indeed, for each Gran(i) for the set 
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           =
                           {
                           t
                           [
                           U
                           ]
                           |
                           t
                           ∈
                           r
                           ∧
                           t
                           [
                           VT
                           ]
                           ∈
                           Gran
                           (
                           i
                           )
                           }
                         we can compute 
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           )
                         and, by definition, 
                           
                              
                                 ∑
                              
                              
                                 i
                              
                           
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           )
                           =
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           →
                           Y
                           ,
                           r
                           )
                        . According to the definition of f(t), we have that the set 
                           
                              
                                 r
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           =
                           {
                           t
                           ′
                           [
                           U
                           ]
                           |
                           t
                           ′
                           ∈
                           preAFD
                           ∧
                           t
                           ′
                           [
                           codGran
                           ]
                           =
                           i
                           }
                           =
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                        ; thus 
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           )
                           =
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           )
                         and it holds 
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           codGran
                           ,
                           X
                           →
                           Y
                           ,
                           preAFD
                           )
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                              
                           
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           )
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                              
                           
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           X
                           →
                           Y
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           )
                           =
                           
                              
                                 G
                              
                              
                                 4
                              
                           
                           (
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           →
                           Y
                           ,
                           r
                           )
                        .

As 
                           |
                           r
                           |
                           =
                           |
                           preAFD
                           |
                        , we may conclude that 
                           
                              
                                 g
                              
                              
                                 4
                              
                           
                           (
                           [
                           r
                           ,
                           G
                           ]
                           X
                           →
                           Y
                           ,
                           r
                           )
                           =
                           
                              
                                 g
                              
                              
                                 4
                              
                           
                           (
                           codGran
                           ,
                           X
                           →
                           Y
                           ,
                           preAFD
                           )
                        .

The last phase (post-processing) maps the derived AFDs into the minimal ATFDs holding in r. In Algorithm 2 
                        PostAFD-G maps the AFDs of the form 
                           codGran
                           ,
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         into the ATFDs of the form 
                           [
                           r
                           ,
                           Gran
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                        . The complexity of the algorithm is 
                           O
                           (
                           |
                           outAFD
                           |
                           )
                        : as the number (
                           |
                           outAFD
                           |
                        ) is of order 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 |
                                 R
                                 |
                              
                           
                           )
                        , Algorithm 2 has complexity 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 |
                                 R
                                 |
                              
                           
                           )
                        . 
                           Algorithm 2
                           PostAFD-G(outAFD). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: outAFD
                                             
                                          
                                          
                                             
                                                Output: postAFD
                                             
                                          
                                          
                                             
                                                1
                                                
                                                
                                                   postAFD
                                                   ←
                                                   ∅
                                                ;/⁎ postAFD 
                                                is a set of
                                                
                                                ATFD
                                                s of the form
                                                
                                                
                                                   codGran
                                                   ,
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                 ⁎/
                                          
                                          
                                             
                                                2
                                                
                                                forall the 
                                                
                                                   codGran
                                                   ,
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                   ∈
                                                   outAFD
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                3
                                                
                                                
                                                   |
                                                   
                                                   postAFD
                                                   =
                                                   postAFD
                                                   ∪
                                                   (
                                                   [
                                                   r
                                                   ,
                                                   Gran
                                                   ]
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                4
                                                
                                                end forall
                                             
                                          
                                          
                                             
                                                5
                                                
                                                return 
                                                postAFD
                                             
                                          
                                       
                                    
                                 
                              
                           

It is straightforward to observe that these three phases allow us to derive all the minimal ATFDs with grouping based on granularity Gran, and holding in r with threshold ε.

Finally, a strategy (see Algorithm 3) is needed to evaluate how to mine a relation r according to a set of temporal granularities. Let us focus on 
                           (
                           GranSet
                           ,
                           ≺
                           )
                        , a set of continuous and total granularities with a total order according to relation FinerThan 
                        [22]. Informally, relation 
                           FinerThan
                           (
                           
                              
                                 Gran
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Gran
                              
                              
                                 2
                              
                           
                           )
                         holds if each granule of granularity Gran
                        1 is contained in a granule of Gran
                        2. If 
                           FinerThan
                           (
                           
                              
                                 Gran
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Gran
                              
                              
                                 2
                              
                           
                           )
                        , then
                           
                              1.
                              
                                 
                                    r
                                    ⊨
                                    [
                                    r
                                    ,
                                    
                                       
                                          Gran
                                       
                                       
                                          2
                                       
                                    
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                    ⇒
                                    r
                                    ⊨
                                    [
                                    r
                                    ,
                                    
                                       
                                          Gran
                                       
                                       
                                          1
                                       
                                    
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                 .

(Pruning condition) 
                                    r
                                    ⊭
                                    [
                                    r
                                    ,
                                    
                                       
                                          Gran
                                       
                                       
                                          1
                                       
                                    
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                    ⇒
                                    r
                                    ⊭
                                    [
                                    r
                                    ,
                                    
                                       
                                          Gran
                                       
                                       
                                          2
                                       
                                    
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                 .

In Algorithm 3 
                        StrategyG(r, 
                           GranSet
                        ) starts to mine, according to order ≺, the ATFDs from the minimal (finest) granularity to the coarsest one in 
                           (
                           GranSet
                           ,
                           ≺
                           )
                        . In mining the ATFDs with coarser granularity, we shall find those ATFDs with antecedent 
                           X
                           ′
                           ⊇
                           X
                        , where X is the antecedent of a ATFD at a finer granularity. If there is no ATFD at granularity Gran
                        
                           i
                        , for the pruning condition no ATFD will be mined at any granularity Gran(j) such that 
                           Gran
                           (
                           i
                           )
                           ≺
                           Gran
                           (
                           j
                           )
                        . In Algorithm 3 
                        StrategyG has complexity 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 |
                                 R
                                 |
                              
                           
                           )
                        , since the three phases PreAFD-AFD-PostAFD are executed at most 
                           |
                           GranSet
                           |
                         times.
                           Algorithm 3
                           StrategyG(r, 
                                 GranSet
                              ,ε). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                   r
                                                   ,
                                                   GranSet
                                                   ,
                                                   ε
                                                
                                             
                                          
                                          
                                             
                                                Output: 
                                                   ATFD
                                                   s
                                                
                                             
                                          
                                          
                                             
                                                1
                                                
                                                
                                                   currGran
                                                   ←
                                                   inf
                                                   {
                                                   
                                                      
                                                         Gran
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ∈
                                                   GranSet
                                                   }
                                                ;
                                          
                                          
                                             
                                                2
                                                
                                                
                                                   ATFD
                                                   s
                                                   ←
                                                   ∅
                                                ;
                                          
                                          
                                             
                                                3
                                                
                                                while 
                                                
                                                   currGran
                                                   ≠
                                                   ∅
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            5
                                                         
                                                      
                                                      
                                                         
                                                            6
                                                         
                                                      
                                                      
                                                         
                                                            7
                                                         
                                                      
                                                      
                                                         
                                                            8
                                                         
                                                      
                                                      
                                                         
                                                            9
                                                         
                                                      
                                                      
                                                         
                                                            10
                                                         
                                                      
                                                      
                                                         
                                                            11
                                                         
                                                      
                                                      
                                                         
                                                            12
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               ATFD
                                                               ←
                                                               {
                                                               [
                                                               r
                                                               ,
                                                               currGran
                                                               ]
                                                               X
                                                               
                                                                  
                                                                     →
                                                                  
                                                                  
                                                                     ε
                                                                  
                                                               
                                                               Y
                                                               
                                                               found
                                                               
                                                               in
                                                               
                                                               r
                                                               
                                                               executing
                                                               
                                                               PreAFD
                                                               -
                                                               G
                                                               ,
                                                               
                                                               AFD
                                                               ,
                                                               
                                                               and
                                                               
                                                               PostAFD
                                                               -
                                                               G
                                                               }
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               ATFD
                                                               =
                                                               ∅
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               return
                                                               
                                                               ATFD
                                                               s
                                                            
                                                         
                                                         
                                                            
                                                               else
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           ATFD
                                                                           s
                                                                           ←
                                                                           ATFD
                                                                           s
                                                                           ∪
                                                                           ATFD
                                                                           ;
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           GranSet
                                                                           ←
                                                                           GranSet
                                                                           -
                                                                           currGran
                                                                           ;
                                                                           
                                                                           /
                                                                           ⁎
                                                                           
                                                                           ATFD
                                                                           s
                                                                           
                                                                           
                                                                              is the set of all minimal
                                                                           
                                                                           
                                                                           ATFD
                                                                           
                                                                              s
                                                                           
                                                                           
                                                                           ⁎
                                                                           /
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           ;
                                                                           
                                                                           /
                                                                           ⁎
                                                                           [
                                                                           r
                                                                           ,
                                                                           
                                                                              
                                                                                 Gran
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           ]
                                                                           X
                                                                           
                                                                              
                                                                                 →
                                                                              
                                                                              
                                                                                 ε
                                                                              
                                                                           
                                                                           Y
                                                                           
                                                                           
                                                                              valid in
                                                                           
                                                                           
                                                                           r
                                                                           
                                                                           for
                                                                           
                                                                           granularities
                                                                           
                                                                           ∈
                                                                           
                                                                              GranSet
                                                                           
                                                                           
                                                                           currGran
                                                                           ←
                                                                           inf
                                                                           {
                                                                           
                                                                              
                                                                                 Gran
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           ∈
                                                                           GranSet
                                                                           }
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                13
                                                
                                                end while
                                             
                                          
                                          
                                             
                                                14
                                                
                                                return 
                                                
                                                   ATFD
                                                   s
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

For SW grouping, in [14] we adopted an approach in 4 phases: PreAFD-G, AFD, PostAFD-G, and StrategyG. We introduce here a novel approach for SW-based analysis, which does not need any PreAFD and PostAFD step. In the following we will focus on G
                        3 and g
                        3 error measures.

We aim at verifying whether the ATFD 
                        
                           [
                           R
                           ,
                           t
                           -
                           Group
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over an instance r of a temporal relational schema 
                           R
                           (
                           U
                           ,
                           VT
                           )
                        . First, we define the relation 
                           ValueCount
                           (
                           r
                           ,
                           v
                           )
                           =
                           {
                           (
                           y
                           ,
                         
                        
                           vt
                           ,
                           c
                           )
                           |
                           c
                           =
                           |
                           {
                           t
                           |
                           t
                           ∈
                           r
                           ∧
                           t
                           [
                           VT
                           ]
                           =
                           vt
                           ∧
                           t
                           [
                           X
                           ]
                           =
                           v
                           ∧
                           t
                           [
                           Y
                           ]
                           =
                           y
                           }
                           |
                           }
                        , which, given the instance r of the schema R and a tuple v of values for attributes X, returns triples 
                           (
                           y
                           ,
                           vt
                           ,
                           c
                           )
                        . A triple 
                           (
                           y
                           ,
                           vt
                           ,
                           c
                           )
                         belongs to 
                           ValueCount
                           (
                           r
                           ,
                           v
                           )
                         iff there exists exactly 
                           c
                           >
                           0
                         distinct tuples 
                           t
                           ∈
                           r
                         where 
                           t
                           [
                           X
                           ]
                           =
                           v
                           ∧
                           t
                           [
                           Y
                           ]
                           =
                           y
                           ∧
                           t
                           [
                           VT
                           ]
                           =
                           vt
                        .

Given r as above, a set 
                           r
                           ′
                           ⊆
                           r
                         is minimal for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                         iff 
                           r
                           –
                           r
                           ′
                         fulfills 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                        , and for every 
                           r
                           ″
                           ⊂
                           r
                           ′
                         we have that 
                           r
                           –
                           r
                           ″
                         does not satisfy 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                        .

In order to identify the ATFD 
                        
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         we can restrict our analysis to the minimal sets 
                           r
                           ′
                        : it can be easily observed that 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over a given instance r iff there exists a minimal set 
                           r
                           ′
                         for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         with 
                           |
                           r
                           ′
                           |
                           ≤
                           ϵ
                           ·
                           |
                           r
                           |
                        . By restricting our analysis to minimal sets, only, we have to find one minimal set with minimum cardinality. This allows us to check immediately if an ATFD 
                        
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over a given instance of R. Let us consider now the following result over minimal sets:
                           Lemma 5.1
                           
                              Given an instance r of a temporal relational schema 
                              
                                 R
                                 (
                                 U
                                 ,
                                 VT
                                 )
                              , for every 
                              
                                 k
                                 ∈
                                 N
                              , for every minimal set 
                              
                                 r
                                 ′
                                 ⊆
                                 r
                                 
                                 for
                                 
                                 [
                                 R
                                 ,
                                 SlidingWindow
                                 (
                                 k
                                 )
                                 ]
                                 X
                                 →
                                 Y
                              , and for every value v, it holds 
                              
                                 ValueCount
                                 (
                                 r
                                 ′
                                 ,
                                 v
                                 )
                                 ⊆
                                 ValueCount
                                 (
                                 r
                                 ,
                                 v
                                 )
                              
                           

VerifySW(
                                 [
                                 R
                              , 
                                 SlidingWindow
                                 (
                                 k
                                 )
                                 ]
                                 X
                               
                              
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                              , r). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                   [
                                                   R
                                                   ,
                                                   SlidingWindow
                                                   (
                                                   k
                                                   )
                                                   ]
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                   ,
                                                   r
                                                
                                             
                                          
                                          
                                             
                                                Output: TRUE or FALSE
                                          
                                          
                                             
                                                1
                                                
                                                
                                                   σ
                                                   ←
                                                   0
                                                ;
                                          
                                          
                                             
                                                2
                                                
                                                foreach 
                                                
                                                   v
                                                   ∈
                                                   {
                                                   x
                                                   |
                                                   ∃
                                                   t
                                                   ∈
                                                   r
                                                   (
                                                   t
                                                   [
                                                   X
                                                   ]
                                                   =
                                                   x
                                                   )
                                                   }
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            3
                                                         
                                                      
                                                      
                                                         
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            5
                                                         
                                                      
                                                      
                                                         
                                                            6
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               σ
                                                               ←
                                                               σ
                                                               +
                                                               MinDelete
                                                               (
                                                               ValueCount
                                                               (
                                                               r
                                                               ,
                                                               v
                                                               )
                                                               ,
                                                               k
                                                               )
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               σ
                                                               >
                                                               ϵ
                                                               ·
                                                               |
                                                               r
                                                               |
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               return
                                                               
                                                               FALSE
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                7
                                                
                                                end foreach
                                             
                                          
                                          
                                             
                                                8
                                                
                                                return TRUE;/⁎ verify if
                                                
                                                
                                                   [
                                                   R
                                                   ,
                                                   SlidingWindow
                                                   (
                                                   k
                                                   )
                                                   ]
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                 
                                                holds over 
                                                r ⁎/
                                          
                                       
                                    
                                 
                              
                           


                        Lemma 5.1 provides us with the following property: the tuples of r which have the same attribute values for (
                           X
                           ,
                           VT
                        ) are either totally deleted or totally kept in a minimal set 
                           r
                           ′
                           ⊆
                           r
                         for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                        .

By means of this property, a procedure that verifies 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         over r is described in Algorithm 4. By definition, we have that r does not satisfy 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                         iff there exists at least one pair of tuples 
                           t
                           ,
                           t
                           ′
                         with 
                           t
                           [
                           X
                           ]
                           =
                           t
                           ′
                           [
                           X
                           ]
                           ∧
                           t
                           [
                           Y
                           ]
                           ≠
                           t
                           ′
                           [
                           Y
                           ]
                           ∧
                           t
                           ′
                           [
                           VT
                           ]
                           −
                           t
                           [
                           VT
                           ]
                           ≤
                           k
                        .

Thus, we can partition r into 
                           r
                           =
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       m
                                    
                                 
                              
                           
                        , where 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           =
                           {
                           t
                           |
                           t
                           ∈
                           r
                           ∧
                           t
                           [
                           X
                           ]
                           =
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           }
                         (i.e.tuples having the tuple v
                        
                           i
                         of values for attributes X).

For each i, 
                           1
                           ≤
                           i
                           ≤
                           m
                        , we compute the minimal set 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                              
                                 ′
                              
                           
                         for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         restricted to the set 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        . It follows immediately that 
                           
                              
                                 ⋃
                              
                              
                                 1
                                 ≤
                                 i
                                 ≤
                                 m
                              
                           
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                              
                                 ′
                              
                           
                         represents a minimal set 
                           r
                           ′
                         for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         over the whole relation r.

In the procedure, every set 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                         of the partition is represented by its 
                           ValueCount
                           (
                           r
                           ,
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                         relation, which contains the minimum amount of information needed to determine the cardinality of 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                              
                                 ′
                              
                           
                        .

The whole collection of relations 
                           ValueCount
                           (
                           r
                           ,
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                        , for 
                           1
                           ≤
                           i
                           ≤
                           m
                        , can be computed in 
                           O
                           (
                           |
                           r
                           |
                           ·
                           log
                           (
                           |
                           r
                           |
                           )
                           )
                        , by means of a simple counting aggregation function over r lexicographically ordered and grouped by attributes 
                           X
                           ,
                           Y
                           ,
                           VT
                        .

As shown in Algorithm 4, the auxiliary function MinDelete is applied to each relation 
                           ValueCount
                           (
                           r
                           ,
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                         and it returns the minimum amount of tuples that have to be removed from 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                         to satisfy 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         on 
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        . Since 
                           |
                           ValueCount
                           (
                           r
                           ,
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                           |
                           ≤
                           |
                           
                              
                                 r
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           |
                        , the overall worst-case complexity is reached when the partition is formed by one set only, namely r, i.e. all the tuples in r assume the same (tuple of) values for attributes X.

With 
                           O
                           (
                           f
                           (
                           n
                           )
                           )
                         being the worst case complexity of MinDelete, where n is the size of the input relation, the overall worst case complexity is 
                           O
                           (
                           |
                           r
                           |
                           ·
                           log
                           (
                           |
                           r
                           |
                           )
                           +
                           f
                           (
                           |
                           r
                           |
                           )
                           )
                         (as we shall see, k does not affect the complexity of MinDelete).

We now have to identify an efficient algorithm to compute the function MinDelete, as described in Appendix A. First, Appendix A.1 describes a quadratic time algorithm version of MinDelete, that allows us to introduce the main ideas behind our solution, such as the representation of temporal relations by Directed Acyclic Graphs (DAGs): this naive algorithm shows that 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         can be computed in polynomial time for every instance r of R. Next, Appendix A.2 improves the asymptotic complexity of MinDelete, by providing an 
                           O
                           (
                           |
                           r
                           |
                           ·
                           log
                           |
                           r
                           |
                           )
                         version of its.

We developed two running prototypes for off-line analysis: G-ATFDminer (Granularity Approximate Temporal Functional Dependency Miner) and SW-ATFDminer (Sliding Windows Approximate Temporal Functional Dependency Miner).


                        G-ATFDminer is a Java based system aimed at extracting rules of approximate temporal functional dependency for granularity (Gran) grouping. We test G-ATFDminer on the psychiatric data set of Section 3.1, and on the phamarcovigilance data set of Section 3.2.

We start by considering the scalability of the implemented software. The parameters of the algorithm are set as follows: 
                           ϵ
                           =
                           0.1
                        ; time granularity set to MONTH.

The first analysis refers to tests with a fixed number of rows, but a varying number of attributes. G-ATFDminer was tested on a machine equipped with a 6 core AMD Opteron
                           
                              TM
                            
                           4284, and 8GB of RAM. We use the Ubuntu 12.04 64-bit (kernel 3.2.0-23-generic) operating system, Java version 1.7.0, and Postgresql 9.1 as DBMS.


                           Table 4
                            depicts the processing time in seconds over the psychiatric data set, consisting of 10,000 rows. Likewise, Table 5
                            depicts the processing time in seconds, according to the number of attributes (the number of rows is kept fixed to 10,000) over the pharmacovigilance data set. Fig. 1
                            depicts the processing time compared to the theoretical overall complexity of the algorithm.

The second analysis refers to tests with a fixed number of attributes (5 in the example) over the psychiatric data set and over the pharmacovigilance data set, but with a varying number of rows. Table 6
                            depicts the processing time in seconds for the psychiatric data set (5 attributes). Likewise, Table 7
                            depicts the processing time in seconds for the pharmacovigilance data set (5 attributes): due to the smaller number of rows in this data set, experiments were performed up to 
                              
                                 
                                    2
                                 
                                 
                                    12
                                 
                              
                              ·
                              100
                            rows. Fig. 2
                            compares the processing times with the theoretical overall complexity of the algorithm. The processing time is directly proportional (linearly) to the number of rows in input. The estimated complexity is 
                              n
                              ·
                              log
                              (
                              n
                              )
                           , but by using the pruning strategies, we tear down the processing time close to linear time.

By running the G-ATFDminer, we identify some meaningful dependencies on the psychiatric data set we discuss here:
                              
                                 •
                                 
                                    
                                       [
                                       MONTH
                                       ]
                                       GAF
                                       
                                       Scale
                                       →
                                       Area
                                    : this dependency points out that the state of the patient, expressed by means of the GAF scale, is directly connected to the geographical area the patient lives in. An urban environment, due to its chaotic nature, could negatively influence the state of the patient. Since the dependency refers to the month granularity, one may infer seasonal changes of state in patients, too;


                                    
                                       [
                                       MONTH
                                       ]
                                       Patient
                                       →
                                       GAF
                                       
                                       Scale
                                    : this dependency points out that patients are relatively stable: their state, expressed by the GAF Scale, does not change within a month;


                                    
                                       [
                                       MONTH
                                       ]
                                       Patient
                                       →
                                       
                                          
                                             Operator
                                          
                                          
                                             1
                                          
                                       
                                    : this dependency links the patient to a particular operator (Operator
                                    1 is the first person that talks to the patient during a call or a visit). Patients are more used to talk to the same operator, instead of talking to different ones (strangers);


                                    
                                       [
                                       MONTH
                                       ]
                                       Area
                                       →
                                       Number
                                       
                                       of
                                       
                                       Psychiatrists
                                    : this dependency links the geographical area to the number of psychiatrists deployed during one month: shifts or teams of psychiatrists last for at least one month.

The most relevant dependency we obtained by running the G-ATFDminer on the pharmacovigilance data set is 
                              [
                              MONTH
                              ]
                              (
                              Severity
                              ,
                              Duration
                              ,
                              Gender
                              ,
                              Drug
                              )
                              →
                              Dosage
                           . It points out that drug dosage during a therapy, characterized by drug name, patient gender, duration and the severity (expressed a boolean flag), is likely to be adjusted due to reports about occurrences of adverse reaction. This means that the occurrences of adverse reaction may be linked to the dosage of a drug during therapies.


                        SW-ATFDminer (Sliding Window Approximate Temporal Functional Dependencies Miner) is a Java based software extracting rules of approximate temporal functional dependencies for sliding window (SW) grouping.

We start by considering the scalability of the implemented software. The parameters of the algorithm are set as follows: 
                           ϵ
                           =
                           0.1
                        ; minimum window size is 1day; maximum window size is 100years. This means that the mining algorithm returns the maximum window size for ATFDs to hold within this specified interval.

We now describe some of the mined functional dependencies over the two data sets of Section 3.

The first analysis refers to tests with a fixed number of rows, but a different number of attributes. As in Section 6.1, we tested SW-ATFDminer on a machine equipped with a 6 core AMD Opteron
                           
                              TM
                            
                           4284, and 8GB of RAM. We use the Ubuntu 12.04 64-bit (kernel 3.2.0-23-generic) operating system, Java version 1.7.0, and Postgresql 9.1 as DBMS.


                           Table 8
                            depicts the processing time in seconds over the psychiatric data set, consisting of 10,000 rows. Likewise, Table 9
                            depicts the processing time in seconds, according to the number of attributes (the number of rows is kept fixed to 10,000) over the pharmacovigilance data set: due to the smaller number of attributes in this data set, experiments were performed up to 16 attributes. Fig. 3
                            depicts the processing time compared to the theoretical overall complexity of the algorithm.

One may argue that the experimental results (the blue line in Fig. 3) show that by our approach, due to suitable pruning strategies, it is possible to mine using 25 attributes before having a decay in the performances. Theoretically, this performance decay should occur as the number of attributes exceeds 10, as depicted by the red line of Fig. 3.

The second analysis refers to tests with a fixed number of attributes (5 in the example) over the psychiatric data set and over the pharmacovigilance data set, but with a varying number of rows. Table 10
                            depicts the processing time in seconds for the psychiatric data set (5 attributes). Likewise, Table 11
                            depicts the processing time in seconds for the pharmacovigilance data set (5 attributes): as before, due to the smaller number of rows in this data set, experiments were performed up to 
                              
                                 
                                    2
                                 
                                 
                                    12
                                 
                              
                              ·
                              100
                            rows. Fig. 4
                            compares the processing times with the theoretical overall complexity of the algorithm. The processing time is directly proportional (linearly) to the number of rows in input. The estimated complexity is 
                              n
                              ·
                              log
                              (
                              n
                              )
                           , but by using the pruning strategies, we tear down the processing time close to linear time.

The psychiatric data set consists of 26 attributes. Theoretically, a mining algorithm would need to validate 872,415,232 (i.e. 
                              26
                              ·
                              
                                 
                                    2
                                 
                                 
                                    25
                                 
                              
                           ) functional dependencies: however, after running the pruning operation, only 125,919 have been tested by SW-ATFDminer to obtain 3042 valid rules. By testing only the 
                              0.014
                              %
                            (
                              125
                              ,
                              919
                              /
                              872
                              ,
                              415
                              ,
                              232
                              =
                              0.014
                              %
                           ) of all the possible ATFDs (that is 1 functional dependency every 6945), SW-ATFDminer allows one to treat an otherwise intractable problem.

By running the SW-ATFDminer, we identify some meaningful dependencies we discuss here:
                              
                                 •
                                 
                                    
                                       [
                                       133
                                       days
                                       ]
                                       HealthStructure
                                       →
                                       ContactType
                                    : Due to the large window of 133 days, this dependency points out that healthcare structures are specialized in providing particular contact types (that is either scheduled, urgent, or not classified). For example, urgent contacts are less likely to be registered in community-based structures vs. hospital-based structures.


                                    
                                       [
                                       112
                                       days
                                       ]
                                       Patient
                                       →
                                       GAFScale
                                    : Even in this case the window size is very large (112 days). This dependency states that the patient׳s GAF score (Global Assessment of Functioning is a numeric scale used by mental health professionals to rate subjectively the psychopathology severity, the social and occupational functioning of patients) basically is assessed every 3months, when changes in the patient׳s mental condition are observed.


                                    
                                       [
                                       13
                                       days
                                       ]
                                       FirstContact
                                       →
                                       ContactType
                                    : This dependency states that, in a window of 13 days, whenever a patient contacts the service for the first time (FirstContact=TRUE), the type of that contact is the same for all the patients. This occurs also when the contact is not the first one (FirstContact=FALSE). This could be of interest: in fact, both the antecedent and the consequent of the dependency may assume 2 or 3 values, so one could guess, for instance, that the first contact of a patient is usually urgent, and the other contacts are routine/scheduled ones. This could be considered as an indicator of a good quality of care, as after an urgent contact (usually in an emergency room), the next contact is scheduled with a short waiting list.


                                    
                                       [
                                       12
                                       days
                                       ]
                                       (
                                       GAFScale
                                       ,
                                       Patient
                                       )
                                       →
                                       Duration
                                    : Over a window of 12days, this dependency links the patient and the current condition (measured by the GAF score) to the duration of the contact. It means that, if a patient is scored with a higher functioning (high GAF score), the duration of the outpatient contact is shorter, since the need for psychological, psycho-pharmacological and social support is reduced. If a patient has a lower GAF score, the duration of the outpatient contact is longer.


                                    
                                       [
                                       5
                                       days
                                       ]
                                       Patient
                                       →
                                       Referral
                                    : This dependency states that, in a window of 5days, the referral of the service depends on the patient (typically, the referral is a family member, a neighbor, the police, or the physician). The small window size indicates that the referral of a contact is strictly linked to the condition of the patient at that particular stage of the disease.


                                    
                                       [
                                       5
                                       days
                                       ]
                                       (
                                       Duration
                                       ,
                                       GAFScale
                                       )
                                       →
                                       Professional
                                    : This dependency links the duration of the contact and the GAF score of the patient to the professional involved in the contact. The duration of the contact is longer if the patient is talking to his/her usual professional, while if talking to an unusual professional, the contact is shorter.

We selected 19 attributes from the pharmacovigilance (PhV) data set, and processed them by the SW-ATFDminer. Theoretically, a mining algorithm would need to validate 4,980,736 functional dependencies (i.e. 
                              19
                              ·
                              
                                 
                                    2
                                 
                                 
                                    18
                                 
                              
                           ): however, after running the pruning operation, SW-ATFDminer tested only 49,904 of them.

By running the SW-ATFDminer, we identify some meaningful dependencies we discuss here:
                              
                                 •
                                 
                                    
                                       [
                                       30
                                       days
                                       ]
                                       (
                                       Drug
                                       ,
                                       AdverseReaction
                                       )
                                       →
                                       Outcome
                                    : Due to the large size of the window, this dependency points out that – given an adverse drug reaction – the outcome does not change. This is of interest for the analyst (i.e.asserting that the suspected drug is indeed the one that caused the reaction). In this case, it is not completely understood by pharmacologists why this dependency does not hold even for bigger window sizes.


                                    
                                       [
                                       23
                                       days
                                       ]
                                       (
                                       Drug
                                       ,
                                       AdverseReaction
                                       )
                                       →
                                       HealthcareRegion
                                    : This dependency links a drug and its adverse reaction to the geographical region where that event has been detected. This dependency is explained as follows. Many reports are related to specific active pharmacovigilance projects. For example, many reports from the Lombardy region come from a project focusing on the monitoring of emergency departments: many drug-reaction couples (e.g., bleeding and aspirin) occur several times in the considered data sets due to this project. Even in this case, the length of the sliding window needs further investigations. Moreover, it is of interest to analyze this kind of dependency only for those reports which are not related to specific pharmacovigilance projects.


                                    
                                       [
                                       11
                                       days
                                       ]
                                       (
                                       Drug
                                       ,
                                       TreatmentDuration
                                       )
                                       →
                                       Outcome
                                    : This dependency states that the outcome of any adverse reaction induced by a drug can be linked to the drug itself and to the duration of the treatment. This dependency is similar to the first one. In this case, it is interesting to observe that, given a drug, both the induced adverse reaction and the duration of the treatment induce a dependency with respect to the outcome. This could confirm that the same drug may produce different outcomes, according to the time span of the treatment.


                                    
                                       [
                                       6
                                       days
                                       ]
                                       AdverseReaction
                                       →
                                       Severity
                                    : This dependency links the reaction to its severity. It is acknowledged by pharmacologists that a reaction is usually severe/not severe regardless of the associated drug. This feature holds even in this case, where severity is associated with the overall report, possibly containing several reactions for the same drug.


                                    
                                       [
                                       5
                                       days
                                       ]
                                       (
                                       ATC
                                       ,
                                       AdverseReaction
                                       )
                                       →
                                       DrugRole
                                    : The ATC (Anatomical Therapeutic Chemical) classification system is widely used to classify drugs. ATC classifies drugs into different groups, according to the organ or system on which they act, and/or their therapeutic and chemical characteristics. This dependency links the higher level of this classification (e.g. cardiovascular system, dermatology, central nervous system), and the observed adverse reaction to the drug role (e.g. suspected of being the cause of the reaction, or just contemporary). This dependency may be explained by the “notoriety” of a reaction with respect to a group of drugs. For example, a hypertensive drug is expected to possibly induce hypotension, an anti-arrhythmic one may cause bradycardia. The short width of the sliding window could be explained by the irregular flow of reports and by the fact that different types of reports come in different time periods. Even in this case, the found window size has to be studied and deeply considered by pharmacologists.

@&#CONCLUSIONS@&#

In this paper, we introduced and discussed approximate temporal functional dependencies, with their related algorithms and clinical data mining issues. More precisely, we discussed how to mine pure temporally grouping temporal functional dependencies. We considered both granularity-based and sliding window temporal groupings. We applied ATFD mining to two different clinical data sets, related to psychiatric patient management and to pharmacovigilance. ATFDs proved to be an interesting tool for mining clinical data and the derived dependencies have been discussed as for their clinical relevance.

As a future work, we plan to extend mining techniques to other kinds of temporal functional dependencies, according to the framework proposed in [7]. Moreover, a tuning of these techniques for specific temporal clinical data will be considered. In particular ATFDs could be the result of specific tools within an integrated suite of (temporal) data mining tools for clinical data, comprising both temporal dependencies and temporal association rules.

None declared.

This appendix describes two implementations for the MinDelete function: Appendix A.1 describes a naive implementation, while Appendix A.2 describes a smarter implementation.

Function MinDelete of Algorithm 5 receives as input a relation 
                           
                              
                                 r
                              
                              
                                 ¯
                              
                           
                         with schema 
                           
                              
                                 R
                              
                              
                                 ¯
                              
                           
                           (
                           Y
                           ,
                           VT
                           ,
                           C
                           )
                        ; this relation stores, for a given tuple of values for attributes X, the number C of tuples, which share the same value for the attribute Y at the same valid time VT in the original instance r.
                           Algorithm 5
                           MinDeleteNaive(
                                 
                                    
                                       r
                                    
                                    
                                       ¯
                                    
                                 
                                 ,
                                 k
                              ). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   ,
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                Output: 
                                                   DAG
                                                   _
                                                   Shortest
                                                   _
                                                   Path
                                                   (
                                                   V
                                                   ,
                                                   E
                                                   ,
                                                   W
                                                   ,
                                                   S
                                                   ,
                                                   f
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                1
                                                / ⁎ 
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                 
                                                is supposed to contain only tuples 
                                                
                                                   (
                                                   y
                                                   ,
                                                   vt
                                                   ,
                                                   c
                                                   )
                                                 
                                                where 
                                                y 
                                                is a value in the domain of 
                                                Y, and both
                                                vt 
                                                and 
                                                c 
                                                are natural numbers ⁎ /
                                          
                                          
                                             
                                                2
                                                assign to y a value 
                                                   ∈
                                                   Dom
                                                   (
                                                   Y
                                                   )
                                                ;
                                          
                                          
                                             
                                                3
                                                
                                                
                                                   s
                                                   ←
                                                   (
                                                   y
                                                   ,
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         t
                                                         ∈
                                                         r
                                                      
                                                   
                                                   t
                                                   [
                                                   VT
                                                   ]
                                                   −
                                                   k
                                                   −
                                                   1
                                                   ,
                                                   0
                                                   )
                                                ;
                                          
                                          
                                             
                                                4
                                                
                                                
                                                   e
                                                   ←
                                                   (
                                                   y
                                                   ,
                                                   
                                                      
                                                         max
                                                      
                                                      
                                                         t
                                                         ∈
                                                         r
                                                      
                                                   
                                                   t
                                                   [
                                                   VT
                                                   ]
                                                   +
                                                   k
                                                   +
                                                   1
                                                   ,
                                                   0
                                                   )
                                                ;
                                          
                                          
                                             
                                                5
                                                
                                                
                                                   V
                                                   ←
                                                   r
                                                   ∪
                                                   {
                                                   s
                                                   ,
                                                   e
                                                   }
                                                ;
                                          
                                          
                                             
                                                6
                                                
                                                
                                                   E
                                                   ←
                                                   {
                                                   (
                                                   s
                                                   ,
                                                   t
                                                   )
                                                   |
                                                   t
                                                   ∈
                                                   r
                                                   }
                                                   ∪
                                                   {
                                                   (
                                                   t
                                                   ,
                                                   e
                                                   )
                                                   |
                                                   t
                                                   ∈
                                                   r
                                                   }
                                                   ∪
                                                   {
                                                   (
                                                   t
                                                   ,
                                                   t
                                                   ′
                                                   )
                                                   |
                                                   t
                                                   ,
                                                   t
                                                   ′
                                                   ∈
                                                   r
                                                   ∧
                                                   t
                                                   [
                                                   VT
                                                   ]
                                                   <
                                                   t
                                                   ′
                                                   [
                                                   VT
                                                   ]
                                                   ∧
                                                   (
                                                   t
                                                   ′
                                                   [
                                                   VT
                                                   ]
                                                   −
                                                   t
                                                   [
                                                   VT
                                                   ]
                                                   >
                                                   k
                                                   ∨
                                                   t
                                                   [
                                                   Y
                                                   ]
                                                   =
                                                   t
                                                   ′
                                                   [
                                                   Y
                                                   ]
                                                   )
                                                   }
                                                ;
                                          
                                          
                                             
                                                7
                                                
                                                foreach 
                                                
                                                   (
                                                   t
                                                   ,
                                                   t
                                                   ′
                                                   )
                                                   ∈
                                                   E
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                8
                                                
                                                
                                                   |
                                                   
                                                   W
                                                   (
                                                   t
                                                   ,
                                                   t
                                                   ′
                                                   )
                                                   ←
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         t
                                                         ″
                                                         ∈
                                                         r
                                                         ∧
                                                         t
                                                         ″
                                                         ≠
                                                         t
                                                         ′
                                                         ∧
                                                         t
                                                         [
                                                         VT
                                                         ]
                                                         <
                                                         t
                                                         ″
                                                         [
                                                         VT
                                                         ]
                                                         ≤
                                                         t
                                                         ′
                                                         [
                                                         VT
                                                         ]
                                                      
                                                   
                                                   t
                                                   ″
                                                   [
                                                   C
                                                   ]
                                                
                                             
                                          
                                          
                                             
                                                9
                                                
                                                end foreach
                                             
                                          
                                          
                                             
                                                10
                                                
                                                return 
                                                
                                                   DAG
                                                   _
                                                   Shortest
                                                   _
                                                   Path
                                                   (
                                                   V
                                                   ,
                                                   E
                                                   ,
                                                   W
                                                   ,
                                                   S
                                                   ,
                                                   f
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Given such relation 
                           
                              
                                 r
                              
                              
                                 ¯
                              
                           
                        , the algorithm computes the minimum number of tuples t, with 
                           t
                           [
                           X
                           ]
                           =
                           x
                        , to be deleted from r in order to have the TFD 
                        
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                         to hold over the remaining tuples of r that share the same tuple x of values for 
                           t
                           [
                           X
                           ]
                        . That is, Algorithm 5 looks for a minimal set 
                           
                              
                                 r
                              
                              
                                 x
                              
                              
                                 ′
                              
                           
                           ⊆
                           
                              
                                 r
                              
                              
                                 x
                              
                           
                         for 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                        .

The procedure builds a DAG with positive weights on the edges. The nodes of G represent tuples of the input relation, and have two auxiliary nodes s and e. The set E of edges and their respective weights W are defined as follows:
                           
                              •
                              there is one edge from s to every 
                                    t
                                    ∈
                                    r
                                 , and one edge from every 
                                    t
                                    ∈
                                    r
                                  to e;

one edge connects two tuples 
                                    t
                                    ,
                                    t
                                    ′
                                    ∈
                                    r
                                 , iff the two tuples with subsequent VTs (
                                    t
                                    [
                                    VT
                                    ]
                                    <
                                    t
                                    ′
                                    [
                                    VT
                                    ]
                                 ) do not create a conflict with respect to 
                                    [
                                    R
                                    ,
                                    SlidingWindow
                                    (
                                    k
                                    )
                                    ]
                                    X
                                    →
                                    Y
                                 . This occurs when either 
                                    t
                                    [
                                    Y
                                    ]
                                    =
                                    t
                                    ′
                                    [
                                    Y
                                    ]
                                  or 
                                    t
                                    ′
                                    [
                                    VT
                                    ]
                                    −
                                    t
                                    [
                                    VT
                                    ]
                                    >
                                    k
                                 ;

the weight of every edge 
                                    (
                                    t
                                    ,
                                    t
                                    ′
                                    )
                                  is the number of tuples that must be deleted if all the tuples represented by t together with all the tuples represented by 
                                    t
                                    ′
                                  will be kept in the final solution and no other tuples are in between, with respect to their valid time. In particular, when considering tuples within the sliding window, we cannot have tuples between 
                                    t
                                    [
                                    VT
                                    ]
                                  and 
                                    t
                                    ′
                                    [
                                    VT
                                    ]
                                  with the same corresponding values for attributes X and different values for Y (i.e. violating the dependency).

Every path from s to e in the DAG describes one possible “deletion-strategy”. Every edge indicates that the two tuples may coexist without violating the dependency. If an edge 
                           e
                           =
                           (
                           t
                           ,
                           t
                           ′
                           )
                         is chosen in the shortest path between s and e, it means that t and 
                           t
                           ′
                         are kept in r, and thus all the tuples of the DAG in-between them are deleted. The number of such deleted tuples is represented by the weight of the edge e.

As an example, let us consider in Fig. A1
                         the edge between nodes 
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         and 
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 6
                              
                           
                        . Tuples 
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 2
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 3
                              
                           
                           ,
                           …
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 5
                              
                           
                         will be deleted. Every path from s to e guarantees that 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                         is satisfied by all the remaining tuples sharing the same tuple x of values for attributes X. Indeed, all the edges on a path guarantee that the two connected nodes represent tuples that can be in a relation satisfying the given temporal functional dependency. Moreover the sum of the weights on every path from s to e is exactly the number of the tuples to be deleted, if the corresponding strategy would be adopted. Finding the weighted shortest path from s to e in the DAG corresponds to identifying the minimum number of tuples to be deleted to make r
                        
                           x
                         consistent with 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           →
                           Y
                        , i.e. considering only those tuples with the given (tuple of) values for attributes X.

The complexity of such a procedure is 
                           O
                           (
                           |
                           r
                           
                              
                                 |
                              
                              
                                 2
                              
                           
                           )
                        , and it is determined by the worst case complexity to compute the weights for the edges. Such a computation requires, in the worst case, a quadratic parse of the original relation r: this dominates the overall complexity for every single source shortest path procedure used to compute the output value. We shall see in the next section how such weights can be incrementally computed just in time, tearing down the complexity of the whole procedure by exploiting the particular structure of the generated DAG.

The procedure MinDelete can be improved with respect to the asymptotic complexity analysis, obtaining the procedure described in Algorithm 6. The soundness and completeness of such a procedure is given by Lemma A.1, which can be proved by contradiction.
                           Lemma A.1
                           
                              Given a shortest path 
                              
                                 P
                                 =
                                 s
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                                 ,
                                 e
                               
                              in the 
                              DAG 
                              builtup according to Algorithm 
                              5, for every pair of consecutive nodes 
                              
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                               
                              in P there does not exist a path 
                              
                                 P
                                 ′
                               
                              in the 
                              DAG 
                              with 
                              
                                 |
                                 P
                                 ′
                                 |
                                 >
                                 1
                               
                              and 
                              
                                 P
                                 ′
                                 =
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       1
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       m
                                       ′
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                              .

This result strongly depends on how the weights are computed in the DAG, and informally it enables us to disregard all the edges that can lead to a longer path when computing the shortest path through the function SHP. SHP computes the cost of the shortest path between two given nodes. For example, in the DAG of Fig. A1, the edge 
                           (
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 7
                              
                           
                           )
                         can be deleted without affecting any value for every shortest path. Indeed, looking at the edge weights we observe that 
                           
                              
                                 W
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       7
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       i
                                       +
                                       1
                                    
                                    
                                       i
                                       +
                                       6
                                    
                                 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                                 [
                                 C
                                 ]
                                 >
                                 W
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       4
                                    
                                 
                                 )
                                 +
                                 W
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       4
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       7
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       i
                                       +
                                       1
                                    
                                    
                                       i
                                       +
                                       3
                                    
                                 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                                 [
                                 C
                                 ]
                                 +
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       i
                                       +
                                       5
                                    
                                    
                                       i
                                       +
                                       6
                                    
                                 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                                 [
                                 C
                                 ]
                              
                           
                        
                     

Thus, every path featuring 
                           (
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 7
                              
                           
                           )
                         is not the shortest one, since such an edge may be replaced by the edge pairs 
                           (
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 4
                              
                           
                           )
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 4
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 i
                                 +
                                 7
                              
                           
                           )
                        , to obtain a path with a lower weight. Corollary 1 follows from this result.
                           Corollary 1
                           
                              Given a shortest path 
                              
                                 P
                                 =
                                 s
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                               
                              in the 
                              DAG 
                              from s to any node 
                              
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                                 ∈
                                 V
                              , then either 
                              
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                                 [
                                 VT
                                 ]
                                 −
                                 
                                    
                                       t
                                    
                                    
                                       m
                                       −
                                       1
                                    
                                 
                                 [
                                 VT
                                 ]
                                 >
                                 k
                              , or for every 
                              
                                 t
                                 ′
                               
                              with 
                              
                                 
                                    
                                       t
                                    
                                    
                                       m
                                       −
                                       1
                                    
                                 
                                 [
                                 VT
                                 ]
                                 <
                                 t
                                 ′
                                 [
                                 VT
                                 ]
                                 <
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                                 [
                                 VT
                                 ]
                              , we have 
                              
                                 t
                                 ′
                                 [
                                 Y
                                 ]
                                 ≠
                                 
                                    
                                       t
                                    
                                    
                                       m
                                    
                                 
                                 [
                                 Y
                                 ]
                              .

This means that every node 
                           
                              
                                 t
                              
                              
                                 m
                              
                           
                           ∈
                           V
                         has either
                           
                              •
                              a predecessor in its shortest path outside the sliding window or;

an immediate predecessor among the tuples with the same value for attribute Y in the sliding window.

We call such a tuple, if it exists, the minimal window predecessor of t
                        
                           m
                        . Given a node t, we say that 
                           t
                           ′
                        , with 
                           t
                           [
                           VT
                           ]
                           −
                           t
                           ′
                           [
                           VT
                           ]
                           >
                           k
                        , is its minimal-external predecessor if and only if for every 
                           t
                           ″
                         with 
                           t
                           [
                           VT
                           ]
                           −
                           t
                           ″
                           [
                           VT
                           ]
                           >
                           k
                        , we have 
                           SHP
                           (
                           s
                           ,
                           t
                           ″
                           )
                           +
                           W
                           (
                           t
                           ″
                           ,
                           t
                           )
                           ≥
                           SHP
                           (
                           s
                           ,
                           t
                           ′
                           )
                           +
                           W
                           (
                           t
                           ′
                           ,
                           t
                           )
                        .


                        Corollary 2 completes the needed properties for our procedure. It can be proved by contradiction by looking at the properties of the weights in the DAG.
                           Corollary 2
                           
                              For every pair of tuples 
                              
                                 t
                                 ,
                                 t
                                 ′
                               
                              with 
                              
                                 t
                                 [
                                 VT
                                 ]
                                 ≤
                                 t
                                 ′
                                 [
                                 VT
                                 ]
                              , let 
                              
                                 
                                    
                                       t
                                    
                                    
                                       ¯
                                    
                                 
                               
                              and 
                              
                                 
                                    
                                       t
                                    
                                    
                                       ¯
                                    
                                 
                                 ′
                               
                              be the minimal external predecessors of t and 
                              
                                 t
                                 ′
                               
                              respectively: then, it holds 
                              
                                 
                                    
                                       t
                                    
                                    
                                       ¯
                                    
                                 
                                 [
                                 VT
                                 ]
                                 ≤
                                 
                                    
                                       t
                                    
                                    
                                       ¯
                                    
                                 
                                 ′
                                 [
                                 VT
                                 ]
                              .

Suppose that we are looking for a given node t. Properties highlighted by the two corollaries 1 and 2 restrict the value of 
                           SHP
                           (
                           s
                           ,
                           t
                           )
                         to 
                           min
                           (
                           (
                           SHP
                           (
                           s
                           ,
                           t
                           ′
                           )
                        
                        
                           +
                           W
                           (
                           t
                           ′
                           ,
                           t
                           )
                           )
                           ,
                        
                        
                           (
                           SHP
                           (
                           s
                           ,
                           t
                           ″
                           )
                        
                        
                           +
                           W
                           (
                           t
                           ″
                           ,
                           t
                           )
                           )
                        . Thus, 
                           t
                           ′
                         is the minimal-external predecessor of t, and 
                           t
                           ″
                         is the minimal-window predecessor of t (if any).
                           Algorithm 6
                           MinDelete(
                                 
                                    
                                       r
                                    
                                    
                                       ¯
                                    
                                 
                                 ,
                                 k
                              ). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                ,k
                                             
                                          
                                          
                                             
                                                Output: Min
                                             
                                          
                                          
                                             
                                                1
                                                
                                                optimized version for MinDelete;/⁎ 
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                 
                                                contains only tuples 
                                                
                                                   (
                                                   y
                                                   ,
                                                   vt
                                                   ,
                                                   c
                                                   ,
                                                   lc
                                                   ,
                                                   pw
                                                   ,
                                                   pwc
                                                   ,
                                                   fw
                                                   ,
                                                   shp
                                                   )
                                                 
                                                where
                                                y, vt 
                                                and
                                                c 
                                                are defined as in 
                                                
                                                   Algorithm
                                                   5. Attributes
                                                lc, pw, pwc, fw 
                                                and
                                                shp 
                                                are natural numbers. ⁎/
                                          
                                          
                                             
                                                2
                                                
                                                for 
                                                
                                                   i
                                                   =
                                                   1
                                                   
                                                   to
                                                   
                                                   |
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   |
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            3
                                                         
                                                      
                                                      
                                                         
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            5
                                                         
                                                      
                                                      
                                                         
                                                            6
                                                         
                                                      
                                                      
                                                         
                                                            7
                                                         
                                                      
                                                      
                                                         
                                                            8
                                                         
                                                      
                                                      
                                                         
                                                            9
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                               
                                                               i
                                                               =
                                                               1
                                                               ∨
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                     −
                                                                     1
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               <
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           Count
                                                                           ←
                                                                           0
                                                                           ;
                                                                           j
                                                                           ←
                                                                           i
                                                                           ;
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           while
                                                                           
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 j
                                                                              
                                                                           
                                                                           [
                                                                           VT
                                                                           ]
                                                                           =
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           VT
                                                                           ]
                                                                           ∧
                                                                           j
                                                                           ≤
                                                                           |
                                                                           r
                                                                           |
                                                                           do
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           |
                                                                           
                                                                           Count
                                                                           =
                                                                           Count
                                                                           +
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 j
                                                                              
                                                                           
                                                                           [
                                                                           C
                                                                           ]
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           end
                                                                           
                                                                           while
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               LC
                                                               ]
                                                               ←
                                                               Count
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                10
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                11
                                                ;/⁎ T 
                                                is assumed to be a balanced binary search tree. Each node of 
                                                T 
                                                is ordered on the field 
                                                key 
                                                which assumes values in the domain of 
                                                y 
                                                and contains attributes 
                                                idx 
                                                and 
                                                bonus 
                                                which are natural numbers. ⁎/
                                          
                                          
                                             
                                                12
                                                
                                                
                                                   T
                                                   ←
                                                   ∅
                                                   ;
                                                   Count
                                                   ←
                                                   0
                                                ;
                                          
                                          
                                             
                                                13
                                                
                                                for 
                                                
                                                   i
                                                   =
                                                   |
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   |
                                                 
                                                down 
                                                
                                                to
                                                1 do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            14
                                                         
                                                      
                                                      
                                                         
                                                            15
                                                         
                                                      
                                                      
                                                         
                                                            16
                                                         
                                                      
                                                      
                                                         
                                                            17
                                                         
                                                      
                                                      
                                                         
                                                            18
                                                         
                                                      
                                                      
                                                         
                                                            19
                                                         
                                                      
                                                      
                                                         
                                                            20
                                                         
                                                      
                                                      
                                                         
                                                            21
                                                         
                                                      
                                                      
                                                         
                                                            22
                                                         
                                                      
                                                      
                                                         
                                                            23
                                                         
                                                      
                                                      
                                                         
                                                            24
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               PW
                                                               ]
                                                               ←
                                                               NIL
                                                               ;
                                                               n
                                                               ←
                                                               T
                                                               .
                                                               search
                                                               (
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               Y
                                                               ]
                                                               )
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               n
                                                               ≠
                                                               NIL
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                                  
                                                                     
                                                                        
                                                                           if
                                                                           
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 n
                                                                                 [
                                                                                 idx
                                                                                 ]
                                                                              
                                                                           
                                                                           [
                                                                           VT
                                                                           ]
                                                                           −
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           VT
                                                                           ]
                                                                           ≤
                                                                           k
                                                                           
                                                                           then
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           |
                                                                           
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 n
                                                                                 [
                                                                                 idx
                                                                                 ]
                                                                              
                                                                           
                                                                           [
                                                                           PW
                                                                           ]
                                                                           ←
                                                                           i
                                                                           ;
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 n
                                                                                 [
                                                                                 idx
                                                                                 ]
                                                                              
                                                                           
                                                                           [
                                                                           PWC
                                                                           ]
                                                                           ←
                                                                           Count
                                                                           −
                                                                           n
                                                                           [
                                                                           bonus
                                                                           ]
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           end
                                                                           
                                                                           if
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           T
                                                                           .
                                                                           delete
                                                                           (
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           Y
                                                                           ]
                                                                           )
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               n
                                                               ←
                                                               NewNode
                                                               (
                                                               )
                                                               ;
                                                               n
                                                               [
                                                               key
                                                               ]
                                                               ←
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               Y
                                                               ]
                                                               ;
                                                               n
                                                               [
                                                               idx
                                                               ]
                                                               ←
                                                               i
                                                               ;
                                                               n
                                                               [
                                                               bonus
                                                               ]
                                                               ←
                                                               Count
                                                               +
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               C
                                                               ]
                                                               ;
                                                               T
                                                               .
                                                               insert
                                                               (
                                                               n
                                                               )
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               i
                                                               >
                                                               1
                                                               ∨
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               >
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                     −
                                                                     1
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               Count
                                                               ←
                                                               Count
                                                               +
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               LC
                                                               ]
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                25
                                                
                                                endfor
                                             
                                          
                                          
                                             
                                                26
                                                
                                                foreach 
                                                
                                                   t
                                                   ∈
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                27
                                                
                                                
                                                   |
                                                   
                                                   t
                                                   [
                                                   FW
                                                   ]
                                                   =
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         ∈
                                                         r
                                                         ∧
                                                         t
                                                         [
                                                         VT
                                                         ]
                                                         ≥
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         [
                                                         VT
                                                         ]
                                                         ∧
                                                         t
                                                         [
                                                         VT
                                                         ]
                                                         −
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         [
                                                         VT
                                                         ]
                                                         ≤
                                                         k
                                                      
                                                   
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                28
                                                
                                                foreach
                                             
                                          
                                          
                                             
                                                29
                                                
                                                
                                                   Ext
                                                   ←
                                                   Win
                                                   ←
                                                   0
                                                ;
                                          
                                          
                                             
                                                30
                                                
                                                for 
                                                i=1 to 
                                                
                                                   |
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   |
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            31
                                                         
                                                      
                                                      
                                                         
                                                            32
                                                         
                                                      
                                                      
                                                         
                                                            33
                                                         
                                                      
                                                      
                                                         
                                                            34
                                                         
                                                      
                                                      
                                                         
                                                            35
                                                         
                                                      
                                                      
                                                         
                                                            36
                                                         
                                                      
                                                      
                                                         
                                                            36
                                                         
                                                      
                                                      
                                                         
                                                            37
                                                         
                                                      
                                                      
                                                         
                                                            38
                                                         
                                                      
                                                      
                                                         
                                                            39
                                                         
                                                      
                                                      
                                                         
                                                            40
                                                         
                                                      
                                                      
                                                         
                                                            41
                                                         
                                                      
                                                      
                                                         
                                                            42
                                                         
                                                      
                                                      
                                                         
                                                            43
                                                         
                                                      
                                                      
                                                         
                                                            44
                                                         
                                                      
                                                      
                                                         
                                                            45
                                                         
                                                      
                                                      
                                                         
                                                            46
                                                         
                                                      
                                                      
                                                         
                                                            47
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                         
                                                            
                                                               OutValue
                                                               ←
                                                               Ext
                                                               +
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               LC
                                                               ]
                                                               −
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               C
                                                               ]
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               PW
                                                               ]
                                                               ≠
                                                               NIL
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               InValue
                                                               ←
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     t
                                                                     [
                                                                     PW
                                                                     ]
                                                                  
                                                               
                                                               [
                                                               SHP
                                                               ]
                                                               +
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               PWC
                                                               ]
                                                               ;
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               SHP
                                                               ]
                                                               ←
                                                               min
                                                               (
                                                               InValue
                                                               ,
                                                               OutValue
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               else
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               SHP
                                                               ]
                                                               ←
                                                               OutValue
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               i
                                                               <
                                                               |
                                                               r
                                                               |
                                                               ∧
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               <
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                     +
                                                                     1
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                                  
                                                                     
                                                                        
                                                                           Win
                                                                           ←
                                                                           Win
                                                                           +
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           LC
                                                                           ]
                                                                           ;
                                                                           Ext
                                                                           ←
                                                                           Ext
                                                                           +
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           LC
                                                                           ]
                                                                           ;
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           if
                                                                           
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                                 +
                                                                                 1
                                                                              
                                                                           
                                                                           [
                                                                           FW
                                                                           ]
                                                                           >
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           FW
                                                                           ]
                                                                           
                                                                           then
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           |
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       for
                                                                                       
                                                                                       j
                                                                                       =
                                                                                       
                                                                                          
                                                                                             t
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                       
                                                                                       [
                                                                                       FW
                                                                                       ]
                                                                                       
                                                                                       to
                                                                                       
                                                                                       
                                                                                          
                                                                                             t
                                                                                          
                                                                                          
                                                                                             i
                                                                                             +
                                                                                             1
                                                                                          
                                                                                       
                                                                                       [
                                                                                       FW
                                                                                       ]
                                                                                       −
                                                                                       1
                                                                                       
                                                                                       do
                                                                                    
                                                                                 
                                                                                 
                                                                                    
                                                                                       |
                                                                                       
                                                                                          
                                                                                             
                                                                                                
                                                                                                   Ext
                                                                                                   ←
                                                                                                   min
                                                                                                   (
                                                                                                   Ext
                                                                                                   ,
                                                                                                   Win
                                                                                                   +
                                                                                                   
                                                                                                      
                                                                                                         t
                                                                                                      
                                                                                                      
                                                                                                         j
                                                                                                      
                                                                                                   
                                                                                                   [
                                                                                                   SHP
                                                                                                   ]
                                                                                                   −
                                                                                                   
                                                                                                      
                                                                                                         t
                                                                                                      
                                                                                                      
                                                                                                         j
                                                                                                      
                                                                                                   
                                                                                                   [
                                                                                                   LC
                                                                                                   ]
                                                                                                   )
                                                                                                   ;
                                                                                                
                                                                                             
                                                                                             
                                                                                                
                                                                                                   if
                                                                                                   
                                                                                                   
                                                                                                      
                                                                                                         t
                                                                                                      
                                                                                                      
                                                                                                         j
                                                                                                      
                                                                                                   
                                                                                                   [
                                                                                                   VT
                                                                                                   ]
                                                                                                   <
                                                                                                   
                                                                                                      
                                                                                                         t
                                                                                                      
                                                                                                      
                                                                                                         j
                                                                                                         +
                                                                                                         1
                                                                                                      
                                                                                                   
                                                                                                   [
                                                                                                   VT
                                                                                                   ]
                                                                                                   
                                                                                                   then
                                                                                                
                                                                                             
                                                                                             
                                                                                                
                                                                                                   |
                                                                                                   
                                                                                                   Win
                                                                                                   ←
                                                                                                   Win
                                                                                                   −
                                                                                                   
                                                                                                      
                                                                                                         t
                                                                                                      
                                                                                                      
                                                                                                         j
                                                                                                      
                                                                                                   
                                                                                                   [
                                                                                                   LC
                                                                                                   ]
                                                                                                
                                                                                             
                                                                                             
                                                                                                
                                                                                                   end
                                                                                                   
                                                                                                   if
                                                                                                
                                                                                             
                                                                                             
                                                                                                
                                                                                             
                                                                                          
                                                                                       
                                                                                    
                                                                                 
                                                                                 
                                                                                    
                                                                                       end
                                                                                       
                                                                                       for
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           end
                                                                           
                                                                           if
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                48
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                49
                                                
                                                
                                                   Min
                                                   ←
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         |
                                                         r
                                                         |
                                                      
                                                   
                                                   [
                                                   SHP
                                                   ]
                                                   ;
                                                   Count
                                                   ←
                                                   0
                                                ;
                                          
                                          
                                             
                                                50
                                                
                                                for 
                                                
                                                   i
                                                   =
                                                   |
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   |
                                                   −
                                                   1
                                                 
                                                down to 1 do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            51
                                                         
                                                      
                                                      
                                                         
                                                            52
                                                         
                                                      
                                                      
                                                         
                                                            53
                                                         
                                                      
                                                      
                                                         
                                                            54
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                               
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                     +
                                                                     1
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               >
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               Count
                                                               ←
                                                               Count
                                                               +
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                     +
                                                                     1
                                                                  
                                                               
                                                               [
                                                               LC
                                                               ]
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               Min
                                                               ←
                                                               min
                                                               (
                                                               Min
                                                               ,
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               SHP
                                                               ]
                                                               +
                                                               Count
                                                               )
                                                               ;
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                55
                                                
                                                endfor
                                             
                                          
                                          
                                             
                                                56
                                                
                                                return 
                                                Min
                                             
                                          
                                       
                                    
                                 
                              
                           

The procedure described in Algorithm 6 makes use of these properties to tear down the complexity of procedure MinDelete to 
                           O
                           (
                           n
                           ·
                           log
                           (
                           n
                           )
                           )
                        . The procedure requires that the tuples are ordered lexicographically on 
                           VT
                           ,
                           Y
                         (given an arbitrary order on Y) in the input relation r. In the following, we assume that retrieving a tuple t
                        
                           j
                         given its index j has a computational cost 
                           log
                           (
                           |
                           
                              
                                 r
                              
                              
                                 ¯
                              
                           
                           |
                           )
                        , by supposing that there is some sort of an indexing structure (e.g. a B-tree) built up on the indexes of the tuples, and that the computational cost of computing such a structure is 
                           O
                           (
                           |
                           
                              
                                 r
                              
                              
                                 ¯
                              
                           
                           |
                           ·
                           log
                           |
                           
                              
                                 r
                              
                              
                                 ¯
                              
                           
                           |
                           )
                        .

Moreover, the procedure assumes that in the input relation there are five additional auxiliary not-initialized attributes LC, PW, PWC, FW and 
                           SHP
                        . These integer attributes have the following meaning:
                           
                              •
                              
                                 LC means “level count”, and it represents the sum for the C attribute for all the tuples that share the same VT with the current one (including t itself). Formally 
                                    
                                       
                                          t
                                          [
                                          LC
                                          ]
                                          =
                                          
                                             
                                                ∑
                                             
                                             
                                                t
                                                ′
                                                ∈
                                                r
                                                ,
                                                t
                                                [
                                                VT
                                                ]
                                                =
                                                t
                                                ′
                                                [
                                                VT
                                                ]
                                             
                                          
                                          t
                                          [
                                          C
                                          ]
                                       
                                    
                                 Such an attribute is introduced in order to improve the readability of the code: the attribute is computed at the very beginning of the procedure and for every 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                  with a simple single scan of 
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                  (lines from 2 to 10 in Algorithm 6).


                                 PW stands for “predecessor in window” and it is the index for which 
                                    
                                       
                                          t
                                       
                                       
                                          t
                                          [
                                          PW
                                          ]
                                       
                                    
                                  is the minimal-window predecessor of t in 
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                 .

Formally (recall that tuples in r are lexicographically ordered on 
                                    VT
                                    ,
                                    Y
                                 ):
                                    
                                       
                                          t
                                          [
                                          PW
                                          ]
                                          =
                                          {
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               max
                                                               
                                                               i
                                                            
                                                         
                                                         
                                                            
                                                               (
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           ∈
                                                                           
                                                                              
                                                                                 r
                                                                              
                                                                              
                                                                                 ¯
                                                                              
                                                                           
                                                                           ∧
                                                                           t
                                                                           [
                                                                           Y
                                                                           ]
                                                                           =
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           Y
                                                                           ]
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           ∧
                                                                           t
                                                                           [
                                                                           VT
                                                                           ]
                                                                           −
                                                                           
                                                                              
                                                                                 t
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                           [
                                                                           VT
                                                                           ]
                                                                           ≤
                                                                           k
                                                                        
                                                                     
                                                                  
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            
                                                               ∃
                                                               t
                                                               ∈
                                                               
                                                                  
                                                                     r
                                                                  
                                                                  
                                                                     ¯
                                                                  
                                                               
                                                               (
                                                               t
                                                               [
                                                               Y
                                                               ]
                                                               =
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               Y
                                                               ]
                                                            
                                                         
                                                         
                                                            
                                                               ∧
                                                               t
                                                               [
                                                               VT
                                                               ]
                                                               −
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               [
                                                               VT
                                                               ]
                                                               ≤
                                                               k
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      NIL
                                                   
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 PWC represents the weight of the edge between a node t and its minimal window predecessor (if any): 
                                    
                                       
                                          t
                                          [
                                          PWC
                                          ]
                                          =
                                          {
                                          
                                             
                                                
                                                   
                                                      W
                                                      (
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            t
                                                            [
                                                            PW
                                                            ]
                                                         
                                                      
                                                      ,
                                                      t
                                                      )
                                                   
                                                   
                                                      if
                                                      
                                                      t
                                                      [
                                                      PW
                                                      ]
                                                      ≠
                                                      NIL
                                                   
                                                
                                                
                                                   
                                                      NIL
                                                   
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 Both PW and PWC are computed in the second for-loop of the algorithm (lines from 13 to 25 of Algorithm 6), but their computation is much more complex with respect to the one for LC values.

In fact, a naive way to compute them may lead to a quadratic complexity, making all our efforts unfruitful. On the contrary, the values PW and PWC can be computed for all the tuples 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                  in 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    ·
                                    log
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                  by using a balanced tree T, say a B-tree, as an auxiliary structure (any other data structure where the computational cost to search/insert/delete is logarithmic will perform the same way).

A node n of such a tree consists of a key value 
                                    n
                                    [
                                    key
                                    ]
                                 , which represents a value in the domain of Y, given an arbitrary order of the values for Y. 
                                    n
                                    [
                                    idx
                                    ]
                                  represents the index of the last tuple with attribute Y equal to the key encountered in the current window. 
                                    n
                                    [
                                    bonus
                                    ]
                                  is a value to easily compute the value of PWC. During the procedure, for every node 
                                    n
                                    ∈
                                    T
                                  we guarantee that for every 
                                    n
                                    ′
                                    ∈
                                    
                                    T
                                 , with 
                                    n
                                    ≠
                                    n
                                    ′
                                 , 
                                    n
                                    [
                                    key
                                    ]
                                    ≠
                                    n
                                    ′
                                    [
                                    key
                                    ]
                                 . This second for-loop that computes the values for attributes PW and PWC for all the tuples 
                                    t
                                    ∈
                                    r
                                 , works backward from the tuple with the maximum value for the attributes 
                                    VT
                                    ,
                                    Y
                                 . At every step, PW is assigned to be NIL for the current tuple t
                                 
                                    i
                                 , and the key 
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    Y
                                    ]
                                  is searched into T. If there exists a node 
                                    n
                                    ∈
                                    T
                                  with 
                                    n
                                    [
                                    key
                                    ]
                                    =
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    Y
                                    ]
                                  and 
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                    [
                                    VT
                                    ]
                                    −
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    VT
                                    ]
                                    ≤
                                    k
                                 , then t
                                 
                                    i
                                  is the minimal-window predecessor of 
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                 , and 
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                    [
                                    PW
                                    ]
                                    =
                                    i
                                 .

The value 
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                    [
                                    PWC
                                    ]
                                  is computed as follows: at every step Count is increased by the value 
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    LC
                                    ]
                                  of the current tuple if it represents the first tuple of all the tuples with the same VT. When we insert a node n, we store into 
                                    n
                                    [
                                    bonus
                                    ]
                                  the current value of Count, which is the sum of all the C attributes for the tuples already encountered. The weight 
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                    [
                                    PWC
                                    ]
                                    =
                                    W
                                    (
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          n
                                          [
                                          idx
                                          ]
                                       
                                    
                                    )
                                  is simply computed as 
                                    Count
                                    −
                                    n
                                    [
                                    bonus
                                    ]
                                 .

At the end of the iteration, n is removed from the tree and a new node for the current tuple is inserted into T. For every iteration we have a constant number of retrieve/search/delete/insert operations, each one costing 
                                    O
                                    (
                                    log
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                 . The loop completes after 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    ·
                                    log
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                  operations.


                                 FW stands for “first in window”, and for a tuple t it represents the minimum index j such that a tuple t
                                 
                                    j
                                  exists for which 
                                    0
                                    ≤
                                    t
                                    [
                                    VT
                                    ]
                                    −
                                    
                                       
                                          t
                                       
                                       
                                          j
                                       
                                    
                                    [
                                    VT
                                    ]
                                    ≤
                                    k
                                 .

The third for-loop of the algorithm (lines from 26 to 28 of Algorithm 6) computes j for every tuple 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                 . Algorithm 6 performs 
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                  
                                 Min operations on the indexes, by using the value 
                                    t
                                    [
                                    VT
                                    ]
                                  for the current tuple t. We recall that the index i of every tuple is given according to the lexicographical order on 
                                    VT
                                    ,
                                    Y
                                 . Then, for every 
                                    i
                                    ≤
                                    j
                                  we have 
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    VT
                                    ]
                                    ≤
                                    
                                       
                                          t
                                       
                                       
                                          j
                                       
                                    
                                    [
                                    VT
                                    ]
                                 . The complexity of the third loop is 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    ·
                                    log
                                    |
                                    r
                                    |
                                    )
                                 .

The fourth for-loop of the algorithm (from line 30 to 48 of Algorithm 6) for every tuple 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                  computes 
                                    SHP
                                 . At the end of the fourth loop, we require that 
                                    t
                                    [
                                    SHP
                                    ]
                                    =
                                    SHP
                                    (
                                    s
                                    ,
                                    t
                                    )
                                  for every 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                 .

We use two additional variables, namely Ext and Win, belonging to the set of natural numbers. Ext represents the 
                                    SHP
                                  value for the minimal-external predecessor for the tuple t. Win represents the sum of all the attributes C for all the tuples 
                                    t
                                    ′
                                  of the current tuple t with 
                                    t
                                    [
                                    VT
                                    ]
                                    −
                                    t
                                    ′
                                    [
                                    VT
                                    ]
                                    ≤
                                    k
                                 . For every tuple, the value of the attribute 
                                    SHP
                                  is the minimum between the minimal-external predecessor and the 
                                    SHP
                                  of the minimal-windows predecessor (if any) plus their respective weights. At the end of every iteration, we update – if needed – the value Ext (lines from 37 to 47). Then we collect all the tuples that are in the current window, and that will not be included into the next one. Such a set of tuples is non-empty iff 
                                    
                                       
                                          t
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    [
                                    FW
                                    ]
                                    >
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    FW
                                    ]
                                  where t
                                 
                                    i
                                  is the current tuple.

According to the property expressed by Corollary 2, the set containing the candidates for minimal-external predecessor is restricted to the current tuple, and the t
                                 
                                    j
                                  ones, with 
                                    j
                                    =
                                    
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    FW
                                    ]
                                    ,
                                    …
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    [
                                    FW
                                    ]
                                    −
                                    1
                                 . Values for 
                                    
                                       
                                          t
                                       
                                       
                                          j
                                       
                                    
                                    [
                                    SHP
                                    ]
                                    =
                                    SHP
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          j
                                       
                                    
                                    )
                                  are already defined, and the value for 
                                    W
                                    (
                                    
                                       
                                          t
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    )
                                  is computed by the most internal for-loop (lines from 40 to 45) by means of Win. A graphical representation of this for-loop is depicted in Fig. A2
                                 .

Having 
                                    SHP
                                    (
                                    s
                                    ,
                                    t
                                    )
                                  for every 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                 , we still have to determine the cost of the shortest path of the entire graph, i.e. 
                                    SHP
                                    (
                                    s
                                    ,
                                    f
                                    )
                                 . This is done by the fifth and last for-loop (lines from 50 to 55 of Algorithm 6). Basically, this loop moves backward from the tuple 
                                    t
                                    ∈
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                  with maximum value for the attributes VT and Y, computing the distance between the current tuple and f: at the end, the minimum value is returned. The complexity of the fifth loop is 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                  and the overall complexity of the procedure MinDelete shown in Algorithm 6 is 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    ·
                                    log
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                 .

In conclusion, the complexity of procedure VerifySW is 
                                    O
                                    (
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    ·
                                    log
                                    |
                                    
                                       
                                          r
                                       
                                       
                                          ¯
                                       
                                    
                                    |
                                    )
                                 : this complexity does not depend on the size of the sliding window k, which is provided as input. However, the sliding window size may assume any positive value: we are interested in finding all the independent ATFDs 
                                    [
                                    R
                                    ,
                                    SlidingWindow
                                    (
                                    k
                                    )
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                  with the maximum sliding window size, where only ϵ and r are provided by the user. Indeed, k is the maximum value, for which the approximate temporal dependency 
                                    [
                                    R
                                    ,
                                    SlidingWindow
                                    (
                                    k
                                    )
                                    ]
                                    X
                                    
                                       
                                          →
                                       
                                       
                                          ε
                                       
                                    
                                    Y
                                  holds over r.

At the beginning of this section we observed that, in the worst case, the number of couples (X,Y) to be tested is exponential [23]. The size k of the sliding window is provided as a parameter, which does not affect the complexity of the procedure. One may ask if testing all the possible sliding windows in the interval 
                           [
                           0
                           ,
                           
                              
                                 max
                              
                              
                                 t
                                 ∈
                                 r
                              
                           
                           t
                           [
                           VT
                           ]
                           ]
                         is reasonable: in fact, testing all the possible sliding windows would increase the overall complexity, depending in this case on the value 
                           
                              
                                 max
                              
                              
                                 t
                                 ∈
                                 r
                              
                           
                           t
                           [
                           VT
                           ]
                        . However, such a test is not necessary in this case.
                           Lemma A.2
                           Downward closure property


                           
                              For every temporal relation R, for every couple of attributes 
                              
                                 X
                                 ,
                                 Y
                              , for every instance r of R, for every 
                              
                                 0
                                 ≤
                                 ϵ
                                 ≤
                                 1
                              , and for every k, if 
                              
                                 [
                                 R
                                 ,
                                 SlidingWindow
                                 (
                                 k
                                 )
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               
                              holds over r, then for every 
                              
                                 k
                                 ′
                                 ≤
                                 k
                               
                              we have that 
                              
                                 [
                                 R
                                 ,
                                 SlidingWindow
                                 (
                                 k
                                 )
                                 ]
                                 X
                                 
                                    
                                       →
                                    
                                    
                                       ε
                                    
                                 
                                 Y
                               
                              holds over r.


                        Lemma A.2 asserts that finding the maximum k, if it exists, for which 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                         
                        
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over r, may suffice. Then, by having X, Y and ϵ fixed, we perform a dichotomic search by the procedure VerifySW, starting from 
                           k
                           =
                           
                              
                                 max
                              
                              
                                 t
                                 ∈
                                 r
                              
                           
                           t
                           [
                           VT
                           ]
                        , till we either terminate unsuccessfully or find the maximum sliding window k for which 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over r. The complete procedure is given in Algorithm 7.


                        VerifySW can be applied at most 
                           log
                           (
                           
                              
                                 max
                              
                              
                                 t
                                 ∈
                                 r
                              
                           
                           
                           t
                           [
                           VT
                           ]
                           )
                         times. Finally, let 
                           
                              
                                 k
                              
                              
                                 max
                              
                           
                           =
                           
                              
                                 max
                              
                              
                                 t
                                 ∈
                                 r
                              
                           
                           t
                           [
                           VT
                           ]
                         be the maximum value for the attribute VT in the instance r; the encountered complexity in finding the maximum size k (if any) for which 
                           [
                           R
                           ,
                           SlidingWindow
                           (
                           k
                           )
                           ]
                           X
                           
                              
                                 →
                              
                              
                                 ε
                              
                           
                           Y
                         holds over r is 
                           |
                           r
                           |
                           ·
                           log
                           (
                           |
                           r
                           |
                           )
                           ·
                           log
                           (
                           
                              
                                 k
                              
                              
                                 max
                              
                           
                           )
                        , by assuming that the VT is non-negative, and k
                        
                           max
                         is expressed in the lower time-granule of its temporal domain (e.g. if VT is a year–month–day date then k
                        
                           max
                         is expressed in days).
                           Algorithm 7
                           MaxSlidingWindow(
                                 R
                                 ,
                                 X
                                 ,
                                 ϵ
                                 ,
                                 Y
                                 ,
                                 r
                              ). 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                   R
                                                   ,
                                                   X
                                                   ,
                                                   ϵ
                                                   ,
                                                   Y
                                                   ,
                                                   r
                                                
                                             
                                          
                                          
                                             
                                                Output: k
                                             
                                          
                                          
                                             
                                                1
                                                ;/⁎ A procedure for the dichotomic search of the maximum size
                                                
                                                k, if it exists, such that [
                                                   R
                                                   ,
                                                   SlidingWindow
                                                   (
                                                   k
                                                   )
                                                   ]
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                 
                                                holds over 
                                                r.⁎ /
                                          
                                          
                                             
                                                2
                                                
                                                
                                                   
                                                      
                                                         k
                                                      
                                                      
                                                         max
                                                      
                                                   
                                                   ←
                                                   
                                                      
                                                         max
                                                      
                                                      
                                                         t
                                                         ∈
                                                         r
                                                      
                                                   
                                                   
                                                   t
                                                   [
                                                   VT
                                                   ]
                                                ]; 
                                                   
                                                      
                                                         k
                                                      
                                                      
                                                         min
                                                      
                                                   
                                                   ←
                                                   0
                                                ;
                                          
                                          
                                             
                                                3
                                                
                                                while 
                                                
                                                   
                                                      
                                                         k
                                                      
                                                      
                                                         max
                                                      
                                                   
                                                   ≠
                                                   
                                                      
                                                         k
                                                      
                                                      
                                                         min
                                                      
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            5
                                                         
                                                      
                                                      
                                                         
                                                            6
                                                         
                                                      
                                                      
                                                         
                                                            7
                                                         
                                                      
                                                      
                                                         
                                                            8
                                                         
                                                      
                                                      
                                                         
                                                            9
                                                         
                                                      
                                                      
                                                         
                                                            10
                                                         
                                                      
                                                      
                                                         
                                                            11
                                                         
                                                      
                                                      
                                                         
                                                            12
                                                         
                                                      
                                                      
                                                         
                                                            13
                                                         
                                                      
                                                      
                                                         
                                                            14
                                                         
                                                      
                                                      
                                                         
                                                            15
                                                         
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                               
                                                               VerifySW
                                                               (
                                                               [
                                                               R
                                                               ,
                                                               SlidingWindow
                                                               (
                                                               
                                                                  
                                                                     k
                                                                  
                                                                  
                                                                     max
                                                                  
                                                               
                                                               )
                                                               ]
                                                               X
                                                               
                                                                  
                                                                     →
                                                                  
                                                                  
                                                                     ε
                                                                  
                                                               
                                                               Y
                                                               ,
                                                               r
                                                               )
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               return
                                                               
                                                               
                                                                  
                                                                     k
                                                                  
                                                                  
                                                                     max
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               NOT
                                                               
                                                               VerifySW
                                                               (
                                                               [
                                                               R
                                                               ,
                                                               SlidingWindow
                                                               (
                                                               
                                                                  
                                                                     k
                                                                  
                                                                  
                                                                     min
                                                                  
                                                               
                                                               )
                                                               ]
                                                               X
                                                               
                                                                  
                                                                     →
                                                                  
                                                                  
                                                                     ε
                                                                  
                                                               
                                                               Y
                                                               ,
                                                               r
                                                               )
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               return
                                                               
                                                               NIL
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                         
                                                            
                                                               k
                                                               ←
                                                               ⌈
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              k
                                                                           
                                                                           
                                                                              max
                                                                           
                                                                        
                                                                        +
                                                                        
                                                                           
                                                                              k
                                                                           
                                                                           
                                                                              min
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                               
                                                               ⌉
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               VerifySW
                                                               (
                                                               [
                                                               R
                                                               ,
                                                               SlidingWindow
                                                               (
                                                               k
                                                               )
                                                               ]
                                                               X
                                                               
                                                                  
                                                                     →
                                                                  
                                                                  
                                                                     ε
                                                                  
                                                               
                                                               Y
                                                               ,
                                                               r
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               
                                                                  
                                                                     k
                                                                  
                                                                  
                                                                     min
                                                                  
                                                               
                                                               ←
                                                               k
                                                            
                                                         
                                                         
                                                            
                                                               else
                                                            
                                                         
                                                         
                                                            
                                                               |
                                                               
                                                               
                                                                  
                                                                     k
                                                                  
                                                                  
                                                                     max
                                                                  
                                                               
                                                               ←
                                                               k
                                                            
                                                         
                                                         
                                                            
                                                               end
                                                               
                                                               if
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                16
                                                
                                                end while
                                             
                                          
                                          
                                             
                                                17
                                                
                                                if
                                                
                                                
                                                   VerifySW
                                                   (
                                                   [
                                                   R
                                                   ,
                                                   SlidingWindow
                                                   (
                                                   
                                                      
                                                         k
                                                      
                                                      
                                                         max
                                                      
                                                   
                                                   )
                                                   ]
                                                   X
                                                   
                                                      
                                                         →
                                                      
                                                      
                                                         ε
                                                      
                                                   
                                                   Y
                                                   ,
                                                   r
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                18
                                                
                                                
                                                   |
                                                
                                                
                                                return 
                                                k
                                                
                                                   max
                                                
                                             
                                          
                                          
                                             
                                                19
                                                
                                                else
                                             
                                          
                                          
                                             
                                                20
                                                
                                                
                                                   |
                                                
                                                
                                                return NIL
                                             
                                          
                                          
                                             
                                                21
                                                
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           

@&#REFERENCES@&#

