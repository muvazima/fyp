@&#MAIN-TITLE@&#A column generation approach for a multi-attribute vehicle routing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We investigate the characteristics of a new problem with seasonal supply behavior.


                        
                        
                           
                           We propose a mathematical programming model for the problem.


                        
                        
                           
                           We propose a branch-and-price algorithm.


                        
                        
                           
                           It includes new bounds and structural modifications in the multi-period problem.


                        
                        
                           
                           The efficiency of the algorithm is investigated based on extensive numerical tests.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi-attribute vehicle routing problem

Heterogeneous fleet

Multiple depots

Branch-and-price

Dairy transportation problem

@&#ABSTRACT@&#


               
               
                  In this paper, we consider a multi-attribute vehicle routing problem derived from a real-life milk collection system. This problem is characterized by the presence of a heterogeneous fleet of vehicles, multiple depots, and several resource constraints. A branch-and-price methodology is proposed to tackle the problem. In this methodology, different branching strategies, adapted to the special structure of the problem, are implemented and compared. The computational results show that the branch-and-price algorithm performs well in terms of solution quality and computational efficiency.
               
            

@&#INTRODUCTION@&#

The vehicle routing problem (VRP) lies at the center of logistics and distribution management and is one of the most studied problems in the field of operations research. Numerous variants have been studied since the problem was first introduced by Dantzig and Ramser (1959). The simplest problem in this domain is the capacitated vehicle routing problem (CVRP). In the CVRP, all the customers correspond to deliveries. The customers’ demands are deterministic, known in advance, and may not be split. The vehicles are identical and based at a single central depot. Each vehicle can perform only one route, and the quantity supplied cannot exceed the vehicle capacity. The objective most commonly used is to minimize the total cost (i.e., a weighted function of the number of routes and their length or travel time) of serving all the customers (Toth and Vigo, 2002).

Many real-world combinatorial optimization problems, including logistics applications and transportation problems, have several complicating attributes. These attributes lead to the characteristics, constraints, and objectives that define the problem. When there are many attributes the problem becomes complex and challenging. In the combinatorial optimization literature, such problems are called “multi-attribute problems.” Recently, the research community has focused on simultaneously considering multiple attributes, to provide more representative models of real-world situations. In particular, VRP researchers have recently concentrated on multi-attribute vehicle routing problems (MAVRP; see Hartl et al., 2006). They have explored several variations of the MAVRP, each representing a specialized extension of the classical VRP and reflecting a real-world application. However, not all variants have received the same attention. Furthermore, most of the contributions have developed heuristics and metaheuristics, and there are few efficient exact algorithms for the variants of the MAVRP.

We introduce a new MAVRP variant that incorporates some common real-world features. It is inspired by collection-redistribution activities in the raw-milk industry of Quebec. This problem consists of route planning for a heterogeneous fleet of vehicles departing from different depots. The vehicles must visit a set of producers in specific time windows, and the collected product is then delivered to processing plants. Finally, the vehicles return to their home depots. The most similar model in the literature is the multi-depot heterogeneous vehicle routing problem with time windows (MDHVRPTW).

The main goal of this paper is to investigate the challenges of complex problems with features such as collection-redistribution activities. We formulate a multi-attribute VRP with certain special features that takes the form of an MDHVRPTW with deliveries to plants. The main contributions of this paper are summarized as follows:

                        
                           •
                           We introduce a variant of the MAVRP. It differs from well-studied variants such as VRPTW and MDVRPTW because there is an extra level of difficulty associated with the assignment of routes to plants.

We propose a set partitioning formulation for this problem.

We develop a branch-and-price algorithm. It includes a number of structural exploration and exploitation features that improve the computational efficiency of the solution strategy.

We perform an extensive analysis using a large set of randomly generated instances, to illustrate the efficiency of the algorithm and investigate the characteristics of the problem.

The remainder of the paper is organized as follows. In Section 2, we describe in detail the problem class and its different variants. In Section 3, we give a brief literature review to better position the present study. In Section 4, we choose a special case of the problem class and present the set partitioning model. In Section 5, we present the proposed solution methodology, and experimental results are given in Section 6. Finally, Section 7 provides concluding remarks.

In this section, we introduce a new MAVRP variant inspired by the dairy transportation problem in Quebec (see Lahrichi et al., 2013). Basically, it consists of constructing collection routes that are then assigned to plants that receive the collected products. It is usually encountered in the collection and redistribution of perishable products. There are three types of stakeholders, as described below:

                        
                           •
                           The producers, which periodically produce a limited quantity of one or more products.

The plants, which periodically receive the products. They transform these raw materials into consumable goods.

The carriers, which collect the products from the producers and deliver them to the plants. Each carrier has one or more depots where the vehicles are located.

The vehicles usually have different capacities, fixed costs, and variable costs. The fixed costs are the expenses that are not related to the distance traveled and have to be paid when the vehicle is used; the variable costs depend on the distance traveled. In most applications, each producer has an associated time window indicating the earliest and latest collection times. Each plant has an associated demand window indicating the minimum and maximum quantities that can be delivered.

A route is a path that starts and ends at a depot and visits producers and plants; it may contain one or more pick-up and delivery phases. A route is feasible if the pick-ups do not exceed the vehicle capacity and the associated time windows are respected. The cost of a route is the sum of the costs of the arcs on the path plus the sum of the vehicle’s fixed and variable costs. We assume throughout this paper that the triangle inequality holds for the costs and travel times. Also, the service times are considered to be independent of the quantities collected or delivered.

There may be some preassignments based on contractual restrictions, strategic/tactical planning decisions, or equipment compatibility. We introduce three: (1) producer-depot preassignments, which assign a producer to a specific depot; (2) producer-plant preassignments, which specify which plant receives the products of a given producer; (3) producer-depot-plant preassignments, which assign a producer to a depot and a plant. The most general variant of the problem has no preassignments.

A vehicle can perform one or more circuits per day. We define three route types as follows:

                        
                           1.
                           
                              Simple route: Each vehicle visits several producers and collects their products. It then delivers its entire load to one plant and returns to its depot (Fig. 1
                              a).


                              Multi-drop route: A vehicle delivers its load to more than one plant before returning to its depot (Fig. 1b).


                              Interlaced multi-drop route: Vehicles perform several circuits per day. A vehicle may visit other producers after completing its first visit to a plant. One or more plants are visited (Fig. 1c).

We consider simple routes, and Section 4 gives the details of this subclass of the problem.

@&#LITERATURE REVIEW@&#

In this section, we review research into different variants of the MAVRP. We focus on exact algorithms rather than heuristic methods and consider variants of the VRP with attributes similar to those of our problem.

Among the variants of the VRP, the VRPTW has received the most attention, and numerous researchers have applied column generation methodology to solve the problem. For the VRPTW, column generation was first used by Desrochers et al. (1992) in a Dantzig–Wolfe decomposition framework. They devised a branch-and-bound algorithm to solve a number of original time-window constrained problems from Solomon (1986) to optimality or near optimality. Kohl et al. (1999) improved the method by adding 2-path inequalities to the LP relaxation of the set partitioning formulation. Kohl and Madsen (1997) proposed a branch-and-bound algorithm in which subgradient and bundle methods were employed to compute the lower bounds. These methods were based on 2-cycle elimination algorithms. Irnich and Villeneuve (2006) proposed a branch-and-price algorithm in which the subproblem is solved using a k-cycle elimination procedure. Branch-and-price has been the leading methodology for the VRPTW since the beginning of the 1990s.


                     Feillet et al. (2004) improved the extension of the Ford–Bellman algorithm proposed by Desrochers (1988). More precisely, they improved the labeling procedure for the elementary shortest path problem with resource constraints (ESPPRC), which is the backbone of a number of solution procedures based on column generation, by proposing new labels and dominance rules. Righini and Salani (2004) proposed an improved bounded bidirectional label-correcting algorithm in which two sequential labeling processes starting from the depot and a copy of the depot (considered the sink node) cooperate to accelerate the solution of the ESPPRC.

The most efficient algorithms for the ESPPRC are based on a partial or complete relaxation of the elementarity condition. Boland et al. (2006) and Righini and Salani (2009) embedded a decremental state space relaxation (DSSR) scheme into the labeling procedure. In this method, the elementarity condition on the generated routes is initially relaxed, transforming the problem into a shortest path problem with resource constraints (SPPRC). After each iteration, using an augmentation strategy, restrictions are added to the problem to prevent the formation of cycles. Several state-space augmentation strategies were evaluated by Boland et al. (2006). Later, Desaulniers et al. (2008) used heuristic dynamic programming and a tabu search (TS) heuristic to rapidly generate routes with negative reduced costs. The dynamic heuristic is based on making the graph more sparse by eliminating arcs that do not seem promising and applying aggressive dominance rules (relaxed conditions). Their method outperformed all previous algorithms in terms of the computational time. Moreover, they successfully solved 5 of 10 Solomon instances not previously solved.


                     Baldacci et al. (2011a) introduced a new state-space relaxation, called the ng-path relaxation, to compute lower bounds for routing problems such as the CVRP and the VRPTW. This relaxation partitions the set of all possible paths ending at a generic vertex. This is done according to prespecified neighborhoods of graph vertices, and a mapping function that associates with each path a subset of the vertices that depends on the order in which these vertices are visited. These subsets of vertices are used to impose partial elementarity. This relaxation proved particularly effective in computing lower bounds for the CVRP, the VRPTW, and the traveling salesman problem with time windows (TSPTW) (see Baldacci et al., 2011b).


                     Martinelli et al. (2014) proposed an efficient ng-route pricing in which a DSSR technique is embedded into the ng-route relaxation. It consists of an ng-route relaxation procedure in which resources associated with the vertices’ neighbors are initially deactivated. These neighborhoods are iteratively augmented using a DSSR scheme to ensure the ng-feasibility of all the columns.

A unified exact method capable of solving different classes of the VRP, including the multi-depot heterogeneous vehicle routing problem (MDHVRP), was proposed by Baldacci and Mingozzi (2009). It is based on the solution of an integer linear programming problem and on dual heuristics. It can solve instances with up to 100 customers to optimality; this takes several hours. Finally, Bettinelli et al. (2011) proposed a branch-and-cut-and-price algorithm for the MDHVRPTW. The method allows for different combinations of cutting and pricing strategies, and both heuristic and exact approaches are proposed for the subproblems.

To summarize, we make the following observations: (1) Our literature review supports our claim regarding the novelty of the problem considered in this paper. To the best of our knowledge, this variant has not been previously studied. The main complexity of the problem corresponds to the plant-assignment phase, (2) many efficient solution techniques have been developed for classes of the VRP with features similar to those of our variant. Our algorithm is based on a specialization of a cutting-edge branch-and-price algorithm, and it incorporates techniques from the literature. We evaluate the efficiency and relevance of these techniques in the context of our problem.

We consider a deterministic subclass of the general problem, which is a real-world tactical planning problem in the context of milk collection. We consider two variants:

                        
                           1.
                           The depot associated with each producer is preassigned based on contractual agreements.

We remove the preassignments; this is a logical extension of the first variant. We claim that slight modifications in the data set can reduce variant 2 to variant 1.

We first consider variant 1 and in Section 5 we show how to adapt the approach for variant 2. We assume that the vehicles perform simple routes as described in Section 2, and collections and deliveries are made once a day.

Several carriers, based in different depots, collect milk from farms in a specific geographical region and deliver it to milk-processing plants. The model is defined on a directed graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           A
                           )
                           ,
                        
                      where 
                        V
                      and 
                        A
                      are the node and arc sets, respectively. The node set contains the depots, producers, and plants: 
                        
                           V
                           =
                           D
                           ∪
                           N
                           ∪
                           U
                        
                      where 
                        
                           D
                           =
                           (
                           1
                           ,
                           …
                           ,
                           d
                           )
                        
                      represents the depot set, 
                        
                           N
                           =
                           (
                           1
                           ,
                           …
                           ,
                           n
                           )
                        
                      the producer set, and 
                        
                           U
                           =
                           (
                           1
                           ,
                           …
                           ,
                           u
                           )
                        
                      the plant set. The arc set 
                        
                           A
                           ⊂
                           V
                           ×
                           V
                        
                      defines feasible movements between different locations in 
                        V
                     . Associated with each arc (i, j) is a transportation cost cij
                      that is proportional to the travel time between locations i and j. Each carrier has one or more vehicle types, and 
                        
                           K
                           =
                           (
                           1
                           ,
                           …
                           ,
                           k
                           )
                        
                      is the set of vehicle types. The capacity, the fixed cost, and the variable cost coefficient of the kth vehicle type are Qk, ck
                     , and vk
                     , respectively. More precisely, vk
                      is the cost for vehicle type 
                        
                           k
                           ∈
                           K
                        
                      to travel one unit of distance. Associated with each plant is a daily demand, Du
                     , and we assume that there is sufficient supply to meet the demand.

We introduce a path-based formulation that yields a set partitioning model. Let 
                        
                           
                              P
                           
                           
                              d
                              u
                           
                           k
                        
                      be the set of feasible routes from depot 
                        
                           d
                           ∈
                           D
                        
                      to plant 
                        
                           u
                           ∈
                           U
                        
                      operated by vehicle type 
                        
                           k
                           ∈
                           
                              K
                              d
                           
                        
                     . Each route 
                        
                           p
                           ∈
                           
                              
                                 P
                              
                              
                                 d
                                 u
                              
                              k
                           
                        
                      can serve only the producers assigned to depot d, and 
                        
                           C
                           d
                        
                      is this set of producers. Let yp
                      be a binary variable such that yp
                      is 1 if route p is selected in the optimal solution and 0 otherwise. The quantity collected on route p, gp
                     , cannot exceed the capacity of the vehicle; gp
                      is 0 for all plants not visited on route p. Parameter aip
                      is 1 if producer i is visited on route p and 0 otherwise. The variable cost of each route 
                        
                           p
                           ∈
                           
                              
                                 P
                              
                              
                                 d
                                 u
                              
                              k
                           
                        
                      is cp
                     ; it is the sum of the arc costs of the route. The path-based model is as follows:

                        
                           (1)
                           
                              
                                 min
                                 
                                 
                                    ∑
                                    
                                       u
                                       ∈
                                       U
                                    
                                 
                                 
                                    ∑
                                    
                                       d
                                       ∈
                                       D
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       
                                          K
                                          d
                                       
                                    
                                 
                                 
                                    ∑
                                    
                                       p
                                       ∈
                                       
                                          
                                             P
                                          
                                          
                                             d
                                             u
                                          
                                          k
                                       
                                    
                                 
                                 
                                    (
                                    
                                       c
                                       p
                                    
                                    +
                                    
                                       c
                                       k
                                    
                                    )
                                 
                                 
                                    y
                                    p
                                 
                              
                           
                        
                     subject to

                        
                           (2)
                           
                              
                                 
                                    ∑
                                    
                                       u
                                       ∈
                                       U
                                    
                                 
                                 
                                    ∑
                                    
                                       d
                                       ∈
                                       D
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       
                                          K
                                          d
                                       
                                    
                                 
                                 
                                    ∑
                                    
                                       p
                                       ∈
                                       
                                          
                                             P
                                          
                                          
                                             d
                                             u
                                          
                                          k
                                       
                                    
                                 
                                 
                                    a
                                    
                                       i
                                       p
                                    
                                 
                                 
                                    y
                                    p
                                 
                                 =
                                 1
                                 
                                 
                                    (
                                    i
                                    ∈
                                    N
                                    )
                                 
                                 ;
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    ∑
                                    
                                       d
                                       ∈
                                       D
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       
                                          K
                                          d
                                       
                                    
                                 
                                 
                                    ∑
                                    
                                       p
                                       ∈
                                       
                                          
                                             P
                                          
                                          
                                             d
                                             u
                                          
                                          k
                                       
                                    
                                 
                                 
                                    g
                                    p
                                 
                                 
                                    y
                                    p
                                 
                                 ≥
                                 
                                    D
                                    u
                                 
                                 
                                 
                                    (
                                    u
                                    ∈
                                    U
                                    )
                                 
                                 ;
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    y
                                    p
                                 
                                 ∈
                                 
                                    {
                                    1
                                    ,
                                    0
                                    }
                                 
                                 
                                 
                                    (
                                    d
                                    ∈
                                    D
                                    ;
                                    k
                                    ∈
                                    
                                       K
                                       d
                                    
                                    ;
                                    u
                                    ∈
                                    U
                                    ;
                                    p
                                    ∈
                                    
                                       
                                          P
                                       
                                       
                                          d
                                          u
                                       
                                       k
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     Constraint (2) ensures that each producer is visited exactly once by exactly one route, and constraint (3) guarantees that the plant demands are satisfied. In the following sections, we describe our algorithm in detail.

In this section, we present our algorithm. In the path-based integer model (1)–(4), the number of paths is so large that it is not practical to solve the model directly using a MIP solver. Thus, the usual solution method is based on the branch-and-price algorithm. This is a branch-and-bound algorithm where the lower bounds are computed using column generation (for a complete survey of column generation methods, see Lübbecke and Desrosiers, 2005). Column generation is often successful when the associated integer programs are set partitioning (or set covering) problems. In the VRP, each variable of the set partitioning formulation represents a feasible route. However, most successful decomposition approaches for the VRP formulate the pricing problem as an ESPPRC. At each iteration of the column generation, a restricted linear master problem (RLMP) is solved rather than the master problem itself. The columns in the RLMP are limited to those that have already been generated in the pricing problem.

The search tree is initialized at the root node. Initialization involves adding to the RLMP sufficient columns to obtain a feasible solution. At each node of the search tree, the RLMP contains a subset of the feasible columns, already priced out by the subproblem, which are in compliance with the branching decisions. It is solved by column generation. If the solution is integer, it is a valid solution to the original master problem, and it is compared to the incumbent solution. Otherwise, branching occurs to eliminate the current fractional point. In other words, when no column is available to enter the basis but the solution of the linear relaxation is not integer, branching occurs. A valid branching scheme will eliminate the current fractional solution, produce a balanced search tree, and keep the structure of the problem unchanged. At the end of the search process, the best integer solution found is the optimal solution for the original problem.

As mentioned in Section 4, variant 2 has no preassignments. The decision about the depot associated with each producer is made during the solution process. A slight modification allows our algorithm to solve this more general problem: we set 
                        
                           
                              C
                              d
                           
                           =
                           N
                        
                      for each depot 
                        
                           d
                           ∈
                           D
                        
                     . Variant 2 may be useful for proposing a first set of assignments or revising an existing set in a strategic planning phase. In Sections 5.1–5.4, we describe the branch-and-price algorithm.

A relaxation of the integrality constraint (4) yield the linear master problem. The RLMP, which is restricted to a subset of columns 
                           
                              
                                 
                                    
                                       P
                                       ′
                                    
                                 
                                 
                                    d
                                    u
                                 
                                 k
                              
                              ⊆
                              
                                 P
                                 
                                    
                                       d
                                       u
                                    
                                 
                                 k
                              
                              ,
                           
                         takes the following form:

(RLMP)

                           
                              (5)
                              
                                 
                                    min
                                    
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          U
                                       
                                    
                                    
                                       ∑
                                       
                                          d
                                          ∈
                                          D
                                       
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          
                                             K
                                             d
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          p
                                          ∈
                                          
                                             
                                                
                                                   P
                                                   ′
                                                
                                             
                                             
                                                d
                                                u
                                             
                                             k
                                          
                                       
                                    
                                    
                                       (
                                       
                                          c
                                          p
                                       
                                       +
                                       
                                          c
                                          k
                                       
                                       )
                                    
                                    
                                       y
                                       p
                                    
                                 
                              
                           
                        subject  to

                           
                              (6)
                              
                                 
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          U
                                       
                                    
                                    
                                       ∑
                                       
                                          d
                                          ∈
                                          D
                                       
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          
                                             K
                                             d
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          p
                                          ∈
                                          
                                             
                                                
                                                   P
                                                   ′
                                                
                                             
                                             
                                                k
                                                
                                                   d
                                                   u
                                                
                                             
                                          
                                       
                                    
                                    
                                       a
                                       
                                          i
                                          p
                                       
                                    
                                    
                                       y
                                       p
                                    
                                    =
                                    1
                                    
                                    
                                       (
                                       i
                                       ∈
                                       N
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       ∑
                                       
                                          d
                                          ∈
                                          D
                                       
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          
                                             K
                                             d
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          p
                                          ∈
                                          
                                             
                                                
                                                   P
                                                   ′
                                                
                                             
                                             
                                                k
                                                
                                                   d
                                                   u
                                                
                                             
                                          
                                       
                                    
                                    
                                       g
                                       p
                                    
                                    
                                       y
                                       p
                                    
                                    ≥
                                    
                                       D
                                       u
                                    
                                    
                                    
                                       (
                                       u
                                       ∈
                                       U
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       y
                                       p
                                    
                                    ≥
                                    0
                                    
                                    
                                       (
                                       d
                                       ∈
                                       D
                                       ;
                                       k
                                       ∈
                                       
                                          K
                                          d
                                       
                                       ;
                                       u
                                       ∈
                                       U
                                       ;
                                       p
                                       ∈
                                       
                                          
                                             
                                                P
                                                ′
                                             
                                          
                                          
                                             d
                                             u
                                          
                                          k
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

It is worth mentioning that, contrary to most cases where column generation is applied, a set covering formulation is not appropriate for our problem given that the presence of constraint (7) may results in multiple visits to producers in some extreme cases. Therefore, constraint (6) is kept under the equality form.

To obtain the first set of dual variables of the master problem, we add two sets of initial columns. The first set consists of routes that start and end at a given depot and visit one producer and one plant for all possible combinations of depots, producers, and plants. The second set is generated using the classical savings heuristic of Clarke and Wright (1964).

The pricing problem aims to find one or more master problem variables p with a negative reduced cost with respect to a given dual solution of the linear relaxation of the master problem. In our column generation approach, the pricing problem is decomposed into several similar subproblems. Each subproblem is an ESPPRC associated with a specific depot, plant, and vehicle type, where the set of resource constraints contains time windows and vehicle capacities. Consider the following dual variables of the RLMP (5)–(8):

                           
                              
                                 λi
                                 :
                              unrestricted dual variable of constraint (6) for producer 
                                    
                                       i
                                       ∈
                                       N
                                    
                                 ;

nonnegative dual variable of constraint (7) for plant 
                                    
                                       u
                                       ∈
                                       U
                                    
                                 .

Let xij
                         be a binary decision variable that is 1 if vertex vj
                         follows vi
                         on the shortest path, and 0 otherwise. Variable ti
                         is the time at which the service starts at vertex i if the shortest path visits this node. Binary variable fu
                         is 1 if the shortest path visits plant u, and 0 otherwise. A supply qi
                         is associated with each producer i. Each producer has a time window [ei, li
                        ] during which the service may occur. The node 0
                           d
                         represents the depot and the node 
                           
                              0
                              d
                              ′
                           
                         represents a copy of the depot that plays the role of a fictitious sink node in the standard form of the shortest path problem.

Using this notation, the pricing problem for a vehicle type k, which leaves depot 
                           
                              
                                 0
                                 d
                              
                              ,
                              d
                              ∈
                              D
                              ,
                           
                         and services the producers of the set 
                           
                              
                                 C
                                 d
                              
                              ,
                           
                         is as follows:

                           
                              (9)
                              
                                 
                                    min
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       (
                                       
                                          v
                                          k
                                       
                                       
                                          c
                                          
                                             i
                                             j
                                          
                                       
                                       −
                                       
                                          λ
                                          i
                                       
                                       )
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    −
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          U
                                       
                                    
                                    
                                       g
                                       p
                                    
                                    
                                       μ
                                       u
                                    
                                    +
                                    
                                       c
                                       k
                                    
                                 
                              
                           
                        subject to

                           
                              (10)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          h
                                       
                                    
                                    −
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       x
                                       
                                          h
                                          j
                                       
                                    
                                    =
                                    0
                                    
                                    
                                       (
                                       h
                                       ∈
                                       
                                          C
                                          d
                                       
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       x
                                       
                                          
                                             0
                                             d
                                          
                                          j
                                       
                                    
                                    =
                                    1
                                    ;
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       f
                                       u
                                    
                                    −
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          u
                                       
                                    
                                    =
                                    0
                                    
                                    
                                       (
                                       u
                                       ∈
                                       U
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          U
                                       
                                    
                                    
                                       f
                                       u
                                    
                                    =
                                    1
                                    ;
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       f
                                       u
                                    
                                    −
                                    
                                       x
                                       
                                          u
                                          
                                             0
                                             d
                                             ′
                                          
                                       
                                    
                                    =
                                    0
                                    
                                    
                                       (
                                       u
                                       ∈
                                       U
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          U
                                       
                                    
                                    
                                       x
                                       
                                          u
                                          i
                                       
                                    
                                    =
                                    0
                                    ;
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       (
                                       
                                          t
                                          i
                                       
                                       +
                                       
                                          s
                                          i
                                       
                                       +
                                       
                                          t
                                          
                                             i
                                             j
                                          
                                       
                                       −
                                       
                                          t
                                          j
                                       
                                       )
                                    
                                    ≤
                                    0
                                    
                                    
                                       (
                                       i
                                       ∈
                                       
                                          C
                                          d
                                       
                                       ;
                                       j
                                       ∈
                                       
                                          C
                                          d
                                       
                                       ∪
                                       U
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       e
                                       i
                                    
                                    ≤
                                    
                                       t
                                       i
                                    
                                    ≤
                                    
                                       l
                                       i
                                    
                                    
                                    
                                       (
                                       i
                                       ∈
                                       
                                          C
                                          d
                                       
                                       ∪
                                       U
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       g
                                       p
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       q
                                       i
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          
                                             C
                                             d
                                          
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≤
                                    
                                       Q
                                       k
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ∈
                                    
                                       {
                                       1
                                       ,
                                       0
                                       }
                                    
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       ∈
                                       
                                          C
                                          d
                                       
                                       )
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       f
                                       u
                                    
                                    ∈
                                    
                                       {
                                       1
                                       ,
                                       0
                                       }
                                    
                                    
                                    
                                       (
                                       u
                                       ∈
                                       U
                                       )
                                    
                                    .
                                 
                              
                           
                        Constraints (10)–(15) are flow constraints that result in a path from the depot 0
                           d
                         to 
                           
                              0
                              d
                              ′
                           
                         ensuring that the shortest path visits a plant before returning to the depot. Constraints (16) and (17) are time-window constraints. Constraint (18) is the capacity constraint, and Constraints (19) and (20) ensure integrality.

The subproblems above are variants of the ESPPRC and thus are NP-hard problems in the strong sense (see Dror, 1994). To reduce the number of iterations to solve this complex problem to optimality, one may try to generate multiple negative-reduced-cost columns using fast heuristics. However, when the heuristic procedures fail to find a new column, we must perform at least one iteration of the exact procedure to prove the optimality of the lower bound. We solve the subproblems with a bilevel column generation procedure. The first level consists of a procedure based on heuristic dynamic programming (HDP), which is the followed by an exact dynamic programming (EDP) procedure (defining the second level). We describe these procedures below. We first summarize the EDP and then describe the heuristic strategies that speed up the procedure. Finally, the bilevel procedure is presented in Algorithm 1
                        , which shows how these procedures interact.

Classical dynamic programming algorithms start from an initial label associated with the depot and extend the labels along arcs using extension functions. To avoid creating too many labels, dominated labels are eliminated by a dominance procedure. As described in Section 3, much research has focused on the computational efficiency of the labeling procedure for the ESPPRC subproblem. DSSR (see Righini and Salani, 2009; Boland et al., 2006) and the ng-route relaxation (see Baldacci et al., 2011a) have received the most attention.

DSSR can be considered a special case of the ng-route relaxation. However, we consider DSSR as a stand-alone procedure and DSSR embedded into the ng-route relaxation (see Martinelli et al., 2014) as different strategies for the pricing problems. In both cases, the elementarity relaxation of the ESPPRC allows the generation of paths with cycles throughout the labeling procedure. The relaxation is iteratively tightened by considering new resources that forbid cycles. However, in the ng-route relaxation (but not DSSR), the ng-feasible columns may still contain cycles. Therefore, the lower bound obtained using the ng-route relaxation can be weaker than the DSSR bound, representing the optimal lower bound.


                           Decremental state-space relaxation (DSSR): This relaxation of the ESPPRC allows the generation of paths with cycles throughout the labeling procedure. The relaxation is iteratively tightened by considering some nodes to be critical and forbidding multiple visits to them. Critical nodes are selected based on an augmentation policy, from those nodes involved in a cycle in at least one route. If at the end of a labeling iteration, the paths contain no cycles, the solution is valid for the ESPPRC. Otherwise, the relaxed state space is augmented by one or more resources associated with newly recognized critical nodes and the procedure restarts. At the end of each iteration of the labeling algorithm, the nodes with visit multiplicity greater than one on the lowest cost path are recognized as new critical nodes.

In our implementation, each label 
                              
                                 σ
                                 =
                                 (
                                 C
                                 ,
                                 T
                                 ,
                                 L
                                 ,
                                 
                                    S
                                    ^
                                 
                                 ,
                                 ϕ
                                 )
                              
                            has a component C to represent the reduced cost of the partial path, a resource T for the time, a resource L for the vehicle load, a resource 
                              
                                 S
                                 ^
                              
                            for the number of unreachable critical nodes, and a set ϕ⊆Φ that contains the critical nodes unreachable from the current label, where Φ represents the set of all the recognized critical nodes at a given state of the procedure. At the end of each iteration of the SPPRC, a state-space augmentation policy defines which nodes should be added into Φ, and a resource associated with each of the critical nodes is added into the resource set to prevent cycling on that node.

For 
                              
                                 
                                    σ
                                    1
                                 
                                 =
                                 
                                    (
                                    
                                       C
                                       1
                                    
                                    ,
                                    
                                       T
                                       1
                                    
                                    ,
                                    
                                       L
                                       1
                                    
                                    ,
                                    
                                       
                                          S
                                          ^
                                       
                                       1
                                    
                                    ,
                                    
                                       ϕ
                                       1
                                    
                                    )
                                 
                              
                            and 
                              
                                 
                                    σ
                                    2
                                 
                                 =
                                 
                                    (
                                    
                                       C
                                       2
                                    
                                    ,
                                    
                                       T
                                       2
                                    
                                    ,
                                    
                                       L
                                       2
                                    
                                    ,
                                    
                                       
                                          S
                                          ^
                                       
                                       2
                                    
                                    ,
                                    
                                       ϕ
                                       2
                                    
                                    )
                                 
                              
                            two labels corresponding to two partial paths from a depot to a given node, we say that σ
                           1 dominates σ
                           2 if the following criteria are met:

                              
                                 (a
                                    DSSR)
                                 
                                    T
                                    1 ≤ T
                                    2,


                                    L
                                    1 ≤ L
                                    2,


                                    C
                                    1 ≤ C
                                    2,


                                    C
                                    1 − μ
                                    
                                       u*(L
                                    2 − L
                                    1) ≤ C
                                    2, where 
                                       
                                          u
                                          *
                                          =
                                          a
                                          r
                                          g
                                          
                                             max
                                             
                                                u
                                                ∈
                                                U
                                             
                                          
                                          
                                             {
                                             
                                                μ
                                                u
                                             
                                             }
                                          
                                       
                                    ,


                                    
                                       
                                          
                                             
                                                S
                                                ^
                                             
                                             1
                                          
                                          ≤
                                          
                                             
                                                S
                                                ^
                                             
                                             2
                                          
                                       
                                    ,


                                    ϕ
                                    1⊆ϕ
                                    2.

Condition (d
                           DSSR) is used to prevent the dominance of partial paths that appear to be dominated by other paths with respect to the conditions (a
                           DSSR)–(c
                           DSSR) and (e
                           DSSR)–(f
                           DSSR) in a producer node, but that later become less costly by delivering more product to a plant.


                           ng-route decremental state-space relaxation (
                           ng
                           R-DSSR): The ng-route relaxation (Baldacci et al., 2011a), originally proposed for the CVRP and the VRPTW, provides a good compromise between obtaining good lower bounds and efficiently pricing routes that are not necessarily elementary.

The ng-route relaxation can be described as follows. Suppose that 
                              
                                 V
                                 
                                    r
                                    d
                                 
                              
                            represents the set of producers visited by partial path r starting from depot d. Moreover, for each producer 
                              
                                 i
                                 ∈
                                 
                                    C
                                    d
                                 
                                 ,
                              
                            let 
                              
                                 
                                    N
                                    i
                                 
                                 ⊆
                                 
                                    C
                                    d
                                 
                                 ,
                              
                            the so-called original neighborhood of producer i, represent a set (with an a priori fixed size) of producers, selected according to a neighborhood criterion for producer i. For label σ, associated with a given partial path r = (d, i
                           1, …, in
                           ), we define a set 
                              
                                 Π
                                 
                                    (
                                    r
                                    )
                                 
                                 ⊆
                                 
                                    V
                                    
                                       r
                                       d
                                    
                                 
                                 ,
                              
                            containing all prohibited extensions from producer in
                           . The set Π(r) is

                              
                                 (21)
                                 
                                    
                                       Π
                                       
                                          (
                                          r
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             i
                                             j
                                          
                                          ∈
                                          
                                             V
                                             
                                                r
                                                d
                                             
                                          
                                          
                                             |
                                          
                                          
                                             i
                                             j
                                          
                                          ∈
                                          
                                             ⋂
                                             
                                                k
                                                =
                                                j
                                                +
                                                1
                                             
                                             n
                                          
                                          
                                             N
                                             
                                                i
                                                k
                                             
                                          
                                          ,
                                          j
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          n
                                          −
                                          1
                                          }
                                       
                                       ∪
                                       
                                          {
                                          
                                             i
                                             n
                                          
                                          }
                                       
                                       .
                                    
                                 
                              
                           Consequently, each label σ = (C, T, L, Sng, Π) has new members Sng
                           , representing the size of the Π set, where Π represents the set of inaccessible producers according to the ng-rules. Again, to reduce the number of possible labels, a dominance rule is incorporated into the algorithm.

Given two labels σ
                           1 = (C
                           1, T
                           1, L
                           1, Sng
                           
                           1, Π
                           1) and σ
                           2 = (C
                           2, T
                           2, L
                           2, Sng
                           
                           2, Π
                           2), representing two partial paths ending at a given producer, label σ
                           1 dominates label σ
                           2 if and only if any possible extension from σ
                           1 is feasible from label σ
                           2 with a lower reduced cost. This condition is satisfied if the following criteria are met:

                              
                                 (ang
                                    )
                                 
                                    T
                                    1 ≤ T
                                    2,


                                    L
                                    1 ≤ L
                                    2,


                                    C
                                    1 ≤ C
                                    2,


                                    C
                                    1 − μ
                                    
                                       u*(L
                                    2 − L
                                    1) ≤ C
                                    2, where 
                                       
                                          u
                                          *
                                          =
                                          a
                                          r
                                          g
                                          
                                             max
                                             
                                                u
                                                ∈
                                                U
                                             
                                          
                                          
                                             {
                                             
                                                μ
                                                u
                                             
                                             }
                                          
                                       
                                    ,


                                    Sng
                                    
                                    1 ≤ Sng
                                    
                                    2,


                                    Π
                                    1⊆Π
                                    2.

The ng-route decremental state-space relaxation (ngR-DSSR) consists of an ng-route relaxation procedure in which initially empty sets 
                              
                                 
                                    
                                       N
                                       i
                                    
                                    ^
                                 
                                 ⊆
                                 
                                    N
                                    i
                                 
                                 ,
                              
                            called applied neighborhoods, are considered rather than the original neighborhoods 
                              
                                 N
                                 i
                              
                           . At the end of each iteration, all columns with negative reduced costs and no cycles as well as those that satisfy the ng-rules with respect to the original neighborhoods (called ng-feasible columns) are added to the RLMP. If the best column according to its reduced cost is not ng-feasible, some of the applied neighborhoods are augmented and the procedure restarts. Two augmentation strategies are considered:

                              
                                 1.
                                 At the end of an iteration, the nodes that violate the ng-rules on the best columns are recognized as critical. Newly recognized critical node i is then added into the applied neighborhoods of all other nodes that consider i as their neighbor, according to their original neighborhoods.

Here we augment the applied neighborhoods of only those nodes forming a cycle involving i, when the ng-rules are violated, by adding i into these neighborhoods.

Our experiments showed that the second strategy is more efficient. The smaller sets of applied neighborhoods facilitate dominance by more easily satisfying condition (fng
                           ). Note that in our implementation, 
                              
                                 
                                    N
                                    i
                                 
                                 ^
                              
                            is initialized (set to ∅) at the root node and not elsewhere in the search tree. This is because of the high likelihood of the recreation of cycles that violate the ng-rules, if 
                              
                                 
                                    N
                                    i
                                 
                                 ^
                              
                            is reset to ∅ at each node of the tree; this is equivalent to extra iterations to augment the applied neighborhoods to ensure ng-feasibility.

To speed up the generation of the negative-reduced-cost columns, we implement a relaxed version of the labeling procedure described above. The relaxations are based on weakening the dominance rules (reducing the number of conditions tested) so that a larger number of labels are discarded. This may result in the generation of some but not all of the existing negative-reduced-cost paths, in a shorter computational time. We accelerate the labeling procedure by ignoring the dominance conditions corresponding to the comparison of unreachable nodes. For the DSSR, this is done by relaxing conditions (e
                           DSSR) and (f
                           DSSR), while for the ngR-DSSR, (eng
                           ) and (fng
                           ) are ignored. This harsh dominance accelerates the labeling process by extending a smaller set of labels from each node and by comparing new labels to a shorter list of existing labels.

To schematically show how the column generators cooperate within our algorithm, let NBCOL
                           HDP and NBCOL
                           EDP represent the number of negative-reduced-cost columns generated by HDP and EDP, respectively. We now present the procedure which, at each iteration, finds the non-dominated paths and adds them to the RLMP.

Clearly, the difficulty of this algorithm depends on the size of the problem: the number of depots, plants, producers, and vehicle types. The difficulty is also affected by the tightness of the time window and vehicle capacity constraints.

As mentioned in Section 4, variant 2 has no preassignments. The following modification to the algorithm for variant 1 makes it applicable to variant 2: we solve the ESPPRC for a depot, a specific vehicle type, and for the entire set of producers instead of a preassigned subset.

As mentioned in Section 5, we find an integer solution via a branch-and-price algorithm. In the literature, binary branching strategies, which divide a problem into two more restricted problems, have been proposed for the VRPTW. Branching must be performed at each node where the optimal solution to the linear relaxation includes fractional path variables. The classical branching strategy is branching on the flow variables, i.e., 
                           
                              
                                 ∑
                                 k
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 k
                              
                              ,
                           
                         where 
                           
                              x
                              
                                 i
                                 j
                              
                              k
                           
                         represents the flow on arc (i, j) for vehicle k. This results in two new nodes in the tree, one with the new constraint 
                           
                              
                                 ∑
                                 k
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 k
                              
                              =
                              0
                           
                         and the other with 
                           
                              
                                 ∑
                                 k
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 k
                              
                              =
                              1
                           
                        . The advantage of this strategy is that the added constraints are easily integrated into both the master and pricing problems. Moreover, it finds an optimal integer solution if such a solution exists. However, this approach is not efficient enough to obtain integer solutions rapidly. In other words, the elimination of one arc from the graph via the branching constraint (especially the constraint 
                           
                              
                                 ∑
                                 k
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 k
                              
                              =
                              0
                           
                        ) may have little effect on the solution and does not necessarily decrease the complexity of the problem (see Gélinas et al., 1995).

To overcome this weakness, we study two bilevel branching procedures. In each case, the procedure is followed by branching on flow variables. We describe these procedures below.


                        Branching by plant assignment (BPA): The special structure of our problem allows us to derive efficient new constraints through a branching scheme. Since there are multiple plants to which the products of a specific producer can be delivered, we can assign producers to plants via the branching procedure. Since producers are preassigned to depots, this strategy attempts to divide the problem into several smaller problems, each containing one depot, one plant, and a limited number of producers. We branch on the flow variables when there are no more producer-plant candidates for branching. The producers that are not permitted to serve a plant because of branching decisions are removed from the subgraph associated with the plant. We branch on the producer-plant candidate with flow closest to 0.5. This flow is obtained by summing the basic variables of the master problem associated with the routes containing a given producer and a given plant. The removal of a producer from the subgraph associated with a plant is much more restrictive than the elimination of a single arc. Therefore, we expect this strategy to be more effective than branching on the flow variables.


                        Branching on time windows (BTW): This binary branching strategy, originally proposed by Gélinas et al. (1995) for the VRPTW, splits the time window of a node into two new subintervals; each branch corresponds to one of the subintervals. Some routes become infeasible following a split in a producer’s time window. Gélinas et al. (1995) claimed that this strategy is stronger than branching on flow variables since constraints such as time and capacity have a major impact on the difficulty of the VRPTW.

We have proposed different options for column generation and two branching strategies. To evaluate the performance of these approaches, we carried out a series of computational experiments, and we report the results in this section. First, we describe the creation of a large set of randomly generated instances for our tests. Then, we discuss the efficiency of DSSR and ngR-DSSR. Next, we compare the two branching strategies, BPA and BTW. We ran the experiments on a computer with a 2.67 GHz processor and 24 GB of RAM. The algorithms were implemented in C++ and the linear models were solved using Cplex 12.2.

Since, to the best of our knowledge, there is no prior study of the multi-depot vehicle routing problem with time windows and deliveries to plants, we generated new test problems. We considered narrow and wide time windows, where the wide windows are on average twice as wide as the narrow windows. We also considered different plant locations on the graph.

In the case that we call inside plants, the depots and plants are randomly located in a ( − 50, 50)2 square, according to a continuous uniform distribution. The producers are randomly located in a ( − 100, 100)2 square; they are placed one by one via a generation-validation procedure. Suppose that vi
                         is the current producer, min
                           d
                         is the distance from vi
                         to its closest depot, and z is a number in the interval [0, 1] chosen according to a continuous uniform distribution. This producer is retained if z < exp( − h.min
                           d
                        ) where h = 0.05, and otherwise is dropped. The application of this probabilistic function, inspired by Cordeau et al. (1997), increases the likelihood of producer clusters around the depots.

In the case that we call outside plants, the plant locations are randomly generated in the area beyond the region containing the producers: ( − 150, 150)2 − ( − 100, 100)2, where the producers are located randomly in a ( − 100, 100)2 square via a new generation-validation procedure. We retain producers satisfying z < exp( − h(min
                           d
                        .α + min
                           p
                        (1 − α))) where min
                           d
                         and min
                           p
                         are the distances from the newly generated producer to the closest depot and the closest plant, respectively. Moreover, z and α are two uniform random numbers that are respectively generated in [0, 1] and [0.3, 0.7]. Once again, this probabilistic function leads to clusters of producer nodes in the region between the plants and the depots. Fig. 2
                        shows an example of an instance with three depots, three outside plants, and 100 producers.


We use the Euclidean distance between two nodes. The preassignments of producers to depots for variant 1 are done one by one in numerical order: we greedily assign each producer to its closest depot while trying to ensure that each depot has the same number of producers.

The service duration and the quantity supplied by each producer are randomly and independently chosen according to a discrete uniform distribution on [1, 25]. To increase the probability of feasible instances, we set the sum of the plant demands to 90 percent of the total supply available.


                        Table 1
                        shows the characteristics of the four problem classes. The size of each instance is determined by the number of depots, producers, and plants; the values that we considered are presented in Table 2
                        . Instances with the same number of depots and plants have those facilities in the same positions. We generated five instances for each size combination of each problem class. For example, instance pr04-50-2D3P-5 represents the fifth instance of the fourth class with fifty producers, two depots, and three plants.

To evaluate the efficiency of our column generation, we ran a group of tests for a set of problems with 50 producers, representing the most difficult instances. We considered one instance from each group of five for a given size combination of each class, forming a group of 16 instances. We solved the root linear relaxation using either DSSR or ngR-DSSR with two different neighborhood sizes, 
                           
                              
                                 |
                              
                              
                                 N
                                 i
                              
                              
                                 |
                                 =
                                 5
                              
                           
                         and 
                           
                              
                                 |
                              
                              
                                 N
                                 i
                              
                              
                                 |
                                 =
                                 8
                              
                           
                         for each producer 
                           
                              i
                              ∈
                              N
                           
                        . Table 3
                        gives the results both with and without HDP. The pairs in the “nb. Iter.” column give the number of heuristic and exact column-generation iterations. Column “T” gives the computational time (in seconds) to solve the linear relaxation.

On average the use of HDP improves the computational time by decreasing the number of calls to EDP. We also studied the use of metaheuristics to generate columns; we implemented a method based on TS. This approach, inspired by the procedure of Desaulniers et al. (2008), attempts to generate new negative-reduced-cost columns from the set of existing columns. However, our experiments showed that it did not improve the computational time. Our results support those reported by Desaulniers et al. (2008). However, our results for instances with 100 and 200 nodes show that TS is more efficient for larger instances and longer routes.

As mentioned in Section 5, a branching scheme is often necessary. We now evaluate the performance of the two branching strategies introduced in Section 5.4. We present the results for three approaches. All three use EDP and HDP, because they decrease the average computational time. The first method uses DSSR, the second uses ngR-DSSR with 
                           
                              
                                 |
                              
                              
                                 N
                                 i
                              
                              
                                 |
                                 =
                                 5
                                 ,
                              
                           
                         and the third uses ngR-DSSR with 
                           
                              
                                 |
                              
                              
                                 N
                                 i
                              
                              
                                 |
                                 =
                                 8
                              
                           
                        . Our experiments have shown that 
                           
                              
                                 |
                              
                              
                                 N
                                 i
                              
                              
                                 |
                                 >
                                 8
                              
                           
                         increases the computational time and therefore reduces the number of instances solved to optimality within the time limit.

As previously noted, in variant 1 the producers are preassigned to the depots; we consider both variants 1 and 2 in this section. We set the maximum computational time for each instance to five hours. There are three possibilities: (a) The optimal solution is attained, (b) the optimal solution is not attained, but one or more integer solutions are found during the branching process, (c) no integer solutions are found.


                           Tables A.1–A.4
                           
                           
                           
                           in Appendix A provide the detailed results for variant 1. Generally the performance of the algorithm decreases as the number of producers increases, for both branching strategies. However, given a fixed number of producers, increasing the number of depots generally reduces the difficulty. This is because of a decrease in the producer-depot ratio when the producers are preassigned.

We now group the instances from classes pr01–pr04 according to the number of producers; this gives three groups of 30, 40, and 50 producers with 80 instances in each group. Table 4
                           presents the percentage of instances solved to optimality by each branching strategy; the percentage of instances in which at least one integer solution was found; the mean time to solve the five instances in a class (T1); and the mean time for the instances that achieved optimality (T2).

It can be seen that BTW is more successful for larger instances. Table 5
                           shows that both branching strategies weaken in terms of the number of problems solved to optimality and the mean CPU time when the time windows are wider, i.e., pr02 and pr04. BTW weakens more significantly because although we split the time windows during the branching, the new windows are still wide enough that numerous routes with similar costs may be feasible.

Based on Table 4, using DSSR with BTW gives the best results. It represents the highest percentage of solved instances to optimality and therefore the least T1 and T2, among the six different combination of subproblem solving strategies and branching strategies. Table 5 also shows that (with the exception of class pr02), when BTW is used, DSSR almost always outperforms ngR-DSSR in terms of the percentage of solved problems. DSSR also has a smaller T1 values.

We solved the same instances using the algorithm adapted for variant 2. We used the same two branching strategies. Tables A.5–A.8
                           
                           
                           
                           in Appendix A report the detailed results for pr01–pr04 with 30, 40, and 50 producers.

We again group the instances according to the number of producers. Tables 6
                           and 7
                           compare the performance of BPA and BTW in terms of the instances solved to optimality and those with at least one integer solution. BTW generally outperforms BPA in terms of the number of instances solved. However, BPA is competitive with BTW when the time windows are wider (pr02 and pr04).


                           Table 6 shows that the combination of BTW and ng5 definitely outperforms the other combinations. A comparison of pr01 and pr03 with pr02 and pr04 shows the higher difficulty of the instances with wider time windows. The results indicate that the plant location (inside or outside) has no significant impact on the difficulty of the problem.

To evaluate the impact of preassignments in terms of solution quality and computational time, we selected a subset of instances with 40 producers (instances with the identifier “2” among the five instances with the same size combination). The results for this subset of instances, using the DSSR and BTW strategies for both variants 1 and 2 are reported in Table 8
                        . In this table, the column “st.” represents the status of the obtained solution based on the three possible cases described in Section 6.3. The columns “LB”, “UB” and “CPU” represents the value of the solution in the root node, best upper bound obtained in the time limit and the computational time, respectively.

The performance of our algorithm depends on the producer-depot ratio, and variant 2 is therefore more difficult to solve. In fact, a higher producer-depot ratio represents larger subproblems, and consequently, the overall computation is more time demanding. This fact is illustrated by the larger number of instances with optimal solutions in a much smaller average computational time in the case of instances in variant 1, compared to the instances in variant 2.

However, one must notice that the quality of producer-depot preassignments has a significant impact on the value of the solution. As mentioned in Section 6.1, in our instances, we assigned producers to the depots based on a greedy heuristic. Table 8 compares also the solution quality of the same instances with and without the mentioned preassignment strategy. The comparison shows that there is a trade-off between computational effort and solution quality following a simple producer-depot preassignment. In fact, as this is the case in most MDVRPs, the producer-depot assignment may have a significant impact on the quality of the solution (an average deterioration of 37 percent in the value of the solution obtained for the considered instances). These results show the potential gain of integrating assignment decisions into the model, where the decision maker has this choice.

@&#CONCLUSIONS@&#

We have considered a new variant of the vehicle routing problem with attributes such as multiple depots, heterogeneous fleets of vehicles, time windows, and deliveries to plants. Its main novelty is the need to satisfy the plant demands by delivering the supplies collected earlier. We introduced a new set covering model for this problem, and we proposed a specialized cutting-edge column generation procedure to solve its linear relaxation. We also presented a new branching strategy based on the special structure of the problem and compared its performance with the well-known BTW.

To evaluate our algorithm, we developed randomly generated test problems with and without producer-depot preassignments. We obtained promising results in terms of solution quality and computational time, especially for problems with up to 50 producers.

Future research will focus on developing more intelligent branching strategies and considering the more complex route structures presented in Section 2. Our long-term goal is the effective solution of the given problem in the presence of stochastic parameters, which would make the model more realistic.

@&#ACKNOWLEDGEMENTS@&#

Partial funding for this project was provided by the Natural Sciences and Engineering Research Council of Canada (NSERC), through its Industrial Research Chair, Collaborative Research and Development, and Discovery Grant programs. We also received support from the Fonds de recherche du Québec—Nature et technologies (FRQ-NT) through its Team Research Project program, and from the EMME/ 2-STAN Royalty Research Funds (Dr. Heinz Spiess). We also gratefully acknowledge the support of Fonds de recherche du Québec through infrastructure grants and the support of Calcul Québec and Compute Canada through access to their high-performance computing infrastructure.

We now present the detailed results obtained for variants 1 and 2. Each instance is solved using DSSR, ng5, and ng8 relaxations. Moreover, each of these relaxation strategies are combined with the two considered branching strategies BPA and BTW. The performance of different strategies are compared using the following metrics:

                        
                           1.
                           Computational time: This is reported for the problems that achieved optimality (case (a)) and represents the time to obtain the optimal solution. The CPU is set to 18,000 (s) when the optimal solution is not found within five hours (cases (b) and (c)).

Root gap: This is calculated via (optimal solution - root solution)/root solution. For cases (b) and (c), the root gap is set to ∞.

Optimality gap: This is obtained via (best upper bound - best lower bound)/best lower bound. For case (a), the gap is zero and for case (c) it is infinity and therefore not reported.

Lower bound (LB) improvement: This is obtained via (best lower bound - root solution)/root solution, and it is presented for case (c). In a best-first branching strategy, this value represents the improvement in the lower bound; it allows us to compare the performance of different branching strategies for problems with no integer solution. Recall that in a best-first branching strategy the node with the best LB is treated first.

Note that, as mentioned in Section 6.1 for each size configuration of each class (e.g. pr01-30-2D2P), we considered five instances. T1 is the mean time to solve the five instances in a class, and T2 is the mean time for the instances that achieved optimality. Moreover, # Opt. Sol. and # Int. Sol. are the number of instances corresponding to case (a) and case (b), respectively. The root gap, Opt. gap, and LB Imp. columns give the mean percentages for the root gaps, optimality gaps, and LB improvements when relevant. Note that, because of the significant ratio of fixed costs to variable costs, the gaps are generally small.

@&#REFERENCES@&#

