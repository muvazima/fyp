@&#MAIN-TITLE@&#The Steiner Traveling Salesman Problem with online edge blockages

@&#HIGHLIGHTS@&#


               
                  
                     
                        Highligts
                        
                           
                           The Steiner Traveling Salesman Problem with as many as k online edge blockages is considered.


                        
                        
                           
                           First a lower bound on the competitive ratio is shown; then an exponential-time online optimal algorithm for the problem is presented; and lastly a polynomial-time online asymptotically optimal algorithm is presented.


                        
                        
                           
                           Experimental results show that the polynomial-time online algorithm takes only a fraction of the running time of the offline optimal algorithm, yet produces solutions of competitive quality to the offline optimal solutions.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Traveling Salesman Problem

Steiner TSP

Online edge blockage

Online algorithm

Competitive ratio

@&#ABSTRACT@&#


               
               
                  We consider the online Steiner Traveling Salesman Problem. In this problem, we are given an edge-weighted graph G = (V, E) and a subset D⊆V of destination vertices, with the optimization goal to find a minimum weight closed tour that traverses every destination vertex of D at least once. During the traversal, the salesman could encounter at most k non-recoverable blocked edges. The edge blockages are real-time, meaning that the salesman knows about a blocked edge whenever it occurs. We first show a lower bound on the competitive ratio and present an online optimal algorithm for the problem. While this optimal algorithm has non-polynomial running time, we present another online polynomial-time near optimal algorithm for the problem. Experimental results show that our online polynomial-time algorithm produces solutions very close to the offline optimal solutions.
               
            

@&#INTRODUCTION@&#

The Traveling Salesman Problem (TSP) is one of the fundamental combinatorial optimization problems that have numerous applications in operational research. In its classic version, we are given a complete edge-weighted graph with the optimization goal to find a Hamiltonian cycle that achieves the minimum weight (or makespan) (Garey and Johnson, 1979). The edge weights are non-negative, which can be used to model various traversing cost such as distance or traveling time between two locations. In a Hamiltonian cycle, every vertex of the graph appears exactly once. TSP is NP-hard (Garey and Johnson, 1979) and APX-hard even if all edge-weights are 1 or 2 (Papadimitriou and Yannakakis, 1993). When the edge weights satisfy the triangle inequality (a.k.a. metric TSP), it can be approximated within a factor of 1.5 (Christofides, 1976).

In many applications, the edge-weighted graph modeling a real instance might neither be complete, nor all vertices need to be visited by the salesman. This inspired the study of the Steiner Traveling Salesman Problem (Cornuéjols, Fonlupt, and Naddef, 1985; Fleischmann, 1985; Ratliff and Rosenthal, 1983), denoted as sTSP in this paper, which is a special case of the General Routing Problem introduced by Orloff (1974). Formally, in sTSP, we are given an edge-weighted graph G = (V, E) and a set D⊆V of destination (or client) vertices, with the optimization goal to find a minimum weight closed tour that visits every destination vertex at least once.


                     Ratliff and Rosenthal (1983) studied a very special case of sTSP, abstracted from a background application of order-picking in a rectangular warehouse; the rectangular warehouse is composed of a number of aisles and there are certain orders to be picked up from the aisles such that the total travel time is minimized. The edge-weighted graph modeling the warehouse is series-parallel. Ratliff and Rosenthal (1983) presented a linear time algorithm for this special case. Cornuéjols et al. (1985) examined more structural properties of sTSP on series-parallel graphs and extended the linear time algorithm to all series-parallel graphs. De Koster, Le-Duc, and Roodbergen (2007) surveyed a number of works on sTSP variants for order-picking in different kinds of warehouses. For another application of sTSP on road networks, Fleischmann (1985) presented a cutting plane procedure to solve instances containing as many as 292 cities. Recently, Letchford, Nasiri, and Theis (2013) presented several new compact polynomial-size formulations for the sTSP instances and demonstrated that the integer programming branch-and-bound solver in IBM ILOG CPLEX Optimization Studio can solve the instances in these formulations faster; in the best of their formulations, the integer programming branch-and-bound solver can solve instances with over 200 cities. Another important sTSP variation is called Graphical Traveling Salesman Problem, denoted as gTSP, in which D = V (Cornuéjols et al., 1985). The optimization goal is the same—to find a minimum weight closed tour that visits every vertex at least once. For the edge-weighted version, Fonlupt and Nachef (1993) presented polynomial time dynamic programming algorithms for certain special classes of graphs; for the edge-unweighted version, several interesting results on approximating gTSP were obtained in the last three years: Gharan, Saberi, and Singh (2011) presented a randomized algorithm with an expected worst-case approximation ratio 1.5 − ε, where ε is a positive constant in the order of O(10−12); Momke and Svensson (2011) made a significant improvement by decreasing the approximation ratio to 1.461; and the currently best 1.4-approximation algorithm is by Sebő and Vygen (2014).

In this paper we consider sTSP on general edge-weighted graphs, for another important application in package delivery services accompanying the booming e-businesses, online shopping in particular. In a sizable city as large as Xi’an, China, every day hundreds of vehicles deliver tens to hundreds of thousands of packages to clients to complete the last step of online transactions. Without a guaranteed fast package delivery service, online shopping would not be as attractive as it is nowadays. Besides establishing warehouses in multiple well distributed places, one way to improve the delivery service is to design effective routing strategies for service vehicles in the urban traffic network, which can be modeled as an edge-weighted graph. Furthermore, such a sizable traffic network is apt to road blockages due to traffic hours, accidents and other sudden road surface changes such as sinking. Some road blockages are predictable and perhaps can be forecasted, while some other are unpredictable. In real-time sTSP, the salesman (or the package delivery vehicle driver) has the real-time edge blockage information, that is, whenever an edge in the graph fails, he knows about it instantly (for example, through traffic radio). We further assume that the blocked edges are non-recoverable to the salesman but the remainder graph remains connected such that a feasible closed tour can always be achieved. We design algorithms for the salesman on how to plan for a provably good closed tour to visit all the destination vertices, while facing the online edge blockages.

In the literature of online TSP, some variations have been studied, for example the sequence of requested vertices (i.e. the destinations in our case) comes in the online fashion (Ausiello, Feuerstein, Leonardi, Stougie, and Talamo, 2001; Jaillet and Lu, 2011; Jaillet and Wagner, 2006; 2008). There are also works on uncertain traversal time between two vertices. The interested readers might refer to the review by Pillac, Gendreau, Guéret, and Medaglia (2013) for more details. A related routing problem with online edge blockages is the Canadian Traveler Problem (CTP), introduced by Papadimitriou and Yannakakis (1991). In CTP, the goal is to find a shortest path from a source vertex s to a destination vertex t in a given edge-weighted graph G = (V, E), while edges could be blocked during the traversal from s to t. It is PSPACE-complete to find an online algorithm with a constant competitive ratio for CTP (Papadimitriou and Yannakakis, 1991). When the number of blocked edges is at most k, the variation is denoted as k-CTP. Bar-Noy and Schieber (1991) studied k-CTP and several other CTP variations from the worst-case perspective. Zhu, Xu, and Liu (2003) and later Westphal (2008) independently proved a tight lower bound of 2k + 1 on the competitive ratio, and both presented an optimal online algorithm for k-CTP. Xu, Hu, Su, Zhu, and Zhu (2009) presented another greedy and more practical online algorithm for k-CTP. When there are multiple travelers, Zhang, Xu, and Qin (2013) proved a lower bound on the competitive ratio for a k-CTP variation in which the objective is to minimize the maximum traversal time among the travelers; they designed two online algorithms with provable performance. Recently, Liao and Huang (2014) considered another variation of online TSP, called covering Canadian Traveler Problem (CCTP), which is the closest to our target problem sTSP. In CCTP, a complete edge-weighted graph satisfying triangle inequality is given, and the traveler needs to visit all vertices and then return to the origin; in CCTP the blocked edges are generated by the adversary in a different way than in sTSP—all blocked edges incident at a vertex are revealed to the traveler when he arrives the vertex, and no more edge incident at the vertex can be blocked afterward. Liao and Huang (2014) presented an efficient 
                        
                           O
                           (
                           
                              k
                           
                           )
                        
                      touring strategy when the number of blockages is up to k.

In this paper, we investigate sTSP with real-time online edge blockages, in the perspective of competitive analysis (Borodin and El-Yaniv, 1998). The rest of the paper is organized as follows. In Section 2 we formally define the real-time sTSP problem, and introduce some basic notations and assumptions. We present a lower bound on the competitive ratio for real-time sTSP in Section 3, and an optimal online algorithm in Section 4. While this optimal algorithm has non-polynomial running time, we present in Section 5 another online polynomial-time near optimal algorithm for the problem. We discuss the implementation of the online polynomial-time algorithm, and the experimental results in Section 6. We conclude in Section 7 with some discussion on the achieved results and some possible future work.

We use an undirected, connected, edge-weighted graph G = (V, E, D) to model the traffic network, where the edge weight w(u, v) represents the traversal time from vertex u to vertex v for edge {u, v} ∈ E. We assume without loss of generality that, if edge {u, v} ∈ E then its weight w(u, v) is the shortest traversal time from vertex u to vertex v in the network G. Clearly, such edge weights satisfy the triangle inequality. The destination vertices, including the package depot s, form the set D⊆V. Throughout the paper, we assume there are at most k online edge blockages, and let δ = 〈e
                     1, e
                     2, …, ek
                     〉 denote the sequence of these online blocked edges, which will be revealed to the salesman during the traversal. This way, the instance of sTSP can be denoted as a quadruple I = (V, E, D, δ) (or sometimes simplified as a pair I = (G, δ)). Our goal is to design a provably good strategy to handle the online edge blockages, for the salesman to find a short closed tour (starting from s and coming back to s) that visits every destination vertex of D at least once.

Our discussion is based on the following assumption.

                        Assumption 1
                        
                           
                              
                                 (a)
                                 The blocked edges are unrecoverable; the remainder graph is connected such that feasible closed tours always exist.

In the course of traversal, the edges that have been traversed by the salesman will not be blocked.

In practice, the repair time for unavailable roads will be longer than our total delivery time, and therefore in Assumption 1(a) we assume that a blocked edge is unrecoverable. We also assume that the graph is always connected as otherwise the pack delivery will not be possible. Assumption 1(b) is made for not to allow the adversary to “push” the salesman into an extremely bad situation, in which no constant performance ratio can be guaranteed for visiting even only one destination; it is made also to map the more practical situations where our total delivery time is relatively short.

In real-time sTSP, the salesman knows about a blocked edge e = {u, v} when it happens. Since the oblivious adversary can choose when and which edge to block, this is equivalent to the salesman knowing about the blocked edge e = {u, v} when he arrives at vertex u or vertex v. We use OPT(G, δ) to denote the optimal (offline) closed tour in graph (V, E − δ, D); we also abuse it to denote its total traversal time when there is no ambiguity. Similarly, we use A(G, δ) to denote the closed tour obtained by an online algorithm A on the instance I = (G, δ), and abuse it to denote its total traversal time when there is no ambiguity. Then, the competitive ratio of the algorithm A on the instance I = (G, δ) is defined as

                        
                           
                              
                                 
                                    c
                                    A
                                 
                                 
                                    (
                                    G
                                    ,
                                    δ
                                    )
                                 
                                 =
                                 
                                    
                                       A
                                       (
                                       G
                                       ,
                                       δ
                                       )
                                    
                                    
                                       OPT
                                       (
                                       G
                                       ,
                                       δ
                                       )
                                    
                                 
                                 .
                              
                           
                        
                     The competitive ratio of the algorithm A (for a minimization problem such as our real-time sTSP) is defined as the supremum of cA
                     (G, δ) over all instances I = (G, δ), that is, 
                        
                           
                              c
                              A
                           
                           =
                           
                              sup
                              
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                           
                           
                              c
                              A
                           
                           
                              (
                              G
                              ,
                              δ
                              )
                           
                        
                     . If cA
                      is finite, the algorithm A is said cA-competitive. The quantity 
                        
                           β
                           =
                           
                              inf
                              A
                           
                           
                              c
                              A
                           
                        
                      is the limit of the competitive ratios for sTSP, that can ever be achieved by online algorithms. Note that cA
                      ≥ 1 for any online algorithm A, and thus 1 is a trivial lower bound on β.

Recall that we consider an instance of sTSP denoted as a quadruple I = (V, E, D, δ), where V is the vertex set, E is the edge set and the edge weight w(u, v) is the shortest traversal time from vertex u to vertex v in the network G = (V, E, D) for edge {u, v} ∈ E, D⊆V is the set of destination vertices including the service depot or source vertex s, and δ = 〈e
                     1, e
                     2, …, ek
                     〉 denotes the sequence of online blocked edges that will be revealed to the salesman during the traversal. Also recall that edge blockages are real-time information, meaning that the salesman knows about a blocked edge e = {u, v} whenever it occurs, such as through the radio. Due to the oblivious adversary, this is equivalent to the salesman knowing about the blocked edge e = {u, v} when he arrives at vertex u or vertex v.

The edges in the graph are undirected. Nevertheless, whenever we are clear about the traversal direction for an edge, we express the edge as directed. For instance, if the salesman encounters the blocked edge e = {u, v} when he arrives at vertex u, then we write the blocked edge as e = (u, v) indicating the intended traversal direction from vertex u to vertex v; if he encounters the blocked edge when he arrives at vertex v, then we write the blocked edge as e = (v, u).

                        Theorem 1
                        For real-time sTSP, β ≥ k + 1, that is, there is no online algorithm of competitive ratio less than k + 1.

We prove this lower bound of k + 1 by showing that for any online algorithm, there is an instance I = (V, E, D, δ) of real-time sTSP, such that the competitive ratio of the algorithm on the instance I is almost k + 1.

In the instance I, the graph G = (V, E, D) is shown in Fig. 1
                           , with D = {s, v
                           
                              k + 2, v
                           
                              k + 3, …, v
                           2k + 2}, V − D = {v
                           1, v
                           2, …, v
                           
                              k + 1, v
                           2k + 3}, and E = {{s, vi
                           }, {vi, v
                           
                              k + 1 + i
                           }, {v
                           
                              k + 1 + i
                           , v
                           2k + 3}∣1 ≤ i ≤ k + 1}. The edge weights are, for 1 ≤ i ≤ k + 1,

                              
                                 (3.1)
                                 
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   w
                                                   (
                                                   s
                                                   ,
                                                   
                                                      v
                                                      i
                                                   
                                                   )
                                                   =
                                                   1
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                                
                                                   w
                                                   (
                                                   
                                                      v
                                                      i
                                                   
                                                   ,
                                                   
                                                      v
                                                      
                                                         k
                                                         +
                                                         1
                                                         +
                                                         i
                                                      
                                                   
                                                   )
                                                   =
                                                   ϵ
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                                
                                                   w
                                                   (
                                                   
                                                      v
                                                      
                                                         k
                                                         +
                                                         1
                                                         +
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      v
                                                      
                                                         2
                                                         k
                                                         +
                                                         3
                                                      
                                                   
                                                   )
                                                   =
                                                   ϵ
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where ε is a small positive real number.

Using any online algorithm A, from depot s, if the salesman chooses to traverse edge (s, vi
                           ), for some i such that 1 ≤ i ≤ k + 1, then edge (vi, v
                           
                              k + 1 + i
                           ) is blocked by the adversary when the salesman arrives at vertex vi
                           . Clearly the salesman has to go back to depot s afterward, and uses A to choose another edge (s, vj
                           ) to traverse, for some j such that 1 ≤ j ≤ k + 1; If j ≠ i, then edge (vj, v
                           
                              k + 1 + j
                           ) is blocked when the salesman arrives at vertex vj
                           . And so on for the first k distinct attempts by the salesman to traverse exactly k out of the k + 1 edges of form (s, vi
                           ), i = 1, 2, …, k + 1, the corresponding k edges of form (vi, v
                           
                              k + 1 + i
                           ) are blocked in sequence, denoted as δ. The salesman will succeed in his (k + 1)st try, resulting in a closed tour of length, by the edge weights in Eq. (3.1), equal to

                              
                                 
                                    
                                       A
                                       (
                                       G
                                       ,
                                       δ
                                       )
                                       ≥
                                       2
                                       k
                                       +
                                       1
                                       +
                                       ϵ
                                       +
                                       2
                                       (
                                       k
                                       +
                                       1
                                       )
                                       ϵ
                                       +
                                       ϵ
                                       +
                                       1
                                       =
                                       2
                                       k
                                       +
                                       2
                                       +
                                       2
                                       (
                                       k
                                       +
                                       2
                                       )
                                       ϵ
                                       .
                                    
                                 
                              
                           
                        

On the other hand, the length of the optimal (offline) closed tour on G = (V, E − δ, D) is

                              
                                 
                                    
                                       OPT
                                       (
                                       G
                                       ,
                                       δ
                                       )
                                       =
                                       1
                                       +
                                       ϵ
                                       +
                                       2
                                       (
                                       k
                                       +
                                       1
                                       )
                                       ϵ
                                       +
                                       ϵ
                                       +
                                       1
                                       =
                                       2
                                       +
                                       2
                                       (
                                       k
                                       +
                                       2
                                       )
                                       ϵ
                                       .
                                    
                                 
                              
                           It follows that

                              
                                 
                                    
                                       
                                          c
                                          A
                                       
                                       ≥
                                       
                                          
                                             A
                                             (
                                             G
                                             ,
                                             δ
                                             )
                                          
                                          
                                             OPT
                                             (
                                             G
                                             ,
                                             δ
                                             )
                                          
                                       
                                       ≥
                                       
                                          
                                             2
                                             k
                                             +
                                             2
                                             +
                                             2
                                             (
                                             k
                                             +
                                             2
                                             )
                                             ϵ
                                          
                                          
                                             2
                                             +
                                             2
                                             (
                                             k
                                             +
                                             2
                                             )
                                             ϵ
                                          
                                       
                                       →
                                       k
                                       +
                                       1
                                       ,
                                    
                                 
                              
                           when ε approaches 0. This proves the theorem.□

Recall that in analyzing the competitive ratio for an online algorithm, we examine the worst-case performance and thus we assume without loss of generality in the sequel that the salesman knows about a blocked edge e = {u, v} only when he arrives at vertex u or vertex v. In this section we present an exponential-time online algorithm and show that it is (k + 1)-competitive, which is optimal considering the lower bound in Theorem 1.

At the high-level, this algorithm is iterative. In each iteration, it calls an exact TSP algorithm to compute a minimum-weight closed tour on the unvisited destinations, and then the salesman starts from source s to traverse along the closed tour in one direction. While there remain unvisited destinations, source s is always considered unvisited. If successful, the salesman comes back to source s and the algorithm terminates; otherwise, the salesman encounters a blocked edge e = (u, v) on the closed tour. Depending on whether there are multiple occurrences of edge e on the closed tour, the salesman finds a way from vertex u back to source s by possibly discovering another new blocked edge.

Due to this edge blockage “discovering” nature, we call our online algorithm as Discover. Note that any existing exact TSP algorithm runs in exponential time, and thus our algorithm Discover also runs in exponential time. In the following, we explain one iteration of the algorithm Discover in details, assuming there is at least one blocked edge.

There are five steps in an iteration of the algorithm Discover, a high-level description of which is in Algorithm 1
                        .

In Step 1, the algorithm Discover computes the shortest paths between all pairs of unvisited destinations of D in the current graph, and then it calls an exact TSP algorithm to compute a minimum-weight Hamiltonian cycle C on these unvisited destinations. The salesman is standing at source s.

In Step 2, starting from source s, the salesman traverses along the closed tour C in one direction. He encounters the first blocked edge e
                        1 = (u, v) ∈ E while arriving at vertex u. Note that u ∈ V (v too) is not necessarily a destination. The tour C could contain multiple occurrences of edge e
                        1, since e
                        1 can be on the shortest paths for multiple pairs of destinations. If C contains only one occurrence of edge e
                        1, the algorithm goes into Step 3; otherwise the algorithm goes into Step 4.

In Step 3, the salesman retraces from vertex u back to source s, and continues to traverse along the closed tour C in this direction (which is opposite to the starting direction). If the salesman encounters a new blocked edge e
                        2 = (x, y), e
                        2 ≠ e
                        1, he retraces from vertex x back to source s; if the salesman succeeds in visiting all the destinations before or up to arriving vertex v, he retraces from the last destination back to source s. In either case, the iteration ends; furthermore, in the latter case, the algorithm terminates as all destinations are visited.

In Step 4, there are ℓ ≥ 2 occurrences of e
                        1 on the tour C, which we denote as 
                           
                              
                                 e
                                 1
                                 1
                              
                              ,
                              
                                 e
                                 1
                                 2
                              
                              ,
                              …
                              ,
                              
                                 e
                                 1
                                 ℓ
                              
                           
                         in order in the starting traversal direction: the encountered occurrence is the first
                        
                           
                              
                                 e
                                 1
                                 1
                              
                              =
                              
                                 (
                                 
                                    u
                                    1
                                 
                                 ,
                                 
                                    v
                                    1
                                 
                                 )
                              
                           
                         (see Fig. 2
                        ). The algorithm examines the last occurrence 
                           
                              e
                              1
                              ℓ
                           
                        . The last occurrence 
                           
                              e
                              1
                              ℓ
                           
                         is said in the opposite direction to the first occurrence, if the salesman would arrive the last occurrence of e
                        1 at vertex v before vertex u when there were no edge blockages during the traversal, that is, 
                           
                              
                                 e
                                 1
                                 ℓ
                              
                              =
                              
                                 (
                                 
                                    v
                                    ℓ
                                 
                                 ,
                                 
                                    u
                                    ℓ
                                 
                                 )
                              
                           
                         (see Fig. 2(a)); otherwise the last occurrence 
                           
                              e
                              1
                              ℓ
                           
                         is said in the same direction as the first occurrence, that is, 
                           
                              
                                 e
                                 1
                                 ℓ
                              
                              =
                              
                                 (
                                 
                                    u
                                    ℓ
                                 
                                 ,
                                 
                                    v
                                    ℓ
                                 
                                 )
                              
                           
                         (see Fig. 2(b) and (c)). In the former case, the salesman continues the traversal from vertex u
                        ℓ in the last occurrence 
                           
                              e
                              1
                              ℓ
                           
                         as arrows shown in Fig. 2(a) and the algorithm goes into Step 5.

In the latter case, the algorithm finds (any) two consecutive occurrences of e
                        1 that are in the same direction, denoted as 
                           
                              
                                 e
                                 1
                                 j
                              
                              =
                              
                                 (
                                 
                                    u
                                    j
                                 
                                 ,
                                 
                                    v
                                    j
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 e
                                 1
                                 
                                    j
                                    +
                                    1
                                 
                              
                              =
                              
                                 (
                                 
                                    u
                                    
                                       j
                                       +
                                       1
                                    
                                 
                                 ,
                                 
                                    v
                                    
                                       j
                                       +
                                       1
                                    
                                 
                                 )
                              
                           
                         (or the symmetric scenario 
                           
                              
                                 e
                                 1
                                 j
                              
                              =
                              
                                 (
                                 
                                    v
                                    j
                                 
                                 ,
                                 
                                    u
                                    j
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 e
                                 1
                                 
                                    j
                                    +
                                    1
                                 
                              
                              =
                              
                                 (
                                 
                                    v
                                    
                                       j
                                       +
                                       1
                                    
                                 
                                 ,
                                 
                                    u
                                    
                                       j
                                       +
                                       1
                                    
                                 
                                 )
                              
                              ,
                           
                         which can be analogously discussed), for some j such that 1 ≤ j < ℓ (see Fig. 2(b)). The salesman continues the traversal from vertex u
                        
                           j + 1 toward vertex vj
                         along the tour C as arrows shown in Fig. 2(b). If fails, the salesman encounters a new blocked edge e
                        2 = (x, y), e
                        2 ≠ e
                        1, and then he retraces from vertex x back to source s; the iteration ends. If succeeds, the salesman continues the traversal from vertex v
                        ℓ in the last occurrence 
                           
                              e
                              1
                              ℓ
                           
                         and the algorithm goes into Step 5.

If the algorithm finds no such two consecutive occurrences of e
                        1 that are in the same direction, then ℓ = 3 and the second occurrence 
                           
                              
                                 e
                                 1
                                 2
                              
                              =
                              
                                 (
                                 
                                    v
                                    2
                                 
                                 ,
                                 
                                    u
                                    2
                                 
                                 )
                              
                           
                         is in the opposite direction (see Fig. 2(c)). The salesman continues the traversal from vertex u
                        3 toward vertex u
                        2 along the tour C as arrows shown in Fig. 2(c). If fails, the salesman encounters a new blocked edge e
                        2 = (x, y), e
                        2 ≠ e
                        1, and then he retraces from vertex x back to source s; the iteration ends. If succeeds (i.e. in arriving again at vertex u), the salesman retraces from vertex u
                        1 to source s, then continues the traversal from source s to vertex v
                        3 in this direction (which is opposite to the starting direction), and further to vertex v
                        2 and further to vertex v
                        1. During this part of traversal out of source s, if the salesman encounters a new blocked edge e
                        2 = (x, y), e
                        2 ≠ e
                        1, he retraces from vertex x back to source s; if the salesman succeeds in visiting all the destinations, he retraces from vertex v
                        3 back to source s. In either case, the iteration ends; furthermore, in the latter case, the algorithm terminates as all destinations are visited.

In Step 5, the salesman continues the traversal from an incident vertex (either u
                        ℓ or v
                        ℓ) in the last occurrence 
                           
                              
                                 e
                                 1
                                 ℓ
                              
                              ,
                           
                         in the starting direction, to source s (see Fig. 2(a) and (b)). If he encounters a new blocked edge e
                        2 = (x, y), e
                        2 ≠ e
                        1, then he retraces from vertex x back to source s. Either way the iteration ends.


                        
                           Lemma 1
                           In one iteration of the algorithm Discover, if only one blocked edge is encountered but the algorithm does not terminate, then the traveling cost is at most w(C).

Note that this happens only in the first two cases of Step 4 where the algorithm goes to Step 5.

Consider the case where the last occurrence of the blocked edge e
                              1 is in the opposite direction to the first occurrence. That is, 
                                 
                                    
                                       e
                                       1
                                       1
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          1
                                       
                                       ,
                                       
                                          v
                                          1
                                       
                                       )
                                    
                                 
                               and 
                                 
                                    
                                       e
                                       1
                                       ℓ
                                    
                                    =
                                    
                                       (
                                       
                                          v
                                          ℓ
                                       
                                       ,
                                       
                                          u
                                          ℓ
                                       
                                       )
                                    
                                 
                               as shown in Fig. 2(a). The salesman continues the traversal from vertex u
                              ℓ to source s successfully. The traversed paths from source s to vertex u
                              1 and from vertex u
                              ℓ to source s are two non-overlapping segments of the tour C, and thus their total weight is at most the weight w(C) of the tour C.

Consider the case where the last occurrence of the first blocked edge e
                              1 is in the same direction to the first occurrence, and there are two consecutive occurrences of e
                              1 in the same direction, that is, 
                                 
                                    
                                       e
                                       1
                                       j
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          j
                                       
                                       ,
                                       
                                          v
                                          j
                                       
                                       )
                                    
                                 
                               and 
                                 
                                    
                                       e
                                       1
                                       
                                          j
                                          +
                                          1
                                       
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          
                                             j
                                             +
                                             1
                                          
                                       
                                       ,
                                       
                                          v
                                          
                                             j
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                 
                               for some j such that 1 ≤ j < ℓ, as shown in Fig. 2(b). The salesman continues the traversal from vertex u
                              
                                 j + 1 to vertex vj
                               and then (from vertex v
                              ℓ) to source s successfully. The traversed paths from source s to vertex u
                              1, from vertex u
                              
                                 j + 1 to vertex vj
                              , and from vertex v
                              ℓ to source s are three non-overlapping segments of the tour C, and thus their total weight is at most the weight w(C) of the tour C.□

In one iteration of the algorithm Discover, if one blocked edge is encountered and the algorithm terminates, then the traveling cost is at most 2w(C).

Note that this happens in Step 3 or in the third case of Step 4.

Consider the case where there is only one occurrence of the blocked edge e
                              1 = {u, v} in the closed tour C. In Step 3, the traversed paths from source s to vertex u and from source s to the last destination before or up vertex v are two non-overlapping segments of the tour C. As they are both traversed twice, the traveling cost is thus at most 2w(C).

Consider the case where there are multiple occurrences of the blocked edge e
                              1 = {u, v} in the closed tour C, but there are no two consecutive occurrences of e
                              1 in the same direction, as shown in Fig. 2(c). The only paths that are retraced by the salesman are the ones from source s to vertex u
                              1 and from source s to vertex v
                              3 in the last occurrence 
                                 
                                    
                                       e
                                       1
                                       3
                                    
                                    ,
                                 
                               which are non-overlapping segments of the tour C. Therefore, the traveling cost is at most 2w(C).□

In one iteration of the algorithm Discover, if two blocked edges are encountered, then the traveling cost is at most 2w(C).

When two blocked edges are encountered by the salesman, the retracing from vertex x of the second blocked edge e
                              2 = (x, y) back to source s is implemented. If the second blocked edge e
                              2 = (x, y) is encountered by the salesman in Step 3, then the two non-overlapping paths from source s to vertex u and from source s to vertex x are traversed twice. Thus the traveling cost is at most 2w(C).

When the last occurrence of the first blocked edge e
                              1 is in the opposite direction to the first occurrence, that is, 
                                 
                                    
                                       e
                                       1
                                       1
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          1
                                       
                                       ,
                                       
                                          v
                                          1
                                       
                                       )
                                    
                                 
                               and 
                                 
                                    
                                       e
                                       1
                                       ℓ
                                    
                                    =
                                    
                                       (
                                       
                                          v
                                          ℓ
                                       
                                       ,
                                       
                                          u
                                          ℓ
                                       
                                       )
                                    
                                 
                               as shown in Fig. 2(a), and the salesman encounters the second blocked edge e
                              2 = (x, y) during the traversal from vertex u
                              ℓ to source s, the two non-overlapping paths from source s to vertex u and from vertex u to vertex x are traversed twice. Thus the traveling cost is at most 2w(C).

Consider the case where the last occurrence of the first blocked edge e
                              1 is in the same direction as the first occurrence, and there are two consecutive occurrences of e
                              1 in the same direction, that is, 
                                 
                                    
                                       e
                                       1
                                       j
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          j
                                       
                                       ,
                                       
                                          v
                                          j
                                       
                                       )
                                    
                                 
                               and 
                                 
                                    
                                       e
                                       1
                                       
                                          j
                                          +
                                          1
                                       
                                    
                                    =
                                    
                                       (
                                       
                                          u
                                          
                                             j
                                             +
                                             1
                                          
                                       
                                       ,
                                       
                                          v
                                          
                                             j
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                 
                               as shown in Fig. 2(b). If the salesman encounters the second blocked edge e
                              2 = (x, y) during the traversal from vertex u
                              
                                 j + 1 to vertex vj
                              , then the two non-overlapping paths from source s to vertex u
                              1 and from vertex u
                              
                                 j + 1 to vertex x are traversed twice. Thus the traveling cost is at most 2w(C). If the salesman encounters the second blocked edge e
                              2 = (x, y) during the traversal from vertex v
                              ℓ to source s, then the three non-overlapping paths from source s to vertex u
                              1, from vertex u
                              
                                 j + 1 to vertex vj
                              , and from vertex v
                              ℓ to vertex x are traversed twice. Thus the traveling cost is at most 2w(C).

Consider the last case where the last occurrence of the first blocked edge e
                              1 is in the same direction as the first occurrence, and there are no such two consecutive occurrences of e
                              1 in the same direction, as shown in Fig. 2(c). If the salesman encounters the second blocked edge e
                              2 = (x, y) during the traversal from vertex u
                              3 to vertex u
                              2, then the two non-overlapping paths from source s to vertex u
                              1 and from vertex u
                              3 to vertex x are traversed twice. Thus the traveling cost is at most 2w(C). Otherwise, the salesman is back to source s with retracing cost equal to the weight of the path from source s to vertex u
                              1. The second half of the traversal out of source s by the salesman can be discussed analogously, and the paths herein are non-overlapping with the paths traversed in the first half. Thus the total traveling cost is at most 2w(C).□

For real-time sTSP, the algorithm Discover is (k + 1)-competitive. That is, the algorithm Discover is optimal.

From Lemmas 1–3 we know that in each iteration, if the algorithm Discover does not terminate, then it either spends w(C) to reveal a blocked edge or spends 2w(C) to reveal two distinct blocked edges, and manages to come back to source s, where C is the minimum-weight Hamiltonian cycle on the set of unvisited destinations. Let OPT(G, δ) denote the weight of the optimal (offline) closed tour on D in graph G = (V, E − δ, D), where δ denotes the sequence (or the set) of blocked edges. Clearly w(C) ≤ OPT(G, δ).

Suppose the algorithm Discover executes k
                              1 iterations each revealing a blocked edge as discussed in Lemma 1, k
                              2 iteration revealing a blocked edge and terminates as discussed in Lemma 2, and k
                              3 iterations each revealing two blocked edges as discussed in Lemma 3. Then,

                                 
                                    
                                       
                                          
                                             k
                                             2
                                          
                                          ≤
                                          1
                                          
                                          and
                                          
                                          
                                             k
                                             1
                                          
                                          +
                                          
                                             k
                                             2
                                          
                                          +
                                          2
                                          
                                             k
                                             3
                                          
                                          =
                                          k
                                          .
                                       
                                    
                                 
                              Moreover, only if k
                              2 = 0, the algorithm Discover might execute an extra termination iteration by computing another minimum-weight Hamiltonian cycle C on the set of unvisited destinations to complete the traversal and back to source s. Therefore, the total traveling cost by Discover is at most

                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      k
                                                      1
                                                   
                                                   w
                                                   
                                                      (
                                                      C
                                                      )
                                                   
                                                   +
                                                   
                                                      (
                                                      
                                                         k
                                                         2
                                                      
                                                      +
                                                      1
                                                      )
                                                   
                                                   w
                                                   
                                                      (
                                                      C
                                                      )
                                                   
                                                   +
                                                   2
                                                   
                                                      k
                                                      3
                                                   
                                                   w
                                                   
                                                      (
                                                      C
                                                      )
                                                   
                                                
                                             
                                             
                                                ≤
                                             
                                             
                                                
                                                   (
                                                   k
                                                   +
                                                   1
                                                   )
                                                   w
                                                   (
                                                   C
                                                   )
                                                
                                             
                                          
                                          
                                             
                                             
                                                ≤
                                             
                                             
                                                
                                                   (
                                                   k
                                                   +
                                                   1
                                                   )
                                                   OPT
                                                   (
                                                   G
                                                   ,
                                                   δ
                                                   )
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              That is, the algorithm Discover is (k + 1)-competitive.□

The algorithm Discover presented above is optimal, in the sense that its worst-case competitive ratio matches the lower bound of k + 1 in Theorem 1. However, the running time of the algorithm Discover is exponential, as it calls an exact TSP algorithm O(k) times. We next present a polynomial-time online algorithm and show that it is (k + 4)-competitive.

At the high-level, this algorithm is also iterative. It first builds an approximate closed tour on all the destinations, using the minimum spanning tree (MST) based 2-approximation algorithm for TSP. The algorithm maintains a set of segments of unvisited destinations dynamically. Each segment starts with an unvisited destination and ends with an unvisited destination. There is initially only one segment which is the approximate closed tour in the first step; in the subsequent iterations of traversal, a segment could be broken into shorter ones if some parts of the segment are visited, or it disappears if all its destinations are visited. The algorithm terminates when all destinations are visited, i.e., there is no more segment left.

To visit the destinations, in each subsequent iteration of traversal, the salesman starts at one destination and tries to visit the first unvisited destination in the queue, via a shortest path. If he succeeds, he continues the traversal along the first segment until a blocked edge on the segment is encountered or the segment is exhausted. Otherwise, he encounters a blocked edge on the shortest path. Depending on where and how this blocked edge sits in the segments, the salesman finds a way either back to the starting destination or to visit the destinations in the involved segments. Each of these involved segments is then either shortened or broken into two shorter segments. The overall traversal is thus decomposed into pieces, where each piece is a traversal from one destination to another. We call this online algorithm as Piecemeal.

At the beginning (that is, the initialization step), the algorithm Piecemeal firstly computes the shortest paths between all pairs of destinations of D in graph G = (V, E, D), then it computes an MST on D in the complete edge-weighted graph on D, next it replaces the edges of the MST by their respective shortest paths in graph G = (V, E, D), and lastly it removes multiple edges (if any, but keeps one copy) to form a simple Steiner tree in graph G = (V, E, D) interconnecting all destinations of D. This resultant simple Steiner tree is denoted as T. The algorithm Piecemeal then duplicates every edge of T and uses them to construct a closed tour C on D in graph G = (V, E, D). We fix a direction, called the traversal direction, to traverse C from source s in order to visit all the destinations and then back to source s, and to orient the edges of C. Clearly, every edge of T ({u, v} for example) appears exactly once in the traversal direction in C ((u, v) for example) and exactly once in the opposite direction ((v, u) correspondingly).

The queue of unvisited destinations is denoted as Q, in which the order of all destinations is determined by their first occurrences on C starting at source s and following the traversal direction. Without visiting all the destinations, source s is always considered unvisited and it stays at the end of queue. That is, the queue Q starts with s, followed by the sequence of destinations, and ends with s. The destination at the head of Q is called the first unvisited destination. There is only one segment of unvisited destinations initially, from s to s. The salesman stands at source s at the end of initialization.

In this subsection, we explain an iteration of the algorithm Piecemeal in details, assuming that (1) there is at least one blocked edge, (2) there are ℓ segments of unvisited destinations denoted as S
                        1, S
                        2, …, S
                        ℓ in the traversal order, (3) the first unvisited destination is d
                        1 (which is the head destination of segment S
                        1), and (4) the salesman is standing at destination d
                        0 (recall that source s is also a destination). Every segment starts with an unvisited destination and ends with an unvisited destination. The last segment S
                        ℓ always ends with source s; every other segment is (or will be) associated with an already revealed blocked edge, which determines the ending destination in the segment. A high-level description of the iteration is in Algorithm 2
                        .

Note that during the entire course of traversal, an unvisited destination is considered “visited” and subsequently dequeued only if the salesman reaches it while he traverses along the segment containing the destination; other ways of reaching the destination is not considered as “formal visiting”, for the ease of presentation and performance analysis.

Also for the ease of presentation, the explanation of the algorithmic execution is described in the main text, while the network updating and the analysis on the traveling cost are done in a separate paragraph called “postprocessing”. In particular, the overall performance analysis of the algorithm Piecemeal is done via a kind of amortization, in which a part (or parts) of the traveling cost in each iteration will be “attributed” to a copy (or copies) of certain blocked edge(s). Toward the end, it can be guaranteed (in Lemmas 5 and 6) that each copy of every blocked edge is attributed with a traveling cost no more than the length of a shortest path from one destination to another.

The rest of this subsection discusses the detailed execution of an iteration of the algorithm Piecemeal, and the postprocessing.

First of all, if d
                        0 = s and |Q| = 1, the algorithm Piecemeal terminates.

Otherwise, the algorithm computes a shortest path in the current graph (that is, graph G with the known blocked edges removed) from d
                        0 to d
                        1, denoted as P(d
                        0, d
                        1), and the salesman traverses from d
                        0 to d
                        1 along P(d
                        0, d
                        1). In Case 1, the salesman succeeds in arriving d
                        1. He then follows segment S
                        1 to visit the destinations therein in the traversal direction (see Fig. 3
                        (a)); either segment S
                        1 is exhausted or a new blocked edge e
                        1 = (u, v) is encountered while the salesman arrives at vertex u. In the former situation, the salesman stands at the last destination of segment S
                        1. In the latter situation, the salesman retraces from vertex u, if u is not a destination, to the last destination he visited. The iteration ends.

                           
                              
                                 Postprocessing in Case 1: In the former situation, the length of P(d
                              0, d
                              1) is attributed to the blocked edge that is associated with segment S
                              1. In the latter situation, the length of P(d
                              0, d
                              1) is attributed to the blocked edge e
                              1 = (u, v); segment S
                              1 is accordingly updated to start with the destination immediately after vertex u; furthermore, the other segment containing the second occurrence of the blocked edge e
                              1 = (v, u), if it exists and it could be S
                              1, is broken at this occurrence into two shorter segments, the front one of which is associated with the new blocked edge e
                              1 = (v, u) and the tail one inherits the old blocked edge. In both situations, the destinations of the original segment S
                              1 visited by the salesman while he traversed along S
                              1 are dequeued. It is important to recall that during the traversal, the salesman might have visited some other destinations while he traversed along path P(d
                              0, d
                              1). These destinations are not considered visited and thus not dequeued.
                        
                     

In the other cases (Case 2 and Case 3 in the following), the salesman encounters a blocked edge e
                        1 = (u, v) ∈ E while traversing along path P(d
                        0, d
                        1) and arriving at vertex u. Clearly, u ≠ d
                        1. Note that vertices u and v might not be destinations. In Case 2, edge e
                        1 does not occur in any existing segments of unvisited destinations (see Fig. 3(b)). In this case, the salesman retraces from vertex u to d
                        0, and the iteration ends.

                           
                              
                                 Postprocessing in Case 2: Twice of the length of P(d
                              0, u) is attributed to the new blocked edge e
                              1 = {u, v}.
                        
                     

In Case 3, the blocked edge e
                        1 occurs in one or two existing segments of unvisited destinations (recall that every edge {u, v} of T appears exactly once as (u, v) and exactly once as (v, u) in the original closed tour C). Consider the segment Sj
                         in which edge e
                        1 occurs as e
                        1 = (u, v) (see Fig. 3(c)–(e)). If there is no such segment, then consider the segment Sj
                         in which edge e
                        1 occurs as e
                        1 = (v, u). We discuss the former scenario as it is more complex than the latter. The salesman traverses from vertex u along segment Sj
                         in the opposite traversal direction to visit the destinations inside. He either arrives at the starting destination of segment Sj
                         (Case 3a, see Fig. 3(c)), or arrives at vertex u in the other occurrence e
                        1 = (v, u) (Case 3b, that is, segment Sj
                         contains both occurrences of edge e
                        1, see Fig. 3(d)), or encounters a new blocked edge e
                        2 = (y, x), e
                        2 ≠ e
                        1, while visiting vertex x (Case 3c, see Fig. 3(e)).

In the first situation Case 3a, see Fig. 3(c), the salesman stands at the starting destination of segment Sj
                        , and the iteration ends.

                           
                              
                                 Postprocessing in Case 3a: The length of P(d
                              0, u) is attributed to the new blocked edge e
                              1 = (u, v). All the destinations of segment Sj
                               visited by the salesman are dequeued, and segment Sj
                               is accordingly updated to start with the destination immediately after vertex u in the original segment Sj
                              ; furthermore, the other segment containing the other occurrence of edge e
                              1, if it exists and it could be Sj
                              , is broken at the occurrence into two shorter segments, the front one of which is associated with the new blocked edge e
                              1 = (v, u) and the tail one inherits the old blocked edge. The blocked edge associated with segment Sj
                               is unchanged.
                        
                     

In the second situation Case 3b, see Fig. 3(d), the salesman retraces from vertex u along path P(d
                        0, u) back to destination d
                        0, and the iteration ends.

                           
                              
                                 Postprocessing in Case 3b: The length of P(d
                              0, u) is attributed to the new blocked edge e
                              1 = (u, v), and the length of P(u, d
                              0) is attributed to the new blocked edge e
                              1 = (v, u). All the destinations of segment Sj
                               visited by the salesman are dequeued, and segment Sj
                               is accordingly updated by collapsing the v-to-v sub-segment into a single vertex v. The blocked edge associated with segment Sj
                               is unchanged.
                        
                     

In the last situation Case 3c, see Fig. 3(e), the salesman finds the segment Sh
                         in which the second new blocked edge e
                        2 occurs in the traversal direction, i.e. e
                        2 = (x, y). If such segment Sh
                         does not exist, the salesman immediately retraces from vertex x along segment Sj
                         back to vertex u, then along P(d
                        0, u) further to destination d
                        0, and the iteration ends. Upon finding segment Sh
                        , the salesman traverses from vertex x along segment Sh
                         in the opposite traversal direction to visit the destinations inside. He either arrives at the starting destination of segment Sh
                        , or arrives at vertex u in the other occurrence e
                        1 = (v, u), or encounters a third new blocked edge e
                        3 = (b, a), e
                        3 ≠ e
                        2, while visiting vertex a (see Fig. 3(e)). In either of three scenarios, the salesman retraces along segment Sh
                         back to vertex x, then retraces along segment Sj
                         back to vertex u, and lastly retraces along path P(d
                        0, u) back to destination d
                        0. The iteration ends.

                           
                              
                                 Postprocessing in Case 3c: The length of P(d
                              0, u) is attributed to the new blocked edge e
                              1 = (u, v), and the length of P(u, d
                              0) is attributed to the new blocked edge e
                              2 = (x, y). All the destinations of segment Sj
                              , and of segment Sh
                               if it exists, visited by the salesman are dequeued, and segments Sj
                               and Sh
                               are accordingly updated by breaking at all the occurrences of edges e
                              1, e
                              2, e
                              3, and all resultant segments are properly associated with a blocked edge each. Clearly, directed edges e
                              1 = (u, v) and e
                              2 = (x, y) are not associated with any segment.
                        
                     


                        
                           Lemma 4
                           In the algorithm Piecemeal, every edge of the closed tour C is traversed at most twice.

An edge of the closed tour C can be traversed by the salesman only if it belongs to some segment of unvisited destinations. During the execution of the algorithm Piecemeal, certain shortest paths might include an edge of C, but the traversal cost on the edge is counted toward the length of the shortest path.

One sees that in both Cases 1 and 3, an edge of C can be traversed by the salesman once to visit certain unvisited destinations, and possibly another time to retrace back to some vertex. All the traversed edges are subsequently removed from the segments through the segment updating process. Therefore, every edge of the closed tour C is traversed by the salesman at most twice.□

In the algorithm Piecemeal, if a blocked edge is revealed to the salesman while it is not on any segment of unvisited destinations, then the edge is attributed with at most twice of the length of one shortest path.

A new blocked edge not on any segment of unvisited destinations is encountered by the salesman in Case 2, where it is attributed twice of the length of a part of the shortest path. Before it is revealed, it cannot be associated with any segment; after it becomes known, it can no longer be in any shortest path in subsequent iterations, and thus the attribution happens only once. The lemma is thus proven.□

In the algorithm Piecemeal, every blocked directed edge of the closed tour C is attributed with at most the length of one shortest path.

Note that a blocked directed edge of the closed tour C does not incur any traversal cost, but during the execution of the algorithm Piecemeal it might be attributed with the length of a shortest path. First of all, when such a block edge is revealed to the salesman but the edge is no longer on any segment of unvisited destinations, from Lemma 5 the edge is attributed with at most twice of the length of one shortest path. Then each directed copy of the blocked edge is attributed with one of the length of the shortest path.

In the other cases, a directed copy of the blocked edge is revealed to the salesman when it is on a segment of unvisited destinations. Either this directed copy or its opposite counterpart is attributed with the length of a shortest path in that particular iteration (in Case 1 and Case 3). The other copy, if exists, can be attributed with the length of the same shortest path in that particular iteration too; if this happens, the copy will not be associated with any segment. If the other copy exists but is not attributed with the length of the same shortest path in that particular iteration, then the copy could be associated with a segment of unvisited destinations; if so, the copy could later on be attributed with the length of a shortest path in Case 1. Either way, the attribution can happen at most once. This proves the lemma.□

For real-time sTSP, the algorithm Piecemeal runs in polynomial time and is (k + 4)-competitive.

The initialization of the algorithm Piecemeal takes O(|V|3)-time, in which all pairs of shortest paths are computed, then an MST on D is computed to construct the Steiner tree T on D, and lastly T is duplicated to construct the closed tour C. In every iteration, a shortest path P(d
                              0, d
                              1) is computed, in O(|V|2)-time, followed by the traversal along the path and the closed tour C, which can be done in O(|V|2)-time as well. Since every iteration the length of the shortest path P(d
                              0, d
                              1), or a part of it, is attributed to some new or known blocked edge, and there are at most 2k directed blocked edges, the algorithm Piecemeal terminates in at most 2k iterations. It follows that the overall running time of the algorithm Piecemeal is in O(max {k, |V|}|V|2).

From Lemma 4, the traversal cost on the edges of the closed tour C is at most 2w(C). Lemmas 5 and 6 together show that the additional traversal cost along the shortest paths in all but the last iteration is the total length of at most 2k − 1 shortest paths. This is because the length of the first shortest path P(s, s) is 0. In the last iteration, the length of the shortest path is not attributed to any blocked edge. Therefore the total traversal cost along shortest paths is the length of at most 2k shortest paths. Let OPT (G, δ) denote the weight of the optimal (offline) closed tour on D in graph G = (V, E − δ, D), where δ denotes the sequence (or the set) of blocked edges. Clearly w(C) ≤ 2OPT(G, δ), and the length of every shortest path computed in the execution of the algorithm Piecemeal is no more than 
                                 
                                    
                                       1
                                       2
                                    
                                    OPT
                                    
                                       (
                                       G
                                       ,
                                       δ
                                       )
                                    
                                 
                              .

Therefore, the total traveling cost by Piecemeal is less than or equal to

                                 
                                    
                                       
                                          
                                             (
                                             2
                                             ×
                                             2
                                             +
                                             2
                                             k
                                             ×
                                             
                                                1
                                                2
                                             
                                             )
                                          
                                          OPT
                                          
                                             (
                                             G
                                             ,
                                             δ
                                             )
                                          
                                          =
                                          
                                             (
                                             4
                                             +
                                             k
                                             )
                                          
                                          OPT
                                          
                                             (
                                             G
                                             ,
                                             δ
                                             )
                                          
                                          .
                                       
                                    
                                 
                              That is, the algorithm Piecemeal is (k + 4)-competitive.□

We have implemented the online algorithm Piecemeal in Python to examine its efficiency and effectiveness. We also programmed in OPL language the sTSP instances as integer programming instances using the single-commodity flow formulation by Letchford et al. (2013), then used the integer programming branch-and-bound solver in IBM ILOG CPLEX Optimization Studio (64 bit, V12.6.0) to compute the optimal solutions. In the sequel, this is referred to as the offline optimal algorithm. All experiments were carried out on a normal desktop with a 2.33GHz Intel Core Quad CPU and a 8GB RAM, operating under Windows 7. The default CPLEX settings of the studio were used.

In the following, n = |V|, m = |E|, and d = |D| denote the numbers of vertices, edges, and destinations in an instance of the sTSP, respectively. We applied a similar procedure as in Letchford et al. (2013) for creating an instance: (1) randomly distribute the n vertices into a 100 × 100 square in the two-dimensional plane; (2) randomly pick m edges out of the 
                        
                           
                              1
                              2
                           
                           n
                           
                              (
                              n
                              −
                              1
                              )
                           
                        
                      candidates, ensuring the final graph is connected, and set the edge weight to be the Euclidean distance between its two ending vertices; (3) set the first generated vertex to be the source s and the first d generated vertices to be the destinations.

During the course of traversal by Piecemeal, we randomly block k of the encountered edges, with the caution to maintain the graph connectivity. This determines the sequence δ of k blocked edges, and the complete instance is denoted as I = (V, E, D, δ) = (G, δ). Here G = (V, E, D) is also called the underlying network. The traveling cost of the algorithm Piecemeal on (G, δ) is Piecemeal(G, δ); the length of the TSP tour by the offline optimal algorithm is OPT(G, δ).

In the experiment, we tested n = 40, 80, 120, 160, 200; we examined different m’s at 2n, 4n, 6n to mimic the sparse traffic networks, and different d’s at n/10, n/6, n/2, respectively; the number of blocked edges, k, changes along with the underlying network, and its upper bound was set to n/6, n/4, n/2, respectively. For each of the 15 combinations of n and m, we generated 30 distinct underlying networks. There are in total 30 × 15 × 9 = 4050 instances in our experiment.

The running times of the online algorithm Piecemeal and the offline optimal algorithm depend on the underlying network G = (V, E, D) and the k blocked edges. Note also that Piecemeal is implemented in a script language Python while the optimal algorithm is optimized in a mature studio. On our desktop, for the 810 instances associated with n = 40 all together (n = 80, 120, 160, 200, respectively), Piecemeal took about 1.1 minutes (4.5, 7.3, 16.9, 33.8 minutes, respectively), while the optimal algorithm took about 34 minutes (40, 62, 97, 170 minutes, respectively). In summary, Piecemeal runs in less than one fifth of running time of the optimal algorithm, despite the performance difference in programming languages and the incomparable optimization efforts between the two implementations.

For each instance I = (G, δ), we have computed Piecemeal(G, δ) and OPT(G, δ); we also computed the optimal TSP tour on the destinations in the underlying network G = (V, E, D), that is, without any blocked edges, and denoted the length of the tour by OPT(G). Clearly, OPT(G) ≤ OPT(G, δ) ≤ Piecemeal(G, δ). These 4050 triples, in the non-decreasing order of OPT(G, δ)’s, are plotted in Fig. 4
                     . In general, the OPT(G)’s also appear increasing, so do the Piecemeal(G, δ)’s. But the Piecemeal(G, δ)’s seem more bumpy than the OPT(G)’s; and the difference between Piecemeal(G, δ) and OPT(G, δ) grows larger than the difference between OPT(G, δ) and OPT(G).

We also plotted the 4050 values of the ratio 
                        
                           
                              r
                              1
                           
                           =
                           
                              
                                 OPT
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                              
                                 OPT
                                 (
                                 G
                                 )
                              
                           
                        
                      against the number k of blocked edges in Fig. 5
                     (a), and used the method of linear least squares that fits r
                     1 = 0.007k + 1; similarly, the 4050 values of the ratio 
                        
                           
                              r
                              2
                           
                           =
                           
                              
                                 
                                    P
                                    i
                                    e
                                    c
                                    e
                                    m
                                    e
                                    a
                                    l
                                 
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                              
                                 OPT
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                           
                        
                      against the number k of blocked edges are plotted in Fig. 5(b), for which the method of linear least squares fits r
                     2 = 0.074k + 1. To examine the effects of the density of the network and the density of the destinations in the network, the 4050 values of the ratio 
                        
                           
                              r
                              2
                           
                           =
                           
                              
                                 
                                    P
                                    i
                                    e
                                    c
                                    e
                                    m
                                    e
                                    a
                                    l
                                 
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                              
                                 OPT
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                           
                        
                      are separated into three groups corresponding to m = 2n, 4n, 6n, respectively, and plotted against the number k of blocked edges, in Fig. 6
                     (a)–(c), respectively. The method of linear least squares fits r
                     2 = amk + 1, where am
                      = 0.071, 0.085, 0.115, respectively. From this regression analysis, we may conclude that the denser a network is, the larger average effect a blocked edge has. It is worth nothing, though, that on only the data points with k ≤ 20, the method of linear least squares fits 
                        
                           
                              r
                              2
                           
                           =
                           
                              a
                              m
                              ′
                           
                           k
                           +
                           1
                           ,
                        
                      where 
                        
                           
                              a
                              m
                              ′
                           
                           =
                           0.114
                           ,
                           0.105
                           ,
                           0.115
                           ,
                        
                      respectively, suggesting that a blocked edge has very close average effect disregarding the network density. Analogously, the 4050 values of the ratio 
                        
                           
                              r
                              2
                           
                           =
                           
                              
                                 
                                    P
                                    i
                                    e
                                    c
                                    e
                                    m
                                    e
                                    a
                                    l
                                 
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                              
                                 OPT
                                 (
                                 G
                                 ,
                                 δ
                                 )
                              
                           
                        
                      are separated into three groups corresponding to d = n/10, n/6, n/2, respectively, and plotted against the number k of blocked edges, in Fig. 7
                     (a)–(c), respectively. The method of linear least squares fits r
                     2 = adk + 1, where ad
                      = 0.123, 0.094, 0.058, respectively. From this regression analysis, we may conclude that the denser the destinations are, the less average effect a blocked edge has. Regression on only the data points with k ≤ 20 shows a similar, though weaker, tendency (
                        
                           
                              a
                              d
                              ′
                           
                           =
                           0.149
                           ,
                           0.123
                           ,
                           0.092
                           ,
                        
                      respectively).

@&#CONCLUSIONS@&#

In this paper, we investigated the online Steiner TSP, in which the online edge blockages are real-time information. We presented a lower bound on the competitive ratios, and an optimal online algorithm Discover for the problem. While the running time of the algorithm Discover is non-polynomial, we presented a polynomial-time algorithm Piecemeal and showed that it is near optimal. Our experimental results on thousands of instances show that the algorithm Piecemeal is efficient, taking only a fraction of the running time of the offline optimal algorithm, and is effective, producing solutions of competitive quality to the offline optimal solutions.

Theoretically, it would be interesting to close the gap of 3 between the lower bound and the competitive ratio of the polynomial-time algorithm Piecemeal. That is, whether or not the lower bound is tight for polynomial-time algorithms. One may either improve the lower bound or design a better polynomial-time online algorithm.

Another possible future research is to consider a variation of sTSP in which the online edge blockages can be forecasted, that is, the salesman can be informed of a blocked edge a certain time prior it happens. This variation has real applications where edge blockages are not random events, but predictable, such as due to traffic hours.

@&#ACKNOWLEDGEMENTS@&#

Zhang and Xu would like to acknowledge the financial support of NSFC Grants No. 71071123 and No. 61221063 and PCSIRT Grant No. IRT1173. Zhang is also supported by Grant No. 2014M550503 from China Postdoctoral Science Foundation. Zhang, Tong and Lin are supported by NSERC. Lin is also supported by a visiting professorship from the Zhejiang Sci-Tech University.

@&#REFERENCES@&#

