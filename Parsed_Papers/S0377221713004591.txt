@&#MAIN-TITLE@&#Heuristic for the rectangular two-dimensional single stock size cutting stock problem with two-staged patterns

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a recursion for packing rectangular items into strips.


                        
                        
                           
                           We propose a recursion for placing strips on the plate.


                        
                        
                           
                           The cutting plan is obtained from solving a sequence of residual problems.


                        
                        
                           
                           Solve more than 75% of the benchmark instances to optimality.


                        
                        
                           
                           Achieve better solution quality than a commercial stock cutting software package.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cutting

Two-dimensional cutting stock

Two-staged patterns

Column generation

@&#ABSTRACT@&#


               
               
                  Two-staged patterns are often used in manufacturing industries to divide stock plates into rectangular items. A heuristic algorithm is presented to solve the rectangular two-dimensional single stock size cutting stock problem with two-staged patterns. It uses the column-generation method to solve the residual problems repeatedly, until the demands of all items are satisfied. Each pattern is generated using a procedure for the constrained single large object placement problem to guarantee the convergence of the algorithm. The computational results of benchmark and practical instances indicate the following: (1) the algorithm can solve most instances to optimality, with the gap to optimality being at most one plate for those solutions whose optimality is not proven and (2) for the instances tested, the algorithm is more efficient (on average) in reducing the number of plates used than a published algorithm and a commercial stock cutting software package.
               
            

@&#INTRODUCTION@&#

The Two-Dimensional single stock size Cutting Stock problem (TDCS) appears in several industries, where stock plates of the same size are divided into rectangular items. The stock may be metal plate, plate glass, or wood panel. In Wäscher et al. (2007), the TDCS is formally referred to as the two-dimensional SSSCSP (single stock size cutting stock problem), in which m types of rectangular items with specified demands are completely produced from plates of the same size L
                     ⊗
                     W (length⊗width), such that the input (number of plates used, simply “plate count”) is minimized. The item types are characterized by lengths (l
                     1,…,
                     l
                     
                        m
                     ), widths (w
                     1,…,
                     w
                     
                        m
                     ) and demands (d
                     1,…,
                     d
                     
                        m
                     ). A solution of the TDCS is a cutting plan that contains a set of different cutting patterns, each of which has specified layout and frequency. The solution can be obtained from solving the following integer programming (IP) model:
                        
                           
                              
                                 min
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      
                                                         M
                                                      
                                                   
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                M
                                             
                                          
                                       
                                       
                                          
                                             a
                                          
                                          
                                             ij
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ⩾
                                       
                                          
                                             d
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                       ;
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       N
                                       ,
                                       
                                       j
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       M
                                    
                                 
                              
                              ,
                           
                        
                     where M is the number of possible cutting patterns. Each pattern can be obtained from solving a two-dimensional SLOPP (Single Large Object Placement Problem; see Wäscher et al. (2007)), x
                     
                        j
                      the frequency of pattern j (decision variable), j
                     =1,…,
                     M, a
                     
                        ij
                      the frequency of type-i items in pattern j, i
                     =1,…,
                     m and j
                     =1,…,
                     M and N is the set of non-negative integers.

The solution value is the plate count and must be minimized, subject to the constraints that the demands must be satisfied and the pattern frequencies should be integers.

Solving the IP model exactly is time consuming because of the vast set of possible patterns. Actually it may be impossible to enumerate all the patterns. Gilmore and Gomory (1961) proposed the column-generation (CG) approach that solves the following linear programming (LP) model:
                        
                           
                              
                                 min
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                m
                                             
                                          
                                       
                                       
                                          
                                             a
                                          
                                          
                                             ij
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ⩾
                                       
                                          
                                             d
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                       ;
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ⩾
                                       0
                                       ,
                                       
                                       j
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                    
                                 
                              
                              .
                           
                        
                     
                  

Starting from a feasible solution that contains m patterns, the CG solves the LP model iteratively. In each iteration, it generates a pattern P from solving the following two-dimensional SLOPP:
                        
                           
                              
                                 max
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      z
                                                   
                                                   
                                                      P
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      i
                                                   
                                                
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                       P
                                       
                                       is a feasible pattern;
                                       
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       N
                                       ,
                                       
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                    
                                 
                              
                              ,
                           
                        
                     where z
                     
                        P
                      is the value of the pattern, c
                     
                        i
                      the value of a type-i item, obtained from the current dual LP-solution, and p
                     
                        i
                      is the frequency of type-i items in the pattern.

The pattern is used to replace an existing one to update the solution. The iteration is terminated when the value of the new pattern is not larger than 1, then the current LP-solution becomes optimal. The pattern frequencies may be fractional in the optimal LP-solution. A procedure should be used to round them to integers to obtain a feasible solution to the IP model. A residual problem may be generated if the pattern frequencies are simply rounded down as (⌊x
                     1⌋,…,⌊x
                     
                        m
                     ⌋), where the (remaining) demands are 
                        
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                           -
                           
                              
                                 ∑
                              
                              
                                 j
                                 =
                                 1
                              
                              
                                 m
                              
                           
                           
                              
                                 a
                              
                              
                                 ij
                              
                           
                           ⌊
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                           ⌋
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           m
                        
                     . It must be solved to complete the solution.

Guillotine cuts are often required to divide the plates into items. Two-staged (2STG) patterns are among the simplest guillotine pattern types that are used in the cutting process, where the cuts in the first stage split the plate into strips, and those in the second stage divide the strips into items. The cuts in the same stage are in the same direction, and the cut directions of the two stages are perpendicular to each other. The items can be orientated or non-orientated. In the later case an item can be placed on the plate with its length orientation being either horizontal or vertical. This paper concerns the TDCS with 2STG patterns (TDCS_2STG). The TDCS_2STG is denoted as TDCS_2STGO for the orientated case and as TDCS_2STGR for the case of allowing rotation (non-orientated). The TDCS_2STGR is the focus of this paper.

The proposed algorithm is denoted as the RCCG (repeated constrained column-generation), where R (repeated) means that the complete solution (the complete cutting plan) is obtained from repeatedly solving the residual problems until the demands are satisfied, C (constrained) indicates that the patterns are generated mainly using a procedure for the constrained two-dimensional SLOPP (C_SLOPP), and CG means that each residual problem is solved by the CG approach. Each run of the CG fulfills some portion of the remaining demands. More precisely, the master problem solved in each run of the CG can be formulated as follows, where r
                     
                        i
                     
                     =
                     d
                     
                        i
                      for the first run:
                        
                           
                              
                                 min
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                m
                                             
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                
                                                =
                                                
                                                   
                                                      r
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                m
                                                ;
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                
                                                ⩾
                                                0
                                                ,
                                                
                                                j
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                m
                                             
                                          
                                       
                                    
                                 
                              
                              .
                           
                        
                     
                  

Let A
                     =[a
                     
                        ij
                     ]
                        m×m
                     , R
                     =[r
                     
                        i
                     ]
                        m×1 and X
                     =[x
                     
                        j
                     ]
                        m×1. The problem can also be written as:
                        
                           (1)
                           
                              
                                 min
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                m
                                             
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       |
                                       AX
                                       =
                                       R
                                       ;
                                       
                                       X
                                       ⩾
                                       0
                                    
                                 
                              
                              .
                           
                        
                     
                  

The sub-problem solved for generating the patterns in the first run is the unconstrained SLOPP (U_SLOPP):
                        
                           
                              
                                 max
                              
                              
                                 
                                    
                                       
                                          
                                             z
                                          
                                          
                                             P
                                          
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                m
                                             
                                          
                                       
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       P
                                       
                                       is a 2STGR pattern;
                                       
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       N
                                    
                                 
                              
                              .
                           
                        
                     
                  

The U_SLOPP is naturally constrained despite the absence of explicit constraints on the demand per piece type, because p
                     
                        i
                     
                     ⩽⌊(LW)/(l
                     
                        i
                     
                     w
                     
                        i
                     )⌋ must be hold for any feasible pattern. The patterns in the subsequent runs are generated from solving the following sub-problem (C_SLOPP):
                        
                           (2)
                           
                              
                                 max
                              
                              
                                 
                                    
                                       
                                          
                                             z
                                          
                                          
                                             P
                                          
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                m
                                             
                                          
                                       
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       P
                                       
                                       is a 2STGR pattern;
                                       
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       N
                                       )
                                       ∩
                                       
                                          
                                             (
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             ⩽
                                             r
                                             )
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                    
                                 
                              
                              .
                           
                        
                     
                  

As later demonstrated in the computational test, the RCCG is powerful in input minimization. It can solve most benchmark instances to optimality. For those solutions whose optimality is not proven, the gap to optimality is at most one plate. For the instances tested, the RCCG is more effective in input minimization than a published algorithm and a commercial stock cutting software package.

The remaining contents are organized as follows. The literature is reviewed in Section 2. The C_SLOPP procedure for 2STGR patterns is described in Section 3, followed by the presentation of the RCCG algorithm in Section 4. The computational results are reported in Section 5 and the conclusions are given in Section 6.

@&#LITERATURE REVIEW@&#

The solution of the TDCS is a cutting plan that contains a set of different cutting patterns, where both the frequency and items layout of each pattern are specified.

There are at least three approaches for the TDCS. The first is the integer programming (IP) approach that is exact, where the decision variables are the pattern frequencies that must be non-negative integers. IP models for the TDCS_2STGO have been presented in Lodi et al. (2004) and Silva et al. (2010). The later authors used the C callable library of the ILOG Cplex 11.0 solver for the optimization of the proposed model. They tested both their model and that of Lodi et al. (2004), using a 1.87gigahertz Intel Core Duo processor with 2gigabyte of RAM memory, where the time limit was set to be 7200seconds for each instance. For the 20 benchmark instances (ATP instances 30–49), the model of Silva et al. (2010) solved 12 of them to proven optimality, and that of Lodi et al. (2004) solved 4 of them to proven optimality. This indicates that exact algorithms are not appropriate for solving large-scale TDCS_2STGO instances. Considering that the solution space of the TDCS_2STGR is much larger than that of the TDCS_2STGO, it may be not wise to try IP models.


                        Macedo et al. (2010) presented an IP arc-flow model for the TDCS_2STG (both TDCS_2STGO and TDCS_2STGR). The model was also solved with ILOG Cplex 11.0 solver. Two sets of real instances from the wood industry were used in the computational test.

The second approach is the sequential heuristic procedure (SHP). It generates a pattern using the remaining items to satisfy some portion of the demands, and repeats until all demands are satisfied. The SHP has been used widely in solving the one-dimensional cutting stock problem (Belov and Scheithauer, 2007; Cui and Liu, 2011). Suliman (2006) presented an SHP-based approach for the TDCS, where the patterns are not 2STG ones.

The third is the CG approach. It solves the linear relaxation of the IP model to obtain the optimal LP-solution, in which the pattern frequencies may be fractional and must be rounded to integers to make the cutting plan feasible. Each pattern is obtained from solving the related U_SLOPP. In rounding the solution, shortage of the items is not allowed, but surplus may be generated and is taken as waste. The approach usually yields good solutions when the average pattern frequency is large. Sophisticated rounding procedures may be required when the average demand of the item types is small, because then the average pattern frequency is also small, subsequently simple rounding procedure may lead to large errors.

Most CG-based algorithms do not restricted the patterns to be 2STG ones (Alvarez-Valdes et al., 2002; Cui and Yang, 2012). The CG approach in Alvarez-Valdes et al. (2002) solves the U_SLOPP by several methods, including dynamic programming, GRASP and tabu search. Three different strategies are used in rounding the solutions. The CG approach in Cui and Yang (2012) solves the U_SLOPP by dynamic programming to generate extended block patterns. A simple rounding procedure is used in geting integer solutions.


                        Cintra et al. (2008) presented a special CG approach, where the TDCS is solved in two phases, and both non-staged and staged patterns are considered, including the 2STG (both 2STGO and 2STGR) patterns. The patterns are generated using dynamic programming. The CG algorithm is executed several times in the first phase. The input of the first execution is the original problem. The fractional frequencies in the LP solution of the current execution are simply rounded down to integers, producing a residual problem that is taken as the input of the next execution. The first phase is terminated when the rounding procedure produces zero frequencies for all patterns. Then a heuristic strategy is used in the second phase to solve the last residual problem.

The RCCG in this paper is also a special CG approach. It differs from the general CG approach in the following aspects. (1) The general CG approach only runs once to obtain the solution. The RCCG solves the residual problems successively until all demands are satisfied. (2) The general CG approach uses an U_SLOPP procedure to generate the patterns, whereas the RCCG mainly uses a C_SLOPP procedure.

Both the RCCG and the approach in Cintra et al. (2008) solve the residual problems repeatedly. The former uses a C_SLOPP procedure in pattern-generation to guarantee the convergence of the algorithm. The later calls a U_SLOPP procedure to generate the patterns and a heuristic in the second phase to solve the final residual problem if necessary to complete the solution.

It should be noted that an approach similar to the RCCG is presented in Poldi and Arenales (2009) to solve the one-dimensional cutting stock problem of multiple stock lengths, where a one-dimensional bounded knapsack problem is solved to generate the patterns, and several rounding procedures are used to obtain integer solutions. The approach is the same as the RCCG in the sense that residual problems are successively solved by the CG approach until all demands are satisfied, and the patterns are obtained from solving a C_SLOPP.

The RCCG uses a C_SLOPP procedure to generate 2STGR patterns. The time efficiency of the C_SLOPP procedure is vital because a large number of patterns must be generated before the complete cutting plan is determined.

Several exact and heuristic algorithms for the 2STGO patterns have been reported, such as the bottom-up approach (Hifi and M’Hallah, 2005), the strip generation algorithms (Hifi and M’Hallah, 2006), the beam search algorithm (Hifi et al., 2008), and the parallel beam search algorithm (Hifi and Saadi, 2012). There are still other algorithms for the 2STGO. A more detailed review is available in Hifi and Saadi (2012).

Algorithms dealing with the 2STGR have been rarely reported. Lodi and Monaci (2003) presented an exact approach for the 2STGR. 17 small benchmark instances were solved in the computational test. The computation time is too long for middle- and large-scale 2STGR instances.

The C_SLOPP procedure in this paper is a fast and easy to code heuristic for generating 2STGR patterns. It uses two simple recursions, one for packing the items into strips, and the other for placing the strips on the plate. The computational results indicate that the procedure is adequate for being used under the RCCG frame to solve the TDCS_2STGR. It should be noted that some existing C_SLOPP procedures for 2STGO patterns, such as those in Hifi and M’Hallah (2006) and Hifi et al. (2008), may also be adapted to generate 2STGR patterns.


                        Fig. 1
                         shows two 2STG patterns, where the numbers denote the item types. They have obvious strip structure. The left is an X-pattern in which the strips are horizontal, and the right is a Y-pattern where the strips are vertical. A 2STG pattern can be divided into items within two stages. The plate is divided into strips at the first stage, and the strips into items at the second stage. The first-stage cuts are horizontal for an X-pattern. They are vertical for a Y-pattern.

The C_SLOPP procedure solves approximately model (2) to obtain the current pattern. It first calls a strip-generation procedure to pack the items into strips and then places the strips on the plate.

It is sufficient only to generate horizontal strips. Vertical strips can be obtained from rotating the horizontal ones by 90°. It is assumed that L
                        ⩾
                        W. The assumption is reasonable because swapping the length and width of the plate does not affect the solution when the items are non-orientated and both X- and Y-patterns are considered.

Blank types are introduced to facilitate presentation. Type-i item is related with blank types i and m
                        +
                        i, i
                        =1,…,
                        m. There are 2m blank types. The size of type i is l
                        
                           i
                        
                        ⊗
                        w
                        
                           i
                         and that of type (m
                        +
                        i) is w
                        
                           i
                        
                        ⊗
                        l
                        
                           i
                        .

The number of strip types to be considered is also 2m. Each strip type is related with a blank type and vice versa, where the strip width is the same as that of the blank type. The following paragraphs first introduce the necessary notations and then give the recursion for determining the strip types. The explanation follows afterwards.

The following notations are used, where j
                        =1,…,2m:
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          ε
                                          
                                             j
                                          
                                       
                                       Blank type to which type-j strip is related
                                    
                                    
                                       
                                          κ
                                          
                                             j
                                          
                                       
                                       Item type to which type-j strip is related. κ
                                          
                                             j
                                          
                                          =
                                          ε
                                          
                                             j
                                           when ε
                                          
                                             j
                                          
                                          ⩽
                                          m; κ
                                          
                                             j
                                          
                                          =
                                          ε
                                          
                                             j
                                          
                                          −
                                          m when m
                                          <
                                          ε
                                          
                                             j
                                          
                                          ⩽2m
                                       
                                    
                                    
                                       
                                          W
                                          
                                             j
                                          
                                       
                                       Width of type-j strip, W
                                          1
                                          ⩽⋯⩽
                                          W
                                          2m
                                          
                                       
                                    
                                    
                                       
                                          L
                                          
                                             j
                                          
                                       
                                       Length of the blank type related with type-j strip
                                    
                                    
                                       
                                          U
                                       
                                       
                                          U
                                          ={u
                                          1,…,
                                          u
                                          
                                             m
                                          }. u
                                          
                                             i
                                           is the upper bound of type-i items that can be used in generating the strips
                                    
                                    
                                       
                                          ν(j, x)
                                       Value of strip x
                                          ⊗
                                          W
                                          
                                             j
                                          
                                       
                                    
                                    
                                       
                                          η(j, x, i)
                                       Frequency of type-i items in strip x
                                          ⊗
                                          W
                                          
                                             j
                                          , i
                                          =1,…,
                                          m
                                       
                                    
                                    
                                       
                                          n(j, i)
                                       Frequency of type-i items in strip L
                                          ⊗
                                          W
                                          
                                             j
                                          , n(j, i)=
                                          η(j, L, i), i
                                          =1,…,
                                          m
                                       
                                    
                                 
                              
                           
                        
                     

Initially let W
                        0
                        =0; ν(0, x)=0 and η(0, x, i)=0, x
                        =0,…,
                        L and i
                        =1,…,
                        m. Let i
                        =
                        κ
                        
                           j
                         for type-j strip; then W
                        
                           j
                        
                        =
                        w
                        
                           i
                         and L
                        
                           j
                        
                        =
                        l
                        
                           i
                         when ε
                        
                           j
                        
                        ⩽
                        m; W
                        
                           j
                        
                        =
                        l
                        
                           i
                         and L
                        
                           j
                        
                        =
                        w
                        
                           i
                         when m
                        <
                        ε
                        
                           j
                        
                        ⩽2m. The following recursion determines the solution to type-j (j
                        =1,…,2m) strip:
                           
                              (3)
                              
                                 ν
                                 (
                                 j
                                 ,
                                 x
                                 )
                                 =
                                 
                                    max
                                 
                                 
                                    
                                       
                                          ν
                                          (
                                          j
                                          -
                                          1
                                          ,
                                          x
                                          )
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          ν
                                          (
                                          j
                                          ,
                                          x
                                          -
                                          
                                             
                                                L
                                             
                                             
                                                j
                                             
                                          
                                          )
                                          |
                                          
                                             
                                                L
                                             
                                             
                                                j
                                             
                                          
                                          ⩽
                                          x
                                          ,
                                          
                                          η
                                          (
                                          j
                                          ,
                                          x
                                          -
                                          
                                             
                                                L
                                             
                                             
                                                j
                                             
                                          
                                          ,
                                          i
                                          )
                                          <
                                          
                                             
                                                u
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The strip types are arranged in ascending order of their widths (W
                        1
                        ⩽⋯⩽
                        W
                        2m
                        ). Their solutions are also obtained in the same order. The solution ν(j, x) of type-j strip is initialized as that of type (j
                        −1). This is feasible because W
                        
                           j
                        
                        ⩾
                        W
                        
                           j−1. Then blank type j is considered to improve the solution. The solution ν(j, x) may be obtained from horizontally building a piece of blank type j (item type i) at the right edge of strip (x
                        −
                        L
                        
                           j
                        )⊗
                        W
                        
                           j
                         that has value ν(j, x
                        −
                        L
                        
                           j
                        ) and contains η(j, x
                        −
                        L
                        
                           j
                        , i) type-i pieces. η(j, x
                        −
                        L
                        
                           j
                        , i)<
                        u
                        
                           i
                         should hold because a type-i piece is being added.

The strip-generation procedure is based on the recursion. It is greedy in nature. Considering that η(j, x, i) should be determined for j
                        =1,…,2m, x
                        =0,…,
                        L and i
                        =1,…,
                        m, the complexity of the strip-generation procedure is O(2m
                        2
                        L).

The C_SLOPP procedure will be described for X-patterns. It can also be used for Y-patterns when the length and width of the plate is swapped. The recursion for determining the X-pattern, its explanation, and the contents of the C_SLOPP procedure are given in the next paragraphs.

Let N(y, i) be the frequency of type-i items in segment L
                        ⊗
                        y, y
                        =0,…,
                        W and i
                        =1,…,
                        m. G strip sets generated by the strip-generation procedure will be used to obtain the solution, where each set is generated using specified upper bounds of the items. The method for determining the upper bounds will be described later. Let F(g, y) be the value of segment L
                        ⊗
                        y when the first g sets of strips have been used, y
                        =0,…,
                        W and g
                        =1,…,
                        G. The value of the X-pattern is F(G, W). Initially let F(0, y)=0 and N(y, i)=0, i
                        =1,…,
                        m and y
                        =0,…,
                        W. The following recursion determines the solution to segment L
                        ⊗
                        y, where j
                        =1,…,2m and y
                        =0,…,
                        W:
                           
                              (4)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   z
                                                
                                                
                                                   ji
                                                
                                             
                                             =
                                             0
                                             
                                             if
                                             
                                             y
                                             <
                                             
                                                
                                                   W
                                                
                                                
                                                   j
                                                
                                             
                                             ,
                                             
                                                
                                                   z
                                                
                                                
                                                   ji
                                                
                                             
                                             =
                                             
                                                min
                                             
                                             {
                                             
                                                
                                                   r
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             n
                                             (
                                             j
                                             ,
                                             i
                                             )
                                             +
                                             N
                                             (
                                             y
                                             -
                                             
                                                
                                                   W
                                                
                                                
                                                   j
                                                
                                             
                                             ,
                                             i
                                             )
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                             
                                             otherwise,
                                             
                                             i
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             m
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             F
                                             (
                                             g
                                             ,
                                             y
                                             )
                                             =
                                             
                                                max
                                             
                                             
                                                
                                                   
                                                      F
                                                      (
                                                      g
                                                      -
                                                      1
                                                      ,
                                                      y
                                                      )
                                                      ,
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      |
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                               =
                                                               1
                                                            
                                                            
                                                               m
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      
                                                         
                                                            z
                                                         
                                                         
                                                            ji
                                                         
                                                      
                                                      ,
                                                      
                                                      j
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      2
                                                      m
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        The solution of F(g, y) is initialized to F(g
                        −1, y), that is, the solution to segment L
                        ⊗(y
                        −1). Then 2m branches are considered to improve the solution. The jth branch is related with placing strip L
                        ⊗
                        W
                        
                           j
                         on top of segment L
                        ⊗(y
                        −
                        W
                        
                           j
                        ). It contains z
                        
                           ji
                         copies of type-i items. z
                        
                           ji
                         is at most n(j, i)+
                        N(y
                        −
                        W
                        
                           j
                        , i), where n(j, i) is the number of type-i items in strip L
                        ⊗
                        W
                        
                           j
                        , and N(y
                        −
                        W
                        
                           j
                        , i) is that in segment L
                        ⊗(y
                        −
                        W
                        
                           j
                        ). z
                        
                           ji
                         should not exceed the residual demand r
                        
                           i
                        . This means that surplus is taken as waste when n(j, i)+
                        N(y
                        −
                        W
                        
                           j
                        , i)>
                        r
                        
                           i
                        . The value of the branch is 
                           
                              
                                 
                                    V
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    m
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    ji
                                 
                              
                           
                        .

For a specified g, the complexity of the recursion is O(2m
                        2
                        W). This is true because F(g, y) should be determined for y
                        =1,…,
                        W, and for each specified y, O(2m
                        2) operations are required to obtain all V
                        
                           j
                        , j
                        =1,…,2m.

When G
                        =1, only one set of strips are used and the items in the current residual problem are all used in generating them. Let h
                        =⌊W/(G
                        −1)⌋ when G
                        >1. The upper bounds of the items used for generating the gth set of strips is determined as u
                        
                           i
                        
                        =
                        r
                        
                           i
                        
                        −
                        N((g
                        −1)h, i), i
                        =1,…,
                        m. It means that when the first g
                        −1 strip sets have been used to improve the solution, the upper bounds are updated by deleting the items that are included in segment L
                        ⊗((g
                        −1)h), and then used in generating the gth set of strips. For illustrative purposes, assume that W
                        =201 and G
                        =3; then h
                        =⌊W/(G
                        −1)⌋=100. When g
                        =1, u
                        
                           i
                        
                        =
                        r
                        
                           i
                        
                        −
                        N(0, i)=
                        r
                        
                           i
                        . This means that the upper bounds are equal to the demands (in the residual problem) for the first strip set. Then the strips are used in solving recursion (4) to obtain F(1, y), meanwhile N(y, i) is also determined, y
                        =0,…,
                        W and i
                        =1,…,
                        m. Fig. 2
                        a shows the case of g
                        =2, where u
                        
                           i
                        
                        =
                        r
                        
                           i
                        
                        −
                        N(100, i). It indicates that the upper bounds are determined by removing the items included in the current solution to segment L
                        ⊗100 (the hatched area in the figure), that is, the solution related with F(1,100). This set of strips is used in solving recursion (4) to obtain F(2, y) and update N(y, i). The case for the last strip set (g
                        =3) is shown in Fig. 2b, where u
                        
                           i
                        
                        =
                        r
                        
                           i
                        
                        −
                        N(200, i). The upper bounds are determined by removing the items included in the current solution to segment L
                        ⊗200, namely the solution related with F(2,100). Then the strips are used in solving recursion (4) to obtain F(3, y)=
                        F(G, y). The value of the X-pattern is F(G, W)=
                        F(3,201).

The C_SLOPP procedure is based on recursion (4). Its contents are shown in Fig. 3
                        . The complexity is O(2m
                        2
                        GL)+
                        O(2m
                        2
                        GW)=
                        O[2m
                        2
                        G(L
                        +
                        W)], where O(2m
                        2
                        GL) denotes the complexity for solving recursion (3) G times, and O(2m
                        2
                        GW) denotes that for solving recursion (4) G times.

It is sufficient to consider normal sizes in solving the C_SLOPP (Hifi and M’Hallah, 2006; Cui and Yang, 2011). When the items are non-orientated, normal sizes are the combinations of the lengths and widths of the item types. The RCCG considers the following normal lengths in solving recursion (3):
                           
                              
                                 
                                    
                                       
                                          x
                                          |
                                          x
                                          =
                                          
                                             ∑
                                          
                                          (
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                β
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                w
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ⩽
                                          L
                                          ,
                                          
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   ⌊
                                                   L
                                                   /
                                                   
                                                      
                                                         l
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ⌋
                                                
                                             
                                          
                                          ,
                                          
                                          
                                             
                                                β
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   ⌊
                                                   L
                                                   /
                                                   
                                                      
                                                         w
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ⌋
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

It considers the following normal widths in solving recursion (4):
                           
                              
                                 
                                    
                                       
                                          y
                                          |
                                          y
                                          =
                                          
                                             ∑
                                          
                                          (
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                β
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                w
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ⩽
                                          W
                                          ,
                                          
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          {
                                          0
                                          ,
                                          1
                                          ,
                                          …
                                          ,
                                          ⌊
                                          W
                                          /
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          ⌋
                                          }
                                          ,
                                          
                                          
                                             
                                                β
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          {
                                          0
                                          ,
                                          1
                                          ,
                                          …
                                          ,
                                          ⌊
                                          W
                                          /
                                          
                                             
                                                w
                                             
                                             
                                                i
                                             
                                          
                                          ⌋
                                          }
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The RCCG consists of the following steps, where the terms CGC, CGU and ROUND will be explained later:
                        
                           
                              Step 1.
                           Solve the original problem using the CGU and call the ROUND to obtain the related partial cutting plan and the residual problem. Go to Step 4 if the residual problem is null.

Solve the current residual problem using the CGC and call the ROUND to obtain the related partial cutting plan and the residual problem. Go to Step 4 if the residual problem is null.

Go to Step 2 with the new residual problem just generated.

Combine all partial cutting plans to form the complete cutting plan.

The CGC is implemented according to the following steps:
                        
                           
                              Step 1:
                           Construct the initial LP-solution by setting A equal to the unit matrix. It means that the initial solution is X
                              =
                              R. Each pattern contains only one item because a
                              
                                 ii
                              
                              =1, a
                              
                                 ij
                              
                              =0 when i
                              ≠
                              j, where i, j
                              =1,…,
                              m.

Determine the current values of the items as [c
                              1,…,
                              c
                              
                                 m
                              ]=[1,…,1]A
                              −1.

Call the C_SLOPP procedure to obtain the current pattern P. Go to Step 5 if the pattern value is not larger than 1.

Replace the kth column of matrix A with P and go to Step 2, where k is determined according to the following formula:
                                 
                                    
                                       
                                          
                                             x
                                          
                                          
                                             k
                                          
                                       
                                       /
                                       
                                          
                                             p
                                          
                                          
                                             k
                                          
                                       
                                       =
                                       
                                          min
                                       
                                       {
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       /
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       >
                                       0
                                       ,
                                       
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       m
                                       }
                                       .
                                    
                                 
                              
                           

Output the LP-solution to the ROUND for further processing.

The CGU differs from the CGC only in Step 3, where the U_SLOPP procedure should be called to generate the pattern.

In solving each residual problem using the CGC, parameter G (the number of strip sets) for the C_SLOPP procedure is set to be 1 at the early stage until no improvement of the LP-solution can be achieved, then it is set to be 15. This is useful to reduce the computation time, because the pattern generation time increases with G. Both X-patterns and Y-patterns are considered in calling the C_SLOPP procedure.

The CGU in Step 1 denotes that the CG is used to solve the TDCS problem, where a U_SLOPP procedure is used to generate each pattern. The U_SLOPP procedure is based on the approach in Section 2.3 of Hifi (2001). If the first residual problem is set to be the original problem, then Step 1 can be omitted. Step 1 is useful to reduce the computation time because U_SLOPP procedures are much faster than C_SLOPP ones in generating patterns. The partial cutting plan generated in Step 1 may be null when the average demand of the item types is very small.

The ROUND denotes a procedure that rounds the optimal LP solution to obtain the related partial cutting plan and the residual problem. Let the optimal LP-solution to the current residual problem be X
                     =(x
                     1,…,
                     x
                     
                        K
                     ), where the patterns have been arranged in descending order of their material utilizations. The material utilization of a pattern is the ratio between the total area of the included items and the plate area. The ROUND consists of the following steps.
                        
                           
                              Step 1.
                           Let X
                              =(⌊x
                              1⌋,…,⌊x
                              
                                 K
                               ⌋). Get the residual items. Let k
                              =1.

Determine Δx
                              
                                 k
                              , an integer that represents the possible maximum incremental frequency of the kth pattern, without producing surplus. If Δx
                              
                                 k
                              
                              >0 then let x
                              
                                 k
                              
                              =
                              x
                              
                                 k
                              
                              +Δx
                              
                                 k
                               and update the residual items.

If k
                              <
                              K and the number of residual items is not null then let k
                              =
                              k
                              +1 and go to Step 2; otherwise stop with the partial cutting plan and a new residual problem.

Steps 2 and 3 are necessary for the RCCG because of the following reason. If the LP solution is obtained from using the CGC, then there is at least one pattern whose frequency is not zero after calling the ROUND, because the frequency of each item type in a pattern is not larger than the demand. This guarantees the convergence of the RCCG.

Although the RCCG is presented for the non-oriented case, it can be adapted to deal with the oriented case. This section contains four subsections. The RCCG is compared with the heuristic algorithm of Cintra et al. (2008) in Section 5.1, with the exact algorithm of Silva et al. (2010) in Section 5.2, and with a commercial stock cutting software package in Section 5.3. The effect of the G value is explained in Section 5.4. Four sets of instances are used. The first set is obtained from Cintra et al. (2008), the second and third from Silva et al. (2010), and the fourth from practice. The RCCG and the commercial stock cutting software package were executed on a personal computer (Intel Core 2 Quad CPU Q9400 2.66gigahertz, RAM 3.37gigabytes). The computer used in Cintra et al. (2008) has processor Intel Pentium IV, clock of 1.8gigahertz and memory of 512megabits, and that used in Silva et al. (2010) has processor Intel Core Duo, clock of 1.87gigahertz and memory of 2gigabytes).

It seems that the algorithms in Cintra et al. (2008) and Silva et al. (2010) consider only X-patterns in which the first-stage cuts are horizontal. Subsequently the RCCG generates only X-patterns in Sections 5.1 and 5.2 to make the comparisons fair. Both X- and Y-patterns are considered in Section 5.3.

The following notations are used in the sub-sections:
                        
                           
                              
                              
                              
                                 
                                    
                                       Z
                                       
                                          LB
                                       
                                    
                                    Lower bound of the integer solution. It can be obtained for the LP solution to the original problem (see Step 1 of the RCCG)
                                 
                                 
                                    
                                       Z
                                       RCCG
                                    
                                    Solution value (pattern count) of the RCCG
                                 
                                 
                                    Δ
                                    Denoting that the solution value is equal to the lower bound Z
                                       
                                          LB
                                       
                                    
                                 
                              
                           
                        
                     
                  

In interpreting the computation results, it should be noted that the RCCG solution (the solution obtained by the RCCG) is optimal if Z
                     RCCG
                     =
                     Z
                     
                        LB
                     . When Z
                     RCCG
                     >
                     Z
                     
                        LB
                     , the optimality of the RCCG solution remains an open issue. In fact, if Z
                     
                        LB
                      is not a tight bound, the RCCG solution may indeed be optimal.

The 12 instances in Set 1 are used. The demand of an item type is in [1,100]. The other features of the instances are given in Table 1
                        .


                        Table 2
                         lists the computational results, where Z
                        CGRp denotes the solution value of the CGRp. The Z
                        
                           LB
                         and Z
                        CGRp values are copied from Table 8 in Cintra et al. (2008) for the orientated case, and from Table 10 in Cintra et al. (2008) for the non-orientated case.

For the orientated case, the number of instances solved to proven optimality is 9 for the RCCG and 10 for the CGRp. Compared with the CGRp, the solution of the RCCG is better in 1 instance (Gcut3dr), the same in 9 instances, and worse in 2 instances (Gcut4dr and Gcut8dr). This indicates that the solution quality of the RCCG is slightly lower than that of the CGRp for the orientated case. The average computation time of an instance is 0.04seconds for the RCCG. It is 1.6seconds for the CGRp. The former is about 2.5% of the later. The RCCG may be faster than the CGRp, although the later used a different computer.

For the non-orientated case, the number of instances solved to proven optimality is 9 for the RCCG and 4 for the CGRp. Compared with the CGRp, the solution of the RCCG is better in 6 instances, the same in 5 instances, and worse in 1 instance (Gcut8dr). This indicates that the solution quality of the RCCG is obviously higher than that of the CGRp for the non-orientated case. The average computation time of an instance is 0.073seconds for the RCCG. It is 4.924seconds for the CGRp. The former is only about 1.5% of the later. The RCCG solution to Gcut9dr is shown in Fig. A1 in Appendix A. The solution is optimal. Its plate count (125) is smaller than that of the CGRp solution by one.

From the computational results in this sub-section, it can be said that the average solution quality of the RCCG is better than that of the CGRp, and the RCCG may be faster than the CGRp. The statement is true at least for this set of instances.

The exact algorithm in Silva et al. (2010) is denoted as SILVA. Two sets (Sets 2 and 3) of benchmark instances are used. The items are oriented because the computational results of the SILVA for the non-oriented case are not available.

Set 2 contains 30 small instances. Their features are available from Table 3
                         in the e-appendix of Silva et al. (2010). Table 3 shows the computational results, where Z
                        SILVA denotes the solution value of the SILVA and is copied from Table 9 of the e-appendix in Silva et al. (2010). The SILVA solved all instances to optimality. The RCCG solved 25 of them to optimality. For the 5 instances (A2, CHL1, CW2, Hchl4s and 3) not solved to optimality, the gap to optimality is only one plate. The average computation time of an instance is 0.19seconds for the RCCG. It is 8.6seconds for the SILVA. The former is only about 2.2% of the later. The RCCG may be faster than the SILVA, although the later used a different computer.

Set 3 contains 20 medium-scale instances. Table 4
                         shows the instance features and the computational results, where l
                        
                           avg
                         denotes the average item length, w
                        
                           avg
                         the average width, and d
                        
                           avg
                         the average demand. The Z
                        
                           LB
                         and Z
                        SILVA values are copied from Table 9 of the e-appendix in Silva et al. (2010). Although the SILVA is an exact algorithm, it did not solve some instances to proven optimality because the computation time limit of 7200seconds for each instance. The number of instances solved to proven optimality is 14 for the RCCG and 12 for the SILVA. Compared with the SILVA, the solution of the RCCG is better in 3 instances (ATP31, ATP42 and ATP43), the same in 16, and worse in 1 (ATP49). This indicates that the average solution quality of the RCCG is better than that of the SILVA. The average computation time of an instance is 9.5seconds for the RCCG and 3643seconds for the SILVA. The former is only about 2.6% of the later. The RCCG may be faster than the SILVA.

The RCCG solution to instance ATP42 is shown in Fig. A2 in Appendix A. It is optimal and the plater count (15) is smaller than that of the SILVA solution by one.

From the computational results in this sub-section, it can be said that when the scale of the instances is large, the average solution quality of the RCCG may be better than that of the exact algorithm SILVA if the computation time is limited, and the RCCG may be faster than the SILVA. The statement is true at least for the instances in Set 2. This also indicates that the exact algorithm is not adequate when the instance-scale is large because of the unaffordable long computation time.

This subsection compares the RCCG with the Plus2D, a commercial stock cutting software package that can be obtained from http://www.nirvanatec.com (Plus 2D Metal Demo Version 9.11), using the three sets of instances in the previous two sub-sections and a set (Set 4) of practical instances. The Plus2D can generate two-staged, three-staged and more complex patterns. It is restricted to generate only two-staged patterns here. Both X- and Y-patterns are considered.

The lower bound Z
                        
                           LB
                         for the solution value of an instance is obtained in Step 1 of the RCCG (before rounding the fractional frequencies) and is equal to 
                           
                              ⌈
                              ∑
                              
                                 
                                    x
                                 
                                 
                                    k
                                 
                              
                              ⌉
                           
                        , where x
                        
                           k
                         denotes the frequency of the kth pattern.


                        Table 5
                         lists the computational results for Set 1, where Z
                        Plus2D is the solution value of the Plus2D. The number of instances solved to proven optimality is 10 for the RCCG and 8 for the Plus2D. Compared with the Plus2D, the RCCG yielded better solution in 4 instances (Gcut3dr, Gcut8dr, Gcut11dr and Gcut12dr) and the same in others.


                        Table 6
                         shows the computational results for Set 2. The number of instances solved to proven optimality is 28 for the RCCG and 26 for the Plus2D. Compared with the Plus2D, the RCCG yielded better solution in 2 instances (A4 and CHL6) and the same in others.


                        Table 7
                         shows the computational results for Set 3. The number of instances solved to proven optimality is 16 for the RCCG and 12 for the Plus2D. Compared with the Plus2D, the RCCG yielded better solution in 4 instances (ATP32, ATP33, ATP37 and ATP40) and the same in others.

The average computation time of the RCCG for an instance is 0.08seconds for Set 1, 0.56seconds for Set 2, and 20.82seconds for Set 3. The average computation time of the Plus2D is longer than two times of that of the RCCG.


                        Table 8
                         shows the computational results for 5 practical instances (Set 4), where the items data (see Appendix B) are the same for all instances, and the plate sizes are different. The items data were obtained from the practical cutting process of plate glass. The plate sizes are common in the glass industry of China. The total plate area and gap are listed in the bottom rows. The RCCG solved all instances to optimality. Its solutions are all better than those of the Plus2D. The material utilization of the RCCG is higher than that of the Plus2D by 3.98%. The average computation time of an instance is 22seconds for the RCCG and 69seconds for the Plus2D.

Recall that parameter G (the number of strip sets) for the C_SLOPP procedure has default value 15. The effect of the G value on the solution value of the RCCG is summarized in Table 9
                        , using the instances in Set 2 and assuming oriented items. The total number (N) of plates used for each G value is listed in the last row. It is seen that the N value is the largest when G
                        =1 and smallest when G
                        =15 and G
                        =30. Other sets of instances were also tested. The results show that the N value usually decreases with the increase in G, and the smallest N value appears between G
                        =5 and G
                        =15. As a result, G
                        ∈[5,15] may be adequate.

@&#CONCLUSIONS@&#

The algorithm RCCG in this paper solves the two-dimensional single stock size cutting stock problem with two-staged patterns and rotation of items. It calls the column-generation approach repeatedly to solve the residual problems until all demands are satisfied. The convergence of the algorithm is guaranteed by solving the constrained single large object placement problem to generate the cutting patterns.

Two-staged patterns are simple to cut than most pattern types, and are widely used in practice. The algorithm can generate the cutting plans quickly, and solve most instances to optimality. The comparisons among the approaches indicate that the algorithm is effective in reducing the number of plates used (the statement is true at least for the instances tested).

Future research work may include the use of the RCCG frame to solve the two-dimensional cutting stock problem with other types of cutting patterns, such as T-shape patterns (Cui and Huang, 2013), three-staged patterns (Cui and Huang, 2012), and general guillotine patterns (Armas et al., 2012).

@&#ACKNOWLEDGMENT@&#

This research is part of Project 61063031 supported by National Natural Science Foundation of China.

The RCCG solution to Gcut9dr is shown in Fig. A1
                     . Its plate count (125) is smaller than that of the CGRp (Cintra et al., 2008) solution by one. The frequencies of the 11 patterns are respectively 17, 10, 6, 9, 7, 3, 15, 11, 20, 26 and 1.

The RCCG solution to instance ATP42 is shown in Fig. A2
                     . Its plate count (15) is smaller than that of the SILVA (Silva et al., 2010) solution by one. The frequencies of the 15 patterns are all 1.

The items data are the same for the five practical instances. There are 58 item types. The three numbers in each group denote the length, width and demand of an item type (see Table B1
                     ).

@&#REFERENCES@&#

