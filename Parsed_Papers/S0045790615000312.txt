@&#MAIN-TITLE@&#Context-aware multi-objective resource allocation in mobile cloud

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A resource allocation method to minimize time and energy of tasks in mobile cloud is proposed.


                        
                        
                           
                           A two-stage approach using NSGA-II, entropy and TOPSIS methods is employed.


                        
                        
                           
                           A context-aware Offloading Middleware for Mobile Cloud is developed to manage offloading.


                        
                        
                           
                           A virtual credit based incentive mechanism is used to motivate users to cooperate in offloading.


                        
                        
                           
                           The proposed method appropriately manages the trade-off between time and energy.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mobile cloud

Offloading

Context-awareness

Resource allocation

Multi-objective optimization

@&#ABSTRACT@&#


               
               
                  Mobile Cloud Computing (MCC) augments capabilities of mobile devices by offloading applications to cloud. Resource allocation is one of the most challenging issues in MCC which is investigated in this paper considering neighboring mobile devices as service providers. The objective of the resource allocation is to select service providers minimizing the completion time of the offloading along maximizing lifetime of mobile devices satisfying deadline constraint. The paper proposes a two-stage approach to solve the problem: first, Non-dominated Sorting Genetic Algorithm II (NSGA-II) is applied to obtain the Pareto solution set; second, entropy weight and Technique for Order Preference by Similarity to Ideal Solution (TOPSIS) method are employed to specify the best compromise solution. Furthermore, a context-aware offloading middleware is developed to collect contextual information and handle offloading process. Moreover, to stimulate selfish users, a virtual credit based incentive mechanism is exploited in offloading decision. The experimental results demonstrate the ability of the proposed resource allocation approach to manage the trade-off between time and energy comparing to traditional algorithms.
               
            

@&#INTRODUCTION@&#

In spite of significant improvements of mobile device technologies, mobile devices still encounter resource scarcity (limited processing power, memory, battery life) running intensive computing applications such as image processing, speech recognition and data mining. To overcome this resource restriction, it has been suggested to offload computation from mobile device to the cloud [1].

Doing this, Mobile Cloud Computing (MCC) augments computing capabilities of mobile devices to enable them to run computational intensive applications to provide better user-experiences. On the other hand, mobile devices have sensing abilities to gather contextual information of user environment. Therefore MCC can provide adoptive, efficient, context-aware services for users which is a common view of pervasive computing [1,2].

A three-tier architecture is defined for MCC which consists of remote cloud servers, nearby computing servers known as cloudlets and neighboring mobile devices [1,3,4]. However, as cloud servers are not always available, offloading to remote cloud can be costly and introduces latency [5–7] while offloading to local cloudlets limits mobility of devices [1,6,8]. In this paper third tier is considered which is defined as ‘Mobile Cloud’ [9,10] consisting of neighboring mobile devices (mobile phones, PDAs, laptops, etc.) which are encountered to each other opportunistically and belong to different individuals. In the Mobile Cloud, both service requester and service providers are mobile devices.

Given an offloading service request in Mobile Cloud, as shown in Fig. 1
                     , it is a challenging issue to determine whether and where to offload the subtasks among vicinal mobile devices minimizing the completion time of tasks as well as consumed energy of all mobile devices along satisfying deadline constraint. In addition, in order to provide dynamic and accurate resource allocation, it is required to gather contextual information of devices, applications, and environment to be used in decision [11]. Moreover, an integrated system is required to manage the offloading process in mobile cloud.

Most of the previous works on resource allocation in MCC attempt to decide only which portion of application to be offloaded to the cloud in order to optimize execution time or energy [3,4,8,12,13]. Some other studies try to select appropriate resource providers among available mobile devices to allocate tasks [5,9,10,14–17]. For example, Scavenger [14] uses a dual-profiling scheduler and develops a cyber foraging framework to allocate tasks to available surrogates towards minimizing execution time. In [5], a context aware application offloading scheme is proposed for mobile peer-to-peer environments. The authors define three context aware offloading policies that select a surrogate for each application partition in order to minimize the initiator device’s energy consumption, or minimize the execution time of the application or maximize the success in application execution. In Serendipity [9], initiator device assigns subtasks to resource providers among intermittently encountered mobile devices. Time-optimizing Serendipity only minimizes completion time while energy-aware Serendipity only minimizes energy consumption of mobile devices. In [10] authors define a Mobile Device Cloud (MDC) environment consisting of highly collaborative mobile devices where the offloading schema is to only maximize the lifetime of the MDC. Authors in [16] introduce HYCCUPS, an offloading framework for Hybrid Contextual Cloud for Ubiquitous Platforms comprising of Smart phones and propose an adaptive contextual search algorithm to schedule mobile applications. In local decision, the initiator device decides whether to execute the task locally or offload it onto another device in order to minimize overall execution time regarding the battery energy, resource availability and mobility of mobile while in remote decision, a remote device determines whether it can execute that task or not.

However, to the best of our knowledge, those methods mostly focus on a single decision metric (usually time or energy) to decide about the offloading target. Specifically, none of the previous literatures in MCC provides a resource allocation approach which optimizes both overall execution time and consumed energy simultaneously while minimizing completion time along the energy consumption is a significant problem since in addition to keeping tasks deadline, minimizing the tasks completion time improves the quality of users’ experience from using MCC and minimizing energy consumption simultaneously increases the lifetime of the mobile cloud.

In Our previous work [15], we have investigated the resource allocation problem among neighboring mobile devices aiming to minimize the completion time of offloading while maximizing lifetime of mobile devices. An Optimal Fair Multi-criteria Resource Allocation (OFMRA) algorithm has been proposed to solve the resource allocation problem assuming that the subtasks are identical. However most of applications have subtasks with different computational workloads. In such case, the resource allocation problem is a more complex problem. In addition, an Offloading Mobile Cloud Framework (OMCF) has been developed which collects profile information and handles the offloading process.

In this paper, the resource allocation problem is formulated as a multi-objective optimization that aims to minimize completion time of tasks as well as consumed energy of all participating mobile devices along satisfying deadlines. In contrast to our previous work [15], the subtasks are assumed to have different size which makes the resource allocation problem more complex than previous study. Therefore, to solve the multi-objective optimization in reasonable time, a two-stage approach is employed. First, a Non-dominated Sorting Genetic Algorithm II (NSGA-II) is applied to the problem to obtain the set of Pareto solutions. Second, a Multi-Attribute Decision-Making (MADM) technique is used to specify best compromise solution which is based on entropy weight and the Technique for Order Preference by Similarity to Ideal Solution (TOPSIS). It is noteworthy that encouraging selfish mobile devices to cooperate in each other’s offloading process; a virtual credit based incentive mechanism has also been exploited in offloading decision.

In addition, a context-aware Offloading Middleware for Mobile Cloud (OMMC) is developed to collect context of devices (e.g. energy level and processing power), subtasks (e.g. execution time) and environmental variables (e.g. network bandwidth), and also to manage the offloading process based on proposed resource allocation algorithm.

The main contributions of this paper are summarized as follows: (1) formulation of resource allocation problem as a multi-objective optimization which aims at minimizing completion time and energy consumption of offloading while considering some constraints such as user’s acceptable deadline, service providers’ residual energy and budget constraint; (2) solving the multi-objective optimization using NSGA-II to obtain near optimal Pareto solutions and using entropy and TOPSIS methods to determine the best compromise solution without the need of user preferences; (3) design and implementation of OMMC, a context aware offloading middleware that gathers contextual information of mobile cloud and manages offloading process; (4) exploiting a virtual credit based incentive mechanism to more engage mobile devices in offloading process.

The rest of the paper is organized as follows. Section 2 reviews the related works. Section 3 describes architecture of context-aware OMMC system and the profile estimation. In Section 4 the multi-objective resource allocation is formulated and is solved using the two-stage approach and moreover, virtual credit based incentive mechanism has been described. Section 5 explains evaluation results of OMMC. Finally, the paper is concluded in Section 6.

@&#RELATED WORK@&#

There are several studies that investigate the task allocation problem in grid or cloud computing [18–20] however those do not simultaneously consider time and energy as the metrics in task allocation optimization. Only few studies consider time and energy together. For example, authors in [20] explore the task allocation problem in grid which aims to minimize the instantaneous power and the completion time simultaneously satisfying deadlines and tasks’ architectural requirements. They proposed a solution from cooperative game theory based on the concept of Nash Bargaining Solution. However, in [20] (and all above studies), power management of servers is achieved through regulating the instantaneous power consumption by using Dynamic Voltage Scaling (DVS) which is not available in mobile environments. In mobile environments, to reduce the energy consumption of devices, tasks should be assigned appropriately. In addition, regarding energy criterion in [20], the authors only try to minimize the aggregate energy consumption of all nodes. However in heterogeneous environments such as mobile cloud where battery capacity of devices (smartphones, laptops, PDA) are limited, it is also important to address the residual energy of devices since minimizing overall energy consumption leads to assigning more tasks to the devices with low energy consumption rate and thus these devices may drain-out of batteries rapidly. In current research, both the energy consumption and residual energy of devices are considered in formulation of the problem to maximize the lifetime of mobile cloud. In other words, data centers consume huge amounts of electrical energy, leading to high operational costs and carbon footprints to the environment and thus reduction of overall energy consumption is important [18]. However, in mobile cloud, service providers are mobile devices with limited battery capacity where if a device ran out of energy it is dropped from cloud. Therefore, the residual energy of devices is a critical criterion in task allocation decision [8,10].

Moreover, most of the work on task allocation in grid and cloud computing is regarded infrastructure based powerful computing systems with high bandwidth connectivity. However, due to recent enhancements in mobile computing and wireless communication technologies, many researchers have turn to mobile grid and mobile cloud computing where mobile devices are resource providers. There are many studies in Mobile Ad-Hoc Grid such as [21,22], investigate the task allocation problem among nearby mobile devices which does not require any pre-configured infrastructure. The resource allocation problem in those studies is somehow similar to our work, but most of the approaches presented in mobile grid only consider the completion time or energy consumption as objectives. For example, [21] tries to minimize the consumed power satisfying deadline constraint of applications.

Regarding MCC, several comprehensive surveys on offloading in mobile cloud computing have been published such as [1] in recent years stating various offloading methods, architectures and context aware services which augment capability of mobile devices. Considering three tier architecture of MCC, we can divide previous researches of resource allocation in MCC into two categories: (1) offloading to the cloud or nearby servers; (2) offloading among neighboring mobile devices.

Some studies have explored the feasibility and improvement of offloading to the cloud via presenting an offloading framework such as [13]. Some other studies, besides presenting an offloading framework, have tried to determine application partitioning and decide which part to be offloaded to the cloud towards minimizing execution time or maximizing energy saving of initiator mobile device [3,4,8,12]. For example, AIOLOS [4], MAUI [8] and CloneCloud [12] present an energy-aware offloading architecture to gather extensive profiles that are used in decision of whether to execute each method locally or remotely, minimizing energy consumption of initiator mobile device. In those papers, the identified tasks are sent to the cloud and cloud providers are responsible to determine the destination of each task. A few papers, such as [23], also have investigated the resource allocation problem in mobile cloud from cloud providers’ perspective. Authors of [23] study the resource allocation problem in offloading, aiming at minimizing the overall energy consumption in a mobile cloud computing system from an environmental impact perspective. They model the energy minimization problem as a congestion game in which a mobile device is a player and his strategy is to select an appropriate cloud server to minimize the overall energy consumption of the mobile device and the cloud infrastructure.

However, cloud servers are not always available and offloading to remote cloud can be costly and leads to latency [5,6]. To overcome above pitfalls, some studies have investigated offloading the application to the nearby servers. In [6] the authors suggest offloading the application to the nearby servers known as cloudlet in order to reduce interactive response time of the application via one-hop network of the cloudlet. Another example is Spectra [24] which provides a remote execution system that enables mobile devices to use resources of nearby powerful servers. Spectra decides which methods will be offloaded and to which surrogate, to balance the competing objectives of performance, energy conservation of the mobile devices, and applications quality. However, in Spectra, mobile devices should consult to a central database containing server information which creates a bottleneck.

Considering local servers as resource providers would limit the mobility of the users and cause scalability problems in accessing to shared resources. In this regard, Rahimi et al. [25] combine the capabilities of local servers and remote cloud and provide MAPCloud, a middleware for offloading. They propose MuSIC an optimal and fair service allocation algorithm to optimize several QoS metrics including completion time of the application, energy consumption of mobile device and user cost. Similarly, authors of [3] consider remote cloud servers and nearby cloudlets and model the competition of mobile devices on shared resources of the hybrid cloud as a game where each mobile device decides which subtasks to be offloaded and to which local server or to the cloud. The proposed game aims at minimizing response time of tasks regarding the constraint that mobile device’s power consumption should not exceed an expected threshold. However, the paper does not provide an offloading framework and the evaluation are performed using MATLAB simulation. Third layer of MCC, i.e. nearby mobile devices, are not considered as service providers in both of above works. Thus, in the absence of local computing infrastructure, subtasks are always assigned to the remote cloud which brings delay and cost.

There are few studies investigating third tier of MCC consisting of neighboring mobile devices where both client and service providers are mobile devices. For example, authors in [7] provide the preliminary design of a framework to create virtual mobile cloud computing using mobile phones as the service providers. Their proposed framework consists of several components including context manager, resource manager and offloading manager. The context manager collects the contextual information such as the location and number of nearby devices and forms the mobile cloud using an ad-hoc discovery mechanism and a P2P grouping scheme. The resource manager monitors resources on the initiator device and checks the application profiling to decide whether a task should be locally executed on a mobile device or an instance of the virtual provider should be created. The offloading manager handles the job transmission over the virtual mobile cloud and detects failures in the execution and re-emits them. However, the objective of resource allocation decision making is not explained. In addition, it assumes that users have a common goal which motivates them to participate in offloading process but in absence of common activities, the method is not applicable.

Marinelli [26] presents Hyrax, a platform for Android smart phones which explores the feasibility of using a network of mobile devices as resource providers communicating with each other using WiFi. Although the experimental results show the scalability of Hyrax, the performance of the platform is poor for CPU-bound tasks. In [27], a Hybrid Local Mobile Cloud Model (HLMCM) is defined consisting of cloudlet and mobile devices where cloudlet plays the role of central broker while both cloudlet and neighboring mobile devices play the role of service provider. The objective of application scheduling is to maximize the profit as well as lifetime of HLMCM, while satisfying resource capacity constraint of service providers. They propose the Hybrid Ant Colony based Application Scheduling (HACAS) algorithm to solve the scheduling problem. However, the completion time of application which is one of the important QoS features has not been taken into account in their scheduling. In our proposed method, this shortcoming is regarded in parallel with lifetime of the mobile cloud. In addition, in both [26,27], central server runs the scheduling algorithm and manages the offloading process which is a bottleneck while in our proposed method, resource allocation decision and execution of offloading process are performed individually on each mobile device.

Scavenger [14] is a cyber foraging framework that enables initiating mobile devices to use computational resources of available surrogates to execute remoteable methods. Scavenger uses a dual-profiling scheduler for cost assessment which is also employed in our proposed method. It performs resource allocation based on speed of surrogates so as minimizing execution time. However in Scavenger, the energy consumption of devices is not considered. In addition, all surrogates in conducted experiments are desktops whilst Scavenger seems heavy to be executed on mobile phones. In contrast, both the energy consumption and the execution overhead will be considered in our proposed method since mobile devices are main players in MCC.

In [5], a context aware application offloading scheme for mobile peer-to-peer environments is proposed in which nearby smart phones create a mobile peer-to-peer network and share their computational tasks. The presented scheme collects contextual information from nearby devices and environment and infers appropriate information regarding a specific context aware offloading policy. The authors propose a partitioning and assignment mechanism based on the application’s resource consumption and resource availability of candidate surrogates. They define three context aware offloading policies that select a surrogate for each application partition in order to:
                        
                           •
                           minimize the initiator device’s energy consumption through maximizing the energy saving in initiator device, or

minimize the execution time of the application, or

maximize the success in application execution as a compound probability of mobility, power and social considerations.

However, regarding resource allocation, it optimizes only one of the time, energy, or probability of success separately and so does not consider above criteria simultaneously. In addition, regarding the policy of minimizing the energy consumption, it considers only the local device’s energy consumption and ignores residual energy of other devices contributed in offloading while maximizing life time of mobile cloud needs attention to energy consumption of all participating devices as will be regarded in our proposed method. Moreover, in the case of minimizing execution time of the application, their goal is saving the initiator device’s CPU through offloading more partitions to other surrogates whereas minimizing overall application completion time is not regarded.

As the most related work to this paper, Ref. [9] considers local tier of mobile cloud, consisting of intermittently encountered mobile devices where both service requester and service providers are mobile. This work designs Serendipity system which enables offloading using gathered information profile and releases two versions of task allocation algorithm, time optimizing and energy aware Serendipity. In time optimizing, the subject is to minimize execution time of application and a greedy algorithm is presented which iteratively selects the surrogate with minimum completion time for each subtask. In energy aware Serendipity, it aims at maximizing lifetime of mobile devices considering deadline constraint, and uses the energy model presented in [28] as utility function for surrogate selection. Although task allocation methods of Serendipity optimize execution time and energy separately, these two conflicting criteria are not optimized together handling the tradeoff between them. In addition, that work assumes that all subtasks of an application are identical which is far from reality whilst subtasks are considered to have different sizes in our proposed method. Moreover, as most of above articles, Serendipity assumes that all devices are cooperative, which is not the case of real world. To address the selfishness of mobile users, a virtual credit based incentive mechanism is proposed and applied in our offloading decision which encourages selfish devices to cooperate in each other’s offloading process.

In [10] a MDC environment consisting of highly collaborative mobile devices is considered where the offloading schema is to maximize lifetime of the MDC. The authors implement an experimental platform similar to Serendipity [9] for evaluation of different offloading techniques and profiling. However, minimizing completion time along the energy consumption is a significant problem since in addition to keeping tasks deadline (which is the case of above study), minimizing the tasks completion time improves the quality of users’ experience from using MCC. In addition, authors assume only collaborative scenarios such as group of people on a mission where all devices have a common goal.

Authors in [16] present HYCCUPS, an offloading framework for Hybrid Contextual Cloud for Ubiquitous Platforms comprising of Smart phones where both clients and computing resources are mobile devices. They also propose an adaptive contextual search algorithm to schedule mobile applications in HYCCUPS. Specifically, when an application offloading request is generated in HYCCUPS, a local and a remote decision should be taken. In local decision, the source device decides whether to execute the task locally or offload it onto another device. Regarding offloading, it sends a task offload request to all connected devices, and waits for their responses as their potentials to run the task. They define the computing potential as “the time required by the processor to run a workload considering current and predicted values for CPU load and CPU frequency in the near future”. After collecting all devices’ response, their method selects the best candidate device considering the local device, in order to minimize overall execution time (computing potential) regarding the battery energy, resource availability and mobility of mobile devices as constraints. In remote decision, when a device receives the offloaded task request, it determines whether it can execute that task or not. Moreover, they use a cost model to prevent selfishness in the system in which client and service provider store a positive and negative debt respectively due to offloaded task. This method encourages devices to offload in order to reduce their debt while their incentive method is not accurate. Furthermore, the subject of their task assignment is to minimize execution time calculated as computing potential regarding battery energy, and resource availability of devices while energy consumption minimization is not regarded in resource allocation objectives. In contrast, our proposed resource allocation approach minimizes overall execution time and energy consumption simultaneously satisfying deadline constraint.

Ref. [17] also investigates the problem of resource offloading to optimize energy usage in the mobile opportunistic cloud consisting of connected mobile devices. The authors propose a centrality-based offloading scheme which objects to maximize the energy consumption efficiency, node availability and reliability of process execution, using social centrality principle as the mobility and interactivity model during the offloading process. However, the process completion time (one of the important features of QoS) and its conflict with energy consumption are not regarded in their offloading scheme. In addition, authors use social relationships between users as the incentive to encourage users to cooperate in other’s offloading, whereas in the absence of social relationships, their method is not applicable.

In our previous work [15], we have considered the resource allocation problem among neighboring mobile devices subject to minimizing completion time of offloading as well as maximizing lifetime of mobile devices. Regarding assumption of identical subtasks, we have proposed OFMRA algorithm based on branch and bound approach to solve the resource allocation problem and using weighted sum formula to achieve the best solution. However, in reality, subtasks of the most applications are not identical. In addition, in our previous work, we have developed OMCF which collects profile information and handles the offloading process. In this paper, we extend our work to collect more contextual information and improve the management of offloading process by employing a decision algorithm that considers subtasks with different sizes.

As mentioned earlier, the OMMC is a context aware offloading middleware which collects contextual information to be leveraged to infer relevant aspects in offloading process and especially resource allocation. Referring to context; there are several definitions. Schilit et al. [29] describes three aspects of context that should be considered, i.e. where you are (the user’s location), who you are with (other users in the vicinity), and what resources are nearby (the resources in the user’s environment). Dey [11] define context as “any information that can be used to characterize the situation of an entity i.e. whether a person, place, or object that is considered relevant to the interaction between a user and an application, including the user and applications themselves.”

In mobile cloud computing, context awareness is referred to forming clouds of computational resources as well as processing information [1]. To make a cloud, OMMC collects contextual information of nearby devices, application, and environment, such as processing power, CPU usage and network bandwidth, which are regarded as contextual information in similar works [5,13,16]. OMMC also considers residual energy of mobile devices which is an important aspect of context that refers to energy awareness. OMMC interprets the obtained profiling data about surrounding computation resources and applies them into dynamic decision making for resource allocation. Context aware systems should be notified of changes in the context and automatically reconfigure their configurations to adapt to the context [1,5]. As long as OMMC is running, the contextual information in context database is continuously updated, so the proposed contextual resource allocation adapts to environmental changes. In addition, OMMC records the contextual information and uses them to learn and predict for future estimations.

OMMC middleware composes of two parts: OMMC Client which requests offloading service and OMMC Server which provides services. A mobile device runs both parts of the middleware. Fig. 2
                         shows high-level overview of OMMC middleware.

The OMMC Client consists of four main components: context manager, resource allocation, proxy, and offloading manager.
                           
                              (1)
                              
                                 Context manager: Context manager gathers contextual information of task, resource providers, and network via their aggregators i.e. task profiler, device profiler and network profiler, respectively.

Device profile contains processing power and energy consumption model of each mobile device which is announced via discovery protocol. Task profile contains information about runtime and size of input/output of each subtask. There are several task partitioning techniques [4,8,14] in which developers annotate offloadable parts of application using libraries of programming languages. For example, authors in [14] provide Scavenger library based on Python which is used by developers to annotate remote executable methods. In this paper, based on above techniques, it is assumed that developers of the applications have presented offloadable parts of the task in task profile.

Details of estimating profile information (profile of task, mobile devices and network) and its computational overhead will be discussed in Section 3.2.

After completion of an offloading, context manager collects contextual information about the amount of energy and time it took to run each subtask on its surrogates and also network information measured in the recently offloading process to make a history and up to date context repository. OMMC uses the historical information to learn and improve its profile estimation for future offloading.
                           
                              (2)
                              
                                 Resource allocation: Resource allocation module in OMMC client uses the contextual information to specify whether and where each subtask should be executed. The computational overhead of the resource allocation module has been considered in proposed method and also in experimental evaluations.


                                 Client proxy: Client proxy establishes connections between client mobile and its resource providers and schedules input files transmission. The communication is based on TCP which provides reliable transmission. Input file of all subtasks of each device are sent tandem where devices with slower processing power are scheduled sooner in order to provide more time to complete their subtasks.

Client proxy also monitors network connectivity and detects network disconnection. There are several methods for handling fault tolerance and network disconnection [5,8] such as rerunning the resource allocation algorithm to reallocate the failed subtasks or run the failed subtasks locally on initiator device. Since the overhead of rerunning the resource allocation algorithm and reallocating subtasks are significant [22], we employ the idea presented in [8] and resume failed subtasks and run them locally which is the best effort solution for low mobility scenarios.

However, in high mobility conditions, disconnections can happen quite often. To overcome this problem, context-based failure prevention mechanisms can be employed in the resource allocation process, such as the one described in [5] which uses the mobility prediction (i.e. the schema proposed in [30]) to predict whether an offloading will be likely to succeed or not. More details are out of the scope of current research and will be regarded as future work.
                           
                              (4)
                              
                                 Offloading manager: This module coordinates components of OMMC client and the application as well as managing the offloading process.

On the server side, there are four components: discovery module, device profiler, service providing manager and server proxy. Every mobile device willing to cooperate in offloading, introduces itself through discovery protocol. We use the proactive discovery protocol proposed in [31] in which every device broadcasts an advertisement message including device’s profile (processing power, battery energy level, etc.) periodically. Regarding overhead of discovery protocol, it is noteworthy that discovery is performed in parallel with other processes and so does not impose processing delay to them, although the power consumption of discovery is considerable.

Server proxy handles the communications between the service provider and client mobile together with client proxy. Finally, service providing manager coordinates the components of OMMC server.

When an offloading service request arrives to OMMC client, it decides whether and where to offload it. Thus the steps of offloading process in OMMC are as follows:
                           
                              1.
                              
                                 Surrogate discovery: At first, client mobile uses discovery mechanism to search for vicinal mobile devices within range. In discovery protocol, each mobile device sends its device profile.


                                 Context gathering: Using context manager, client mobile senses and collects context data of vicinal devices, subtasks of the given task, and network information.


                                 Resource allocation: Gathered contextual information is passed to resource allocation module to determine subtask assignments. Then proxy of OMMC client sends subtask’s related data to specified resource providers based on file transfer scheduler.


                                 Task execution: Each resource provider executes its assigned subtasks and returns the results.


                                 Monitoring and collecting results: After completion of all subtasks, OMMC client collects partial results and merges them.


                                 Payment: When offloading process finishes, payments to resource providers are performed using virtual credit based incentive protocol which will be described in next section.

There are several techniques in order to predict runtime, energy consumption, and output size of a subtask on a specific surrogate [4,8,14]. In current paper, a dual profiling technique inspired from [14] is used which consists of a peer centric profile and a task centric profile.

Given a subtask to be executed on a specific surrogate, the peer centric profile is consulted first in order to provide the most accurate data. Peer centric profile is a history based profile including runtime and energy consumption of the last n runs of a subtask on a specific peer. In this paper, the average of the profile data from the last ten runs is calculated as an estimate. Using weighted average, which gives greater significance to more recent profile data, would be another approach.

In a mobile and heterogeneous environment such as mobile cloud, it is likely that no information exist for a specific peer. In such cases, the task centric profile is used. Here, task centric profile estimates runtime and energy consumption of a subtask on a specific surrogate based on the methods proposed in [14,8], respectively.

In order to estimate runtime, authors in [14] employ benchmarking to acquire processing power of each peer as its strength score, where PassMark benchmark [32] is employed in this paper. On the other hand, they store a task centric profile containing subtasks’ weight which is the expected running time on a machine of strength one. To assess the runtime of a subtask on a specific surrogate, the subtask’s weight is divided by the peer’s strength. Regarding energy consumption, the method proposed in [8] is used in which an energy consumption model is created per peer. That research constructs a synthetic benchmark and runs it multiple times to record the number of CPU cycles (CPU utilization) and the corresponding peer’s energy consumption for each run in order to build a simple linear model, using least-squares linear regression. Then this model is used to predict the energy consumption of a method as a function of its CPU cycles. As described, the linear energy consumption model is obtained offline.

As stated in [14], benchmarking based task weighting is not so accurate and comprehensive, but in absence of knowledge about estimated runtime of a subtask on unknown surrogates, it brings a more informed resource assignment in mobile clouds. The same conclusion is regarded for energy consumption estimation mechanism.

Network profile including network bandwidth and latency are obtained using the method explored in [8], i.e. 1KB of data is sent periodically and transmission duration is measured to specify the network throughput.

Regarding the explanation on how to calculate the dual profiles, the runtime and energy consumption of profiling (task, device and network) are not considerable and are ignored in this paper. In addition, it is noteworthy that the benchmarking in task centric profile (runtime and energy consumption) is always performed offline and has no overhead on offloading process.

As described in Section 3, given an offloading service request, client mobile collects contextual information and uses them to decide whether and where to offload each subtask. In this paper, it is assumed that at any time, only one offloading service can be performed and the offloading service requests arrive sequentially. In addition, we assume low mobility scenarios where mobile service providers stay in vicinity of mobile client during the offloading process. Although the mobility of resource providers is an important challenge in high mobility environments, however it is out of the scope of current research and will be addressed in our future work.

In this section, we formulate the resource allocation in mobile cloud as a multi-objective optimization which aims at minimizing completion time and energy consumption while satisfying applications deadline and the minimum residual energy of devices, as QoS constraints. Then a two-stage approach is proposed to solve the multi-objective resource allocation.

Suppose that the task in a given offloading request consists of n parallel and independent subtasks and m neighboring mobile devices are discovered as resource providers. Let R
                        1 indicates the initiator mobile device, Rj denotes jth resource provider and R
                        0 represents the standard mobile device with known computing configuration. The notations of variables are shown in Table 1
                        .

A solution of the resource allocation problem is a binary matrix b of n rows, one for each subtask, and m
                        +1 columns, one for each resource provider plus one column for initiator device (the mobile that starts offloading) where bij
                         is 1 if the ith subtask is allocated to jth mobile device and otherwise is zero.

The objective of the resource allocation is to optimize completion time and energy consumption simultaneously. Since all subtasks of the task are parallel and independent, as described in [19], the completion time of the task consists of resource allocation runtime and the maximum entry of tlj
                         where tlj
                         is the turnaround time it takes for Rj
                         to execute its assigned subtasks. The time taken for initiator device (j
                        =1) to complete its assigned subtasks is summation of their runtimes plus the time to transmit the input data to surrogates (
                           
                              sendDelay
                           
                        ). The time that is required per each resource provider Rj
                         (j
                        >1) to prepare the result of offloading request includes execution time of the subtask on that device, transmissions time of input and output files of that subtask and the time the subtask waits in file transfer scheduler of client proxy queue before transmission. The time that a subtask, 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                        , waits in initiator queue to be sent to its resource provider (
                           
                              
                                 
                                    Qdelay
                                 
                                 
                                    j
                                 
                              
                           
                        ) is the summation of transition time of the earlier subtasks in the device queue. Therefore the completion time of the task is calculated as:
                           
                              (1)
                              
                                 
                                    
                                       
                                       
                                          
                                             completeTime
                                             =
                                             
                                                
                                                   
                                                      max
                                                   
                                                   
                                                      j
                                                      ∈
                                                      {
                                                      1
                                                      …
                                                      m
                                                      +
                                                      1
                                                      }
                                                   
                                                
                                             
                                             
                                                
                                                   tl
                                                
                                                
                                                   j
                                                
                                             
                                             +
                                             algoRuntime
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   tl
                                                
                                                
                                                   j
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               +
                                                               sendDelay
                                                               ,
                                                            
                                                            
                                                               j
                                                               =
                                                               1
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              t
                                                                           
                                                                           
                                                                              ij
                                                                           
                                                                        
                                                                        +
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          
                                                                                             Vin
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                       
                                                                                       +
                                                                                       
                                                                                          
                                                                                             Vout
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                       
                                                                                    
                                                                                    
                                                                                       
                                                                                          
                                                                                             BW
                                                                                          
                                                                                          
                                                                                             j
                                                                                          
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               +
                                                               
                                                                  
                                                                     Qdelay
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               ,
                                                            
                                                            
                                                               j
                                                               >
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             sendDelay
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      k
                                                      =
                                                      2
                                                   
                                                   
                                                      m
                                                      +
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                   
                                                
                                             
                                             (
                                             1
                                             -
                                             
                                                
                                                   b
                                                
                                                
                                                   i
                                                   0
                                                
                                             
                                             )
                                             
                                             ∗
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  Vin
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  BW
                                                               
                                                               
                                                                  k
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   Qdelay
                                                
                                                
                                                   j
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      k
                                                      =
                                                      2
                                                   
                                                   
                                                      j
                                                      -
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   b
                                                
                                                
                                                   ik
                                                
                                             
                                             
                                             ∗
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  Vin
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  BW
                                                               
                                                               
                                                                  k
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Minimizing completion time as the only goal of resource allocation leads to assigning more subtasks to devices with more computational power, and as a result, those devices will drain-out of batteries more rapidly. Therefore, the energy consumption of mobile devices is also important to be regarded as another objective of task allocation. However, in heterogeneous environments such as mobile cloud where battery capacity of devices are limited, minimizing overall energy consumption leads to assigning more tasks to the devices with low energy consumption rate and thus the lifetime of mobile cloud decreases.

Therefore, to minimize the energy consumption in a fair manner, subtasks should be allocated to devices such that the minimum residual energy of all devices also be maximized. Consequently, to provide fairness in resource allocation, we consider the residual energy of devices as another objective of the resource allocation problem regarding the energy model proposed in [28], and allocate subtasks in proportion to remaining energy of mobile devices. This avoids devices with low residual energy to be participated in offloading process. Energy consumption of initiator device (j
                        =1) includes the consumed energy to run its assigned subtasks locally, the consumed energy to transfer input data of offloaded subtasks to their surrogates, and also consumed energy for running resource allocation algorithm. The energy consumed on resource provider Rj
                         consists of the energy consumed for running the assigned subtasks and the energy consumed for sending the results. Thus the energy consumption of all devices contributed in an offloading is formulated as:
                           
                              (2)
                              
                                 
                                    
                                       
                                       
                                          
                                             energy
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      m
                                                      +
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         consumedE
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                
                                                
                                                   E
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         consumedE
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   consumedE
                                                
                                                
                                                   j
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               (
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     e
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               )
                                                               +
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        j
                                                                        =
                                                                        2
                                                                     
                                                                     
                                                                        m
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               (
                                                               
                                                                  
                                                                     et
                                                                  
                                                                  
                                                                     1
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     Vin
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               )
                                                               +
                                                               algoEnergy
                                                            
                                                            
                                                               j
                                                               =
                                                               1
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               [
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     e
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                               
                                                               +
                                                               
                                                                  
                                                                     et
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               
                                                               ∗
                                                               
                                                               
                                                                  
                                                                     Vout
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               ]
                                                               ,
                                                            
                                                            
                                                               j
                                                               >
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Therefore the multi-objective optimization of the resource allocation problem in MCC, regarding one offloading service request at each time, is formulated as:
                           
                              (3)
                              
                                 
                                    
                                       
                                       
                                          
                                             Minimize
                                             
                                             
                                             completeTime
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             Minimize
                                             
                                             energy
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             Subject to:
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             E
                                             
                                                
                                                   0
                                                
                                                
                                                   j
                                                
                                             
                                             -
                                             
                                                
                                                   consumedE
                                                
                                                
                                                   j
                                                
                                             
                                             ⩾
                                             
                                                
                                                   α
                                                
                                                
                                                   j
                                                
                                             
                                             
                                             for all
                                             
                                             j
                                             =
                                             1
                                             …
                                             m
                                             +
                                             1
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 completeTime
                                 ⩽
                                 T
                                 0
                                 ,
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          m
                                          +
                                          1
                                       
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 n
                                 ,
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       b
                                    
                                    
                                       ij
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 for all
                                 
                                 i
                                 =
                                 1
                                 …
                                 n
                                 ,
                                 
                                 j
                                 =
                                 1
                                 …
                                 m
                                 +
                                 1
                                 .
                              
                           
                        Eqs. (3)–(6) consider the feasibility aspects of the solution and are described below:


                        
                           
                              –
                              Energy constraint of resource provider (Eq. (3)): resource provider Rj
                                  accepts and executes the assigned subtasks provided its residual energy is less than threshold αj
                                 .

Deadline constraint (Eq. (4)): this constraint satisfies the deadline requirement of application and guarantees that the completion time of the task does not exceed a specific threshold, T0.

Eq. (5) means all subtasks should be allocated to resource providers to be executed remotely or should be executed by the initiator device, locally.

Eq. (6) expresses that the allocation matrix is binary.

The above multi-objective resource allocation problem is NP-hard similar to 0–1 multi-objective Knapsack problem [25,33]. Herein, heuristic methods are popular to find efficiently an approximate solution. In order to solve the above multi-objective optimization problem where there is a trade-off between completion time and energy consumption, a two-stage approach is designed as shown in Fig. 3
                        .

In the first stage, the fast and elitist NSGA-II algorithm is used to estimate the Pareto optimal solutions. In the next stage, entropy and TOPSIS methods are employed to select the best compromise solution.

Recent years, evolutionary algorithms have been drawn great attention for solving multi-objective optimization problems. They can generate Pareto solution set in single simulation run [34–36]. Some of these multi-objective evolutionary algorithms (MOEAs) are compared in [36].

In this paper, NSGA-II which has been proposed by Deb et al. [35], is used as one of the best MOEAs that has efficiently solved a wide range of multi-objective problems. NSGA-II is a simple and relatively fast algorithm that ranks the population based on fast non-dominated sorting procedure to provide elitism and good convergence near the true Pareto optimal solution set. It uses crowding distance approach to preserve diversity of solutions among the Pareto front. The pseudo code of NSGA-II is described in Table 2
                           .

We use the uniform crossover, polynomial mutation, and the binary tournament selection as the recombination and selection operators to generate new offspring population.

To encode scheduling matrix to real-code GA, a real vector v of size n is used. As mentioned previously, the scheduling matrix is represented as a binary n
                           ∗
                           m matrix b where its elements satisfy 
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 1
                              
                           . Therefore, the entity vi
                            of chromosome v indicates the mobile device that ith subtask is assigned to.

Once a set of Pareto solutions are obtained, it is necessary to select one of them as the target of task allocation. This posteriori evaluation of Pareto solution set is usually performed by MADM methods to select the best compromise solution among Pareto set [37].

The decision matrix in this MADM problem is represented by a r
                           ∗
                           q matrix R consisting of r alternatives (that indicate the Pareto solutions) and q attributes (Aj
                           ), where Ri,j
                            is the value of jth objective function of ith solution.
                              
                                 (7)
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           There are a large number of approaches for solving MADM problems [37]. In this paper, the TOPSIS method [38] is used to determine the best solution. The reason of this selection is that the concept of TOPSIS is rational while its computational complexity is low which is important for mobile devices with limited resources. In addition, TOPSIS can involve objective weights into consideration in comparison process. The TOPSIS method is based on the concept that the chosen solution should simultaneously have shortest distance from the positive ideal solution and the longest distance from the negative ideal solution [38].

In most of the MADM techniques (including TOPSIS), it is essential to provide predetermined information about relative significance of each attribute. Due to availability of Pareto solution set in this paper, it is achievable to evaluate the relative importance of each criterion through analyzing the given set of solutions without presence of user preference [37]. Therefore, Shannon’s entropy concept [39] is utilized in this paper to specify the weight of criteria. The entropy concept is based on information theory and expresses that the uncertainty in a broad distribution is more than in a sharply peaked one. It gives lesser weight to an attribute which has more similar values among the alternatives. The logic behind this weighting is that this attribute cannot help in distinguishing alternatives, thus will be less important.

To calculate the weights of criteria using entropy analysis, it is required to normalize the decision matrix in Eq. (7) for each attribute, Aj
                            as follows:
                              
                                 (8)
                                 
                                    
                                       
                                          p
                                       
                                       
                                          ij
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                R
                                             
                                             
                                                ij
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                v
                                                =
                                                1
                                             
                                             
                                                r
                                             
                                          
                                          
                                             
                                                R
                                             
                                             
                                                vj
                                             
                                          
                                       
                                    
                                    ,
                                    
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    r
                                    ;
                                    
                                    j
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    q
                                    .
                                 
                              
                           The entropy value Ej
                            of each objective is defined as follows:
                              
                                 (9)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    -
                                    
                                       
                                          1
                                       
                                       
                                          ln
                                          r
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             r
                                          
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          ij
                                       
                                    
                                    ln
                                    
                                       
                                          p
                                       
                                       
                                          ij
                                       
                                    
                                 
                              
                           The degree of divergence dj
                            that indicates the contrast intensity of each objective is specified as:
                              
                                 (10)
                                 
                                    
                                       
                                          d
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    1
                                    -
                                    
                                       
                                          E
                                       
                                       
                                          j
                                       
                                    
                                    .
                                 
                              
                           The more different the values of attribute Aj
                            among alternatives, the more its degree of divergence (dj
                           ), and the more significant the attribute Aj
                            for specific problem.

Therefore the weight for each objective is calculated as:
                              
                                 (11)
                                 
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                d
                                             
                                             
                                                j
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                k
                                                =
                                                1
                                             
                                             
                                                q
                                             
                                          
                                          
                                             
                                                d
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

Given the weighting factors, the weighted normalized decision matrix is determined as:
                              
                                 (12)
                                 
                                    
                                       
                                          v
                                       
                                       
                                          ij
                                       
                                    
                                    =
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                    
                                    
                                    ∗
                                    
                                    
                                       
                                          p
                                       
                                       
                                          ij
                                       
                                    
                                    ,
                                    
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    r
                                    ;
                                    
                                    j
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    q
                                    .
                                 
                              
                           
                        

After calculating the weighted normalized decision matrix, to rank alternatives based on TOPSIS method, the solutions should be compared with the positive ideal solution (A
                           +) and the negative ideal solution (A
                           −) which are specified by:
                              
                                 (13)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      +
                                                   
                                                
                                                =
                                                {
                                                (
                                                
                                                   
                                                      
                                                         max
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                |
                                                j
                                                ∈
                                                J
                                                )
                                                ,
                                                (
                                                
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                |
                                                j
                                                ∈
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                )
                                                |
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                r
                                                }
                                                =
                                                {
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      +
                                                   
                                                
                                                ,
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      +
                                                   
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      q
                                                   
                                                   
                                                      +
                                                   
                                                
                                                }
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      -
                                                   
                                                
                                                =
                                                {
                                                (
                                                
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                |
                                                j
                                                ∈
                                                J
                                                )
                                                ,
                                                (
                                                
                                                   
                                                      
                                                         max
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                |
                                                j
                                                ∈
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                )
                                                |
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                r
                                                }
                                                =
                                                {
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      -
                                                   
                                                
                                                ,
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      -
                                                   
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      q
                                                   
                                                   
                                                      -
                                                   
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           where J and J′ are the index set of benefit and cost attributes, respectively.

The distance of each solution from ideal solution (d
                           +) and negative ideal solution (d
                           −) can be computed by:
                              
                                 (14)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      +
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                  
                                                                  
                                                                     j
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     q
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        ij
                                                                     
                                                                  
                                                                  -
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        j
                                                                     
                                                                     
                                                                        +
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      1
                                                      /
                                                      2
                                                   
                                                
                                                ,
                                                
                                                i
                                                =
                                                1
                                                ,
                                                2
                                                ,
                                                …
                                                ,
                                                r
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      -
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                  
                                                                  
                                                                     j
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     q
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        ij
                                                                     
                                                                  
                                                                  -
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        j
                                                                     
                                                                     
                                                                        -
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      1
                                                      /
                                                      2
                                                   
                                                
                                                ,
                                                
                                                i
                                                =
                                                1
                                                ,
                                                2
                                                ,
                                                …
                                                ,
                                                r
                                             
                                          
                                       
                                    
                                 
                              
                           Thus the relative closeness of a solution to the ideal solution according to A
                           + is determined as:
                              
                                 (15)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                             
                                                -
                                             
                                          
                                       
                                       
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                             
                                                +
                                             
                                          
                                          +
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                             
                                                -
                                             
                                          
                                       
                                    
                                    ,
                                    
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    r
                                 
                              
                           where ci
                           
                           ∈(0,1). The more ci
                            approaches to 1, the closer the alternative is to the ideal solution.

Finally the solution with maximum ci
                            is selected as the best solution.

It is noteworthy that if the user preference information exists as vector g, for example g
                           =(0.8,0.2), then it can be mixed with the weights were obtained by entropy as below to gain the extended weighting factors:
                              
                                 (16)
                                 
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          
                                          ∗
                                          
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                q
                                             
                                          
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          
                                          ∗
                                          
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           and the best compromise solution selection is the same as above.

In MCC, there may be selfish devices which refuse to participate in others’ offloading process in order to conserve their energy and computing resources. As mentioned in [1], persuading mobile devices to collaborate and share their resources is one of the challenging issues in MCC. Therefore it is required to encourage those devices to cooperate in offloading.

There are several approaches in order to motivate mobile devices to collaborate and share their resources including common goals and social and monetary incentives [1]. For example, authors in [7] consider common goal as the motivation of devices cooperating in offloading while [17,40] use social incentives to encourage selfish devices. However in the absence of common activities or social relationships between MCC users, those methods are not applicable. Numerous incentive protocols, usually based on credit or reputation have been proposed to stimulate selfish mobile devices in wireless ad hoc network such as [41]. In this paper, a virtual credit based incentive mechanism inspired from [41] is proposed to stimulate mobile devices to cooperate in each others’ offloading.

In this mechanism, when a device provides computing services, it will get imaginary credits according to the service. For simplicity, the credit value of executing each subtask is assumed to be fixed and depends on the amount of resources consumed to run the subtask on a reference standard mobile device (R
                        0) where its computational configuration is known to all devices. This method is similar to runtime estimation mechanism proposed in [14] (using subtasks’ weight which is the expected running time on a machine of strength one). Thus, the credit value of running a subtask 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         is calculated as the weighted summation of expected runtime and energy consumption on reference device, R
                        0 as follows:
                           
                              (17)
                              
                                 
                                    
                                       credit
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 α
                                 
                                 ∗
                                 
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       ,
                                       0
                                    
                                 
                                 +
                                 β
                                 
                                 ∗
                                 
                                 
                                    
                                       e
                                    
                                    
                                       i
                                       ,
                                       0
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                    ,
                                    0
                                 
                              
                           
                         and 
                           
                              
                                 
                                    e
                                 
                                 
                                    i
                                    ,
                                    0
                                 
                              
                           
                         are the time and the energy consumption running 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         on standard device R
                        0 and 
                           
                              α
                           
                         and 
                           
                              β
                           
                         are the weight of time and energy.

The price of a service could be defined more accurately considering context information of resource providers such as residual energy level, remaining time to next power charging, and the scarcity of the software service, as regarded in our future work.

In order to consider the credit based incentive in multi-objective resource allocation problem (described in Eqs. (1)–(6)), a budget constraint (Eq. (18)) is added to the formulation as follows:
                           
                              (18)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          2
                                       
                                       
                                          m
                                       
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       ij
                                    
                                 
                                 
                                 ∗
                                 
                                 
                                    
                                       credit
                                    
                                    
                                       i
                                    
                                 
                                 ⩽
                                 
                                    
                                       M
                                    
                                    
                                       0
                                    
                                 
                                 ,
                              
                           
                        The budget constraint ensures that the overall expense does not exceed to the budget of initiator device (M
                        0).

Finally, assuming that all mobile devices are trustworthy, the monetary transaction is accomplished as follows: At initiation time, all mobile devices have a specific initial credit. When an offloading terminates, the initiator device is charged for overall offloaded subtasks and each resource provider is paid depending on the amount of subtasks it has executed (i.e. payment step of offloading in OMMC, Section 3.1).

Although the profit a device obtains by providing a service is almost equal to the expense it should pay for similar service in its possible future offloading; however the device does not refuse offloading requests for saving its resources since the mobile device may not be capable of executing its task locally in the future and requires offloading the task due to one of the following reasons:
                           
                              (a)
                              Due to device’s resource restriction i.e. CPU, and memory limitation or low energy level.

If the device executes the task locally, the deadline of the task will not be satisfied due to lack of resources.

The required application is not supported by the mobile device and the task should be requested from other mobile devices, i.e. software as a service (SaaS).

Thus, the mobile devices cooperate in offloading processes to obtain adequate credits for their essential future offloading requests. Virtual credit based incentive will affect the offloading as follows: if a mobile device has adequate credit obtained from cooperation in previous offloadings, it can assign more subtasks to other devices as its own offloading request and pay for them (Eq. (18) is satisfied) which leads to saving its energy and completing the task in its deadline or even executing subtasks that the mobile does not support their required softwares. However, in the case of a selfish device, it does not have sufficient credit for its urgent offloading requests (Eq. (18) is not satisfied). Thus it should run more subtasks locally (if it is possible) which leads to lower residual energy of mobile, and longer completion time which results in exceeding the task’s deadline. Moreover, in the case of SaaS or resource restriction, the task cannot be executed on mobile device. In the evaluation, some experiments are conducted to assess the impact of selfishness on offloading decision.

@&#EVALUATION@&#

A prototype of OMMC is implemented in two versions to be executed on Android and Windows OS composing of two parts, OMMC Client and OMMC Server, in which a mobile device runs the appropriate version of OMMC regarding its role in offloading and its OS version. The NSGA-II algorithm is implemented using jMetal framework [42]. A face detection application is used as the case study which takes different pictures as subtasks and identifies all faces in them. The face detector application is implemented on Android and Windows using android.media [43] and Jon’s Java Imaging Library (JJIL) [44] libraries, respectively. The implementation of OMMC comprised approximately 5000 lines of Java code which is used in following extensive experiments.

To evaluate performance and energy consumption of OMMC, a testbed of mobile devices is made where Table 3
                      shows the testbed setup.

Mobile devices are connected to an ad-hoc network using Wi-Fi with mean bandwidth 1.86MBps comprising a mobile cloud. It is assumed that every device has 16,383 Jules of energy, i.e. the battery capacity of two smartphones. T0 is set to 200 seconds and M
                     0 is initialized to 10 units of virtual credit while C is considered as the reference machine with price of 2 units of credit per second. To measure the energy consumption of smartphones and laptops, PowerTour [45] and Joulmeter [46] are used, respectively.

The remainder of this section assesses the quality of solution obtained by the two-stage approach explained in Section 4 and then evaluates the performance of overall proposed resource allocation mechanism.

To evaluate the accuracy and efficiency of obtained Pareto-front using NSGA-II, we compare it with the reference Pareto- front obtained running an extended version of OFMRA [15] (a branch and bound resource allocation algorithm) for different subtask sizes based on branch and bound algorithm. The parameters used for NSGA-II algorithm are shown in Table 4
                        .

In this assessment, two scenarios are considered where mobile device A is initiator device offloading a task which consists of 10 pictures while mobile devices B and D are resource providers. In first scenario the input size of subtasks varies from 142KB to 1MB while in second scenario the task contains pictures with input size 6.8MB to 8.3MB. Fig. 4
                         shows obtained Pareto-front using NSGA-II comparing to optimal Pareto-front (obtained using branch and bound algorithm instead of NSGA-II). The figure demonstrates the ability of NSGA-II algorithm in converging to the true Pareto-optimal front. Therefore, using NSGA-II algorithm leads to near optimal Pareto solution set.

For more performance assessment, D1
                           R
                         and runtime are used where D1
                           R
                         measures the convergence and diversity of the obtained Pareto-front [47] and is calculated as follows:
                           
                              (19)
                              
                                 D
                                 
                                    
                                       1
                                    
                                    
                                       R
                                    
                                 
                                 (
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             Z
                                          
                                          
                                             ∗
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          y
                                          ∈
                                          
                                             
                                                Z
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                 
                                 
                                    min
                                 
                                 {
                                 
                                    
                                       d
                                    
                                    
                                       xy
                                    
                                 
                                 |
                                 x
                                 ∈
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 }
                              
                           
                        In (19), Zi
                         denotes the set of Pareto solutions obtained by NSGA-II; Z∗
                         is the reference solution and 
                           
                              
                                 
                                    d
                                 
                                 
                                    xy
                                 
                              
                           
                         is Euclidean distance using the normalized Pareto solutions (Eq. (8)). Table 5
                         lists the D1
                           R
                         and average runtime of 10 simulation runs.

It is clear from the above table that in addition to high accuracy of the NSGA-II algorithm (small D1
                           R
                         values), it provides very short runtime compared to the exhaustive search (The time has declined by 98%). Thus, the runtime of the proposed resource allocation method will be very short and its overhead will be negligible. In fact, the proposed method is fast while obtains the near optimal Pareto solution set.

As explained in Section 4.2.2, once the set of Pareto solution is obtained, MADM methods are employed to select the best compromise solution among them for task allocation. Specifically, in this paper entropy theory is used to determine the weight of time and energy criteria and then TOPSIS method is employed to specify the best compromise solution. Table 6
                         presents wt
                         and we
                         obtained for the above two scenarios. Moreover, the best solution from Pareto-front determined by TOPSIS method (best compromise solution), the solution with minimum completion time (Time optimal solution), the solution with minimum value of energy function of Eq. (2) (Energy optimal solution), and the positive ideal solution with minimum time and energy (Utopia solution) are represented for two above scenarios.

To demonstrate the performance improvement and energy conservation of our proposed resource allocation method, we compare it with Time Optimizing and Energy Aware algorithms of Serendipity [9]. However, in Serendipity, it is assumed that subtasks are identical, so we extend the Serendipity’s greedy resource allocation algorithms for different subtasks, called Ext-Time Optimizing and Ext-Energy Aware, respectively. In Ext-Time Optimizing, for every subtask, it iteratively selects the surrogate with minimum completion time including transmission and execution time, considering the allocation of previous subtasks. In Ext-Energy Aware, the surrogate with minimum energy function (Eq. (2)) is chosen for every subtask considering deadline constraint.

We consider four experiments to evaluate impact of: (1) different resource providers; (2) subtasks with different computational load and input size; (3) different number of subtasks in an offloading and (4) different rate of offloading requests on the completion time and energy consumption of proposed and traditional resource allocation algorithms mentioned above. In addition, the impact of using virtual credit based incentive in the proposed method is explored using two scenarios which investigates the performance and energy saving.

In evaluation of time and energy, the consumed resources for the resource allocation algorithm are considered in addition to the resources consumed for offloading itself. We consider the following evaluation metrics to compare the resource allocation mechanisms:
                           
                              (a)
                              Completion time of offloading (comprising runtime of resource allocation algorithm, data transmission and subtasks execution).

Energy consumption of mobile devices as calculated from Eq. (2).

Fairness: the fairness provided by the resource allocation method based on Jain index [48] which is computed as:
                                    
                                       (20)
                                       
                                          Jain
                                          
                                          Index
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  j
                                                                  =
                                                                  1
                                                               
                                                               
                                                                  m
                                                               
                                                            
                                                            
                                                               
                                                                  x
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             
                                                m
                                                ·
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      m
                                                   
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 where m is the number of devices contributed in the offloading and xj
                                  is the energy consumption of jth device. The Jain index is between 
                                    
                                       
                                          
                                             1
                                          
                                          
                                             m
                                          
                                       
                                    
                                  and 1; the more the Jain index, the fairer the resource allocation method is.

The minimum of residual energy of mobile devices (lifetime of mobile cloud).

In the following experiments, the value of above evaluation metrics are presented in bar charts a to d and the weight of time and energy criteria obtained by Entropy method are shown above the proposed method’s bar in chart a (completion time). Each experiment has been repeated multiple times and the average of results has been reported.

In order to evaluate the impact of the number of resource providers with different computational power, we consider following seven groups of mobile devices. In this experiment, mobile device A (refer to Table 3) is the client mobile which requests 10 input pictures with different size varies from 142KB to 1MB to be assessed by face detection application (as subtasks) and other mobile devices provide offloading service for mobile device A. The mobile devices are grouped as follows: {A,B}, {A,D}, {A,C}, {A,B,D}, {A,B,C}, {A,C,D} and {A,B,C,D}.


                           Fig. 5
                            shows when the processing power of resource providers are proportional to their energy consumption rate (homogeneous devices), Ext-Time Optimizing and Ext-Energy Aware act the same and the proposed method behaves similar to them (AB group). In this case, the completion time of our proposed method is a bit higher than two other methods due to runtime of resource allocation algorithm.

In heterogeneous environments, Ext-Time Optimizing always assigns subtasks parallel among fast devices in order to minimize completion time, however if these devices have high energy consumption rate, the total energy consumption of devices will increase significantly. On the other hand, Ext-Energy Aware assigns subtasks to devices with low energy consumption and if they have slow computational power, it yields to long completion time. In other word, when mobile devices are heterogeneous and their processing power is in contrast to their energy consumption rate (all groups except AB), the difference between completion time and energy consumption of Ext-Time Optimizing and Ext-Energy Aware algorithms is higher and the trade-off between time and energy is more obvious. However, the proposed resource allocation method manages the trade-off between time and energy allocating subtasks in a manner that minimums both completion time and energy consumption of mobile devices.

Regarding fairness in energy consumption, Ext-Energy Aware almost maximizes lifetime of mobile devices and provides highest fairness while our propose method stands in second place. This is the same for maximizing lifetime of mobile cloud as is shown in chart d by the other metric, namely remaining energy.

Since the proposed method obtains higher weight for time (average of 0.73), it’s behavior is more similar to Ext-Time Optimizing approach in all groups. In addition, Fig. 5 shows that by increasing the number and the processing power of resource providers, the completion time and energy consumption of the offloading decrease.

We explore the impact of computational load (the required processing time) and input size of subtasks in this set of experiments. We take into account five sets of subtasks with different computational load and input size as follow:
                              
                                 •
                                 Case 1: Set of subtasks with low computational load and small input size.

Case 2: Set of subtasks with low computational load and large input size.

Case 3: Set of subtasks with high computational load and small input size.

Case 4: Set of subtasks with high computational load and large input size.

Case 5: monotonic composition of sets 1, 2, 3 and 4.

Above subtask sets contain 10 pictures with input size varying from 142KB to 9.2MB. In this scenario, mobile device A is client mobile while mobile devices B and D are resource providers.

As demonstrated in Fig. 6
                           , in all cases except case 2, Ext-Time Optimizing algorithm provides minimum completion time, maximum energy consumption, minimum fairness and minimum mobile cloud’s lifetime giving most of the subtask to the fastest device (D). Instead, Ext-Energy Aware algorithm disseminates subtasks among mobile devices balanced in order to minimize the energy consumption of devices (and so allocates the minimum number of subtasks to D), and consequently provides the best fairness and the maximum lifetime while gives the longest completion time. In these cases (1, 3, 4 and 5), the proposed resource allocation method (with mean weighting factors of 0.60 and 0.40 for time and energy) stands in second place and handles the trade off between time and energy.

However, in case 2 (subtasks with large input size and low workload) Ext-Time Optimizing and Ext-Energy Aware algorithms behave similar. That is because file transfer time is high comparing to the required processing time (as the file transfer has a significant effect) and the fastest device (here D) should wait more until all large input files of each offloaded subtask be transmitted, before starting execution of its subtasks. Whereas, proposed method executes most of subtasks locally which leads to higher completion time, and less fairness and life time since the time waste and energy consumption for file transmissions, reduces. However, the energy consumption of proposed method is less than two other approaches because it avoids allocating subtasks to D.


                           Fig. 6 also demonstrates that the larger input size or higher workload of subtasks results in longer completion time and higher energy consumption.

In this scenario, we investigate the impact of increasing the number of subtasks on the performance of mentioned resource allocation approaches. For this purpose, we vary the number of subtasks from 10 to 100 pictures to be assessed by the face detection application as an offloading request. In this scenario, mobile device A is client mobile while mobile devices B and D are resource providers. In addition, this experiment assesses the overhead and energy consumption of the resource allocation algorithms. For this regard, the overhead of time and consumed energy due to running resource allocation algorithms are presented separately on top of time and energy charts (charts a and b).

As shown in Fig. 7
                           , increasing the number of subtasks, the differences between Ext-Time Optimizing and Ext-Energy Aware becomes higher and the trade-off between time and energy consumption appears more. However, the proposed resource allocation method (with mean weight of 0.62 and 0.38 for time and energy as shown in Fig. 7-(a)) handles the trade-off between time and energy well and stands in second place. In addition, increasing the number of subtasks, the completion time and energy consumption of offloading increases and the lifetime of mobile cloud decreases while subtasks dissemination becomes more balanced and provides better fairness.

Exploring the overhead and energy consumption of running resource allocation algorithms, the following observations are made: the overhead of Ext-Time Optimizing algorithm due to its greedy strategy is low (0.1s) and the overhead of Ext-Energy Aware algorithm is more than Ext-Time Optimizing algorithm due to calculation of Eq. (2). As shown in Fig. 7-(a), the overhead of the proposed method is also low. For example, for 70 subtasks, the runtime of the proposed algorithm is 9.75s while the completion time of offloading is 252.63s (3.8% of total offloading time). As the population size and max generation number of the NSGA-II algorithm are small, the overhead of the resource allocation algorithm is small comparing to overall offloading process. In addition, energy consumption of running the proposed method is also low and negligible as shown in Fig. 7-(b).

Regarding overhead of discovery protocol, it is noteworthy that two other allocation approaches also need the discovery mechanism. Therefore, comparing to our proposed method, the power consumption of discovery is skipped.

Finally, although the runtime of the proposed algorithm is more than Ext-Time Optimizing and Ext-Energy Aware algorithms, but the completion time and energy consumption of overall offloading (including resource allocation algorithm, context gathering and file transmission) for the proposed mechanism is between two other approaches and manages the trade-off between time and energy consumption well.

In this experiment, the performance of our resource allocation approach is investigated in presence of various rates of offloading requests. We assume that the offloading requests arrive sequentially and are repeated periodically. The arrival of offloading requests follows a Poisson distribution. We vary the arrival rate of offloading requests, 
                              
                                 λ
                              
                            from 0.03 to 0.12 requests per second and compare the evaluation metrics for mentioned resource allocation algorithms. Mobile devices A, B and D are used in this experiment where in every turn, one of them is client mobile and two others are service providers.

As shown in Fig. 8
                           , completion time and consumed energy increase with the offloading requests rate. Ext-Time Optimizing assigns most of subtasks to device D to provide minimum completion time which causes its energy to be consumed drastically and its battery to be drained out sooner. On the other hand, Ext-Energy Aware tries to allocate subtasks to devices in proportion to their battery level, which it leads to longer completion time. However, the proposed resource allocation method stands in second place considering time, energy consumption, fairness and lifetime of mobile cloud, where it’s behavior is more similar to Ext-Time Optimizing algorithm as the mean weight for time and energy are 0.69 and 0.31 respectively (as shown in Fig. 8a). It demonstrates the ability of the proposed approach in handling the trade-off between two conflicting criteria comparing to Ext-Time Optimizing and Ext-Energy Aware algorithms especially as the rate of offloading requests increases.

In this section, two scenarios are performed to assess the impact of the virtual credit based incentive on dissuading users from being selfish and encouraging them to participate in others’ offloading. In both scenarios, mobile devices A, B and D are taken into account that offload a task of case 5 (defined in different subtask sets experiment) where in every turn, one of them is client mobile and two other devices are service providers.

In first scenario, it is assumed that mobile device A is selfish and refuses to cooperate in other’s offloading process. In every turn, the client mobile requests five offloading services. Deadline of each task (T0) is considered to be 100s and if a mobile device cannot meet the deadline, it will not execute the task. Table 7
                            illustrates the number of tasks with satisfied deadline for each client mobile comparing the proposed resource allocation method with and without using the virtual credit based incentive mechanism.

As shown in Table 7, without using any credit based incentive, selfish device A refuses to provide services for other’s offloading requests while receives offloading services from them. Therefore, it completes all of its tasks in their deadlines and does not realize any detriments.

However, applying the described credit based incentive mechanism; selfish device (A) can complete only one task and its other tasks will be exceed their deadlines. As explained in the credit based incentive mechanism in subsection 4.3, every device has an initial credit which here pays for its first offloading request. Thus mobile device A requests an offloading service for its first task however due to rejecting cooperation in others’ offloadings, it does not earn required credit and cannot request offloading for its future tasks. Consequently mobile device A will not be able to run all of its tasks (4 tasks exceed their deadlines). Therefore, using the virtual credit based incentive encourages users to cooperate in others’ offloadings in order to obtain sufficient credit for their future offloadings.

In second scenario, mobile device D is considered as selfish user where in every turn, the client mobile requests two offloading services. The initial energy (E0
                              j
                           ) of mobile devices A, B and D are set to 3400, 3750 and 16,000 (Jules) respectively and the threshold of these devices (
                              
                                 
                                    
                                       α
                                    
                                    
                                       j
                                    
                                 
                              
                           ) are considered to be 3250, 3250 and 13,754 (Jules) which is 20% of their battery capacity. Fig. 9
                            illustrates the completion time and residual energy of devices A, B and D after each offloading comparing the proposed resource allocation method with and without the virtual credit based incentive mechanism.

As Fig. 9 demonstrates, without any incentive mechanism, device D behaves selfishly and refuses to participate in others’ offloading which results in longer completion time and more energy consumption of others’ offloadings. Specifically, after four offloadings, residual energy of device A becomes less than its threshold (see Fig. 9-(b)) and it exits the mobile cloud which results mobile device B to execute all of its tasks locally and thus it takes long time to complete its tasks (see Fig. 9-(a)). Therefore, noncooperation of device D is harmful to the rest of the devices as makes the completion time three times and five times longer in offloadings of A and B devices respectively comparing to the case that employs incentive mechanism. However, using the virtual credit based incentive, device D is persuaded to cooperate in others’ offloadings which leads to shorter completion time of others’ offloadings and to less energy consumption of device A. Thus, none of the devices exits from the mobile cloud.

Based on the experimental results, it can be concluded that using the virtual credit based incentive mechanism; selfish users should change their behavior and cooperate with others to somehow guarantee their future offloading requests to be successful. From the other side, using the proposed incentive mechanism, normal devices would not be drained out by offloadings sooner which increases the lifetime of cloud.

@&#CONCLUSION@&#

Resource allocation is one of the most challenging issues in mobile cloud consisting of neighboring mobile devices where both service requester and service providers are mobile devices. In this paper, a multi-objective resource allocation method is presented which minimizes the completion time of tasks as well as consumed energy of all participating mobile devices along satisfying deadline constraint. To solve the multi-objective optimization in reasonable time, NSGA-II is applied to obtain the set of Pareto solutions. Afterward, the best compromise solution is specified using entropy and TOPSIS methods. In addition, a context-aware offloading middleware, named OMMC, is designed which gathers contextual information and manages the offloading process in mobile cloud. Besides, a virtual credit based incentive mechanism is exploited in offloading decision to encourage users to participate in offloading process.

A prototype of OMMC implemented and evaluated using extensive experiments. The results show that in heterogeneous environment under different subtasks workloads, different number of subtasks and various offloading rates, the proposed resource allocation method appropriately manages the trade-off between completion time and consumed energy and improves the from being drained out by selfish ones.

Given the high mobility of mobile devices, disconnections can happen quite often and proposed method does not make appropriate decisions in such cases. Employing users’ mobility pattern and context aware failure prevention mechanisms are of proposed future work to overcome this challenge and increase the rate of successful offloadings. Moreover, employing the context of user, subtask and service providers to more accurately calculate the credit of subtasks is addressed as another future work that improves the performance of incentive mechanism. Finally extending the proposed method for scenarios in which multiple offloading requests are submitted simultaneously is regarded as the other future work.

@&#REFERENCES@&#

