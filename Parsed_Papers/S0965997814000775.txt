@&#MAIN-TITLE@&#A generic cloud platform for engineering optimization based on OpenStack

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We transform components in engineering optimization applications into virtual types.


                        
                        
                           
                           We build VEOA using VEOMs and other related structures.


                        
                        
                           
                           We use domains for optimization problems, resources are dynamically managed.


                        
                        
                           
                           Two real engineering applications have been conducted for testing purpose.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cloud computing

Engineering optimization

OpenStack

Optimization algorithm

High performance computing

Scheduling algorithm

@&#ABSTRACT@&#


               
               
                  Optimizations have been applied in many different engineering fields. Most of these applications may have similar characteristics: intensive on computing resources, time-consuming on calculation iterations, similar on computing environments and so on. This paper describes a generic cloud platform for engineering optimization by leveraging the compute resources hosted in cloud datacenters. The methodology developed was to decompose the engineering optimization processes into several interconnected sub-tasks, which were further converted and implemented as virtual applications for dynamic cloud deployment using OpenStack. The system can dynamically allocate and recycle the compute resources according to the specific engineering optimization applications. The research presented in the paper contributes on the generic engineering optimization process virtualization and cloud computing based implementation with innovative algorithms development. The system test results showed a way that potentially engineering optimization problems could be embedded into the put forward platform due to the developed large scale and intelligent cloud based optimization services. Further applications for building energy simulation and optimization, stents optimization, water distribution optimization are currently under development.
               
            

@&#INTRODUCTION@&#

Optimization has a long application history in lots of engineering domains. It can be oversimplified defined as searching for a solution to enable the objective function to achieve the maximum or the minimum value. Design variables, objective function and constraints are normally seemed to be the three key components in an engineering optimization application. There are many different types of optimization problems such as multi-objective optimization (MOO) and single-objective optimization (SOO), to which different optimization algorithms can be applied to find out the best solutions [1]. However, the implicit function between the design variables and the objective function which exists in huge amount of engineering applications, together with the purpose of obtaining much more accurate solutions, have always caused a significant number of iterations while doing these optimization applications [1,2]. Besides, getting the value of objective function through an engineering analysis software may be an extremely time-consuming and resource-intensive mission, which has further aggravated the cost of performing an engineering optimization application.

Thousands of researchers which consist of mathematics experts, engineering academics and computer scholars have engaged into the engineering optimization field with the purpose of making it more efficient to perform: better optimal solutions, less iterations, less resource consumption, etc. Means reached from these advanced studies have got huge influences on the development of engineering optimization, topics related include optimization algorithms, generic engineering analysis software development, and high performance computing technologies [3–5].

Cloud computing has offered a novel way to support the various engineering optimization applications: problems that developed as standard services could be automatically started up and shut down, with their resources timely scheduled for computing and withdrew for recycling. In addition, the applications established could also meet the requests for optimization algorithms and environments that asked by the engineering problems. Cloud platforms are normally defined as three different types: IaaS, PaaS and SaaS on the basis of their different virtualization and application levels. Many public and private cloud platforms have been proposed in the recent years, most of which focus on the low level hardware and simple web services, e.g., website service, net disk service, and mail service [6–10]. Generic cloud platform supporting engineering optimization applications has not been widely investigated.

The generic platform developed in this article which seamless integrated cloud computing technologies and engineering optimization applications may lead to many advantages: better resource deployment, greater efficiency at implementation, better user experience, convenient management and further expansion, etc. The research of this paper focuses on virtual engineering optimization application creation, virtual engineering optimization machines scheduling, dynamic computing resources management, system design and other related topics. The cloud platform presented in this paper is based on OpenStack IaaS. Several engineering optimization problems have been conducted on the developed platform into applications used for testing; other engineering optimization applications such as building energy optimization, stents optimization and water distribution optimization applications are also scheduled for further development.

The rest of this paper is organized as follows. Section ‘Related work’ investigates the background research regarding the engineering optimization methods and the high performance computing technologies; Section ‘System design and implementation’ explains the developed methodology, which includes the methods and algorithms applied in this paper as well as the system design, including the platform hardware structure and supporting database; Section ‘System testing’ shows the test cases describing two real optimization applications implemented on the platform and their computing consequents; conclusion and future work are given at the end.

@&#RELATED WORK@&#

This section describes the relevant theories and algorithms relating to the engineering optimization methods and the high performance computing technologies which served as the development basis for the research presented in the paper.

Should an engineering optimization problem be an optimization problem in the first place, which has design variables, objective function and constrains. Assume that the problem could be simply described as y
                        =
                        f(x), where y is the objective function, x stands for the design variables and f is the mathematical model between them. Due to the particularity of the engineering optimization problem, two main preconditions must be clarified before it could be efficiently solved into an application: (1) as f is not certain, how to get the values of x and y to simulate it in order to start the optimization; (2) which optimization algorithm to be selected for the application at iterations. Using generic engineering analysis software to acquire values of y (commonly known as responses) is much easier and suitable for doing engineering optimizations with computer resources than experimental ways, which is why it becomes more and more popular among engineering researchers. Values of x, which is also known as samples, could be extracted from original experimental data or generated through standard sampling algorithms; for the second question, huge number of optimization algorithms can be alternatives, from which each individual problem could select accordingly [1,2,5].

In general, an engineering optimization application would have essential components described as:
                           
                              (1)
                              Samples produced by sampling algorithms or extracted from experimental data.

The value of objective function value calculated by generic engineering analysis software.

The optimization computation to get the optimal solution based on the samples, responses and optimization algorithm selected.

Check the new result to see whether or not it complies with all the requirements of the convergence conditions after calculating its objective function value, if it does, then stop the optimization application; put the solution into samples dataset and its objectives into responses dataset, restart step 3 if otherwise.

The componentized style for doing engineering optimization applications can draw a lot of benefits:
                           
                              (1)
                              Each component has its own target and can above have many candidate algorithms/methods/software to fulfill its task.

If the current optimization algorithm fails to give a satisfied optimal solution, new optimization procedures could be established easily by only changing to some other algorithms or even parameters in use.

The whole optimization application can be further developed into related modules using standard input and output context data files. A typical optimization application for engineering problem can be described with Fig. 1
                                 .

From the programming point of view, the implement process of real engineering optimization application is always driven by controller program, which is also known as main program; parameter files is also a key point for initializing the application and other optimization components; computing environment should be met for components; function-isolated entities can be created as packages (optimization toolbox, analysis toolbox, etc.) with standard APIs, input and out data files which could be called by the main program automatically for accelerating the procedure.

The most important process in an engineering optimization application is to get the value of objective function (response) accurately calculated with standard engineering analysis software. Depending on different engineering applications and optimization objectives, the analysis software in use may differ, e.g. Ansys, Abaqus in structural analysis, Moldflow, UnigraphicsNX in mold design, Revit, 3DMax, AutoCAD in architectural design, Energyplus, Bimserver in building information design, etc. [11–22]. Many cloud datacenters start to deploy the mentioned software as central services. Normally these software provide necessary application programming interfaces (APIs) to help the end users expand its customized functionalities. Popular software would encompass a wide variety of interfaces such as graphic manipulation interface, script operation interface and even networking connection interface as to meet different clients’ tastes. The extensive form for using these engineering software has provided the possibility to develop them into standard modules used for engineering optimization applications.

Optimizations in most engineering fields are constrained, multi-variable, and multi-objective problems. A large amount of algorithms have been developed and utilized within the engineering optimization applications [23]. The long history gradient-based optimization algorithms include gradient descent, conjugate gradient and sequential quadratic programming (SQP) methods etc. need to generate an original design variable and then search the optimal solution through design variables’ gradient direction at iterations [24–27]; direct search methods including pattern search, Nelder-Mead method etc. and trust-region method are also searching direction based optimization methods [28–33]; studies on the intelligence algorithms such as genetic algorithm (GA) [34,35], particle swarm optimization (PSO) and ant colony optimization (ACO) are extremely popular in optimization by far as neither gradient calculation nor searching direction is needed in these algorithms [36,37]; combinations of surrogate function methods e.g. artificial neural network (ANN) [38,39], Kriging and proper criteria for infilling new samples e.g. expected improvement (EI) method, have been defined as surrogate function based optimization algorithms [40–42], which are widely developed for large scale and iteration limited engineering optimization applications; meanwhile, researches on sampling methods such as grid sampling, latin hypercube sampling (LHS) [43,44], have also got considerable evolvements as they have made the sampling process more reasonable. Many optimization algorithms have already been integrated into both commercial and open-source optimization packages such as Matlab optimization toolbox and DACE modeling toolbox with standard input and output data files in order to be used more standardized [42,45].

Detail analysis for the above engineering optimization algorithms is not the main topic of this paper. The system was developed in a flexible and extensible way so that other algorithms can be easily integrated when they are needed. Besides, different algorithms only affect the final optimization solution, not the optimization procedure which is generic. Here a few discussions about SQP, GA, Kriging, EI and LHS are presented, which are applied in the following test cases.

Consider a nonlinear programmingproblem with the form as described below [25,26]:
                              
                                 (1)
                                 
                                    
                                       
                                          
                                             min
                                             
                                             f
                                             (
                                             x
                                             )
                                             ,
                                          
                                       
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               b
                                                               (
                                                               x
                                                               )
                                                               ≥
                                                               0
                                                            
                                                         
                                                         
                                                            
                                                               c
                                                               (
                                                               x
                                                               )
                                                               =
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           The Lagrangian form for this problem is:
                              
                                 (2)
                                 
                                    L
                                    (
                                    x
                                    ,
                                    λ
                                    ,
                                    σ
                                    )
                                    =
                                    f
                                    (
                                    x
                                    )
                                    -
                                    
                                       
                                          λ
                                       
                                       
                                          T
                                       
                                    
                                    b
                                    (
                                    x
                                    )
                                    -
                                    
                                       
                                          σ
                                       
                                       
                                          T
                                       
                                    
                                    c
                                    (
                                    x
                                    )
                                    ,
                                 
                              
                           where 
                              
                                 λ
                              
                            and σ are Lagrange multipliers. At an iterate xk
                           , a basic sequential quadratic programming algorithm defines an appropriate search direction dk
                            as a solution to the quadratic programming sub-problem:
                              
                                 (3)
                                 
                                    
                                       
                                          
                                             min
                                             
                                             f
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   k
                                                
                                             
                                             )
                                             +
                                             ∇
                                             f
                                             
                                                
                                                   (
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   )
                                                
                                                
                                                   T
                                                
                                             
                                             d
                                             +
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                             
                                             
                                                
                                                   d
                                                
                                                
                                                   T
                                                
                                             
                                             
                                                
                                                   ∇
                                                
                                                
                                                   xx
                                                
                                                
                                                   2
                                                
                                             
                                             L
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   k
                                                
                                             
                                             ,
                                             
                                                
                                                   λ
                                                
                                                
                                                   k
                                                
                                             
                                             ,
                                             
                                                
                                                   σ
                                                
                                                
                                                   k
                                                
                                             
                                             )
                                             d
                                             ,
                                          
                                       
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               b
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               )
                                                               +
                                                               ∇
                                                               b
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           x
                                                                        
                                                                        
                                                                           k
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     T
                                                                  
                                                               
                                                               d
                                                               ≥
                                                               0
                                                            
                                                         
                                                         
                                                            
                                                               c
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               )
                                                               +
                                                               ∇
                                                               c
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           x
                                                                        
                                                                        
                                                                           k
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     T
                                                                  
                                                               
                                                               d
                                                               =
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           Note that the term f(xk
                           ) in the expression above may be left out for the minimization problem, since it is constant. SQP is an old gradient-based optimization algorithm, which has still being proved for effective in many engineering optimization applications.

In a genetic algorithm, a population of candidate solutions (called individuals, creatures, or phenotypes) to an optimization problem is evolved towards better solutions. Each candidate solution has a set of properties (its chromosomes or genotype) which can be mutated and altered. Traditionally, solutions are represented in binary as strings of 0s and 1s, but other encodings are also possible. A genetic algorithm optimization problem may have the process which is shown in Fig. 2
                            
                           [34,35]:


                           Ns represents the maximum generations method defines. GA process for optimization is easy to establish as neither surrogate model between the design variables and the objective function nor gradient computation needs to be achieved. However, sometimes this method would take a long time as to find a really satisfied optimal solution.

Kriging surrogate model has been widely accepted by engineering researchers because this method could predict a “surrogate” mathematical function between samples and their responses which could be used for optimizations. With samples x
                           =[x
                           1,x
                           2,...,x
                           n] and their responses y
                           =[y
                           1,y
                           2,...,y
                           n], Kriging model can be established as [41,46]:
                              
                                 (4)
                                 
                                    
                                       
                                          y
                                       
                                       
                                          ˆ
                                       
                                    
                                    (
                                    x
                                    )
                                    =
                                    
                                       
                                          f
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    x
                                    )
                                    β
                                    +
                                    z
                                    (
                                    x
                                    )
                                 
                              
                           it contains two parts: regression part and random part. Coefficient β is the regression ratio. Deterministic drift f(x), provided the global approximation of simulation in the design domain, is often described as a polynomial of x. With the surrogate function 
                              
                                 
                                    
                                       y
                                    
                                    
                                       ˆ
                                    
                                 
                                 (
                                 x
                                 )
                              
                            obtained, optimization can be processed using standard gradient-based optimization algorithms such as SQP.

EI criterion considers both predicted value and predicted variance while infilling a sample into the optimization models. To a new sample x, before its response computation process is terminated, the response y(x) of x is also unavailable. But the Kriging model can predict its average value 
                              
                                 
                                    
                                       y
                                    
                                    
                                       ‾
                                    
                                 
                                 (
                                 x
                                 )
                              
                            and its average variance 
                              
                                 
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 x
                                 )
                                 .
                              
                            Let ymin be the current minimum response value, therefore I(x)=
                           y
                           min
                           −
                           y(x) (assume that it is a minimization problem) will be the improvement of the response value at the given point of x. y(x) is normally distributed with mean 
                              
                                 
                                    
                                       y
                                    
                                    
                                       ‾
                                    
                                 
                                 (
                                 x
                                 )
                              
                            and variance 
                              
                                 
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 x
                                 )
                                 .
                              
                            The likelihood of this improvement is given by the normal density function [12,40]:
                              
                                 (5)
                                 
                                    
                                       
                                          1
                                       
                                       
                                          
                                             
                                                2
                                                π
                                             
                                          
                                          σ
                                          (
                                          x
                                          )
                                       
                                    
                                    exp
                                    
                                       
                                          
                                             -
                                             
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               y
                                                            
                                                            
                                                               min
                                                            
                                                         
                                                         -
                                                         I
                                                         -
                                                         
                                                            
                                                               y
                                                            
                                                            
                                                               ‾
                                                            
                                                         
                                                         (
                                                         x
                                                         )
                                                         )
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                                
                                                   2
                                                   
                                                      
                                                         σ
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           and expected value of the improvement can be obtained by using integration over this density:
                              
                                 (6)
                                 
                                    E
                                    [
                                    I
                                    (
                                    x
                                    )
                                    ]
                                    =
                                    
                                       ∫
                                       
                                          l
                                          =
                                          0
                                       
                                       
                                          l
                                          =
                                          ∞
                                       
                                    
                                    I
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      
                                                         2
                                                         π
                                                      
                                                   
                                                   σ
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             exp
                                             
                                                
                                                   
                                                      -
                                                      
                                                         
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        y
                                                                     
                                                                     
                                                                        min
                                                                     
                                                                  
                                                                  -
                                                                  I
                                                                  -
                                                                  
                                                                     
                                                                        y
                                                                     
                                                                     
                                                                        ‾
                                                                     
                                                                  
                                                                  (
                                                                  x
                                                                  )
                                                                  )
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                         
                                                            2
                                                            
                                                               
                                                                  σ
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                            (
                                                            x
                                                            )
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    dI
                                 
                              
                           using integration by parts, Eq. (6) can be written as
                              
                                 (7)
                                 
                                    E
                                    [
                                    I
                                    (
                                    x
                                    )
                                    ]
                                    =
                                    σ
                                    (
                                    x
                                    )
                                    [
                                    u
                                    Φ
                                    (
                                    u
                                    )
                                    +
                                    ϕ
                                    (
                                    u
                                    )
                                    ]
                                 
                              
                           where
                              
                                 (8)
                                 
                                    u
                                    =
                                    
                                       
                                          
                                             
                                                y
                                             
                                             
                                                min
                                             
                                          
                                          -
                                          
                                             
                                                y
                                             
                                             
                                                ‾
                                             
                                          
                                          (
                                          x
                                          )
                                       
                                       
                                          σ
                                          (
                                          x
                                          )
                                       
                                    
                                 
                              
                           
                           Φ and ϕ denote cumulative distribution function and probability distribution function, respectively. EI criterion is often combined with Kriging model in engineering optimization applications, which in many cases has got better optimal solutions as well as less optimization iterations.

LHS is a method of sampling that can be used to produce input values for estimation of expectations of functions of output variables. Suppose that the joint distribution of the random vector of parameters x is given by g. Denote by g
                           k the cumulative distribution function of x
                           k, and let x
                           jk be the kth component of x
                           j, the jth simulated value, then x
                           jk is defined by (for producing a Latin hypercube sample of size N) [44]:
                              
                                 (9)
                                 
                                    
                                       
                                          x
                                       
                                       
                                          jk
                                       
                                    
                                    =
                                    
                                       
                                          g
                                       
                                       
                                          k
                                       
                                       
                                          -
                                          1
                                       
                                    
                                    (
                                    
                                       
                                          N
                                       
                                       
                                          -
                                          1
                                       
                                    
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          jk
                                       
                                    
                                    -
                                    1
                                    +
                                    
                                       
                                          ξ
                                       
                                       
                                          jk
                                       
                                    
                                    )
                                    )
                                 
                              
                           
                           p
                           =(p
                           jk) is an N
                           ×
                           K matrix, where each column of p is an independent random permutation of 1, 2, …, N, the symbols of ξ
                           jk(j
                           =1, 2, …, N; k
                           =1, 2, …, K) are NK IID U[0,1] random variables independent of p.

The contemporary high performance computing technologies, including parallel computing, cluster computing, grid computing and cloud computing, etc., have been introduced into the above optimization components with the intention of dramatically reducing the computing time, acquiring better optimal solutions and so on.

Originated from 1970s, the parallel computing was introduced to take full use of the advances of computer hardware development: multi-coreandmulti-processorcomputers have multiple processing elements within a single machine. Many parallel algorithms and programming languages have been put forward since then. Related technologies are still broadly used e.g. message processing interface (MPI) [47]. Meanwhile, engineering optimization applications have also got significant changes to perform as to benefit from these new technologies. For example, process of samples analysis could be done in a parallel way by separating them into several groups with MPI; commercial engineering analysis software such as Ansys starts to provide functions for parallel analysis using multi cores and shared memory; parallel optimization algorithms are also introduced to effectively use the multi-core and multi-processor behavior: Pedemonte presents a comprehensive survey on parallel ACO implementations [48], Regis uses radial basis function to do parallel global optimization problems [49], Audet describes a parallel space decomposition technique for the mesh adaptive direct search algorithm [50], Gordon makes a comparison for serial and parallel GA [51], Seiffert gives a survey on ANN on parallel computers [38], Migdalas discusses the developments in novel programming and algorithmic aspects of parallel computing as well as technical advances in parallel optimization [52], etc.

Cluster computing came into place by networking individual computers together to form as a cluster. Computers in a cluster need to have similar hardware in order to achieve better deployment and performance. The parallel computing environment is also installed for parallel jobs. Typically all jobs in a cluster should be executed in a batch mode and maintained by portable batch systems, OpenPBS, for instance. Computers are divided into management, compute and storage nodes in a cluster, with trustful access right from each other, as shown by the following [9,53,54]:


                           Fig. 3
                            describes a computer cluster which consists of n compute nodes named cu
                           1
                           −
                           cun
                           , three networks separately supporting data, manage and internet connections, a manage unit is mounted by a storage unit for network file system (NFS) usage [55].

Grid computing is a distributed computing form which comprises many networked loosely coupled computers running together to perform a large task. This technology has been widely applied in drug discovery, economic forecasting, seismic analysis and other commercial enterprises’ applications. Many well-known Grid projects have been completed, such as Enabling Grids for E-sciencE (EGEE), European Middleware Initiative (EMI), High Performance and Grid Computing Research Group, which further enabled several grid computing standards and application programming interfaces [10,56,57]. Condor-G is one famous grid middleware in Globus software used for job submissions, as shown in Fig. 4
                            
                           [58]:

Where GAHP represents Grid ASCII Helper Protocol, CREAM and LSF are both back end types for managing grid resources.

Grid computing has impassioned studies on technologies for the engineering manufacture such as “sand-box” in order to distributional analyze engineering designs. It also causes the enthusiasm for researches on the grid-related optimization algorithms, for example, Nebro describes a method that uses grid computing system to do multi-objective optimization problems [3], Carretero develops a scheduling algorithm for grid platform based on GA [59], and Chen intends to use ACO to schedule large-scale grid workflows with various QoS parameters [60]. Besides, the open source grid projects and simulation tools for gird architectures e.g. GridSim provide great opportunities for engineering researchers on testing and deploying appropriate platforms [61]. As web-based user interfaces and multi-clients are getting more and more popular through these platforms, engineering optimization application based on networking starts to appear, which could be seemed as the original pushing hand of cloud computing in this filed.

Two key features of a cloud platform are virtualization and dynamic. Virtualization may have different meanings for different platforms: physical hardware virtualization to IaaS, operation system virtualization to PaaS, application software virtualization to SaaS, for instance; dynamic behavior requests the platforms should rapidly respond to end users’ requirements and transparently manage the virtual resources. Customers would not be aware of all applications’ computing processes. Due to the high performance hardware in datacenters and professional scheduling algorithms used to manage resources, all application instances can be conducted with high efficiency at a low cost.

Platforms such as Amazon EC2, Google App Engine, Microsoft Azure are worldwide famous commercial clouds founded by big IT crocodiles, which could be utilized for developing applications such as net disk, web-based applications, standard Windows-based applications and so on [62–64]; engineering software vendors are also trying to persuade clients to build their own private cloud datacenters with technologies they provided in order to get the maximum usage and easier management for these software, Revit, for example; in optimization field, both commercial optimization solvers e.g. Gurobi (offers free license) and free optimization solvers e.g. NEOS are now available on the internet for solving such as linear problems, quadratic problems and mixed problems from users with multiple interfaces e.g. C, C++, Java and Python [65-67]; more importantly, open source cloud platforms e.g. Eucalyptus, CloudStack, OpenStack [6,10,68–72], and cloud computing tools e.g. HTCondor are getting more and more attentions in both the cloud computing field and the engineering optimization area due to the ever-growing participators including IT companies, cloud service providers, engineering researchers and so on [58,73]. All of these qualifications are making the consumption of developing generic cloud platform for engineering optimization with standard IT hardware become into reality.

OpenStack is an open source IaaS cloud platform that controls large pools of computing, storage, and networking resources throughout a datacenter. Founded by Rackspace Hosting and NASA, OpenStack has grown to be ascalable open source cloud operating system. The latest version of OpenStack is Havana.

A standard OpenStack platform should include compute, networking, storage, identity and image services, which normally implemented by nova, quantum, cinder, keystone and glance modules. Keystone and glance are shared services. Messages are passed through all services using a Rabbit MQ software to help them communicate with each other. OpenStack also provides powerful RESTful accessing and programming interfaces that could be used for managing low level physical resources and building user customized cloud platforms as to provide infrastructure, platform and software services themselves, as shown in Fig. 5
                            
                           [7,72].

This section focuses on the system design and implementation for the proposed generic cloud platform which could be used for engineering optimization applications. Contents in this section consist of discussions about the system modules such as virtual engineering optimization machine, virtual engineering optimization application, domain, and console, the architecture of the system, scheduling algorithm, the management methods for jobs and resources, process for application implementation, hardware deployment and database design.

The virtual engineering optimization machine (VEOM) is one of the basic modules in the proposed cloud platform that is defined as a virtual machine image which has been installed machine resident program (MRP), developed engineering optimization package (DEOP) and developed computing environment package (DCEP) within a certain operating system, as shown in Fig. 6
                        .

An engineering optimization package refers to a structure that could be used as a tool for sampling, analysis, modeling or optimization while given certain input data files, it exports certain output files and data after performing within computing environments; the computing environment package is used for establishing the computing environment relied by the application, e.g. Condor grid computing environment, MPI parallel computing environment. Details for these packages are described in Table 1
                        .

In order to communicate with MRP, all packages should be “developed” for transfer data files and controller orders, etc. The MRP is an OS-based program which is used for contacting with application resident program (describes in 3.2) through its API. Normally function-isolated packages can be installed to a VEOM simultaneously, and all VEOMs established for engineering optimization application instances share the same operation system.

Like a virtual machine, a virtual application is a structure without allocating any resources to run, in another word, it’s a “static” application which is organized with structured blocks and data. The virtual engineering optimization application (VEOA) module in the proposed cloud platform is depicted to consist of both platform-based structures and virtual network-based structures, which can be seen from Fig. 7
                        .

In the platform-based structures, the developed main program (DMP) is a “developed” main program which will be automatically transferred into the head host for running optimization jobs. Therefore the main change comparing to the application’s original non-cloud main program is other than calling the optimization packages in VEOMs directly, it has been programmed as using APIs for calling MRP instead. Parameter files are necessary input files serviced for the application. And platform application middleware (PAM) provides key functions for manipulating data pool’s files, also communicating with head host through data files and controller commands using APIs; in the virtual network-based structures, the first created VEOM is also defined as head host with application resident program (ARP) installed, which is used for corresponding with the platform and all VEOMs. ARP is also responsible for recording the whole application instance’s status data including CPU usage, system load, etc. which is further used for dynamically reconfigure the instance and log managements.

With VEOM and VEOA, engineering optimization researchers can develop very characteristic applications, for example, Ubuntu-based Ansys for analysis, Red hat-based optimization toolbox for optimization, Windows 7 based sampling toolbox for sampling, Windows 2008 server based modeling toolbox for modeling and Windows 2012 server based main program to drive the application. All the researchers need to do is building DEOPs and DMPs for the applications accordingly. Since the APIs of MRP, ARP and PAM are equally available for all applications, therefore the final application instance can be implemented with many different ways through this strategy, which makes the proposed platform into a generic engineering optimization form.

After resources allocated by the platform and VEOMs scheduled with scheduling algorithm (discusses in the following), a VEOA later becomes a dynamic resource pool that could be used for engineering optimization jobs running at batch mode, which in another word of this paper, it transforms into a “domain”. Fig. 8
                         has described the process for this conversion, which is also called domain initialization.

Console module is the bash shell based back-end management system of the proposed platform, which is built upon OpenStack APIs and accessed remotely by ssh. Console has got administrative functions such as automatically recycling compute resources, domain database initialization & destruction and log management and user level functions such as responding user requests and job submission.

The system adopts a multi-layer service oriented architecture, which includes OpenStack, VEOM, VEOA, domain, console and portal layers. Portal is the website for the whole system. VEOM, VEOA, and domain layers are mostly corresponding to low level OpenStack APIs, they altogether form the middleware layer; Portal and console layers mainly focus on the user application requests, therefore are defined as application layer. The whole system is described as below in Fig. 9
                        :

For different optimization instances, resource allocated and algorithms needed are different. The scheduling algorithm works as a bridge between user resource definition and VEOM construction. The input of the scheduling algorithm is resource allocation request, and the output is the VEOM instance id, returned to the method called it for further processing.

The scheduling algorithm is divided into two different phases: firstly, to get a VEOM combination solution from the resource allocated and the VEOM pool, including VEOM image id, flavor (resource combination used by OpenStack nova), etc.; secondly, to start all instances with OpenStack APIs, for example, nova, glance and keystone APIs. To make the algorithm work properly, the following assumptions are made:
                           
                              (1)
                              Each optimization application may depend on several DEOPs to accomplish its job.

DEOPs and VEOM images have a many-to-many relationship.

Each virtual machine image has its own platform and cost of construction as well as extra consumption for working normally—defined as startload in the platform.

Firstly, a proper way to map the resource allocated to the VEOM combination is considered, the basic principle of this phase is to use the minimum effort to meet the application software and resource demands. A simple way to describe the procedure is shown as following:
                           
                              (1)
                              Search for the DEOP set needed by this application, normally is a software list S
                                 =[S
                                 1,
                                 S
                                 2,…,
                                 Sn
                                 ].

Find the VEOM images installed the software obtained before V
                                 =[S
                                 1:[V
                                 11,
                                 V
                                 12,…,
                                 V
                                 1s],
                                 S
                                 2:[V
                                 21,
                                 V
                                 22,…,
                                 V
                                 2p],….,
                                 Sn
                                 :[Vn1
                                 ,
                                 Vn2
                                 ,…,
                                 Vnq
                                 ]].

Get all image combinations from the two processes above I
                                 =[[V
                                 11,
                                 V
                                 21,…,
                                 Vn1
                                 ],[V
                                 11,
                                 V
                                 21,…,
                                 Vn2
                                 ],…,[V
                                 1s,
                                 V
                                 2p,…,
                                 Vnq
                                 ]] (same images would be merged).

Calculate in each combination, as to find each image’s instances number using the resource allocation assumption L
                                 =[L
                                 11,21,n1,
                                 L
                                 11,21,n2,…,
                                 L
                                 1s,2p,nq].

From all combinations, return the combination with the minimum startload one, contains which images are used and their resource scheduled 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      llocate
                                                   
                                                
                                                =
                                                [
                                                
                                                   
                                                      V
                                                   
                                                   
                                                      1
                                                   
                                                
                                                :
                                                [
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      11
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      11
                                                   
                                                
                                                ]
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      12
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      12
                                                   
                                                
                                                ]
                                                ,
                                                …
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      1
                                                      m
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      1
                                                      m
                                                   
                                                
                                                ]
                                                ]
                                                ,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      V
                                                   
                                                   
                                                      2
                                                   
                                                
                                                :
                                                [
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      21
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      21
                                                   
                                                
                                                ]
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      22
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      22
                                                   
                                                
                                                ]
                                                ,
                                                …
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      2
                                                      n
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      2
                                                      n
                                                   
                                                
                                                ]
                                                ]
                                                ,
                                                …
                                                ,
                                             
                                          
                                          
                                             
                                                Vx
                                                :
                                                [
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      x
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      x
                                                      1
                                                   
                                                
                                                ]
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      x
                                                      2
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      x
                                                      2
                                                   
                                                
                                                ]
                                                ,
                                                …
                                                ,
                                                [
                                                
                                                   
                                                      C
                                                   
                                                   
                                                      xo
                                                   
                                                
                                                ,
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      xo
                                                   
                                                
                                                ]
                                                ]
                                                ]
                                             
                                          
                                       
                                    
                                  (assumes x VEOM images are scheduled, resources are only shown with symbols C and M, which stand for virtual CPU and virtual Memory).

Secondly, each VEOM instance is established and further embedded into an application domain, which acts as a computing resource pool. All these works are using OpenStack APIs for assistance. This procedure can be defined as:
                           
                              1.
                              Check each image instance’s resource schedule, to see if a nova image flavor has already existed with the same resources.

To the all schedules which is not currently existed, build new flavors using keystone and nova APIs appropriately.

Boot each image instance according to its resource allocation, using keystone and nova APIs, with the cloud user’s tenant and username information as credentials.

Through the above two phases, a mapping table between the resource request and the final instances’ ids and other related information can be achieved. The next step is to update the database records accordingly and the whole algorithm will then be completed.

Domain starts to manage jobs after it has been initialized, the job management is a complex process which is described in Fig. 10
                        .

ARP automatically contacts with PAM for transferring data files which could belong to new jobs submitted by end users from the platform, or the optimal solutions computed by the application jobs. It also has the responsibility to choose a suitable queued job which in this paper defined as the first of the job queue for running if computing resources are available.

If the symbol signifies for dynamically managing the domain’s computing resources has been set to “True”, then the domain will automatically manage its resources. If the workload is higher than the maximum acceptable threshold or lower than the minimum acceptable threshold, ARP will communicate with PAM for asking more computing resources or requesting for recycling wasted computing resources accordingly. Under situations of higher threshold showing up, the PAM would establish new host for the domain if there are still computing resources can be got, ARP will then reconfigure the domain; ARP will inform PAM for shutting down the latest joined non head host in the domain as to recycle its computing resources until the workload is under normal levels in the cases of lower workload. No matter which kind of these two, ARP will collect the newest status data at the end and keep PAM updated. This process is shown in Fig. 11
                        .

Four key steps are needed to implement application instances:
                           
                              (1)
                              Scheduling.

Domain initialization.

Job management.

Resource management. A typical application’s instance implementation process is shown in Fig. 12
                                 .

In Fig. 12, tasks are performed by different modules. The characteristic of virtualization is realized with domain (VEOA) and VEOM modules; and the characteristic of dynamic is carried through console and domain modules. The standby test in this paper is defined to see whether or not the domain has been free for more than 150s. The domain would inform the platform for recycling computing resources if the answer is positive using process just like that has been described in Figs. 9 and 10.

A 4-node cloud platform have been built for system testing, named as node01-node04. Each node has 6-core i7 Intel processor, 32GB ram, 128GB SSD and Ubuntu 12.04 64bit OS installed. There are two NICs on all nodes: one for management networking, the other for data networking. OpenStack Grizzly has been deployed on the four nodes. Node02-node04 only work for compute services, mainly install nova module; node01 also works as management unit, therefore glance, keystone, cinder, quantum modules are also installed. MySQL is used as operation database, which is installed on node01. The whole system contains two 10Gb switches which having all nodes connected, as shown in Fig. 13
                        .

An 8-table MySQL database has been created, including cld_domain, cld_job, cld_host, cld_app, cld_soft, cld_vm, cld_tenantlimit and cld_cloudlimt. Key attributes of each table and their relationships are shown in Figs. 14 and 15
                        
                        .

In Figs. 14 and 15, tables: (1) cld_domain table, maxcpu and maxmem attributes are the maximum virtual resources (in this paper, a virtual CPU stands for a computing core on physical host, a virtual CPU stands for 512GB ram) available for this domain, delthreshold and addthreshold are thresholds trigger resources automatically managed when autosymbol is set to True, working with domain’s load attribute named workload, which in this paper is defined as:
                           
                              (10)
                              
                                 workload
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         w
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               n
                                                            
                                                         
                                                         
                                                            
                                                               w
                                                            
                                                            
                                                               VEOM
                                                            
                                                         
                                                      
                                                      
                                                         n
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        value of workload is either wS
                         if a systematic load value could be computed within computing environment, Condor, for example, or the average workload of all VEOMs, in which wVEOM is defined to
                           
                              (11)
                              
                                 
                                    
                                       w
                                    
                                    
                                       VEOM
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            l
                                                         
                                                         
                                                            5
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            C
                                                         
                                                      
                                                      ×
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            C
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                      ×
                                                      e
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       M
                                    
                                 
                              
                           
                        value of wVEOM fetches the 5-min average load under standard Linux platforms, or the value of weighted sum for CPU and memory usage; (2) cld_host table, position is set to CENTER if this host is the manager of the domain, WORK otherwise; (3) an application may need several DEOPs (reflects in table cld_soft) to fulfill its task, therefore a 1-many relationship is worked up, so as cld_soft and cld_vm (database table for VEOM) tables; (4) cld_tenantlimt and cld_cloudlimit tables work together with cld_domain table to build up a 3-level resources limit system, the exact available resources should be the minimum values from the three at a certain time.

In this section, two real engineering optimization applications are discussed. The first one is called warpage optimization for injection, with a 2-job queue of application problems; the other is called turbine foundation optimization, with a 4-job queue of application problems. All problems are shared with the same DEOPs and computing environment, therefore are executed by job management system within a cloud domain one by one. The dynamic implementation of optimization process on cloud platform is what the tests aiming at, not the optimization problem itself, therefore the optimization optimal solutions are deliberately not discussed within this article. DEOPs for test cases include C++ based sampling toolbox, optimization toolbox, modeling toolbox and Ansys software, Moldflow software. All these DEOPs have been installed on VEOMs with both 32-bit and 64-bit Linux and Windows kvm virtual machine images. In the test platform, all VEOMs are defined to have the same combination of 1 virtual CPU and 8 virtual Memory for their maximum resources might be allocated.

The optimization process aims at minimizing the warpage of the injection molding parts in which process parameters, for instance, the mold temperature, melt temperature, injection time, packing time, packing pressure, and cooling time are the design variables. The warpage values are reduced by optimizing the process parameters [12]. A mobile shell and an air conditioning shell are used for example jobs.

All the two jobs in this test share the following process:
                              
                                 (1)
                                 Using LHS algorithm to generate samples.

Using Moldflow to analyze samples, get their responses.

Using GA algorithm to get optimal result.

Starting iterations until the optimal solution is acceptable.

The above four steps are controlled by main program within MPI runtime environment, application requests Windows 7 OS. With methods discussed above, this application is installed on the proposed platform for testing. As this application’s main program is hard to be developed to dynamic manage compute resources, therefore the autosymbol for this instance is set to False.

Two jobs submitted to example 1 at time spot 60s, the first job got finished around 700s, the other got finished about 600s later.

Example 1 requested 2 virtual CPU and 8 virtual Memory at running time (mapped to 2 VEOMs through scheduling), before jobs submitted to this domain (time spot 60s), no computing resource was scheduled; after domain shut down (time spot around 1550s), all computing resources were recycled.

Workload stayed at 0.0 before jobs running, it quickly got to a very high level as computing was undergoing; it got to low levels again after all jobs terminated and remained at 0.0 after the application was terminated.

Computing cost got a steady climbing at this instance; some minor vibration has been caused by records accuracy.

The application was used to minimize the dynamic displacement of a turbine foundation while loads are exerted on it by moving column/beam places indicated by x, y, z coordinates. The design variables are column/beam coordinates, a minimum dynamic displacement of the foundation is what the optimization looking for, therefore is the objective [74]. Four real turbine foundations named Dingzhou, Yangliuqing, Shaling and Yuanbaoshan are used for example jobs.

The four jobs in this application all use the following process to perform:
                              
                                 (1)
                                 Using LHS algorithm to generate samples.

Using Ansys to analyze samples, get their responses.

Using Kriging to obtain a surrogate model between samples and responses.

Using SQP algorithm to get optimal result (with EI method).

Starting iterations until the optimal solution is acceptable.

The above five steps are controlled by main program within Condor grid runtime environment, application requests Ubuntu OS. This application is also installed on the proposed platform for testing with methods discussed above. As the main program in this application is developed to dynamically manage compute resources while running the process, hence, the autosymbol for this instance is set to True. Values of addthrehod and delthrehold are set to 3.5 and 0.5 for testing purpose.

Four jobs were submitted at time spot 90s, after about 610s’s computing process, all jobs had got finished.

Example 2 made a 4 virtual CPU and 32 virtual Memory request for computing pool at running time (mapped to 4 VEOMs through scheduling). Before jobs queued in this domain (time spot 90s) and after domain automatically changed to standby mode while no jobs were available (time spot around 700s), no resources are used. As the autosymbol of this domain has set to True, domain itself automatically gave up some resources it was consuming due to its workload was too low. After time spot 270s, only 1 virtual CPU and 8 virtual Memory were maintained (3 VEOMs were shut down).

Workload stayed at 0.0 before jobs running, then hovering around at 0.35 until wasted resources were recycled near time spot 270s, domain workload began to stay at a rather high level, and finally dropped down to 0.0 when no jobs existed and remained at this point until domain’s shut down. Note that workload in this chart has different meaning from the above example, for they belong to different applications and compute environments.

Cost got two different slopes at this instance as the first running stage consumed a much more resources; some little vibration is caused by accuracy property for records.

@&#DISCUSSION@&#

The above two application examples are developed to test the effectiveness of the developed generic cloud platform (for generic engineering optimization problems). From all the tests, three main results have been achieved:
                           
                              1.
                              As can be seen from Figs. 16 and 20
                                 
                                 
                                 
                                 
                                 , application instances were executed automatically in the platform, having jobs running at a batch mode within a domain computing resource pool. In order to achieve this, applications were implemented in virtual types using methods described in Section 3. The computing resources such as CPU and memory were allocated according to user’s requests automatically, a batch executing mode has greatly improved the jobs running efficiencies.

Resources were managed in a rational form, which includes the starting, running and finishing of a domain (see Figs. 17, 18 and Figs. 21, 22
                                 
                                 ). For both tests, resources were not scheduled until actual jobs were submitted. After all jobs were finished, resources consumed were automatically recycled by the platform for further management. With the help from a domain resource running management symbol – autosymbol (set to True) and its load value – workload, resources of an application instance domain could also be managed automatically while executing optimization jobs. As can be seen from Figs. 21 and 22, a low level workload will trigger the domain itself to automatically give up some resources, which will be further recycled by the platform, and vice versa.

Costs for application instances are recorded for future expansion and management purposes (e.g. commercializing according to the running cost of a specific optimization application). Other related information also has been included into the system log module. Besides, normally the initialization for a domain should take some time to finish while no jobs would be running at, therefore cost of this procedure should rather record on the platform than on the users. This strategy is reflected by the certain steady process that exists on the cost figures described in Figs. 19 and 23
                                 , which makes a really “pay-as-you-go” mode of service.

Componentized engineering optimization method, with its innate attribute suitable for high performance computing, has been widely developed in many engineering fields for solving real optimization problems. The most important requirement for a componentized engineering optimization application is to divide the whole procedure into several sub components, which concentrate on their different functions. This method has two main advantages:
                        
                           (1)
                           The whole optimization problem could be easily understood using divide and conquer strategy.

Components are function-isolated and have standard processes and algorithms, therefore the current optimization procedure can be easily further developed for different application domain.

Cloud computing has been fostering a worldwide new computing mode in recent years. Clouds should be used to provide computing and storage services. End users could choose their favorite platform as underlying framework to build their own private or public cloud platform for special needs. In this paper, in order to provide cloud-based services for engineering optimization applications, the virtual manner of sampling, analysis, modeling, optimization and control components into virtual machines for each application has been analyzed using DEOP, DMP and MRP. With DEOP, DCEP and MRP installed VEOMs, ARP installed head host in virtual network structures and PAM, data pool in platform structures, all optimization processes can be automatically fed into an overall working process for a specific application (VEOA). After achieving the scheduling details for the allocated VEOMs (scheduling), a domain for this application instance will then be set up as the computing resource pool. Cloud console and domain services for job management have been utilized with the dynamic resources scheduling while the instance is running. Finally, all computing resources will be recovered back to datacenter for future use after the instance is finished (resource management). Virtualization is reflected in the way of generating virtual applications. In addition, the platform also has all common cloud platform behaviors since it is based on OpenStack infrastructure.

Two real engineering optimization applications were developed as examples to demonstrate the platform’s capability. As the engineering optimization method described in this paper has been widely used in many engineering industries, the generic platform developed has a promising potential to be widely utilized in the future in various engineering application domains.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to highly appreciate the financial support provided by the National Basic Research Program of China (No. 2012CB025905) and the Fundamental Research Funds for the Central Universities of China (No. DUT14RC(3)060).

@&#REFERENCES@&#

