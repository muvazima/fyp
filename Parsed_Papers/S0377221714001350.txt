@&#MAIN-TITLE@&#An iterated local search algorithm for the single-vehicle cyclic inventory routing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We define and situate the Single-Vehicle Inventory Routing Problem (SV-CIRP).


                        
                        
                           
                           We discuss and exploit some complex characteristics of the SV-CIRP.


                        
                        
                           
                           We design an efficient iterated local search technique for the SV-CIRP.


                        
                        
                           
                           Our approach outperforms the best available algorithm with 16.02% on average.


                        
                        
                           
                           Our approach is significantly faster and 32 new best known solutions are presented.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Routing

Inventory

Single-vehicle cyclic inventory routing problem

Iterated local search

Metaheuristic

@&#ABSTRACT@&#


               
               
                  The Single-Vehicle Cyclic Inventory Routing Problem (SV-CIRP) belongs to the class of Inventory Routing Problems (IRP) in which the supplier optimises both the distribution costs and the inventory costs at the customers. The goal of the SV-CIRP is to minimise both kinds of costs and to maximise the collected rewards, by selecting a subset of customers from a given set and determining the quantity to be delivered to each customer and the vehicle routes, while avoiding stockouts. A cyclic distribution plan should be developed for a single vehicle.
                  We present an iterated local search (ILS) metaheuristic that exploits typical characteristics of the problem and opportunities to reduce the computation time. Experimental results on 50 benchmark instances show that our algorithm improves the results of the best available algorithm on average with 16.02%. Furthermore, 32 new best known solutions are obtained. A sensitivity analysis demonstrates that the performance of the algorithm is not influenced by small changes in the parameter settings of the ILS.
               
            

@&#INTRODUCTION@&#

A class of routing problems that currently gets a lot of attention are the Inventory Routing Problems (IRP), e.g. Dror and Ball (1987), Andersson, Hoff, Christiansen, Hasle, and Lokketangen (2010), Schmid, Doerner, and Laporte (2013) and Zhong and Aghezzaf (2012). A typical characteristic of these routing problems is that inventory and handling costs at the customers are also taken into account. This corresponds to logistic providers not only distributing goods from a central depot to their customers, but also managing the inventories at these customers. In the literature, the IRP is discussed as a “Vendor Managed Inventory” (VMI) problem, where the supplier coordinates both the routing of a fleet of vehicles distributing the goods and the timely replenishment of inventories at the customers. This strategy allows reducing costs compared to the traditional strategy of the separated management of inventory, done by the customers, and vehicle routing, done by the supplier (Campbell, Clarke, & Savelsbergh, 1998; Christopher, 1998; Waller, Johnson, & Davis, 1999). The Cyclic Inventory Routing Problem (CIRP) is a well-known variant of the general IRP (Aghezzaf, Raa, & Van Landeghem, 2006; Raa & Aghezzaf, 2009). The CIRP is an appropriate optimisation model for a VMI policy when customer demand rates are stable and the planning horizon is infinite. For this class of problems, the objective function is to minimise the long term transportation and inventory costs.

In this paper, we deal with a specific variant of a cyclic inventory routing problem: the Single-Vehicle Cyclic Inventory Routing Problem (SV-CIRP) (Aghezzaf, Zhong, Raa, & Mateo, 2012; Zhong & Aghezzaf, 2011, 2012). In this case, the demand rate is considered constant and a cyclic distribution plan should be developed for a single vehicle starting and ending at a single depot (Andersson et al., 2010). The goal of the SV-CIRP is to minimise the total cost, i.e. the addition of transportation and inventory costs, by determining the quantity to be delivered to the selected customers and the vehicle routes, while avoiding stockouts. Most papers in the literature (e.g. Campbell et al., 1998; Federgruen & Simchi-Levi, 1995; Moin & Salhi, 2007; Ribeiro & Lourenço, 2005) consider an unlimited number of vehicles for the fleet or determine the minimum number of needed vehicles.

The SV-CIRP considers a set of potential customers, each with a demand rate, inventory and handling costs and a fixed reward. Other distribution aspects to be considered are the travel times between customers, the travel cost, the vehicle cost, the average speed and the capacity of the vehicle. The main variable is the cycle time, i.e. the time between two deliveries to each customer. An important property of the SV-CIRP is that the single vehicle is allowed to make multiple trips from the depot within one cycle.

It is worthwhile to study the SV-CIRP since it arises as a sub-problem of the CIRP (Aghezzaf et al., 2006). In this case, the proposed solution procedures are branch-and-price or column generation. The SV-CIRP should also be considered as the inventory routing variant of the Orienteering Problem (OP), the “Inventory Orienteering Problem” (IOP). The goal of the regular OP (Vansteenwegen, Souffriau, & Van Oudheusden, 2011) is to maximise the total score, collected by visiting a selection of customers, without violating a time constraint. Every customer can be visited at most once and the travel times between the customers are given. If inventory and handling costs are added to the standard OP, the result will be the SV-CIRP, except that for the SV-CIRP no upper bound for the cycle time is fixed beforehand. Actually, we think the IOP would better model reality than the SV-CIRP, since the IOP can limit the cycle time to a given upper bound, e.g. a number of hours or a working day. It should be noted that Federgruen and Simchi-Levi (1995) mention this constraint as an extension of what they called inventory-routing models. However, this upper bound would only make the problem easier to solve, due to a smaller number of possible solutions. Moreover, benchmark test instances are available for the SV-CIRP, but not for the IOP. Therefore, we limit our research to the SV-CIRP in this paper, knowing that the proposed solution technique can also solve the IOP.

When solving the SV-CIRP, a number of questions need to be answered in an integrated way: Which customers should be selected? Which cycle time would minimise the combination of inventory, handling and routing costs? How should the selected customers be divided in multiple trips for the single vehicle?

Due to the complexity of this problem, a metaheuristic approach was designed to tackle it. The Iterated Local Search (ILS) metaheuristic is used as a framework to solve this problem. The general structure of ILS is described by Lourenço, Martin, and Stützle (2010): a sequence of local search solutions is built up, instead of repeating random local search trials starting from an empty solution each time. During each iteration of the algorithm, a different part of the solution is removed and then local search moves are used in order to try to reach a better solution. This framework was successful before in dealing with problems where customers need to be selected (e.g., Ribeiro & Lourenço, 2005).

The next section presents an overview of the related literature. In Section 3 a detailed definition of the SV-CIRP is presented and Section 4 discusses some insights in the complexity of the problem. These insights can be considered as a significant contribution of this paper and will be exploited by our solution approach to tackle the SV-CIRP efficiently. This approach is described in detail in Section 5. Experimental results and parameter settings are discussed in Section 6. Thanks to its specific implementation, our approach outperforms the solution approaches available in the literature and obtains many new best known solutions. Conclusions and future work are presented in Section 7.

@&#LITERATURE REVIEW@&#

The Inventory Routing Problem (IRP) was first introduced by Bell et al. (1983). However, many variants of the problem exist, since different authors rarely define the problem in exactly the same way (Coelho, Cordeau, & Laporte, 2012). These authors classify a number of papers based on single or multiple customers, stochastic demands, direct deliveries, problems with multiple products or heterogeneous fleets. A number of comprehensive survey papers about IRP are available. Some of them are the following ones. Kleywegt, Nori, and Savelsbergh (2002) and Adelman (2004) present a classification of IRP variants based on four characteristics: finite or infinite planning horizon, deterministic or stochastic demands, limited or unlimited number of vehicles and one or multiple customers visited per trip. In a recent and comprehensive survey, Andersson et al. (2010) extend these four characteristics and focus more on industrial aspects. For instance, they discuss three different topologies: one-to-one, one-to-many and many-to-many and they add the “instant” planning horizon. In the survey of Schmid et al. (2013), inventory routing problems are discussed and situated amongst other rich vehicle routing problems in the section about “inventory management and vendor managed inventory”.

The fundamental contributions in the class of the CIRP are that of Anily and Federgruen (1990), Gallego and Simchi-Levi (1990) and Hall (1992). Research about an appropriate solution technique for the CIRP led to the formulation of the SV-CIRP, since it came up as a sub-problem in a solution approach based on column generation (Aghezzaf et al., 2006). In Zhong and Aghezzaf (2011), an in-depth analysis of the SV-CIRP reveals that the objective function is non-smooth and non-convex with many local minima. This makes the problem complicated to solve for both exact and heuristic solution approaches. Recently, Haughton (2014) underlined the complexity considering the possible correlation between customer locations and demand rates.

In his PhD dissertation, Zhong (2012) presents an extensive literature survey about the IRP, the CIRP and the SV-CIRP, together with a detailed discussion about the complexity of the SV-CIRP and an efficient mathematical formulation of the problem. He also discusses the differences and similarities with some closely related problems. None of these related problems integrate the above mentioned aspects that make the SV-CIRP unique and complex to solve.

The first solution technique developed for the SV-CIRP is described by Aghezzaf et al. (2006). They solve the SV-CIRP by combining a savings-based heuristic with an insertion move. Zhong and Aghezzaf (2011) propose a steepest decent hybrid algorithm to solve the SV-CIRP to optimality. This approach reaches the objective, but appears very time consuming, since many mixed integer linear problems need to be solved. The algorithm consists of two major steps: (1) solving the SV-CIRP for a fixed cycle time as a mixed integer linear problem and (2) improving the interval of variation of the cycle time using the Frank–Wolfe method (e.g. Frank & Wolfe, 1956). Due to its time consumption, this exact approach can only be applied to small size instances, with 15 customers or less.

To deal with larger instances of the SV-CIRP, Zhong and Aghezzaf (2012) present an iterated local search (ILS) metaheuristic. This is the best (meta)heuristic currently available to deal with the SV-CIRP. As mentioned above, the general structure of ILS is described in Lourenço et al. (2010). Since we also use the ILS framework for our algorithm, we will now discuss its general structure in more detail. However, our implementation of this framework is totally different from the implementation of Zhong and Aghezzaf (2012) and so will be the performance. We discuss the most important differences when we explain our algorithm in Section 5.

ILS typically starts from an initial solution. This solution is further improved by a local search heuristic. Every time local search reaches a local optimum, an acceptance criterion decides whether or not the new solution is accepted. If it is accepted, the next iteration starts with a perturbation of this new local optimum, otherwise the perturbation is applied to the previous local optimum. After the perturbation, the local search heuristic is applied again in the next iteration in order to obtain a new local optimum. The stopping criterion determines when the algorithm stops.

In the improvement phase of Zhong and Aghezzaf (2012), four local search moves are considered that insert, remove and/or relocate customers in order to reduce the total cost. In order to diversify the search, pairs of customers are swapped randomly. Furthermore, a backtracking technique is applied to focus the search to more attractive regions of the search space.

ILS has also been successfully implemented on problems related to the SV-CIRP such as the time windows variant of the Orienteering Problem (Vansteenwegen, Souffriau, Vanden Berghe, & Van Oudheusden, 2009). Its rather simple structure is appropriate to obtain high quality solutions for difficult routing problems in an acceptable time.

In order to illustrate the performance of their algorithm, Zhong and Aghezzaf applied it to different sets of benchmark instances (Aghezzaf et al., 2012; Zhong, 2012; Zhong & Aghezzaf, 2012). We will use the same benchmark instances for evaluating and comparing the performance of our algorithm.

In this section, we first present a detailed definition of the SV-CIRP and the notation and cost function we will use in the remainder of this paper. Then, we focus on the cycle time which is the most important decision variable.

The SV-CIRP considers N potential customers (i
                        =1, … , N), each with an inventory cost (si
                         in euro/tonneshour), a handling cost (hi
                         in euro/delivery), a demand rate (di
                         in tonnes/hour) and a fixed reward (ri
                         in euro/hour). This reward corresponds to the profit that is collected when this customer is included in the distribution plan. The time required to travel between two customers i and j is given by tij
                         and is considered constant. Other aspects related to distribution that need to be taken into account are the fixed vehicle operating cost (ψ in euro/hour), the average speed of the vehicle (ν in kilometer/hour), the travel cost (δ in euro/kilometer) and the vehicle capacity (Q in tonnes). It is assumed that every customer has an infinite inventory capacity. An important decision variable will be the cycle time CT: the time between two deliveries to each customer.

It could be reasonable that the goal of the SV-CIRP were to maximise the difference between rewards and costs, but according to Zhong and Aghezzaf (2012) it is to minimise the total cost (Cost in euro/hour), by determining the quantity to be delivered to each customer and the vehicle routes, while avoiding stockouts at the selected customers. Cost takes into account all above mentioned costs and rewards and can be expressed as a function of the cycle time CT (with S as the set of selected customers and Ttot as the total travel time):
                           
                              (1)
                              
                                 Cost
                                 (
                                 CT
                                 )
                                 =
                                 ψ
                                 +
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ∈
                                             S
                                          
                                       
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       CT
                                    
                                 
                                 +
                                 CT
                                 ∗
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ∈
                                             S
                                          
                                       
                                       
                                          
                                             d
                                          
                                          
                                             i
                                          
                                       
                                       ∗
                                       
                                          
                                             s
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       δ
                                       ∗
                                       ν
                                       ∗
                                       Ttot
                                    
                                    
                                       CT
                                    
                                 
                                 -
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       r
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     

In the SV-CIRP, due to the multiple trips (k trips) a vehicle can make during one cycle, each starting from the depot, the total travel time per cycle Ttot is determined by the sum of all trip travel times. Each trip should respect the vehicle capacity. As will be explained later, this multiple trip possibility makes the problem much more complicated.

A detailed, nonlinear mixed-integer formulation of the SV-CIRP can be found, for instance, in Zhong and Aghezzaf (2012). To make the problem somewhat easier to understand, we include a simple SV-CIRP example, introduced by Zhong (2012) and illustrated in Fig. 1
                        .

In the example, the fixed cost of using the vehicle is 20euro/hours and it travels at 50kilometer/hour at a travel cost of 1euro/kilometer. The vehicle capacity is 50tonnes. The demand rates and rewards per customer as well as the trip times are indicated in Fig. 1. For each customer, the holding cost is 0.5euro/tonneshour and the fixed handling cost is 20euro/cycle. A feasible solution consists out of the following three trips (we indicate the depot with a “0”): (0,a,b,0); (0,d,e,0); (0,g,0). A cycle time of 16.67hours minimises the total cost for this solution to [20+(100/16.67)+(16.67*8*0.5/2)+(1*50*15/16.67)−192=]−87.67euro/hours. A better solution in this case has only two trips: (0,a,b,c,0); (0,d,f,g,0). A cycle time of 12.5h minimises the total cost for this solution to [20+(120/12.5)+(12.5*8*0.5/2)+(1*50*12/12.5)−212=]−109.4euro/hours.

As mentioned above, the cycle time will be the key decision variable. To better understand the difficulty of the multiple trip SV-CIRP, a discussion about the cycle time will be helpful. In this problem, the cycle time is lower and upper bounded. It must be longer than the shortest travel time required to visit all selected customers divided in multiple trips. This minimal cycle time is denoted by Tmin. On the other hand, the cycle time is limited to Tmax, based on the capacity of the vehicle. For a given cycle time CT, the vehicle should deliver CT
                        
                        *
                        
                        di
                         tonnes to each customer i, during each cycle. In each trip, the sum of these deliveries (CT
                        
                        *
                        
                        di
                        ) over all customers visited in that trip is limited by the vehicle capacity. As a result, the trip J with the highest sum of demand rates (according to the customers visited in the trip) determines the value of Tmax:
                           
                              (2)
                              
                                 Tmax
                                 =
                                 
                                    
                                       Q
                                    
                                    
                                       
                                          
                                             max
                                          
                                          
                                             J
                                             ∈
                                             trips
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      ∈
                                                      J
                                                   
                                                
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

A given division in multiple trips, for a set of customers, is not feasible when Tmin is greater than Tmax. For a selection of customers divided in multiple trips, the ideal cycle time would be the “economic-order-quantity” cycle time Teoq (Zhong & Aghezzaf, 2012):
                           
                              (3)
                              
                                 Teoq
                                 =
                                 
                                    
                                       
                                          
                                             δ
                                             ∗
                                             ν
                                             ∗
                                             Tmin
                                             +
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   ∈
                                                   S
                                                
                                             
                                             
                                                
                                                   h
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   ∈
                                                   S
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ∗
                                                   
                                                      
                                                         s
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

However, Teoq can only be selected if it lies between Tmin and Tmax, and then becomes the optimal cycle time (Topt). If Teoq is shorter than Tmin, Tmin will be the optimal cycle time, for this selection of customers and this division in trips. If Teoq is longer than Tmax, Tmax will be the optimal cycle time. Changing the division in trips or the selection of customers obviously alters the values for Tmin and Tmax and thus the values for Teoq and Topt. This property will play an important role when solving the SV-CIRP.

For the first solution discussed for the example of Fig. 1, the minimal cycle time is 15hours (sum of trip lengths) and the maximal cycle time is (50/max{3,3,2}=) 16.67hours. Teoq equals 20.62hours and therefore Topt is 16.67. For the second solution, the minimal cycle time is 12hours (sum of trip lengths) and the maximal cycle time is (50/max{4,4}=) 12.5hours. Teoq equals 18.98hours and therefore Topt is 12.5 for this set of customers, divided in the indicated two trips. These optimal cycle times are used above to calculate the minimal cost for both solutions.

In this section, we present and analyse some characteristics of the SV-CIRP which we exploited to either decrease the computational effort of our method or increase the quality of the results. We believe these characteristics are worthwhile to be discussed explicitly since they can be important for future research on the SV-CIRP. Therefore, we consider these insights to be an important contribution of this paper.

For a given set of customers, a minimal value for Tmin can be determined based on the solution for the Travelling Salesperson Problem (TSP) only considering this set. Later, considering a solution with k trips, we can obtain a solution with k
                        +1 trips applying Divide (explained in Section 5.1). In that case, Tmin of k trips can be used as a lower bound for Tmin of k
                        +1 trips. In order to decide if it is useful to apply Divide with k
                        +1 trips, this lower bound of Tmink
                        
                        +1 is first compared with an upper bound for Tmaxk
                        
                        +1. This upper bound corresponds to a theoretically perfect spreading of the demand rates over the different trips:
                           
                              (4)
                              
                                 
                                    
                                       Tmax
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 ⩽
                                 
                                    
                                       Q
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            i
                                                            ∈
                                                            S
                                                         
                                                      
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      k
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        If the lower bound of Tmink
                        
                        +1 exceeds Tmaxk
                        
                        +1, it is not useful to consider k
                        +1 trips. Furthermore, for any number of trips, Tmax is limited by the customer of the set with the highest demand rate:
                           
                              (5)
                              
                                 Tmax
                                 ⩽
                                 
                                    
                                       Q
                                    
                                    
                                       
                                          
                                             max
                                          
                                          
                                             i
                                             ∈
                                             S
                                          
                                       
                                       (
                                       
                                          
                                             d
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

During the solution of a SV-CIRP, it will be useful to solve a Capacitated Vehicle Routing Problem (CVRP) (Toth & Vigo, 2002) for a given subset of customers and a fixed number of trips. How this CVRP is solved is discussed at the end of Section 5.1. This CVRP solution will minimise the distance required to visit these customers using the fixed number of trips, executed by the single vehicle. If this is also a feasible SV-CIRP solution, the CVRP solution will be a high quality solution for the SV-CIRP.

The useful characteristic discussed here concerns the difference between these CVRP and SV-CIRP solutions. For a given set of customers and number of trips, the optimal CVRP solution is also the optimal SV-CIRP solution, if Teoq is shorter than Tmin. In that case, it is not useful to try to spread the demand rate more evenly over the trips and increase Tmax, since this will always increase Tmin and, in this case, Topt and Cost. This important characteristic is illustrated in Figs. 2 and 3
                        
                        .

In these figures, Cost is plotted as a function of the cycle time (CT). The only difference between the two curves in each figure is a difference in Tmin, corresponding to a different division in trips. Since the set of customers is fixed, all other cost factors are constant, see Eq. (1). The function Cost(Tmin
                        1) corresponds to a lower value of Tmin.

The situation where Teoq is shorter than Tmin is illustrated in Fig. 2. The interval of the feasible cycle times is situated in the right part of this figure. When Tmin is increased, we move to the function Cost(Tmin
                        2) and the interval moves to the right. In this case, Cost will always be increased by increasing Tmin (=Topt).

The other situation, when Teoq is larger than Tmax, is illustrated in Fig. 3. In this case, spreading the demand rate more evenly over the trips could increase Tmax and Topt (closer to Teoq) enough to compensate for the extra cost of an increase in Tmin. When Tmin is increased as a result of spreading the demand rate more evenly over the trips, we move from the lower to the upper curve and the interval moves to the right. In this case, Cost at Tmax (=Topt) of the lower curve is higher than at Tmax of the upper curve.

Based on the same reasoning, evaluating more trips in order to try to improve a solution for a given set of customers is only useful when Teoq is larger than Tmax, since an extra trip will always increase Tmin. When for a given selection and number of trips, Teoq is shorter than Tmin of the CVRP solution, possible solutions with more trips should not be evaluated anymore.

The insights about the bounds for Tmin and Tmax and about the difference between solving the CVRP and the SV-CIRP were not exploited by any of the previous algorithms, but they do increase the efficiency of our approach, described in the next section.

This section describes all components that were integrated in the Iterated Local Search (ILS) framework to efficiently solve the SV-CIRP. ILS is a metaheuristic which has been proposed before to solve other Inventory Routing Problems (Ribeiro & Lourenço, 2005). ILS was also used before by Zhong and Aghezzaf (2012) for the SV-CIRP, but our algorithm is based on a totally different implementation of this framework.

The particular ILS components in our implementation will be discussed one by one: the initialisation, the local search heuristic, the perturbation, the acceptance criterion and the stopping criterion. However, the three calculation functions (Divide, Insert and Relocate) that will be used by the different components are explained first. At the end, an extra component, focussing on the division of customers in trips, is discussed. Algorithm 1 gives an overview of our ILS implementation.
                        
                           
                              
                              
                                 
                                    
                                       Algorithm 1: ILS for the SV-CIRP
                                    
                                 
                              
                              
                                 
                                    
                                       Nr ← 1
                                 
                                 
                                    
                                       Pos ← 1
                                 
                                 
                                    
                                       NrOfIterNoImprovement ← 0
                                 
                                 
                                    
                                       Solution ←
                                       Initialisation
                                    
                                 
                                 
                                    
                                       BestFound ←
                                       Solution
                                    
                                 
                                 
                                    
                                       while 
                                       NrOfIterNoImprovement < MaxIterNoImprovement 
                                       do
                                    
                                 
                                 
                                    
                                       Solution ←Local search heuristic (Solution)
                                 
                                 
                                    
                                       
                                       if 
                                       Solution better than BestFound 
                                       then
                                    
                                 
                                 
                                    
                                       
                                       BestFound ←Solution
                                 
                                 
                                    
                                       
                                       
                                       Nr ←1
                                 
                                 
                                    
                                       
                                       
                                       NrOfIterNoImprovement ←0
                                 
                                 
                                    
                                       
                                       else
                                    
                                 
                                 
                                    
                                       
                                       
                                       NrOfIterNoImprovement ←NrOfIterNoImprovement+1
                                 
                                 
                                    
                                       
                                       end if
                                    
                                 
                                 
                                    
                                       Solution ←Acceptance Criterion (BestFound, Solution)
                                 
                                 
                                    
                                       
                                       while 
                                       Pos > NrOfCustomersInSolution 
                                       do
                                    
                                 
                                 
                                    
                                       
                                       
                                       Pos←Pos-NrOfCustomersInSolution
                                    
                                 
                                 
                                    
                                       
                                       end while
                                    
                                 
                                 
                                    
                                       
                                       if 
                                       Nr > NrOfCustomersInSolution*MaxPercentageToRemove 
                                       then
                                    
                                 
                                 
                                    
                                       
                                       
                                       Nr←1
                                 
                                 
                                    
                                       
                                       end if
                                    
                                 
                                 
                                    
                                       Solution ←Perturbation(Solution, Nr, Pos)
                                 
                                 
                                    
                                       
                                       Nr ←
                                       Nr+ 1
                                 
                                 
                                    
                                       
                                       Pos ←
                                       Pos + Nr
                                    
                                 
                                 
                                    
                                       end while
                                    
                                 
                                 
                                    
                                       if 
                                       BestFound visits all customers 
                                       then
                                    
                                 
                                 
                                    
                                       BestFound ←
                                       OrderAll(BestFound)
                                 
                                 
                                    
                                       else
                                    
                                 
                                 
                                    
                                       BestFound ←
                                       Relocate(BestFound)
                                 
                                 
                                    
                                       end if
                                    
                                 
                                 
                                    Return BestFound
                                 
                              
                           
                        
                     
                  

For a given selection of customers S, Divide determines the best division in trips and the best sequence of visits in each trip. Remember that the single vehicle can make multiple trips from the depot during one cycle.


                        Divide has three phases. It starts by solving a Travelling Salesperson Problem (TSP) for all selected customers. This corresponds to the one trip solution for all customers of S (see Fig. 4
                        ). However, due to the limited capacity of the vehicle, multiple trips might be required to visit all customers in S or might result in a lower Cost.

Since Tmin should be shorter than Tmax for a feasible solution, and since Tmin will never decrease when an extra trip is considered, the maximal demand rate per trip (MaxDemandRate) for k
                        +1 trips, can be determined based on Tmin for k trips. This MaxDemandRate is used in the second phase.
                           
                              (6)
                              
                                 
                                    
                                       MaxDemandRate
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       Q
                                    
                                    
                                       
                                          
                                             Tmin
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Divide uses MaxDemandRate as the capacity constraint when solving a Capacitated Vehicle Routing Problem (CVRP) (Toth & Vigo, 2002) for all customers of S and for a given number of trips. A CVRP is commonly used as a base problem when solving the IRP (Campbell et al., 1998; Federgruen & Simchi-Levi, 1995). Every time a feasible CVRP solution is found for a given number of trips, Tmin and MaxDemandRate are updated for a higher number of trips. The number of trips to evaluate as a CVRP varies between two and a maximal number of trips that can be calculated based on the highest demand rate of a customer in the set and the total demand rate:
                           
                              (7)
                              
                                 MaxNumberOfTrips
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      ∈
                                                      S
                                                   
                                                
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      max
                                                   
                                                   
                                                      i
                                                      ∈
                                                      S
                                                   
                                                
                                                (
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

A higher number of trips would only increase the value of Tmin while Tmax cannot increase anymore since its maximum value, given in Eq. (4), is reached. Therefore, a higher number of trips cannot lead to a better solution.

For a given number of trips, this CVRP solution minimises the distance to visit all customers of a set. Therefore it is a high quality candidate for the SV-CIRP. To verify if this solution is also a feasible SV-CIRP solution, the actual duration of the total tour, Tmin, is compared with Tmax, equal to the vehicle capacity divided by the demand rate of the trip with the highest demand rate, as it can be seen in Eq. (2). If it is a feasible SV-CIRP solution, Teoq, Topt and Cost are calculated.

In a third phase, a local search procedure tries to decrease Cost by spreading the demand rate more evenly over the different trips. Obviously, this will increase Tmin, but it might also decrease Cost. This is illustrated above in Fig. 3. For every customer of the trip with the highest demand rate, it is evaluated if moving this customer to any other trip, leads to a decrease in Cost. The move of the customer leading to the highest decrease, if any, is executed. As long as Cost is decreased, this procedure is repeated. Based on the insight discussed in Section 4.2, this third phase can be skipped when Teoq is shorter than Tmin.

The result of the second phase is called the CVRP solution for a set of customers and a given number of trips. An example is presented in Fig. 5
                        . The result of the third phase is called the SV-CIRP solution for a set of customers and a given number of trips. An example is presented in Fig. 6
                        .

For a given set of customers, the division in trips that leads to the lowest Cost is selected as the result of Divide.

In order to solve the TSP (for one trip, in phase 1) or the CVRP (for more trips, in phase 2), the parallel version of the Clarke and Wright Savings Algorithm is used (Clarke & Wright, 1964; Toth & Vigo, 2002). No local search is added to this savings heuristic since this appears too time-consuming due to the fact that Divide will be used many times each iteration.

If the solution of the Clarke and Wright Savings Algorithm contains more trips than currently considered, a reduce procedure must be applied. This procedure will try to move all customers from one trip to the other trips, respecting MaxDemandRate. The trip that is considered for removal is the one with the lowest average demand rate per customer. If this trip can be emptied completely, it is removed. The procedure for trip reduction is repeated until enough trips are removed or until the trip under consideration cannot be removed. In this latter case, no feasible CVRP solution is found for the current number of trips.


                        Insert is a fast way to add an extra customer to a given solution. In this case, the division of the customers in trips is not changed. One by one, all non-visited customers are considered for insertion and the customer leading to the highest decrease in Cost is inserted. Then again, all non-visited customers are considered until no more customers can be inserted. When considering a customer for insertion, all possible positions in all possible trips are considered. The best position in each trip is selected based on the lowest increase in travel time, and the best trip to insert the customer is selected based on the highest decrease of Cost.

Based on the demand rate of the customer, the current demand rate of the trip and the current Tmin, some trips can immediately be excluded. These three values and the extra distance needed for insertion in that trip also exclude a number of possible trips.


                        Relocate is a well-known local search heuristic for the VRP (e.g. Laporte, Gendreau, Potvin, & Semet, 2000). In our algorithm, Relocate evaluates, for every customer, if the total travel time can be reduced by visiting the customer in another position in its own trip or in another trip. For each customer, the least time-consuming position is determined. The relocation that leads to the highest decrease in travel time is actually implemented (“best improvement local search”) and Relocate is applied again until a local optimum is reached.

Since this heuristic is very time-consuming for larger instances, it is not implemented every time a CVRP is solved. Only just before the algorithm returns the best found solution, it verifies if the total cost can be improved by applying the Relocate local search heuristic. Only if the total cost of this local optimum is lower than the cost of the solution before Relocate, this solution is returned; otherwise, the solution before Relocate is not modified and is returned as the final solution.

An important question is how many customers that should be considered at the beginning of the algorithm. Initialisation starts by selecting randomly half of the customers. Then, Divide is applied to this set in order to determine the best division in trips. If this division has a negative Cost, meaning it is worthwhile for the vehicle to be used for this tour, an initial solution is found and the local search iterations can start. If this is not the case, half of the customers of this set is randomly removed and Divide is applied again, until a solution with a negative Cost is found.

This is a very fast and straightforward way to find a feasible solution to start from. Since the quality of the initial solution is not crucial in finding a high quality solution at the end of the algorithm, it is important not to lose calculation time in this step.

In order to decrease Cost, a good strategy is required to add extra customers to the current set of customers. That is exactly what the local search heuristic will do. One by one, all non-visited customers are considered for insertion and the best one, decreasing Cost most, is inserted. Then again, all non-visited customers are considered until no more customers can be inserted.

This local search heuristic alternates between two ways to look for the best non-visited customer: Insert and Divide. When applying Insert, the customer is added to a given solution and the division in trips is not changed. When Divide is applied, the customer is added to the set of customers of the current solution and the division in trips is optimised for the new set of customers. The most important advantage of this alternation will appear to be that it saves two third of the computation time. This is illustrated in Section 5.4.

This local search heuristic is designed in a completely different way than it was designed by Zhong and Aghezzaf (2012) in their ILS algorithm. They use a best-improvement local search strategy, considering inserting, removing and/or relocating customers in a straightforward way.

A good balance between intensification and diversification is essential for the performance of any metaheuristic. The perturbation procedure plays an important role in finding this balance. Perturbation will remove a number Nr of subsequent customers from the current solution, starting at “position” Pos. In order to determine this position (and the customers to remove), all visited customers are considered to be in one sequence: first the customers of trip 1, then the customers of trip 2 and so on. Starting from position Pos in this sequence, Nr customers are removed. If the end of the sequence is reached, it continues from the beginning, until Nr customers are removed.

The parameter Nr is initialised to one and is increased by one every iteration. If Nr is larger than a given percentage of the customers in the current solution (MaxPercentageToRemove), it is reset to one. This parameter MaxPercentageToRemove is discussed in more detail in Section 6.3. Similarly, Pos is initialised to one and is increased by Nr every iteration. If Pos would be larger than the number of customers in the solution, it is reduced by the number of customers. The updating of these parameters is included in the overview of Algorithm 1.

As a result of this setting of Pos and Nr, a different combination of customers is evaluated every iteration. This is one of the crucial elements in order to obtain high quality solutions. After the perturbation, the local search heuristic is applied to find a new local optimum.

Our diversification is the most important difference with the ILS implementation of Zhong and Aghezzaf (2012). We have a much stronger diversification since we remove a changing number of customers in the diversification phase of each iteration while they only relocate customers by swapping pairs of customers from different tours.

The acceptance criterion is also important to find a good balance between diversification and intensification of the search (Lourenço et al., 2010). With the “random walk” acceptance criterion, the search always continues from the current solution, regardless its Cost, leading to more diversification. With the “better” criterion, the search always continues from the best solution (BestFound), thus only “accepting” better solutions, leading to more intensification.

Our algorithm uses the random walk acceptance criterion, but after a certain number of iterations without improvement, it starts again from the best solution. This “certain number of iterations” is implemented in a very specific way in this case. The first number of iterations after which to return to the best solution is set equal to Count (this parameter is discussed in more detail in Section 6.3). The second number of iterations after which to return to the best solution is equal to the previous number of iterations plus two times Count. The third number is equal to the previous number plus three times Count, etc. When Count is equal to 5, for instance, the search will return to the best solution when the number of iterations without improvement equals 5 (=0+1*5), 15 (=5+2*5), 30(=15+3*5), 50(=30+4*5), 75(=50+5*5), etc.

This means the gap between two returns to the best solution increases with the size of Count. As a result, the algorithm is able to spend enough effort to further improve the best found solution. If the number of iterations without improvement increases, the algorithm can spend more and more time on diversification in order to improve the current solution.

The algorithm stops when the number of subsequent iterations without improvement (NrOfIterNoImprovement) reaches the value of MaxIterNoImprovement. This is one of the three parameters of this algorithm and will be discussed in more detail in Section 6.3.

Based on our design process and experiments, we concluded that determining a suitable selection of customers has a higher impact on the quality of the final results than whether or not the CVRP is solved heuristically or to optimality, or whether or not the CVRP solution or the SV-CIRP solution is used. Therefore, our solution algorithm focuses first on determining a suitable selection of customers.

However, when for a given instance all customers can easily be selected and Teoq is larger than Tmax, a great deal of the algorithm’s search effort should go to determining how all customers can be divided in trips. This will be done by OrderAll. The primary goal of OrderAll is to balance the demand rate over the different trips and only then to reduce the total travel time. This leads to a lower maximal demand rate and thus a higher Tmax (closer to Teoq) and a lower Cost. In each iteration of OrderAll, a CVRP is solved as described in Section 5.1. However, the maximal demand rate per trip, corresponding to the vehicle capacity of the CVRP, is decreased by one percent each iteration. For a given iteration, if no feasible solution is found or Teoq becomes shorter than Tmax, reducing the maximal demand rate is no longer useful and OrderAll is stopped. This step by step reduction of the demand rate forces the CVRP to better spread the demand rate over the different trips. The result is an ideal balance between the maximal demand rate per trip and the total travel time, from a Cost point of view.


                        OrderAll is integrated in the ILS structure in two different ways: when after the stopping criterion, the final solution contains all customers, OrderAll is applied; furthermore, the calculation time of the whole algorithm can be reduced by avoiding a high number of iterations which would all lead to almost the same solution visiting all customers. Therefore, when each of the last three best found solutions (BestFound) visits all customers, the regular iterations are stopped, OrderAll is applied and the algorithm ends.

@&#EXPERIMENTAL RESULTS@&#

These experimental results are based on five sets of ten SV-CIRP benchmark instances. Set 1 is described in Aghezzaf et al. (2012) and Zhong and Aghezzaf (2012), Set 2 is described in the PhD dissertation of Zhong (2012) and Sets 3, 4 and 5 are described in Zhong and Aghezzaf (2012). We made all sets available here: http://www.mech.kuleuven.be/en/cib/op. Set 1 consists of 10 small instances with only 15 customers. For these instances, the optimal results as well as the heuristic results are presented in Aghezzaf et al. (2012) and Zhong and Aghezzaf (2012), respectively. Set 2 consists of 20 customers and results are presented in the PhD dissertation of Zhong (2012). Set 3 contains instances of 25 customers while Sets 4 and 5 contain between 30 and 67 customers. For these three sets only heuristic results are available (Zhong and Aghezzaf, 2012). All instances are constructed using a similar method. The fact that customers are assigned a higher score when they are located further from the depot and/or have higher inventory costs, makes the instances more challenging. More details about these benchmark instances can be found in the above mentioned papers. The available exact and heuristic results will be used in the tables below to evaluate the performance of our ILS algorithm.

There are instances with a higher number of customers for similar (inventory) routing problems, but, to the best of our knowledge, none of these contain all the necessary data to be used as SV-CIRP instances and certainly no benchmark SV-CIRP solutions are available for these instances.

@&#RESULTS@&#

Our ILS algorithm was coded in Java and all experiments were executed on a Dell Latitude E5410 notebook, with Intel Core i5 2.40gigahertz processor and 4.00gigabytes of RAM. The exact algorithm used to solve the instances of Set 1, ran on a DELL PC with AMD(R) Athlon 64×2 Core Processor 5600+, 2.81gigahertz, 2.0gigabytes RAM (Aghezzaf et al., 2012). The results for Set 2 were obtained on a Dell PC with a Pentium 4 CPU, 3.00gigahertz processor with 1.0gigabytes RAM (Zhong, 2012). The solution approaches used to obtain the LS or ILS results for Sets 1, 3, 4 and 5 were implemented in MATLABR2009a 7.8.0 and all instances are tested on a HP PC with Intel Core(TM)2 Quad CPU Q9300, 2.50gigahertz processor with 4.0gigabytes RAM (Zhong and Aghezzaf, 2012).

The results are presented, per set, in Tables 1–5
                        
                        
                        
                        
                        . The first column of each table gives the name of the instance, the next five columns present the benchmark results from the literature and the last three columns contain the results for our ILS algorithm. For each instance, the results from the literature give first the best known Cost (CostBestKnown
                        ) and the required computation time to obtain this result in seconds. Then, in the next three columns, there are the Cost of another algorithm from the literature (CostAlgorithm
                        ), the gap between this result and the best known result and the computation time of this technique. The last three columns show the Cost of our ILS algorithm, the gap between our result and the best known result and the computation time of our algorithm. All gaps are calculated in this way:
                           
                              (8)
                              
                                 Gap
                                 =
                                 100
                                 ∗
                                 
                                    
                                       (
                                       
                                          
                                             Cost
                                          
                                          
                                             BestKnown
                                          
                                       
                                       -
                                       
                                          
                                             Cost
                                          
                                          
                                             Algorithm
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             Cost
                                          
                                          
                                             BestKnown
                                          
                                       
                                    
                                 
                                 %
                              
                           
                        
                     

The last two rows of each table present the average and maximal gap and computation time over all instances.

It should be noted that the reported Cost will always be negative since the sum of the collected rewards, i.e. the only term with a negative sign in the objective function (see Eq. (1)) is greater than the sum of all the costs considered. An alternative for minimising costs would be to maximise total profit and to report the same results with a positive sign. However, we decided to follow the way results are presented in previous research (Aghezzaf et al., 2012; Zhong, 2012; Zhong and Aghezzaf, 2012).

In Table 1, the best known results are obtained by an exact technique and are thus optimal solutions (Aghezzaf et al., 2012). The results in columns 4–6 are obtained by the ILS heuristic of Zhong and Aghezzaf (2012). For these small instances, our ILS approach obtains the optimal solution for each instance in less than 2seconds of calculation time per instance.

In Table 2, the best known results are obtained by the Steepest Descent Hybrid Algorithm (SDHA) of Zhong (2012) and the other technique presented is the same ILS heuristic of Zhong and Aghezzaf (2012) as in Table 1. According to Zhong (2012), the SDHA should be an algorithm that obtains optimal solutions, but we obtain a better Cost for each instance with an average improvement of 10%. After an extra verification of the feasibility of our solutions, we can conclude that the solutions of Zhong (2012) are far from optimal.

As was also the case for Set 1, our algorithm clearly outperforms the ILS of Zhong and Aghezzaf (2012) for Set 2, both in result, on average 19% better, and computation time, around 50 times faster.

For Tables 3–5, the best known results are obtained by the ILS heuristic of Zhong and Aghezzaf (2012). The alternative technique for Table 3 is an improvement heuristic based on insertions (BR-INH) (Aghezzaf et al., 2012). Both techniques obtain almost the same results. The ILS of Zhong and Aghezzaf obtains on average a 0.60% lower Cost, but takes ten times more computation time. Our ILS performs almost the same as the improvement heuristic, both in quality of results and computation time. However, it performs on average 0.67% worse than the ILS of Zhong and Aghezzaf and is around five times faster. For this set, the best known solution could only be improved for instances A25-4 and A25-8. We will discuss these results in more detail, after the results for Sets 4 and 5.

In Tables 4 and 5, the alternative technique is a simple and fast local search algorithm (Zhong and Aghezzaf, 2012). The Cost obtained by our ILS technique is on average 32.71% and 26.22% lower than the Cost obtained by the ILS of Zhong and Aghezzaf (2012) for Sets 4 and 5 respectively. For each instance, a new best known solution is found. Our approach is also around 8–10 times faster. Compared to the LS of Zhong and Aghezzaf (2012), our Cost is 58.22% and 47.78% lower respectively, but it is significantly slower.

Our ILS algorithm clearly outperforms the best technique currently available (the ILS of Zhong and Aghezzaf (2012)) on all sets of instances, except for the instances of Set 3. For five of these instances, the ILS of Zhong and Aghezzaf (2012) performs better than our ILS. For three instances, both procedures reach the same results and for two instances our ILS performs better. When analysing these ten instances, it appeared to us that these instances have a very high vehicle speed compared to the demand rate, the vehicle cost and the inventory costs. In other words, it is very easy (and worthwhile) to visit all customers in these instances. The only decision that needs to be made is how these customers should be divided in trips in order to optimise the cycle time and the total cost; no selection is required. The ILS of Zhong and Aghezzaf (2012) focuses much more on that aspect and succeeds in obtaining a slightly better division in trips than our ILS, leading to results that are on average 0.67% better. Nevertheless, for two instances of Set 3, our ILS obtains new best known solutions. In both cases the new best known solution contains 24 of the 25 customers, i.e. not all the customers. In order to further improve the performance of our algorithm on this special kind of instances, a better solution technique to solve the CVRP in each iteration of OrderAll should be implemented.

When considering all 50 instances, our ILS obtains on average a Cost that is 16.04% better than the Cost obtained by the ILS algorithm of Zhong and Aghezzaf (2012), and it is significantly faster. 32 new best known solutions are found. For each of these instances, the selected customers divided in trips are detailed in Table A of Appendix A. The quality improvement and the computation time reduction are the most noticeable for the larger instances of Set 4 and Set 5. According to us, the main reason we outperform the ILS algorithm of Zhong and Aghezzaf (2012) is our stronger diversification during the search process. We remove a changing number of customers in each diversification phase while Zhong and Aghezzaf (2012) only relocate customers by swapping pairs of customers from different tours. Furthermore, we exploited some typical characteristics of the SV-CIRP, as discussed in Section 4.

The algorithm uses three parameters that need to be set:
                           
                              –
                              
                                 MaxPercentageToRemove: this parameter sets the maximum percentage of customers that can be removed during each perturbation of the solution (see Section 5.6.);


                                 Count: this parameter is used when determining the number of iterations without improvement after which the search process returns to the best known solution (see Section 5.7);


                                 MaxIterNoImprovement: this parameter is used in the stopping criterion. If the number of subsequent iterations without improvement reaches MaxIterNoImprovement, the algorithm stops (see Section 5.8).


                        Table 6
                         presents for each parameter the values that were considered.

Based on a random selection of 10 of the 50 benchmark instances, all combinations of the parameter settings were tested. Based on a trade-off between calculation time and solution quality, the following setting was selected and used in the above mentioned experiments: MaxPercentageToRemove
                        =75, Count
                        =1 and MaxIterNoImprovement
                        =200.

In order to illustrate the sensitivity of the selected parameters, we solved Set 5 with slightly modified values for each parameter. In Table 7
                         we present the average gap and the computation time for these modified parameter settings, indicated in bold. The first row of values presents the above mentioned results (see Table 5) of the original parameter setting. The second and third rows present the results when MaxPercentageToRemove is decreased or increased. The two following rows show the results for alternative values for Count and the last two rows for a higher and lower value of MaxIterNoImprovement.

If we focus on the third parameter, decreasing MaxIterNoImprovement significantly reduces the computation time, from 221seconds to 98seconds on average, but also reduces the quality of the results, with around 3%. Increasing the parameter increases the computation time, from 221seconds to 291seconds, but not the quality of the results. Changing the other parameters only for this set of instances could slightly improve the quality of the results and decrease the computation time for this set. However, the most important conclusion from this table is that the performance of the algorithm is not sensitive to small changes in the parameter values. This is an important characteristic, since it illustrates that it will not be necessary to spend a lot of time on fine tuning the parameters to their optimal value, when using the algorithm in practice.

In this section, we illustrate the impact of the different building blocks and some design decisions on the performance of the algorithm. Different versions of the algorithm are used to solve Set 5 and the difference in the average gap and/or the computation time indicates the effect of a certain design decision. We will refer to these versions following the structure of Section 5.

Currently, no local search is added to the Clarke and Wright Savings Algorithm in order to improve the CVRP solution (see Section 5.1). We considered a relocate move, trying to move each customer to one of the other trips in order to reduce the total travel time. However, when this relocate move is added to the algorithm, the computation time increases by 50%, since the CVRP is solved many times each iteration, and the quality of the results is almost the same (0.3% worse).

In order to illustrate the importance of the initialisation phase (see Section 5.4.), two alternative versions of the algorithm are implemented. One of these versions stops after the current initialisation phase. The results for this version indicate that the results are 73% worse by the initialisation phase alone. The other one does not randomly select half of the customers in the initialisation phase, but it selects the customers based on this ratio:
                           
                              (9)
                              
                                 Ratio
                                 
                                 of
                                 
                                 customer
                                 
                                 i
                                 =
                                 
                                    
                                       
                                          
                                             DistanceToDepot
                                          
                                          
                                             i
                                          
                                       
                                       ∗
                                       
                                          
                                             d
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 N
                              
                           
                        
                     

The customers with the lowest ratio are selected first. The results for this version are 1.22% better than with the random selection. According to us, this is not enough to include this alternative initialisation phase. Especially since for some instances results are better when random selection is used.

On the other side, if we only use Divide in the local search heuristic (see Section 5.5) instead of alternating between Divide and Insert, the improvement of the best known solutions becomes 4% better, but the calculation time triples. If the third phase of Divide, aiming at a better balance of the demand rates per trip, is omitted, the improvement becomes 1.53% smaller. This is the added value of looking for SV-CIRP solutions instead of just looking for CVRP solutions. Clearly, this added value is rather limited for these instances.

We implemented a very particular acceptance criterion (see Section 5.7). In order to illustrate its usefulness, it is interesting to compare our approach with the more typical “better” and “random walk” approaches, explained in Section 5.7. With “better”, the improvement of the best known solutions for these instances is very similar (from 26.22% to 26.41%) and the computation time increases from 221seconds to 286seconds. With “random walk” the improvement decreases to 18.71% and the computation time has been halved.

In Section 5.9, OrderAll is introduced for instances where all customers can easily be visited. Therefore, OrderAll will only be used here for the instances of Set 3. When we solve these instances without using OrderAll, the gap with the best known solutions increases from 0.67% to 3.57% and the average computation time goes from 28seconds to 49seconds.

In this paper, an Iterated Local Search (ILS) metaheuristic to deal with the Single-Vehicle Cyclic Inventory Routing Problem (SV-CIRP) is presented. The SV-CIRP belongs to the class of inventory routing problems in which, besides distribution costs, also inventory and handling costs at the customers are considered. One of the characteristics that makes this a very challenging optimisation problem is the fact that the single vehicle can make multiple trips. As a result, not only a selection of customers needs to be made, but the selected customers should also be divided in trips in an optimal way. We first present a number of non-evident problem characteristics, which we exploited in order to decrease the computation time and increase the quality of the results. These characteristics have been considered while we developed our ILS approach. A particular diversification strategy allows to obtain a very good selection of customers and to minimise costs.

The experimental results, based on 50 benchmark instances of variable sizes, show that our algorithm outperforms the existing solution approaches. Only for five instances, in which all customers can easily be visited, our algorithm is outperformed by the ILS algorithm of Zhong and Aghezzaf (2012). On average, our ILS improves the results of Zhong and Aghezzaf by 16.04% and 32 new best known solutions are found and reported in detail. For the ten smallest instances of only 15 customers, our algorithm finds the optimal solution in 2seconds on average. For the instances with 20 customers, we showed that the so-called optimal solutions are not optimal. For the instances with 25 customers we discovered the specific characteristic that for almost all instances, it is easy to visit all customers and therefore the solution effort should go to finding an appropriate division in multiple trips. For the twenty largest instances with 30–67 customers, our approach improves the results of the ILS algorithm of Zhong and Aghezzaf (2012) with 29.46% and is eight times faster. We made all benchmark instances available online: http://www.mech.kuleuven.be/en/cib/op.

Moreover, the fact that our implementation of the ILS framework outperforms the implementation by Zhong and Aghezzaf (2012) shows that different implementations of the same framework can lead to significantly different solution algorithms and that the performance obtained by any given framework depends strongly on the specific implementation of that framework. Our local search heuristic is designed in a completely different way than the one designed by Zhong and Aghezzaf (2012). We believe our diversification strategy is the most important difference with their implementation. We focus on removing customers and selecting others during the local search, while they focus on relocating customers. Therefore, this succeeds better in obtaining profitable combinations of customers.

Further experiments illustrate the usefulness of some building blocks of the algorithm and the design decisions. We also show that the performance of the algorithm is not sensitive to small changes in the parameter values.

An obvious but challenging path for further research would be to consider more than one vehicle. In that case, it is important to discuss what would be the best way to model reality. Some questions could be: Do all vehicles need to have the same cycle time? Are split deliveries allowed? Etc. It should not be too difficult to modify our ILS algorithm to deal with multiple vehicles, if all these vehicles need to have the same cycle time and split deliveries are not allowed. Obviously, a local search move that changes customers from one vehicle to another should be developed. If different cycle times and/or split deliveries are allowed, the problem would become significantly more complex.

In order to obtain an even better metaheuristic for the SV-CIRP, it might be useful to try to predict which customers should be part of the optimal solution. However, a customer with a high profit, small distance to the rest of the customers and a low demand rate might have a higher potential, but this does not make it a part of the optimal selection of customers. This characteristic is also present in the orienteering problem and the knapsack problem. Furthermore, it would be interesting to look for upper and lower bounds for this problem or sub-problems: for instance, efficient bounds on the number of trips for a given selection of customers, more bounds on the cycle time, bounds based on the demand rate of customers, etc. On the other hand, our metaheuristic could be used or modified to calculate these bounds in order to speed up exact solution approaches for the SV-CIRP.

See Table A
                     .

@&#REFERENCES@&#

