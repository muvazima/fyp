@&#MAIN-TITLE@&#Auction-based cloud service differentiation with service level objectives

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a new study on service differentiation techniques for general cloud system. Our solution potentially opens new business models for cloud systems in the future, and enables ordinary users to exploit the benefits of clouds.


                        
                        
                           
                           We propose Abacus an auction based approach to cloud system resource allocation and scheduling, with enticing features such as incentive-compatibility, system stability and efficiency.


                        
                        
                           
                           We simplify the auction procedure by allowing the users to skip the utility function when the user is unsure or unaware of the exact utility model of his own repeated jobs.


                        
                        
                           
                           We implement Abacus by modifying the scheduling algorithm in Hadoop, and test it on a large-scale cloud platform. Our experimental results verify the truthfulness of our auction-based mechanism, system efficiency, as well as the accuracy of our utility prediction algorithm.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cloud computing

Service differentiation

Auction

MapReduce

@&#ABSTRACT@&#


               
               
                  The emergence of the cloud computing paradigm has greatly enabled innovative service models, such as Platform as a Service (PaaS), and distributed computing frameworks, such as MapReduce. However, most existing cloud systems fail to distinguish users with different preferences, or jobs of different natures. Consequently, they are unable to provide service differentiation, leading to inefficient allocations of cloud resources. Moreover, contentions on the resources exacerbate this inefficiency, when prioritizing crucial jobs is necessary, but impossible. Motivated by this, we propose Abacus, a generic resource management framework addressing this problem. Abacus interacts with users through an auction mechanism, which allows users to specify their priorities using budgets, and job characteristics via utility functions. Based on this information, Abacus computes the optimal allocation and scheduling of resources. Meanwhile, the auction mechanism in Abacus possesses important properties including incentive compatibility (i.e., the users’ best strategy is to simply bid their true budgets and job utilities) and monotonicity (i.e., users are motivated to increase their budgets in order to receive better services). In addition, when the user is unclear about her utility function, Abacus automatically learns this function based on statistics of her previous jobs. Extensive experiments, running Hadoop on a private cluster and Amazon EC2, demonstrate the high performance and other desirable properties of Abacus.
               
            

@&#INTRODUCTION@&#

Cloud computing is a cost-effective paradigm for both the cloud providers and the users. The providers benefit by effectively multiplexing dynamic user demands of various computing resources, e.g., CPU, storage, bandwidth, etc., through virtualization techniques. Meanwhile, the users are liberated from large capital outlays in hardware deployment and maintenance. Successful cloud models include Infrastructure as a Service (e.g., Amazon’s EC2), and data-intensive distributed computing paradigm (e.g., Map-Reduce), both of which are well adopted for a wide spectrum of web services and data management tasks [13,15].

Cloud systems can be categorized into private clouds, which are used exclusively by one organization, and public ones, which rent out their computational capacities to customers. For private clouds, one of the most important objectives is efficiency, meaning that the overall utility derived from the jobs executed with the limited cloud resources. Although public clouds might put profitability before efficiency, both objectives are often aligned and achieved by serving the most valued jobs under resource competition. In order to maximize efficiency, jobs should be differentiated based on their characteristics, including the utilities they generate and the distinct resources they require. For instance, computation-intensive jobs may need powerful CPUs more than other resources, whereas bandwidth is often the most important resource for delay-sensitive applications. Intuitively, resources should be allocated to jobs of high importance, and to jobs that need them the most. Existing cloud systems generally do not provide adequate capability for such service differentiation. In particular, private clouds mainly use simple resource allocation strategies, such as first-in-first-out and fair-share. Public clouds essentially differentiate users based on the amount of money they pay for each type of resources. For instance, Amazon EC2 bundles resources into virtual machines (VMs), and each type of VM has its unique configuration and unit-time price. Based on these prices and the status of their applications, the users decide by themselves the type and number of VM-hours to purchase. Moreover, such prices for computational resources in public clouds often fluctuate continuously, forcing users to monitor these prices and adjust their VM portfolios accordingly, if they want to maximize overall utility within budget limits.

While the above pricing scheme can be seen as a kind of manual service differentiation, to our knowledge, currently there is no solution for automatic service differentiation. Providing this functionality is challenging in several aspects. First, only users (possibly) know the utilities and resource usage patterns of their own jobs; hence, the cloud system needs an effective way to obtain this information from the users. Second, an incentive compatible mechanism is needed to prevent any user from misreporting information so as to increase its own utility, as this may hurt the performance of other jobs as well the overall utility of the entire cloud. Third, realizing an abstract service differentiation solution on a real cloud system is non-trivial, as the implementation must work seamlessly with the existing resource allocation and scheduling modules.

Facing these challenges, we propose a novel cloud resource allocation framework called Abacus, which enables service differentiation for clouds. Abacus acquires information on users’ job characteristics through a novel auction mechanism. Resources are then dynamically allocated according to the auction results and the availability of each type of resources. Abacus’ auction mechanism is incentive-compatible, meaning that every user’s dominating strategy is to simply bid its true job characteristics. This also implies that the auction is stable, i.e., no user can benefit from unilateral bid changes. These properties ensure that as long as a user’s job characteristics remain the same, there is no need to monitor the auction or to change bids. In this aspect, Abacus is much easier to use compared to the price-based service differentiation as in Amazon EC2. Further, the auction is monotonic, which guarantees fairness in the sense that users paying more for a type of resource are always allocated higher quantities of it. Finally, Abacus is efficient, which achieves high overall system utility under the above constraints, as confirmed by our experimental evaluations.

Abacus can be used in various cloud systems, including public and privacy ones, and clouds running on different platforms. To demonstrate the practical impact of Abacus, we implement it on top of Hadoop, and evaluate its effectiveness and efficiency using Map-Reduce workloads. To further improve the usability of Abacus, especially for cloud system users without clear knowledge on the utility model of their own repeated jobs, we extend our standard auction mechanism to enable users to submit bids with only budget information. After running the jobs for a number of rounds under default utility functions, the utility prediction component is capable of recovering the true utility function, using regression techniques. Experiments using a large-scale cluster confirm that Abacus successfully achieves high overall utility, high performance, and all the designed desirable properties.

The main contributions of the paper are listed below
                        
                           •
                           We present a new study on service differentiation techniques for general cloud system. Our solution potentially opens new business models for cloud systems in the future, and enables ordinary users to exploit the benefits of clouds.

We propose Abacus, an auction based approach to cloud system resource allocation and scheduling, with enticing features such as incentive-compatibility, system stability and system efficiency.

We simplify the auction procedure by allowing the users to skip the utility function when the user is unsure or unaware of the exact utility model of his own repeated jobs.

We implement Abacus by modifying the scheduling algorithm in Hadoop, and test it on a large-scale cloud platform. Our experimental results verify the truthfulness of our auction-based mechanism, system efficiency, as well as the accuracy of our utility prediction algorithm.

A preliminary version of Abacus appears in [41]. The main difference between [41] and the full version is that the former mainly focuses on the Abacus model and its theoretical properties, whereas the latter also presents solutions and results that are crucial for applying Abacus in practice. These include (i) a novel algorithm to handle jobs with Service Level Objectives (SLOs), presented in Section 6, which enables Abacus to support jobs running on cloud systems with performance requirements, e.g. maximum response time, (ii) a large-scale experimental evaluation of Abacus on a public cloud (i.e., Amazon EC2) with real-world workloads, presented in Section 7.2, (iii) performance comparison between Abacus and ARIA [37], a state-of-the-art solution for SLO-based scheduling, also presented in Section 7.2. In addition, the full version provides detailed proofs for our theoretical results on the robustness and soundness of the proposed algorithms.

In the following, Section 2 reviews related work. Section 3 provides problem definition and assumptions. Section 4 details the auction mechanism. Section 5 discusses automatic optimization for users not knowing their own utility functions. Section 6 extends Abacus to handle jobs with Service Level Objective. Section 7 contains an extensive experimental evaluation. Finally, Section 8 concludes the paper.

@&#RELATED WORK@&#

Resource allocation [12,25] and scheduling [17,27] in distributed systems have been extensively studied in the networking community. Most previous work focuses on allocating bandwidth among competing network flows. For instance, fair scheduling algorithms, e.g., Weighted Fair Queueing (WFQ) [17] and Generalized Process Sharing (GPS) [27], achieve a max–min fair 
                        [12] allocation. Service differentiations can be provided via these scheduling schemes, when the priorities of the service classes that the jobs belong to are known to the schedulers. In the context of cloud systems, however, the priority of the jobs are usually not known in advance. Consequently, the above solutions no longer apply. In fact, although cloud computing has received increased attention within both the IT industry [1,3,5] and the research community [10], little work addresses the issue of providing service differentiations to users.

Different allocation algorithms are proposed to better meet the requirements of multiple application running over virtualized/grid environment. Stillwell et al. [31] propose to use yield and stretch as metric on resource allocation and performance, along with optimization strategies to maximize the performance of all applications. Our utility definition is a further generalization of their concepts, and is thus applicable on wider domains. Raicu et al. [29] present a data-aware scheduling method, focusing data-intensive applications with the processing logic separated from the data storage layer. Yang et al. [39] discuss a robust scheduler considering the variance of the computation capacity of the distributed nodes instead of the expected performance. Note that all these works assume static workload during the run-time of the resource utilization.

Hindman et al. [23] propose Mesos, a resource allocation system that manipulates resources in a cloud system among different computation platforms, e.g. Hadoop, HBase and MPI. In Mesos, every platform submits its resource requests to the master node, which then makes offers of the resources to the platforms based on the remaining resources available. Each platform can either accept an offer and the corresponding resources, or reject it in anticipation for a better offer in the future. Unfortunately, Mesos does not support any type of service differentiation. Popa et al. [28] extend Mesos to address bandwidth assignment in cloud systems. Since bandwidth is the major bottleneck for communication-intensive applications, they apply new strategies for bandwidth assignment that ensures both fairness and efficiency. This work does not discuss service differentiation, either. There exist other practical approaches to the resource allocation problem on cloud, e.g. [9,32,43], but without theoretical analysis on the effectiveness in competitive environment.

Regarding application profiling, Urgaonkar et al. [35] utilizes OS kernel-based profiling to model the target applications when running on the VMs. They also show that under-provision the applications brings benefit on overall utilization of the computation resource. Meyer et al. [26] show the possibility of understanding the workflow jobs when they are repeated in the distribution system. We apply similar strategy in utility function estimation, which is much more complicated on computing the expected utility under any resource provisioning.

MapReduce [16] is among the most popular paradigms for data-intensive computation in cloud systems, and its open source implementation Hadoop [2] is commonly used for various applications. Scheduling is a fundamental problem in MapReduce. So far, existing work on MapReduce scheduling focuses mainly on system performance; to our knowledge, no existing scheduling solutions can achieve service differentiation for MapReduce with multiple resource types.

Zaharia et al. [40] propose a scheduler that maintains a queue for jobs requesting particular Map or Reduce nodes. They propose two techniques delay, scheduling and copy-compute, which provide efficiency and fairness in a multi-user environment. Our work is orthogonal to theirs, and can be seen as a meta-scheduler for the MapReduce jobs that achieves service differentiation. In fact, our current implementation of Abacus is based on the Fair Scheduler proposed in [40]. Issard et al. [24] independently propose a scheduling strategy similar to [40]. Their method utilizes the queueing strategy for resource allocation, which is optimized by a max-flow model on tasks from all jobs. Moreover, their scheduler allows users to specify different policies, such as fair sharing with preemption.

Sandholm and Lai [30] attempt to provide service differentiation for MapReduce, based on user priorities and a proportional resource allocation mechanism. Abacus differs from their work in two important aspects. First, Abacus manages multiple types of resources, whereas [30] can only handle one type of resource. Second, unlike [30], Abacus is not limited to MapReduce or any particular cloud computing platform. Finally, Abacus can be parameterized to balance fairness and efficiency of the system. Thus, Abacus can be viewed as a generalization of [30].

Herodotou et al. [21,22] explore the problem of performance estimation, without direct optimization on scheduling algorithm. They derive general models to predict the performance of MapReduce jobs when certain resources are assigned to the job. This model enables the users to choose appropriate amount of resource to purchase before starting the job. Abacus can also solve the problem with a much simpler: the users only need to submit their budgets and the system automatically optimizes the resource allocation for all users.

Recently, auctions have been successfully applied to online keyword advertising. Specifically, each advertiser submits a bidding price for each of her interested keywords. After a user issues a query, the search engine returns the search results, along with a number of ads, which are selected based on the auction results. Existing studies have shown that the revenue of such keyword auctions heavily depends on the auction mechanism [18,36]. This has propelled the research from both economics and computer science communities [7,8,20,26], attempting to identify effective and efficient combinations of computational and economical models. Currently, most keyword advertising systems adopt second-price auction mechanisms, e.g., Vickrey–Clarke–Groves (VCG) [38] and Generalized Second Price (GSP) [36]. Several studies also consider budget constraints for the advertisers, e.g., [11,14,19]. Unfortunately, auction mechanisms designed for online advertising are not directly applicable to cloud resource allocation, for several reasons. First, a user needs cloud resources only when it has jobs to run. Hence, traditional fixed assignment strategy may lead to waste of resources, when a user holding resources does not have jobs to use them. Second, the utility functions in our setting are more complicated than online advertising market. In particular, a job usually requires multiple types of resources. Next we describe the proposed solution Abacus, which solves these problems.

Abacus (Auction-BAsed CloUd System) is a general framework for managing multiple types of system resources. Assume that there are m different types of resources. For each resource type j, there are a finite number of identical units of the resource. In existing cloud systems, the cloud users must buy the resources before starting their jobs. In Abacus, the resource allocation is done on the fly, based on the profiles of the jobs currently running in the system. It is conceptually consistent with the new generation of cloud scheduler, which is expected to allocate resources for heterogenous applications under a unified framework.

Abacus allows each user to submit multiple jobs at any time; when a job finishes, it is automatically removed from Abacus. Similar to existing resource managers, e.g., MapReduce fair scheduler [4] and Spark scheduler [6], whenever there is a change in the set of jobs managed by Abacus (i.e., when a job arrives or finishes), Abacus re-runs the resource allocation module. As we explain soon, resource allocation in Abacus mainly involves an auction algorithm (described in Section 4), which is highly efficient as shown in our experiments in Section 7.1.1. Thus, Abacus can effectively support dynamic job arrivals and completions.

Each job submission Ji
                      consists of two parts, 
                        
                           
                              J
                              i
                           
                           =
                           
                              (
                              
                                 b
                                 i
                              
                              ,
                              
                                 u
                                 i
                              
                              )
                           
                           ,
                        
                      in which bi
                      is the budget the user is willing to pay for the job and ui
                      is a utility function indicating the benefit of the job when the job is allocated with a certain amount of resources. We denote 
                        
                           
                              s
                              i
                           
                           =
                           
                              (
                              
                                 s
                                 
                                    i
                                    1
                                 
                              
                              ,
                              
                                 s
                                 
                                    i
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 s
                                 
                                    i
                                    m
                                 
                              
                              )
                           
                        
                      as the vector of resource allocation probabilities assigned to job Ji
                     , in which each sij
                      is a probability associated with resource j in [0, 1]. The utility of the job Ji
                      is evaluated by the submitted utility function ui
                     (si
                     ). Formally, the utility function ui
                      is a mapping 
                        
                           
                              u
                              i
                           
                           :
                           
                              
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                              m
                           
                           ↦
                           R
                        
                     . In this paper, we focus on utility functions in the form of sum of non-decreasing concave functions, i.e. 
                        
                           
                              u
                              i
                           
                           
                              (
                              
                                 s
                                 i
                              
                              )
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              g
                              j
                           
                           
                              (
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              )
                           
                           ,
                        
                      where each gj
                     (sij
                     ) is non-decreasing and concave.

To better illustrate the concept of utility functions, we present two concrete examples. One is sum of linear utility functions. Given a non-negative weight wj
                      for each resource type j, a utility function takes the form 
                        
                           
                              g
                              j
                           
                           
                              (
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              )
                           
                           =
                           
                              w
                              j
                           
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                     . The overall utility of the job is then the weighted sum on the resources assigned to job Ji
                     , i.e., 
                        
                           
                              u
                              i
                           
                           
                              (
                              
                                 s
                                 i
                              
                              )
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              w
                              j
                           
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                     . Linear utility function is suitable for computation models with substitutable resource.

                        Example 1. Web service
                        in Amazon EC2, the user may want to find virtual machines with large amounts of main memory to run his web service. The service is still usable, if EC2 assigns the user with machines with small memory, rendering a lower level of service quality. Therefore, the utility function on EC2 can be written as a linear utility function, with sij
                            as the probability of getting VM of type j and wj
                            being performance of VM of type j running the web service. The job gains positive utility, even when there is no resource assigned on certain type, i.e. ui
                           (si
                           ) > 0 even if 
                              
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 0
                              
                            for some j.

Another important class of functions that satisfy our requirements is logscale utility functions of them form 
                        
                           
                              g
                              j
                           
                           
                              (
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              )
                           
                           =
                           
                              w
                              j
                           
                           log
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                     . The overall utility of a job is then 
                        
                           
                              u
                              i
                           
                           
                              (
                              
                                 s
                                 i
                              
                              )
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              w
                              j
                           
                           log
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                     . The logscale utility function differs from the linear utility function in that the former returns negative infinity if any 
                        
                           
                              s
                              
                                 i
                                 j
                              
                           
                           =
                           0
                        
                     . Thus, the logscale utility function is a better model for jobs that require all types of computation resources.

                        Example 2
                        
                           MapReduce: in MapReduce, each job is processed by two types of operators, i.e. map and reduce, with specified number of required resources on each of the operators. The job cannot be finished if the system does not allow the job to use either type of the operators. The utility of a MapReduce job is the reverse of the running time, i.e. the shorter completion time the better utility. In this utility model, s
                           
                              i1 and s
                           
                              i2 are the probability of getting map and reduce operators during job running, and w
                           1 and w
                           2 indicate computation workloads of map and reduce tasks. It is thus more appropriate to model MapReduce jobs using log-scale utility function, with the Map and Reduce operators as two types of resources.

Note that the results in this paper are valid for both linear and logscale utility functions, and, in general, any utility function satisfying the condition of sum of non-decreasing concave functions.

In both of the examples above, cloud service providers currently only support direct purchase of computation resource, e.g. machine-hours, to run their applications. By employing Abacus, the user only submits his job Ji
                      to Abacus, and Abacus completely handles the resource allocation on behalf of the active users in the system. The major design goal of the auction-based scheduling strategy used in Abacus is to prioritize the jobs, when a large number of jobs are competing for the limited computation resource.

In particular, all of the current jobs are kept in the runtime scheduler in Abacus. Assume that there are n concurrent jobs running in the system with profiles 
                        
                           {
                           
                              J
                              1
                           
                           ,
                           
                              J
                              2
                           
                           ,
                           …
                           ,
                           
                              J
                              i
                           
                           ,
                           …
                           ,
                           
                              J
                              n
                           
                           }
                           ,
                        
                      Abacus calculates the resource assignment vector si
                      for each Ji
                     . There are m resource request queues maintained in Abacus. Each queue Qj
                      stores the running jobs currently waiting for the resource of type j. Given the assignment vectors, 
                        
                           {
                           
                              s
                              1
                           
                           ,
                           …
                           ,
                           
                              s
                              i
                           
                           ,
                           …
                           ,
                           
                              s
                              n
                           
                           }
                           ,
                        
                      when a particular resource of type j is available for a new task, Abacus assigns the resource to job Ji
                      with probability sij
                     . It is important to emphasize that tasks could run independently with a single unit of resource. Therefore, there is no deadlock in the system, in which some jobs with low priority are starving when waiting for other jobs.

There are two important components in Abacus, Auctioneer and Scheduler. Fig. 1
                      presents the relationship between these components, in the context of the MapReduce framework. The auctioneer is responsible for the scheduling probability assignment. When jobs are added or removed from the system, the auctioneer recalculates the probability assignment vectors for the scheduler on all types of resources. To support jobs in MapReduce, there are two queues for map nodes and reduce nodes respectively. Given the probabilities derived by the auctioneer, the scheduler selects the next job waiting for certain resource according to the probabilities. This selection procedure runs again when one of the task finishes the computation and returns the resource to the scheduler.

In our example, there is an idle map node. The scheduling component thus picks up a job among {J
                     1, J
                     2, J
                     3, J
                     6} to run a new map task on the idle node. When the cloud system finishes a job Ji
                     , it charges the user according to his bidding price/budget bi
                     . Abacus is expected to provide better services, i.e., more computation resources for a job, if its bidding budget is higher. This mainly relies on the auction mechanism employed by the auctioneer. Unlike existing solutions on dynamic resource assignment, e.g., Amazon EC2 and Mesos [23], Abacus emphasizes the economic effects on the resource allocation. Instead of considering only the requirements from the jobs, the system balances between the system efficiency and fairness. Generally speaking, users with higher budget is given higher priority in job running, while users with low budget remains active in the system without starving.

Recall from Section 3 that every user submits his job along with profile Ji
                        . Assume that 
                           B
                         is the domain consisting of all valid job submissions. Our auction algorithm calculates an assignment matrix, indicating the priority of job Ji
                         with respect to resource of type j, for every pair of i and j, i.e. 
                           
                              S
                              =
                              
                                 (
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 )
                              
                           
                         of size n × m. In this matrix, every sij
                         is a non-negative real number such that 
                           
                              
                                 ∑
                                 i
                              
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              =
                              1
                           
                         for every resource type j. We use 
                           S
                         to denote the domain of all matrices meeting these constraints. Based on these definitions, the auction mechanism is a function M mapping from the domain of job profiles to the assignment matrix domain, i.e. 
                           
                              M
                              :
                              
                                 B
                                 n
                              
                              ↦
                              S
                           
                        .

In Fig. 2
                        
                        , we present an example auction with three jobs running on a Hadoop system. The profile of job J
                        1 is ($100, 
                           
                              
                                 u
                                 1
                              
                              
                                 (
                                 x
                                 ,
                                 y
                                 )
                              
                              =
                              3
                              x
                              +
                              2
                              y
                           
                        ). where x and y denote the number of map and reduce nodes, respectively. Similarly, jobs J
                        2 and J
                        3 are associated with different budgets and other linear utility functions. Based on the specific auction mechanism, the auction component outputs an assignment matrix on the right side of the figure. The job J
                        1, for example, has probabilities 
                           
                              
                                 s
                                 11
                              
                              =
                              0.310
                           
                         and 
                           
                              
                                 s
                                 12
                              
                              =
                              0.236
                           
                         to get map nodes and reduce nodes, respectively. An interesting observation is that J
                        3 gains more resources on reduce nodes than J
                        2, even though its overall budget is smaller. This is because the system understands that J
                        3’s job utility depends on reduce resource more than J
                        2 does, which is implicitly expressed in J
                        3’s utility function 
                           
                              
                                 u
                                 3
                              
                              
                                 (
                                 x
                                 ,
                                 y
                                 )
                              
                              =
                              2
                              x
                              +
                              4
                              y
                           
                        .

To compute the assignment matrix, the auction component virtually partitions the budget bi
                         of job Ji
                         into small sub-budgets, i.e. 
                           
                              {
                              
                                 b
                                 
                                    i
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 b
                                 
                                    i
                                    m
                                 
                              
                              }
                              ,
                           
                         such that 
                           
                              
                                 ∑
                                 j
                              
                              
                                 b
                                 
                                    i
                                    j
                                 
                              
                              =
                              
                                 b
                                 i
                              
                           
                        . Each sub-budget bij
                         is part of bi
                         for job Ji
                         to spend on resource j. Given the virtual partitions on all jobs in the system, the probability of job Ji
                         on resource j is calculated based on the following equation.

                           
                              (1)
                              
                                 
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             (
                                             
                                                b
                                                
                                                   i
                                                   j
                                                
                                             
                                             )
                                          
                                          α
                                       
                                       
                                          
                                             ∑
                                             
                                                l
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             
                                                (
                                                
                                                   b
                                                   
                                                      l
                                                      j
                                                   
                                                
                                                )
                                             
                                             α
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             (
                                             
                                                b
                                                
                                                   i
                                                   j
                                                
                                             
                                             )
                                          
                                          α
                                       
                                       
                                          
                                             
                                                (
                                                
                                                   b
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                )
                                             
                                             α
                                          
                                          +
                                          
                                             ∑
                                             
                                                l
                                                ≠
                                                i
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   b
                                                   
                                                      l
                                                      j
                                                   
                                                
                                                )
                                             
                                             α
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Here, α is a non-negative scaling factor, balancing the priorities of high-budget jobs and fairness between jobs. When 
                           
                              α
                              =
                              0
                              ,
                           
                         the assignment probability is uniform on all users, i.e. 
                           
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              =
                              1
                              /
                              n
                           
                         for any i and j, regardless of the budgets of the jobs. When α approaches infinity, the job with the highest budget dominates the probability and all other jobs are given almost zero resource of type j. In Abacus, however, we only allow α to be a real number between 0 and 1, to ensure the following important property.

                           Lemma 1
                           
                              When α ∈ [0, 1], the partial derivative
                              
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                               
                              is a monotonically decreasing function with respect to bij.
                           

Intuitively, the lemma above implies that the marginal utility of a job on a certain resource shrinks when more sub-budget is devoted to the resource. This property turns out to be crucial in our following analysis.

In Fig. 3, Abacus partitions the budgets based on the jobs in Fig. 2. Abacus helps job J
                        1, for example, to assign $64 and $36 on map and reduce resources respectively. By setting 
                           
                              α
                              =
                              0.5
                              ,
                           
                         we can easily verify the correctness of the final assignment matrix on the right side, with the sub-budgets on all jobs.

Based on the assignment rule, a job Ji
                         prefers to put more sub-budgets on resources that contribute more to its utility function. However, Abacus does not allow the user to manually adjust virtual sub-budgets themselves. Instead, the auctioneer automatically optimizes the sub-budgets for all jobs. Although it is possible to support sub-budget specification by user, it may lead to violations to the desirable properties, e.g. incurring cycling chaos [18]. The details of the analysis will be covered in the rest of this section.

The auction mechanism employed in Abacus aims to find a probability matrix 
                           
                              S
                              =
                              M
                              (
                              
                                 {
                                 
                                    J
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    n
                                 
                                 }
                              
                              )
                           
                         based on our resource allocation mechanism M. In Algorithm 1
                        , we list the pseudocode for the assignment mechanism M. Basically, the algorithm initializes the sub-budgets by evenly partitioning the budget on all resources, and then applies the round-robin optimization for every job Ji
                        . Given the current sub-budgets from all other jobs, the auction mechanism finds a new sub-budget combination 
                           
                              {
                              
                                 b
                                 
                                    i
                                    1
                                 
                                 
                                    (
                                    t
                                    )
                                 
                              
                              ,
                              …
                              ,
                              
                                 b
                                 
                                    i
                                    m
                                 
                                 
                                    (
                                    t
                                    )
                                 
                              
                              }
                           
                         on all resource types in the current round. The algorithm terminates until all jobs agree on their sub-budgets, i.e. there is no change on the sub-budgets in two consecutive iterations.

To calculate the best sub-budgets for a single job Ji
                        , our Algorithm 2
                         utilizes the concave property of the utility function as well as Lemma 1. Specifically, it reassigns the sub-budget 
                           
                              b
                              
                                 i
                                 j
                              
                              ′
                           
                         for job Ji
                        , proportional to 
                           
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                              
                                 s
                                 
                                    i
                                    j
                                 
                              
                              
                                 (
                                 1
                                 −
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 )
                              
                           
                        . The following lemma shows {bij
                        } is the optimal sub-budget maximizing the utility if the sub-budget configuration reaches a fixed point.

                           Lemma 2
                           
                              In 
                              
                                 Algorithm 2
                              
                              ,
                              
                                 
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                       ′
                                    
                                 
                               
                              for all j, only if
                              
                                 
                                    (
                                    
                                       b
                                       
                                          i
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       b
                                       
                                          i
                                          m
                                       
                                    
                                    )
                                 
                               
                              is the optimal sub-budget combination maximizing Ji’s utility.
                           

In Fig. 4, we elaborate the optimization procedure with our running example. In the initial configuration, all jobs evenly partition the budget on map and reduce resources. In the first round of optimization iterations, J
                        1 finds the sub-budgets ($62, $38) on the resources. In the following, jobs J
                        2 and J
                        3 optimize their sub-budgets in order. J
                        1 is allowed to optimize again when the first round of optimization is done. In the new iteration, J
                        1 slightly changes his sub-budgets. The optimization quickly converges when no job can further improve their utility by shifting the budgets among resources. In the theorem below, we theoretically prove the convergence property of the algorithm.

                           Theorem 1
                           
                              
                                 Algorithm 1
                               
                              always terminates after a finite number of iterations, if α is no larger than 0.5.
                           

While the theorem is valid only when α is no larger than 0.5, we tested α values larger than 0.5 and find the convergence is always reached. Moreover, although the theorem does not characterize the convergence rate of the computation process, experimental result in the rest of the paper also verify the fast convergence in terms of the number of iterations. We believe the convergence rate depends not only on the value of α but also on the strong convexity property of the utility function. Based on the proof of Theorem 1, it is obvious that smaller α leads to more significant update on the assignment matrix, and probably faster converge with fewer iteration. These properties are fully evaluated in the experiments, while deeper theoretical investigation are left as future work.

There are some attractive economical features in Abacus, which guarantees that all users fully trust the system and they always prefer to submit their true job profiles. In particular, the mechanism satisfies two properties. First, it is unnecessary for the users to worry about the optimality of the sub-budgets the system calculates for his jobs. It is impossible to gain additional utility for users by submitting sub-budgets for the jobs. Second, the mechanism is incentive compatible. It is a dominating strategy for the users to tell the maximal budget he is willing to pay and the true utility function on his jobs. These properties are proved by the following lemmata and theorems.

                           Lemma 3
                           
                              The user cannot achieve higher utility if he is allowed to modify sub-budgets by himself.
                           

Therefore, it becomes meaningless for the users to submit the sub-budgets based on their own understandings. If this property is not satisfied, the users will be willing to control the sub-budgets by themselves. This potentially leads to trials on different sub-budget strategies and hurts the system efficiency when every user is testing and changing their strategies continuously. A similar phenomenon has been observed in sponsored search market, when the first price auction mechanism was employed a decade ago [18].

                           Lemma 4
                           
                              The utility of a job Ji is monotonic increasing if the user increases its budget bi on the job.
                           


                              If every user has at most one running job at any time, the auction mechanism used in Abacus is incentive-compatible.
                           

The theorem implies that all users will definitely tell the “truth” about their budget and utility function. Recall our running example in Fig. 2. It means that the owner of job J
                        1 maximizes the utility of J
                        1 by submitting current profile. The utility of the job can never be larger if he fakes a wrong utility function or tells a lower budget of the job. When every user has multiple running jobs, however, it remains possible for the user to manipulate the job profiles to achieve higher overall utilities on the jobs.

In practice, it can be difficult for an ordinary user of the cloud system to come up with the exact utility function of her/his jobs. To alleviate the problem, in this section we propose a novel approach that automatically estimates the utility function of a user’s job, given statistics of similar jobs run by the same user in the past. This enables the user to participate in the auction with only her/his budget information. Our estimation is purely based on analysis over the utilities/performance of the jobs running with utility functions assigned by the system. Since the non-decreasing concave function gj
                     (sij
                     ) can be of arbitrary form, we focus on two common classes of functions introduced in Section 3, namely, linear utility functions and logscale utility functions. Functions in either of the classes are uniquely controlled by d weight coefficients 
                        
                           {
                           
                              w
                              1
                           
                           ,
                           
                              w
                              2
                           
                           ,
                           …
                           ,
                           
                              w
                              d
                           
                           }
                           ,
                        
                      i.e. 
                        
                           
                              u
                              i
                           
                           
                              (
                              
                                 s
                                 i
                              
                              )
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              w
                              j
                           
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                      and 
                        
                           
                              u
                              i
                           
                           
                              (
                              
                                 s
                                 i
                              
                              )
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              w
                              j
                           
                           log
                           
                              s
                              
                                 i
                                 j
                              
                           
                        
                     .

Generally speaking, Abacus allows the user to submit the budget only, without the utility function. In such situations, the system automatically completes the bid by assigning a default utility function, e.g. linear utility function with equal weights. The system thus calculates the assignment probabilities based on the bid with the actual budget but possibly wrong utility function. After a few rounds of job or service running, when sufficient statistics on the performance of the jobs are collected, Abacus is capable of deriving the exact utility function.

In Fig. 5, we present an example of the running jobs on two types of resources with three users. Assume that user 1 does not know his exact utility function and the system assign the utility function 
                        
                           
                              u
                              1
                           
                           
                              (
                              x
                              ,
                              y
                              )
                           
                           =
                           x
                           +
                           y
                        
                     . At the beginning, job J
                     11 is started when J
                     21 and J
                     22 are already running. The resource allocation matrix S
                     (1) is calculated based on bids from all three users. With the evolving of the system, different job combinations lead to different resource allocations. It is clear that the job J
                     11 is completed in the system when S
                     (1) is used as the only resource setting during the whole procedure. Job J
                     12 is run in the system under two different settings, i.e. S
                     (4) and S
                     (5). On the other hand, the system records the performance of J
                     11 and J
                     12 and transform to the measurable utility, i.e. u(J
                     11) and u(J
                     12). If the jobs are Map-Reduce processing, for example, the utility could be the inverse of the job response time. If the jobs are web services, as another example, the utility could be the average throughput of the service server. Given the utility measures, the system estimates the utility functions via a system of linear equations:

                        
                           
                              
                                 
                                    
                                       
                                          u
                                          (
                                          
                                             J
                                             11
                                          
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             w
                                             11
                                          
                                          
                                             s
                                             11
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                          +
                                          
                                             w
                                             12
                                          
                                          
                                             s
                                             12
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                          ,
                                       
                                    
                                 
                                 
                                    
                                       
                                          u
                                          (
                                          
                                             J
                                             12
                                          
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             w
                                             11
                                          
                                          
                                             (
                                             γ
                                             
                                                s
                                                11
                                                
                                                   (
                                                   2
                                                   )
                                                
                                             
                                             +
                                             
                                                (
                                                1
                                                −
                                                γ
                                                )
                                             
                                             
                                                s
                                                11
                                                
                                                   (
                                                   3
                                                   )
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          
                                             w
                                             12
                                          
                                          
                                             (
                                             γ
                                             
                                                s
                                                12
                                                
                                                   (
                                                   2
                                                   )
                                                
                                             
                                             +
                                             
                                                (
                                                1
                                                −
                                                γ
                                                )
                                             
                                             
                                                s
                                                12
                                                
                                                   (
                                                   3
                                                   )
                                                
                                             
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

In the equation above, γ denotes the ratio of S
                     (4) takes in the running time of job J
                     12 in the system. Thus, 
                        
                           γ
                           
                              s
                              11
                              
                                 (
                                 2
                                 )
                              
                           
                           +
                           
                              (
                              1
                              −
                              γ
                              )
                           
                           
                              s
                              11
                              
                                 (
                                 3
                                 )
                              
                           
                        
                      denotes the average amount of resource type 1 which job J
                     12 is expected to get. Since there are only two unknown variables in the linear system, we are able to recover the exact values, by calculating the unique solution to w
                     11 and w
                     12. This means that utility measures on m jobs are sufficient to reconstruct the (linear or logscale) utility functions, in which m is the number of resource types. However, due to the performance fluctuation commonly observed in cloud system, this scheme may not return robust estimation of utility function all the time. To improve the robustness of the estimation method, we formalize a regression-based technique as follows.

Assume that Abacus collects the utility measures on k (k ≥ m) repeated jobs from a particular user. Without loss of generality, let 
                        
                           {
                           
                              J
                              
                                 i
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              J
                              
                                 i
                                 k
                              
                           
                           }
                        
                      denote the jobs. We use Average Job Resource to estimate the resource allocated to the jobs when running in Abacus system.

                        Definition 1. Average job resource
                        Regarding a job Jil
                            from user Ui
                           , the Average Job Resource is a vector of length m, i.e. 
                              
                                 
                                    
                                       s
                                       ¯
                                    
                                    
                                       i
                                       l
                                    
                                 
                                 =
                                 
                                    (
                                    
                                       
                                          s
                                          ¯
                                       
                                       
                                          i
                                          l
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          s
                                          ¯
                                       
                                       
                                          i
                                          l
                                          m
                                       
                                    
                                    )
                                 
                                 ,
                              
                            such that 
                              
                                 
                                    s
                                    ¯
                                 
                                 
                                    i
                                    l
                                    j
                                 
                              
                            is the average probability of assigning resource j to job J
                           
                              i1 from the beginning to the completion of the job.

Based on the definitions above, the input to the utility function estimation component includes (1) the utility measures 
                        
                           {
                           u
                           (
                           
                              J
                              
                                 i
                                 1
                              
                           
                           ,
                           …
                           ,
                           u
                           
                              (
                              
                                 J
                                 
                                    i
                                    k
                                 
                              
                              )
                           
                           }
                        
                     ; and (2) the average job resource of the jobs 
                        
                           {
                           
                              
                                 s
                                 ¯
                              
                              
                                 i
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 s
                                 ¯
                              
                              
                                 i
                                 k
                              
                           
                           }
                        
                     . Given such statistic information, we run a regression to find out the optimal weights to minimize the following objective function.

                        
                           (2)
                           
                              
                                 Minimize:
                                 
                                 
                                    ∑
                                    
                                       l
                                       =
                                       1
                                    
                                    k
                                 
                                 
                                    
                                       (
                                       u
                                       
                                          (
                                          
                                             J
                                             
                                                i
                                                l
                                             
                                          
                                          )
                                       
                                       −
                                       
                                          ∑
                                          
                                             r
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          w
                                          
                                             i
                                             l
                                          
                                       
                                       
                                          
                                             s
                                             ¯
                                          
                                          
                                             i
                                             l
                                          
                                       
                                       )
                                    
                                    2
                                 
                              
                           
                        
                     
                  

It is straightforward to verify that the regression formulation is simply linear, which can be easily solved by running standard solution to linear regression. The computation time is cubic, i.e. O(m
                     3), in terms of the number of resource types. Since m is usually not large in real cloud system, the overhead of the utility function estimation is affordable.

So far, we have assumed that the user’s utility for a job can be expressed as a concave function of the allocated resources, regardless of the amount of resources given to the job. In practice, certain types of jobs must be finished within a given timeframe. This means that insufficient resources lead to violation of the deadline, and, consequently, zero utility for the job. Such constraints are usually expressed by service level objectives (SLOs), which are commonly used in cloud services. Although an SLO can be incorporated into the job’s utility function (i.e., the utility remains zero until there are sufficient resources to meet the SLO), such a utility function is no longer concave, which cannot guarantee the convergence and truth-telling properties of the Abacus auction. In this section, we propose an effective scheduling scheme to enforce SLOs within the Abacus framework, while preserving the desirable properties of the Abacus auction described in Section 4.3.

We model SLOs as constraints. Specifically, the user only pays the cloud service for running a job when the job’s SLO is met. The SLO for a job specifies the minimum utility for the job. Formally, a job is now expressed as 
                        
                           
                              J
                              i
                           
                           =
                           
                              (
                              
                                 b
                                 i
                              
                              ,
                              
                                 u
                                 i
                              
                              ,
                              
                                 m
                                 i
                              
                              )
                           
                           ,
                        
                      in which bi
                      and ui
                      follow the original definitions in Section 3, and mi
                      indicates the minimal utility requirement specified in the SLO.

The main idea of the proposed solution is to postpone jobs that cannot possibly meet their SLOs until there are unused system resources. The solution relies on a job utility estimation module, which is capable of returning an accurate estimation on the expected actual utility of a job. For MapReduce jobs, for example, ARIA [37] provides an algorithm outputting completion estimations on the jobs. Mathematically, given any group of jobs 
                        
                           J
                           =
                           {
                           
                              J
                              1
                           
                           ,
                           
                              J
                              2
                           
                           ,
                           …
                           ,
                           
                              J
                              n
                           
                           }
                           ,
                        
                      the job utility estimation module returns the utility assignment 
                        
                           {
                           
                              u
                              1
                           
                           ,
                           
                              u
                              2
                           
                           ,
                           …
                           ,
                           
                              u
                              n
                           
                           }
                        
                      based on the current availability of resources.

Based on this module, we design a variant of Abacus, called SLO-based Abacus, to maximize the profit of the system, while preserving all desirable economic properties of Abacus. There are two steps in SLO-based Abacus. First, we adopt a greedy strategy to find the most prolific job group such that current cloud computation resources are sufficient to meet their SLOs. In this way, we divide all running jobs into two sets, Prolific Pool and Non-Prolific Pool. Second, the framework assigns resources to the jobs in prolific pool by running the standard auction-based Abacus algorithm. If there are unused resources available, the framework randomly picks up a job from non-prolific pool to use the resource. In the following, we prove two important properties of SLO-based Abacus, which ensures that no user is willing to submit a job with a false budget or SLO.

                        Lemma 5
                        
                           A rational user never submits job Ji with incorrect budget
                           
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 ≠
                                 
                                    b
                                    i
                                 
                              
                           
                           .
                        


                           A rational user never submits job Ji with incorrect minimal utility
                           
                              
                                 
                                    m
                                    i
                                    ′
                                 
                                 ≠
                                 
                                    m
                                    i
                                 
                              
                           
                           .
                        

As a conclusion of the theoretical analysis, SLO-based Abacus preserves the truth-telling properties of the original Abacus framework. It is thus applicable to cloud systems processing jobs with minimal utility SLOs. In the experimental section, we will discuss how SLO-based Abacus is used in Hadoop to handle MapReduce jobs with SLOs.

@&#EXPERIMENTS@&#

In this section, we conduct empirical studies on the performance and properties of Abacus in a real cloud system. Section 7.1 reports results of experiments run on a private cloud system, and Section 7.2 presents results of experiments run on public cloud, i.e. Amazon EC2.


                     Abacus on Hadoop: to test the usefulness of Abacus on practical cloud systems, we added a new auction component into Hadoop 0.20, by redesigning the scheduler in Hadoop based on Fair Scheduler 
                     [40]. Basically, our meta scheduler monitors the profiles as well as the submitted budgets of the active users. We regard Map and Reduce nodes as two independent types of resources. When an event of job arrival or departure happens, the auction component recalculates the allocation probabilities for each active job on map nodes and reduce nodes, using our auction mechanism. The probabilities are fed into the low-level Job Pool scheduler [40] to ensure effective resource allocation and scheduling. The source codes of the implementation and installation instructions on Hadoop 0.20 system are available online.
                        1
                     
                     
                        1
                        
                           https://sites.google.com/site/zhangzhenjie/abacus.zip .
                     
                  

We test Abacus on the Epic platform,
                           2
                        
                        
                           2
                           
                              http://www.comp.nus.edu.sg/~epic .
                         a distributed computation cluster deployed at the National University of Singapore. Epic consists of 72 computing nodes. The master node is equipped with a dual-core 2.4 GHz CPU, 48 GB RAM, two 146 GB SAS hard disks and another two 500 GB SAS hard disks. Each slave node has a single-core 2.4 GHz CPU, 8 GB RAM and a 500 GB SATA hard disk. All the nodes used in the cluster are running CentOS 5.5 and Hadoop 0.20.

We first evaluate the auction component. In the experiments, we measure (1) the number of iterations before convergence, given the bids from all of the users; and (2) the total computation time for the resource allocation matrix. To manually control the setup of the bid combination, experiments in this subsection are not run on the Hadoop system. Instead, we independently test the auction component without running the resource allocation on real computation tasks. We repeat each experiment 1,000 times, and report the average measurements as well as 95% quantiles. The default setting of the experiments involves 32 system users, 4 types of resources, and a balancing parameter 
                              
                                 α
                                 =
                                 0.5
                              
                           . The budgets of the users follow an independent and identical uniform distribution in the range [50, 200]. Both linear utility function and logscale utility function are tested. Every weight wj
                            on resource j in the utility functions follows a uniform distribution on range [0.5, 2].


                           Fig. 6
                            shows the average number of iterations of the auction algorithm under different settings. The auction algorithm generally converges very quickly, within 5 iterations in most settings. When there are more users in the auction, as is shown in Fig. 6(a), the convergence rate is accelerated. This is because every user possesses a small fraction of resources in the system, which is not dramatically affected by the iterations. Therefore, the resource allocation quickly reaches a Nash Equilibrium after a few rounds of updates on the resource allocation. When increasing the number of resource types (Fig. 6(b)), the convergence slightly slows down, since it potentially takes more iterations for a specific user to move budgets from certain resources to others before arriving at the optimal portfolio. In Fig. 6(c), we show that the impact of the balancing parameter α is very different on the linear utility and logscale utility functions. For logscale utility functions, the convergence rate remains constant regardless of α. For linear utility functions, the number of iterations almost doubles, when α changes from 0.5 to 0.9. The reason is that the linear utility function tends to give all resources to the user with highest budget, when α is close to 1. This leads to more iterations to gradually move resources towards a few top-tier users with highest budgets. Logscale utility function, on the other hand, is more robust against α, leading to fewer iterations with large α.


                           Fig. 7
                            shows the 95% quantile results for the above experiments; for example, a 95% quantile of 4 means that among the 1,000 runs of the algorithm, 950 (i.e., 95%) runs terminated within 4 iterations. The results exhibit similar trends as the average results shown in Fig. 6. More importantly, observe that the 95% results are close to their corresponding average values, meaning that the auction algorithm consistently converges within a few iterations.


                           Fig. 8
                           
                            evaluates the total computation time of the auction. When increasing the number of active users (Fig. 8(a)) or the number of resource types (Fig. 8(b)), the computation time also increases. The growing computational cost is mainly due to the increasing CPU time on each iteration, which needs to redistribute the probabilities on every pair of user and resource type. However, even when there are 128 active users submitting bids to the auction component, the auction finishes within 7 ms by average, which is negligible. This implies that the proposed auction algorithm can handle a large number of job arrivals or departures.

Next we verify the incentive compatibility property of Abacus on real systems. To do this, we simulated three different users that submit different types of MapReduce jobs. When generating the workload, we assumed that job arrivals of the three users follow three independent Poisson processes with different arrival rates. In order to create jobs that require different utility functions, we carefully controlled the running time of the Map and Reduce tasks. In Table 1
                           , we list the average execution time for the Map and Reduce tasks of the three users. During the simulation, the users keep submitting new jobs to the system for 30 min from the beginning of the experiments. The system stops after finishing all submitted jobs. We use the inverse of job response time as the measure for job utility. The actual utility function is thus proportional to the processing demands on Map and Reduce tasks. Therefore, we simply employ linear utility function 
                              
                                 u
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 
                                    T
                                    m
                                 
                                 x
                                 +
                                 
                                    T
                                    r
                                 
                                 y
                              
                            in our simulations, in which Tm
                            and Tr
                            are proportional to the expected running time for each Map and Reduce task respectively. For user #1, for example, the utility function is 
                              
                                 
                                    u
                                    1
                                 
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 3
                                 x
                                 +
                                 2
                                 y
                              
                           . Although this simple linear model does not fully reflect the coupling relationship between Map and Reduce tasks [33,34], our experimental results imply that it is sufficient to model the job performance when most of the jobs in the system are short jobs.

The most important implication of incentive compatibility is that the users maximize their job efficiency by submitting the maximum affordable budgets and true utility functions. To show this, we vary the budget for user #3 and fix the budgets of the other two users. When the budget of user #3 grows, the efficiency of the jobs from user #3 improves, as shown in Fig. 9(a). The efficiency gains slow down as the amount of budget increases, due to the concavity of the utility function. On the other hand, the performance of the jobs from the other two users decreases, since their bids are weakened when another participant spends more.

Since all jobs employ linear utility functions in our setting, we vary the weights of the utility function u
                           3 for user #3 to evaluate the impact of truthfulness of the utility functions (Fig. 9(b)). Our test covers 5 different ratios of the map to reduce weight. When the ratio is 4:1, for example, the corresponding utility function is 
                              
                                 
                                    u
                                    3
                                 
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 4
                                 x
                                 +
                                 y
                              
                           . As shown in Table 1, the jobs from user #3 take about 60 s on maps and 10 s on reduces. Thus, the true ratio of map to reduce weight is about 6:1. In Fig. 9(b), we present the results on the job efficiency for all three users. The job efficiency for user #3 is maximized when the ratio on weights is 4:1, which is closest to the true ratio of Map running time to Reduce running time. Since the total computation resource is constant, the jobs from other users taking longer to finish when user #3 is reporting his true utility.

In Fig. 9(c), we test the impact of the balancing parameter α on job efficiency. With a small α, Abacus assigns resources to all jobs with almost equal probability, leading to almost identical average job processing time. With larger values of α, Abacus tends to distinguish jobs based on their profiles.

We next focus on the overall system performance instead of individual job response time. We compare Abacus against the popular First-In-First-Out (FIFO) scheduling strategy, and report the total time to finish all jobs. We aim to show that Abacus enables service differentiation with small overhead on the overall performance of the system. Fig. 10
                            shows that Abacus has competitive performance compared to FIFO, with a varying number of users in the resource auction. Note that in this set of experiments, all system parameters are fixed except for the number of users; in particular, the total amount of computational resources is constant in all experiments. According to the results, when the number of users is relatively low (i.e., less than 5), Abacus outperforms FIFO on system overall performance in most settings, due to the clear statement on the utility functions on the jobs: the system is capable of better scheduling the assignment of map and reduce resources to improve overall throughput. When we increase the number of users beyond a certain point (5 in our experiments), resource contention increases with the number of users, which affects the relative performance of Abacus and FIFO. In particular, Abacus involves more context switching than FIFO, since the former needs to balance jobs from different users based on their bids and utility functions, whereas the latter simply executes each incoming job with all available computational resources. Nevertheless, the total completion time of Abacus in these settings is only slightly worse (at most 5% more) compared to FIFO.

In Fig. 10(b), an interesting observation is that the system performs well when all jobs have the same budget, i.e. when user #3’s budget is $100. This is because Abacus works similarly to Fair Scheduler when all users have the same budget/priority. In this case, the system assigns the resources based on the preference information contained in the utility functions, instead of purely based on their budgets.

We also tested the system performance when the users are submitting different job utility functions. Fig. 10(c) shows the impact of user #3 submitting different utility functions. The results again confirm the superiority of Abacus over FIFO. Abacus improves the system performance by about 20%, even when the user is not reporting the true utility functions. The performance gain increases further when the user tells her true utility function.

Finally, we evaluate the effectiveness of the utility function estimation technique described in Section 5. To understand the job utility for a particular user, we record the utilities (i.e., inverse of the running time) of the MapReduce jobs from user #3 in the Hadoop system. These jobs are run by setting different utility functions, as is done in the experiments in Section 7.1.2. The implementation of the estimation algorithm is not included in the published source code package (since it requires non-free libraries), and it is available upon request.

In Fig. 11
                           (a), we plot 20 result utility functions by mapping each function to a 2D point. Each cross denotes a utility function, calculated by running our algorithm with utility measures on 5 jobs from user #3. The coordinates of each cross on each dimension represents the weight of the function on map/the weight on reduce. Another line plotted in the figure represents the true utility function of the user. Each point on the line indicates a utility function, in which the weight for map is 6 times as that for reduce. The functions on the line thus match the actual requirements of the jobs from user #3. As shown in the figure, the estimated utility functions are generally close to the true utility function. The ratios of the weight on map/reduce weight ratio usually falls in the range from 5 to 9 (the true value being 6). Fig. 11(b) reports the variance of the result when varying the number of jobs. Clearly, the variance plunges as the number of jobs increases. Fig. 11(c) shows that all utility function estimations finish within 3 ms, which is negligible.

The experiments in previous subsection are completely run on a private cluster. In this part of the section, we test Abacus in Hadoop on a public cloud system, i.e. Amazon EC2. Since EC2 are purely based on virtualization techniques, the performance of the VMs are less stable than the machines in the private cluster. In particular, we aim to evaluate the Incentive Compatibility and System Efficiency of Abacus on such public cloud with large variety on computation capacity. Note that Auction Efficiency and Utility Function Estimation are not reported in this subsection, since they do not depend on the infrastructure of the underlying cloud system. In particular, we emphasize that the auction algorithm is independently of the underlying cloud platform, and, thus, the convergence and efficiency results presented in Section 7.1.1 also applies to settings in this subsection.

In our experiments on EC2, we rent 15 virtual machines under the category of M1.large. Without otherwise specification, we use all these virtual machines to run our modified version of Hadoop system. The workload we use is different from the jobs introduced in previous subsection. In particular, we follow the workload construction instructions in [34], with slight changes. In Table 2
                        , we list 10 types of MapReduce jobs run by the users in our experiments. The columns of Map and Reduce indicate the number of map tasks and reduces tasks for particular jobs. The table shows that Job #6 and Job #9 are reduce-intensive jobs and all the others are map-intensive jobs. The Wikipedia dataset is downloaded from http://wiki.dbpedia.org/Downloads38.

To generate accurate linear utility functions, we first test the running time of the map and reduce tasks of all jobs. Recall that each of 10 users is associated with a job in the experiments. Therefore, based on the running time estimations, the linear utility function for a user Ui
                            is constructed as 
                              
                                 
                                    u
                                    i
                                 
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 
                                    T
                                    m
                                 
                                 x
                                 +
                                 
                                    T
                                    r
                                 
                                 y
                                 ,
                              
                            in which wx
                            and wy
                            are the total running time of all map and reduce tasks under the job Ji
                           . Moreover, the default budget for each user is $200. Given the utility functions and budgets assigned to the users, we verify the property of incentive compatibility of the Abacus system.

Similar to the experiments on private cluster, we vary the budget of user U
                           3 from $50 to $800, as is shown in Fig. 12
                           
                           (a). We compare the performance of the jobs under Abacus against the performance of the jobs under FIFO. Since all the other users are willing to pay $200 for their jobs, the running time of the jobs under Abacus are significantly higher than that of the jobs under FIFO, when the budget is below $200. A quick reduction on the running time is observed when the budget is raised from $100 to $400. However, the benefit is no longer significant, if we further increase the budget of user U
                           3, mainly due to the marginalization property of the utility function.

The second group of experiment is conducted to test the impact of the utility function. From the result in Fig. 12(b), it is clear that the running time of the jobs from U
                           3 is minimized when the weight ratio Tm
                           /Tr
                            is 4, which is closest to the actual ratio of the total running times of map and reduce tasks of the jobs. It proves that our mechanism encourages the users to submit the bids with actual needs on the resources.

Finally, we evaluate the overall system efficiency by reporting the total running time of all jobs from all users. FIFO is the baseline approach we compare against in this part of the subsection.

These experiments are divided into two groups. In the first group of the experiments, we vary the number of users in the system and the number of virtual machines rented on EC2 at the same time. Therefore, the computational resource increases in proportional to the number of users. Fig. 13(a) shows that Abacus consistently outperforms FIFO, as long as the average resource among all users remains almost the same. It implies that Abacus is an ideal mechanism balancing between fairness and priority.

The second group of the experiments are done in a very different way. We use all 15 virtual machines under all settings with different number of users. The results are presented in Fig. 13(b). When there are less users in the system, the competition over the resource is not high. Abacus is competitive against FIFO, with about 5% margin advantage on the total running time. However, when there are too many users in the system competing for computation resource, the overall running time of the jobs in Abacus becomes longer than that under FIFO. This is basically due to the transition cost incurred by the scheduling method used in Abacus. Particularly, when a high-priority job comes into the system, existing jobs must give up the resource before completing the MapReduce job. Such results show that priority leads to unfair resource allocation and affects the overall performance when the amount of the resource is seriously below the demands from the users.

In Fig. 14
                           , we present the system profits of Abacus and ARIA [37], which is the state-of-the-art solution to Hadoop scheduling on jobs with service level objectives. We test both algorithms with random deadlines assigned to the MapReduce jobs tested in our previous experiments, where the random deadlines follow three different settings: a normal distribution with variance 2, a normal distribution with variance 3 and a uniform distribution in the range [500, 1000]. To vary the workload of the system, we manipulate the number of MapReduce jobs running in the system. A workload with rate r contains jobs requiring r times of the computation capacity of the current system. It thus leads to more resource competition when the workload rate increases. The results show that Abacus obtains competitive overall profit of the system compared to ARIA. Note that besides overall profit, Abacus also achieves service differentiation with truthfulness and fast-converging auctions, whereas ARIA provides none of these features.

We present Abacus, a new auction-based resource allocation framework for cloud systems. Abacus provides effective service differentiation for jobs with different budgets, utility properties and priorities. We design a novel auction mechanism that is incentive-compatible and highly efficient. Experiments on a real cluster show promising performance. Abacus currently only handles independent computation resources in the system. Hence, an interesting direction for future work is to handle dependent resources, e.g., using a dependency model. We prove that the auction algorithm in Abacus always converges to a Nash Equilibrium, and experiments show that the algorithm usually converges in a small number of iterations. Hence, another interesting topic for further study is to theoretically analyze its convergence speed.

It is more challenging to decouple the dependent resources during resource allocation, while preserving efficiency and fairness of the cloud system. It makes it difficult to design resource allocation mechanism for complicated cloud applications, such as distributed streaming processing systems [42]. We aim to overcome these problems with new dependency models between the resources.

@&#ACKNOWLEDGMENTS@&#

Zhang, Ma and Yang are supported by the HCCS Program from Singapore's A*STAR. Ma is also supported by AcRF grant 1054R-252-000-448-133 from Singapore's Ministry of Education. Ding is partially supported by the NSF of China under Grant 61173081, the Guangdong Natural Science Foundation, China, under Grant S2011020001215, and the Guangzhou Science and Technology Program, China, under Grant 201510010165. The authors would like to thank Prof. Hongyang Chao for her support.


                     Lemma 1
                     
                        Proof
                        First of all, based on chain rule of derivative, we have 
                              
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 ·
                                 
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                              
                           . Since 
                              
                                 
                                    u
                                    i
                                 
                                 
                                    (
                                    
                                       s
                                       i
                                    
                                    )
                                 
                                 =
                                 ∑
                                 
                                    g
                                    j
                                 
                                 
                                    (
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                              
                            and gj
                            is non-decreasing concave function, it is straightforward to verify that 
                              
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 >
                                 0
                              
                            and 
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            decreases monotonically with sij
                           . On the other hand, Eq. (1) implies that 
                              
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                                 
                                    ∂
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            can be reformulated as follows.

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   
                                                      s
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                                
                                                   ∂
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   α
                                                   
                                                      
                                                         (
                                                         
                                                            b
                                                            
                                                               i
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         α
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      (
                                                      
                                                         ∑
                                                         l
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               b
                                                               
                                                                  l
                                                                  j
                                                               
                                                            
                                                            )
                                                         
                                                         α
                                                      
                                                      )
                                                   
                                                   −
                                                   α
                                                   
                                                      
                                                         (
                                                         
                                                            b
                                                            
                                                               i
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         α
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         (
                                                         
                                                            b
                                                            
                                                               i
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      α
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         ∑
                                                         l
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               b
                                                               
                                                                  l
                                                                  j
                                                               
                                                            
                                                            )
                                                         
                                                         α
                                                      
                                                      )
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   α
                                                   
                                                      
                                                         (
                                                         
                                                            b
                                                            
                                                               i
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         α
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      ∑
                                                      
                                                         k
                                                         ≠
                                                         i
                                                      
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            (
                                                            
                                                               b
                                                               
                                                                  k
                                                                  j
                                                               
                                                            
                                                            )
                                                         
                                                         α
                                                      
                                                      )
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         ∑
                                                         l
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               b
                                                               
                                                                  l
                                                                  j
                                                               
                                                            
                                                            )
                                                         
                                                         α
                                                      
                                                      )
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

When 0 ≤ α ≤ 1, (∑
                              l
                           (blj
                           )
                              α
                           )2 is monotonic increasing and 
                              
                                 
                                    (
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                                 
                                    α
                                    −
                                    1
                                 
                              
                            is monotonic decreasing, with respect to bij
                           . Therefore, we can prove the lemma, since both 
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            and 
                              
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                                 
                                    ∂
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            are non-negative monotonic decreasing functions.□


                     Lemma 2
                     
                        Proof
                        Based on the optimality condition, a sub-budget combination 
                              
                                 {
                                 
                                    b
                                    
                                       i
                                       1
                                    
                                 
                                 ,
                                 
                                    b
                                    
                                       i
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    b
                                    
                                       i
                                       m
                                    
                                 
                                 }
                              
                            is optimal if and only if (1) 
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    b
                                    i
                                 
                              
                           ; and (2) we can find some positive constant C such that 
                              
                                 C
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             1
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             2
                                          
                                       
                                    
                                 
                                 =
                                 ⋯
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             m
                                          
                                       
                                    
                                 
                              
                           .

When 
                              
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                              
                            for every j, the first condition is definitely satisfied. In the following, we prove {bij
                           } are also consistent with the second condition. First of all, the partial derivative 
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            can be rewritten as 
                              
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 ·
                                 
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                    
                                       ∂
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 
                                    α
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                 
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    (
                                    1
                                    −
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                              
                           .

On the other hand, Algorithm 2 calculates 
                              
                                 b
                                 
                                    i
                                    j
                                 
                                 ′
                              
                            as follows:

                              
                                 
                                    
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                       =
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                          ′
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   ∂
                                                   
                                                      u
                                                      i
                                                   
                                                
                                                
                                                   ∂
                                                   
                                                      s
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                             
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   s
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                (
                                                
                                                   
                                                      ∂
                                                      
                                                         u
                                                         k
                                                      
                                                   
                                                   
                                                      ∂
                                                      
                                                         s
                                                         
                                                            k
                                                            j
                                                         
                                                      
                                                   
                                                
                                                
                                                   s
                                                   
                                                      k
                                                      j
                                                   
                                                
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      s
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                       
                                          b
                                          i
                                       
                                    
                                 
                              
                           
                        

Therefore, we can further derive as follows:

                              
                                 (A.1)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∂
                                                   
                                                      u
                                                      i
                                                   
                                                
                                                
                                                   ∂
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      ∂
                                                      
                                                         u
                                                         i
                                                      
                                                   
                                                   
                                                      ∂
                                                      
                                                         s
                                                         
                                                            i
                                                            j
                                                         
                                                      
                                                   
                                                
                                                
                                                   α
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                                
                                                   s
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      s
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   α
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                                ·
                                                
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      b
                                                      i
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   (
                                                   
                                                      
                                                         ∂
                                                         
                                                            u
                                                            k
                                                         
                                                      
                                                      
                                                         ∂
                                                         
                                                            s
                                                            
                                                               k
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      s
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   
                                                      (
                                                      1
                                                      −
                                                      
                                                         s
                                                         
                                                            k
                                                            j
                                                         
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   α
                                                   
                                                      b
                                                      i
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   (
                                                   
                                                      
                                                         ∂
                                                         
                                                            u
                                                            k
                                                         
                                                      
                                                      
                                                         ∂
                                                         
                                                            s
                                                            
                                                               k
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      s
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   
                                                      (
                                                      1
                                                      −
                                                      
                                                         s
                                                         
                                                            k
                                                            j
                                                         
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

This shows that 
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       b
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                            is the same for every j and proves the lemma.□


                     Theorem 1
                     
                        Proof
                        To prove the theorem, we first design a new measure on the change rate of a particular sub-budget bij
                            across two iterations. We use Δl
                            to denote the ratio of 
                              
                                 s
                                 
                                    i
                                    j
                                 
                                 
                                    (
                                    l
                                    )
                                 
                              
                            to 
                              
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    
                                       (
                                       l
                                       −
                                       1
                                       )
                                    
                                 
                                 ,
                              
                            after lth iteration. Here, 
                              
                                 s
                                 
                                    i
                                    j
                                 
                                 
                                    (
                                    l
                                    )
                                 
                              
                            and 
                              
                                 s
                                 
                                    i
                                    j
                                 
                                 
                                    (
                                    l
                                    +
                                    1
                                    )
                                 
                              
                            are the probability after and before the iteration. That is,

                              
                                 
                                    
                                       
                                          Δ
                                          l
                                       
                                       =
                                       max
                                       
                                          {
                                          
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   −
                                                   1
                                                   )
                                                
                                             
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   )
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   )
                                                
                                             
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   −
                                                   1
                                                   )
                                                
                                             
                                          
                                          }
                                       
                                       .
                                    
                                 
                              
                           
                           Δl
                            is always a positive real number no smaller than 1. When 
                              
                                 
                                    Δ
                                    l
                                 
                                 =
                                 1
                                 ,
                              
                           
                           
                              
                                 s
                                 
                                    i
                                    j
                                 
                                 l
                              
                            is equal to 
                              
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    
                                       l
                                       −
                                       1
                                    
                                 
                                 ,
                              
                            implying the allocation of resource j w.r.t. job Ji
                            stops changing. In the following, we prove that Δl
                            tends to 1 in Algorithm 1. In particular, we study the relationship between Δl
                            and 
                              
                                 Δ
                                 
                                    l
                                    +
                                    1
                                 
                              
                           . There are two sub-cases possible to happen.

Case 1: If Ji
                            is the one updating sub-budgets in lth iteration, we have

                              
                                 
                                    
                                       
                                          1
                                          
                                             Δ
                                             l
                                          
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             −
                                             1
                                             )
                                          
                                       
                                       ≤
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                       ≤
                                       
                                          Δ
                                          l
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             −
                                             1
                                             )
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

If 
                              
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    
                                       (
                                       l
                                       )
                                    
                                 
                                 ≥
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    
                                       (
                                       l
                                       −
                                       1
                                       )
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                    
                                 
                                 ≤
                                 
                                    
                                       ∂
                                       
                                          u
                                          i
                                       
                                    
                                    
                                       ∂
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             −
                                             1
                                             )
                                          
                                       
                                    
                                 
                                 ,
                              
                            due to the non-increasing property of 
                              
                                 
                                    ∂
                                    
                                       u
                                       i
                                    
                                 
                                 
                                    ∂
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                           . On the other hand, combined with the fact that 
                              
                                 1
                                 −
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    l
                                 
                                 ≤
                                 1
                                 −
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                    
                                       (
                                       l
                                       −
                                       1
                                       )
                                    
                                 
                                 ,
                              
                            we have

                              
                                 
                                    
                                       
                                          
                                             ∂
                                             
                                                u
                                                i
                                             
                                          
                                          
                                             ∂
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                       
                                          (
                                          1
                                          −
                                          
                                             s
                                             
                                                i
                                                j
                                             
                                             
                                                (
                                                l
                                                )
                                             
                                          
                                          )
                                       
                                       ≤
                                       
                                          Δ
                                          l
                                       
                                       
                                          
                                             ∂
                                             
                                                u
                                                i
                                             
                                          
                                          
                                             ∂
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   −
                                                   1
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             −
                                             1
                                             )
                                          
                                       
                                       
                                          (
                                          1
                                          −
                                          
                                             s
                                             
                                                i
                                                j
                                             
                                             
                                                (
                                                l
                                                −
                                                1
                                                )
                                             
                                          
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                        

Since all other sub-budgets from other jobs remain the same, we have 
                              
                                 b
                                 
                                    i
                                    j
                                 
                                 ′
                              
                            is upper bounded by


                           
                              
                                 
                                    
                                       
                                          
                                             
                                                b
                                                i
                                             
                                             
                                                Δ
                                                l
                                             
                                             
                                                
                                                   ∂
                                                   
                                                      u
                                                      i
                                                   
                                                
                                                
                                                   ∂
                                                   
                                                      s
                                                      
                                                         i
                                                         j
                                                      
                                                      
                                                         (
                                                         l
                                                         −
                                                         1
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   −
                                                   1
                                                   )
                                                
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   s
                                                   
                                                      i
                                                      j
                                                   
                                                   
                                                      (
                                                      l
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             
                                                Δ
                                                l
                                             
                                             
                                                
                                                   ∂
                                                   
                                                      u
                                                      i
                                                   
                                                
                                                
                                                   ∂
                                                   
                                                      s
                                                      
                                                         i
                                                         j
                                                      
                                                      
                                                         (
                                                         l
                                                         −
                                                         1
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                                
                                                   (
                                                   l
                                                   −
                                                   1
                                                   )
                                                
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   s
                                                   
                                                      i
                                                      j
                                                   
                                                   
                                                      (
                                                      l
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ≠
                                                   i
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      ∂
                                                      
                                                         u
                                                         k
                                                      
                                                   
                                                   
                                                      ∂
                                                      
                                                         s
                                                         
                                                            k
                                                            j
                                                         
                                                         
                                                            (
                                                            l
                                                            −
                                                            1
                                                            )
                                                         
                                                      
                                                   
                                                
                                                
                                                   s
                                                   
                                                      k
                                                      j
                                                   
                                                   
                                                      (
                                                      l
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      s
                                                      
                                                         k
                                                         j
                                                      
                                                      
                                                         (
                                                         l
                                                         −
                                                         1
                                                         )
                                                      
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           
                        

and thus

                              
                                 (A.2)
                                 
                                    
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                          ′
                                       
                                       ≤
                                       
                                          b
                                          
                                             i
                                             j
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Then, by applying Eq. (1), we can derive the following ratio:

                              
                                 
                                    
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             +
                                             1
                                             )
                                          
                                       
                                       =
                                       
                                          
                                             
                                                (
                                                
                                                   b
                                                   
                                                      i
                                                      j
                                                   
                                                   ′
                                                
                                                )
                                             
                                             α
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      b
                                                      
                                                         i
                                                         j
                                                      
                                                      ′
                                                   
                                                   )
                                                
                                                α
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ≠
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      b
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                α
                                             
                                          
                                       
                                       <
                                       
                                          
                                             (
                                             
                                                Δ
                                                l
                                             
                                             )
                                          
                                          
                                             2
                                             α
                                          
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

The ratio is thus upper bounded, i.e.

                              
                                 
                                    
                                       
                                          Δ
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       =
                                       
                                          
                                             s
                                             
                                                i
                                                j
                                             
                                             
                                                (
                                                l
                                                +
                                                1
                                                )
                                             
                                          
                                          
                                             s
                                             
                                                i
                                                j
                                             
                                             
                                                (
                                                l
                                                )
                                             
                                          
                                       
                                       <
                                       
                                          
                                             (
                                             
                                                Δ
                                                l
                                             
                                             )
                                          
                                          
                                             2
                                             α
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Sub-Case 2: If Jk
                            (k ≠ i) is the one updating the sub-budgets, using similar strategy used in previous sub-case, we know 
                              
                                 
                                    b
                                    
                                       k
                                       j
                                    
                                    ′
                                 
                                 ≤
                                 
                                    Δ
                                    l
                                 
                                 
                                    b
                                    
                                       k
                                       j
                                    
                                 
                              
                           . Then, the probability sij
                            is updated as

                              
                                 
                                    
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             +
                                             1
                                             )
                                          
                                       
                                       =
                                       
                                          
                                             
                                                (
                                                
                                                   b
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                )
                                             
                                             α
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      b
                                                      
                                                         k
                                                         j
                                                      
                                                      ′
                                                   
                                                   )
                                                
                                                α
                                             
                                             +
                                             
                                                ∑
                                                
                                                   m
                                                   ≠
                                                   k
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      b
                                                      
                                                         m
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                α
                                             
                                          
                                       
                                       <
                                       
                                          
                                             (
                                             
                                                Δ
                                                l
                                             
                                             )
                                          
                                          α
                                       
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

If this is the case, we have 
                              
                                 
                                    Δ
                                    
                                       l
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                       
                                          (
                                          l
                                          +
                                          1
                                          )
                                       
                                    
                                    
                                       s
                                       
                                          i
                                          j
                                       
                                       
                                          (
                                          l
                                          )
                                       
                                    
                                 
                                 <
                                 
                                    
                                       (
                                       
                                          Δ
                                          l
                                       
                                       )
                                    
                                    α
                                 
                              
                           .

Therefore, when α < 0.5 and optimization iterations continue running for all jobs in round robin manner, the change ratio tends to be 1, i.e. 
                              
                                 
                                    lim
                                    
                                       l
                                       ↦
                                       ∞
                                    
                                 
                                 
                                    Δ
                                    l
                                 
                                 =
                                 1
                              
                           .

Similarly, we can analyze the situation when sij
                            decreases after the iteration. This will complete the proof that the algorithm must terminate after finite iterations.□


                     Lemma 3
                     
                        Proof
                        By Lemma 2 and Lemma 1, Algorithm 1 always converges and the final results guarantees that the sub-budget is optimal on maximizing the utility of every job. Therefore, no matter what sub-budget the user submits, it is impossible to gain additional utility.□


                     Lemma 4
                     
                        Proof
                        If the user submits another job 
                              
                                 J
                                 i
                                 ′
                              
                            with 
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 <
                                 
                                    b
                                    i
                                 
                              
                            and 
                              
                                 
                                    u
                                    i
                                    ′
                                 
                                 =
                                 
                                    u
                                    i
                                 
                              
                            such that 
                              
                                 J
                                 i
                                 ′
                              
                            achieves better utility than Ji
                           , there exists an optimal sub-budget 
                              
                                 {
                                 
                                    b
                                    
                                       i
                                       1
                                    
                                    ′
                                 
                                 ,
                                 
                                    b
                                    
                                       i
                                       2
                                    
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    b
                                    
                                       i
                                       m
                                    
                                    ′
                                 
                                 }
                              
                            that 
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                                 =
                                 
                                    b
                                    i
                                    ′
                                 
                              
                           . We can construct a new sub-budget that {bij
                           } with 
                              
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       b
                                       i
                                    
                                    
                                       b
                                       i
                                       ′
                                    
                                 
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                              
                           . Because 
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 <
                                 
                                    b
                                    i
                                 
                              
                            and 
                              
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                 
                                 >
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                              
                            for each j. Due to the monotonicity property of the utility function, {bij
                           } must lead to better utility than 
                              
                                 {
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                                 }
                              
                           . Thus, the user can always gain additional utility by increasing the job’s budget from 
                              
                                 b
                                 i
                                 ′
                              
                            to bi
                           , violating the original assumption. We thereby prove the lemma.□


                     Theorem 2
                     
                        Proof
                        By Lemma 4, we have shown the user can improve the utility by bidding the resources using larger budget. Thus, there is no incentive for the user to bid with a smaller budget. In the rest of the proof, we show that telling the true utility function is also a dominating strategy for the user to maximize the utility.

Because of Lemma 4, it is safe to assume the user always tells the maximal budget bi
                            he can afford. Therefore, if the user submits a fake utility function 
                              
                                 u
                                 i
                                 ′
                              
                            instead of ui
                            for job Ji
                           , Abacus will make a different sub-budget partitioning 
                              
                                 {
                                 
                                    b
                                    
                                       i
                                       1
                                    
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    b
                                    
                                       i
                                       m
                                    
                                    ′
                                 
                                 }
                              
                            for job Ji
                           , such that 
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                                 =
                                 
                                    b
                                    i
                                 
                              
                           . The proof of Lemma 2 has already shown that the necessary condition for optimal sub-budget combination is keeping the same partial derivative with respect to every sub-budget. This observation implies that the only optimal solution for the sub-budget is 
                              
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                                 =
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                 
                              
                            to ensure 
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    b
                                    
                                       i
                                       j
                                    
                                    ′
                                 
                                 =
                                 
                                    b
                                    i
                                 
                                 ,
                              
                            where bij
                            is the assignment result if user submits true utility function ui
                           . It is thus impossible for the user to gain additional utility by faking utility functions.□


                     Lemma 5
                     
                        Proof
                        When 
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 <
                                 
                                    b
                                    i
                                 
                                 ,
                              
                            there are three possible cases, including (1) Ji
                            remains in prolific pool; (2) Ji
                            remains in non-prolific pool; and (3) Ji
                            is moved from prolific pool to non-prolific pool. In the first case, the utility of the job decreases, according to Lemma 4, therefore contradicting the user’s will on utility maximization. In the second case, the utility of job remains zero, as the job is not likely to be finished with the desired minimal utility. In the third case, the utility of the job definitely drops as well. It is undesirable for a user to submit 
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 <
                                 
                                    b
                                    i
                                 
                              
                           .

Similarly, when 
                              
                                 
                                    b
                                    i
                                    ′
                                 
                                 >
                                 
                                    b
                                    i
                                 
                                 ,
                              
                            there are three possible cases, including (1) Ji
                            remains in prolific pool; (2) Ji
                            remains in non-prolific pool; and (3) Ji
                            is moved from non-prolific pool to prolific pool. As discussed above, there is no incentive for the users when their jobs stay in the same pool, in the first two cases. Regarding the third case, the job will be finished with the utility, but the user needs to pay more than his budget. This is again a contradiction to the rationality assumption on the user. This completes the proof of the lemma.□


                     Lemma 6
                     
                        Proof
                        When 
                              
                                 
                                    m
                                    i
                                    ′
                                 
                                 >
                                 
                                    m
                                    i
                                 
                                 ,
                              
                            there are three possible cases, including (1) Ji
                            remains in prolific pool; (2) Ji
                            remains in non-prolific pool; and (3) Ji
                            is moved from prolific pool to non-prolific pool. In the first two cases, the utility of the job and the job payments both remain unchanged. In the third case, the utility of the job is negatively affected, as the utility of the job is no longer guaranteed. We can get similar results by adopting the same proving strategy on the case when 
                              
                                 
                                    m
                                    i
                                    ′
                                 
                                 <
                                 
                                    m
                                    i
                                 
                              
                           .□

@&#REFERENCES@&#

