@&#MAIN-TITLE@&#Sphere intersection 3D shape descriptor (SID)

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Descriptive and compact feature descriptor based on sphere intersection operator.


                        
                        
                           
                           Fast and meaningful feature detector based on the descriptor.


                        
                        
                           
                           Shape retrieval framework for evaluation against state-of-the-art benchmarks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mesh processing

Descriptor

Signature

Similarity

Retrieval

@&#ABSTRACT@&#


               Graphical abstract
               
                  
               
               
                  
               
            

@&#INTRODUCTION@&#

Databases of 3D models are becoming nowadays available in a number of disciplines, including computer graphics, CAD, and medicine (Veltkamp and Hagedoorn, 2001). As a result of the extensive growth of 3D databases, shape-retrieval techniques are becoming valuable tools for analysis and discovery. The SHREC contest and benchmark (Boyer et al., 2011) have been stimulating forces in this field.

A common method for matching objects is to represent each object as a set of local shape features sampled from the object's surface. For a pair of objects and a given correspondence between their features, similarity is measured by comparing the corresponding features using a cost function (e.g., Belongie et al., 2001; Chua and Jarvis, 1997; Johnson and Hebert, 1999). Nevertheless, shapes and features can be represented in many different ways, and finding an appropriate representation that is amenable to surface matching is still an open research problem.

Our descriptor is inspired by the Shape Context descriptor recently explored by Kokkinos et al. (2012). Similarly, we sample the continuous surface into a discrete set of samples. Nevertheless, instead of discretization into bins, we utilize continuous 1D surface curves as a more informative representation of the shape. Our idea is that shape characteristics, especially subtle ones require high-order descriptions to represent them appropriately. For example, the tip of the octaflower in Fig. 2 (right) is a complex feature and singular point which cannot be described using principal curvatures. Using our descriptor, we represent the region using explicit 1D curves sampling the surface, thus capturing the feature as can be seen in the graph.

At the core of our shape descriptor computation is a simple sphere and surface intersection operation. Essentially, we grow spheres on the surface and compute their intersection with the surface at several predefined scales. The intersections result in a set of parameterized curves that represent excerpts of the local surface. For each point we accumulate the set of curves. The set of curves is then transformed to the frequency domain, resulting in a compact yet effective 2D representation of local 3D geometry.

We define a shape similarity metric based on the correlation between “interesting shape features” and curvature, following the observation of Marr (1982). To compare two shapes, we filter out smooth or flat regions, and compare the curved regions by measuring the distance between their descriptors.

We evaluate our work by performing both qualitative and quantitative analysis. For qualitative evaluation we use multiple shapes with different characteristics and deformations (see Figs. 2, 8 and 1
                     ). For quantitative evaluation we use the SHREC 11 non-rigid benchmark (Boyer et al., 2011) and SHREC 12 abstract shapes benchmark (Biasotti et al., 2012). The results show that SID outperforms most state-of-the-art algorithms used in the comparison in terms of retrieval rates. With regards to MeshSIFT (Smeets et al., 2013), although retrieval rates are similar to us, we observe that SID holds favorable properties in terms of speed, meaningful keypoint selection and consistency of keypoint selection.

Our contributions are as follows:
                        
                           •
                           A descriptor which captures the shape via explicit sampling of the surface with continuous 1D curves at keypoints. Our descriptor is informative and distinctive (see Fig. 2
                              ).

An efficient and meaningful feature detection scheme based on our descriptor formulation.

A shape retrieval scheme which offers a unique balance and combination of correctness, speed and handling multiple classes of shapes.

@&#RELATED WORK@&#

Shape descriptors and similarity have been extensively studied in fields such as computer-vision, CAD and molecular-biology (Veltkamp and Hagedoorn, 2001). In 2D images and video, shape matching has been broadly researched (Flickner et al., 1995; Jacobs et al., 1995; Ogle and Stonebraker, 1995; Castelli and Bergman, 2001) and is beyond the scope of this work. A major problem in extending these systems to 3D is that 3D models typically lack an underlying regular parametric domain. For example, 2D shapes have a natural arc length parametrization of their boundary contours while 3D surfaces of arbitrary genus do not. As a result, common shape descriptors for 2D contours (e.g., Arbter et al., 1990; Arkin et al., 1990; Kashyap and Chellappa, 1981) cannot be directly extended to 3D surfaces.

Nevertheless, descriptors for 3D shape matching have been studied for more than two decades. Gaussian images (Horn, 1984) and spherical representations (Delingette et al., 1993) are global representations useful for describing simple objects. Stein and Medioni (1992) recognize 3D objects by matching points using structural indexing and their “splash” representation. Similarly, Chua and Jarvis match points to align surfaces using principal curvatures (Chua and Jarvis, 1996) and “point-signatures” (Chua and Jarvis, 1997). The Harmonic shape images (Zhang and Hebert, 1999) map a patch that is topologically equivalent to a disk into a 2D domain. Similar to this work, Spin Images (Johnson and Hebert, 1999) encode the local patch geometry in a compact 2D image using cylindrical coordinates.

Our descriptor significantly differs from these methods as it encodes continuous surface excerpts around a point. Thus, instead of analyzing local properties (for example curvature), we capture the actual surface by encoding curves around a point. This representation benefits from both being compact and yet descriptive. Nonetheless, our formulation is simple, requiring only to compute a surface intersection with a sphere and is not restricted to disk-like patch topology.

Another approach for describing shapes is indexing their features based on statistical properties. Histograms of geometric statistics have been considered (Ankerst et al., 1999; Osada et al., 2001; Ohbuchi et al., 2003) as well as harmonic-based representations (Funkhouser et al., 2003; Kazhdan et al., 2003). Ankerst et al. (1999) propose global histograms encoding shells and sectors around a model's centroid. Osada et al. (2001) represent shapes with probability distributions of geometric properties computed from random points. Kazhdan et al. (2003) represent the global shape using spherical harmonics, for rotational invariant descriptors. Giorgi et al. (2010) utilize best view selection to generate descriptive 2D binary images from 3D models for effective matching. While these methods propose alternate surface representations, ours encodes the explicit surface. Hence, it retains all surface properties and characteristics.

Multi-scale features similar to 2D SIFT (Lowe, 2004) have been explored in the context of 3D shapes (Li and Guskov, 2005; Zaharescu et al., 2009; Smeets et al., 2013). These techniques develop local shape descriptors based on differential properties and scalar functions of the mesh surface. MeshSIFT (Smeets et al., 2013) detects features by smoothing the mesh at various degrees and seeking for local minima/maxima of mean curvature. The feature description is performed by constructing a histogram of slant and angle per each scale in scale space.


                     Zaharescu et al. (2009) present MeshHOG which seeks Laplacian extrema in a scalar function defined on a surface. Sun et al. (2009) and Bronstein and Kokkinos (2010) utilize heat-kernels to compute the bending invariant shape signatures. The use of heat-kernels has many benefits such as mathematically provable properties and detection of small number of meaningful features but is also time consuming and implicit representations of the surface. Pottmann et al. (2009) analyze the stability of differential properties on surfaces with regard to their scale. Sipiran and Bustos (2011) extend the 2D Harris operator to 3D meshes, they analyze the k-ring of vertices around a point in order to form the descriptor and propose two modes of operation for feature detection: choosing points with highest Harris value or clustering. The first method suffers from choosing multiple features on sharp edges of the surface thus being somewhat ambiguous in the feature selection result. The second method suffers from lesser repeatability according to the authors. Darom and Keller (2012) show scale invariant extensions of the SIFT and Spin Images descriptors to 3D meshes. Similar to these works, we also define our shape descriptor in a scale-space context. Nevertheless, our signature is an explicit representation of the surface and not an implicit measurement of a scalar function, shape distribution or differential properties. Thus, our representation is less sensitive to noise and surface inconsistencies.

In a seminal work, Tombari et al. (2013) evaluated and compared 3D feature descriptors. A major conclusion was that the number of keypoints do not correlate with matching success. For example, KPQ (Mian et al., 2010) finds many keypoints and yields good matching scores in contrast to HKS (Sun et al., 2009) and Salient Points (Castellani et al., 2008) which both find very few keypoints and both sub-performed. We come to the conclusion that detecting a small number of meaningful features that produce good retrieval results is still a major challenge. Our method specifically addresses this challenge.


                     Mortara et al. (2004) explore different characteristics of intersection curve resulting from intersecting a sphere with a triangle mesh. Some of the characteristics considered are: concavity vs. convexity, curve length and number of connected components. Their research focused on segmentation of shapes rather than shape retrieval, and did not address the question of fine grain dissimilarity between features. We choose to further explore the sphere to mesh intersection curve with respect to mesh retrieval application.

@&#OVERVIEW@&#

Our framework consists of the following main components: feature detection, feature description, shape similarity. In the following we provide an overview of each component.
                        
                           •
                           
                              Feature detection: the selection of features is done iteratively with spheres of growing radius, centered at mesh vertices. At each step of the feature detection loop we compute a saliency metric on the sphere intersection curve with the surface. Intersecting spheres are detected and only spheres with stronger metric are kept for the next iteration. Fig. 6 demonstrates the iterative detection process.


                              Feature description: given a keypoint and a support sphere radius from the previous step, the sphere intersection curve with the surface is projected to spherical coordinates and parameterized to 
                                 ϕ
                                 (
                                 t
                                 )
                                 ,
                                 θ
                                 (
                                 t
                                 )
                               components. Lastly, 
                                 ϕ
                                 (
                                 t
                                 )
                                 ,
                                 θ
                                 (
                                 t
                                 )
                               are transformed to frequency domain thus producing rotational invariant local feature descriptor. Fig. 3
                               demonstrates the sphere intersection with the mesh, the resulting curve on the 
                                 (
                                 ϕ
                                 ,
                                 θ
                                 )
                               plane and the transformation to frequency domain.


                              Shape similarity: for similarity computation between two meshes, we perform a min cost maximal matching on a bipartite graph generated from the set of descriptors of each mesh. Similarity between two given feature descriptors is given by 
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                               distance of their magnitudes. Thus, model correspondence is performed by minimizing the cost of the matching on the feature descriptors sets.

In the following sections we discuss each component in detail.

Feature point detection is done in an iterative manner. We start with all mesh vertices as candidates for being considered feature points and reduce the amount of candidates in each iteration. In each iteration of the feature detection loop we perform the following for each candidate vertex v:
                           
                              1.
                              Extract the Sphere-with-Surface intersection curve.

Transform the intersection curve to spherical coordinations.

Parameterize the intersection curve as 
                                    (
                                    ϕ
                                    (
                                    t
                                    )
                                    ,
                                    θ
                                    (
                                    t
                                    )
                                    )
                                 .

Compute of saliency metric.

In the end of each iteration we consider the intersection of neighboring spheres and upon sphere-to-sphere intersection we keep only the one with the stronger saliency metric. Thus, the algorithm converges from all mesh vertices to keypoints.

Given a vertex v and radius r we compute the intersection of a sphere of radius r centered at v with the mesh surface. This gives a closed loop of adjacent faces that intersect with the sphere. By choosing the initial radius to be small enough, we enforce only one closed loop per sphere in the first iteration. Then, each iteration we increase r and compute a new sphere intersection curve. In case that the sphere intersection produces several closed loops of faces we take the faces loop closest to the loop from the previous iteration. it follows by induction that we always have one closed loop and that it will not jitter between different components.

The faces are sampled uniformly so we obtain the intersection curve points in global Euclidean coordinate system (see Fig. 5). Then we impose a local Euclidean coordinate system UVW, with origin at v and its W axis as the consistent normal at v. We arbitrarily set the UV axes to be orthonormal to W.

The consistent normal of v is computed as follows:
                              
                                 (1)
                                 
                                    c
                                    n
                                    (
                                    v
                                    )
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   normal
                                                
                                                (
                                                v
                                                )
                                                ,
                                             
                                             
                                                if 
                                                
                                                   
                                                      ‖
                                                      v
                                                      −
                                                      
                                                         icc
                                                      
                                                      ‖
                                                   
                                                   <
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                
                                                   sign
                                                
                                                (
                                                (
                                                v
                                                −
                                                
                                                   icc
                                                
                                                )
                                                ⋅
                                                
                                                   normal
                                                
                                                (
                                                v
                                                )
                                                )
                                                ⋅
                                                
                                                   
                                                      v
                                                      −
                                                      
                                                         icc
                                                      
                                                   
                                                   
                                                      ‖
                                                      v
                                                      −
                                                      
                                                         icc
                                                      
                                                      ‖
                                                   
                                                
                                                ,
                                             
                                             
                                                else
                                             
                                          
                                       
                                    
                                 
                              
                            where icc is the intersection curve centroid and t is a threshold. The first case sets the consistent normal of v to be the normal of v if the intersection curve centroid is too close to v (determined by threshold t). The purpose of this case is to prevent “jitter” of the consistent normal at small scales. The second case sets the consistent normal of v to be the vector connecting the intersection curve centroid and v, we enforce the consistent normal to be in the same direction of the original normal of v by multiplying with 
                              
                                 sign
                              
                              (
                              (
                              v
                              −
                              
                                 icc
                              
                              )
                              ⋅
                              
                                 normal
                              
                              (
                              v
                              )
                              )
                           . The construction of the consistent normal follows the direction of the original normal and gives a normal that is invariant to different deformations: non-rigid, local noise and various triangulations. Thus, we obtain a stable local coordinate system for locally similar surfaces.

Next follows the transformation of c points to local spherical coordinate system. Since r is constant, we can represent c as two 1D functions defined by 
                              (
                              θ
                              ,
                              ϕ
                              )
                           , where 
                              ϕ
                              ,
                              θ
                              ∈
                              [
                              −
                              π
                              /
                              2
                              ,
                              …
                              ,
                              π
                              /
                              2
                              ]
                           . We parameterize the intersection curve by performing a walk on the curve c and encoding the angles 
                              (
                              θ
                              ,
                              ϕ
                              )
                            with respect to the axes. The intersection curve points are transformed into spherical coordinates following the formula:
                              
                                 (2)
                                 
                                    
                                       ϕ
                                       =
                                       
                                          sin
                                       
                                       (
                                       
                                          atan
                                       
                                       2
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             x
                                          
                                       
                                       ,
                                       
                                          
                                             p
                                          
                                          
                                             y
                                          
                                       
                                       )
                                       )
                                    
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    
                                       θ
                                       =
                                       
                                          asin
                                       
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             z
                                          
                                       
                                       )
                                    
                                 
                              
                            where (
                              
                                 
                                    p
                                 
                                 
                                    x
                                 
                              
                           , 
                              
                                 
                                    p
                                 
                                 
                                    y
                                 
                              
                           , 
                              
                                 
                                    p
                                 
                                 
                                    z
                                 
                              
                           ) is a point on c in local Euclidean coordinate system. We apply a sin function to ϕ as we require a cyclic function for the Fourier transform. The origin of ϕ (i.e., 
                              ϕ
                              =
                              0
                           ) is determined by the rotational orientation of the spherical coordinate system imposed at p. See Figs. 4 and 3
                           
                            for demonstration of this operation.

For pruning the candidates we chose a greedy-iterative scheme, which discards the weaker candidates according to the saliency metric (see Fig. 6
                           ). This scheme was preferred over other possibilities for several reasons. First, for performance and simplicity. Second, the focus of this work is to explore the sphere intersection method as a feature descriptor and leave further research on more complex detection schemes to future work.

Since the surface of the local neighborhood of a vertex is sampled at several radii around the vertex, we argue that it is sufficient to have at most one sphere intersecting a face in order to achieve good description of the entire shape. This reduces the problem to eliminating weaker candidates when sphere-to-sphere intersections occur.

We perform the sphere-to-sphere intersection detection by keeping track of the faces inside each sphere, thus the detection is made very efficient by simply querying the faces that are intersected or inside of more then one sphere. Furthermore, the candidates are sorted before the test in descending order by the saliency metric, this ensures that no candidate is unnecessarily eliminated.

We follow the observation of Marr (1982) which correlates between “interesting shape features” and surface sharpness. We define interesting points as points having non-smooth or flat curvature. The detection of feature points is crucial: important parts of the objects should not be missed, while the overall number of feature points directly affects the computational complexity and introduces unimportant information.

Since our feature is an intersection curve along the mesh surface, many formulations can be considered as sole saliency metric or as a combined weighted sum – integral, Laplacian and variance just to name a few. For our implementation we chose to use a weighted sum of integral of absolute value of the intersection curve and sum of Laplacians. Given a vertex v let 
                              
                                 
                                    θ
                                 
                                 
                                    v
                                 
                              
                              (
                              t
                              )
                           , 
                              
                                 
                                    ϕ
                                 
                                 
                                    v
                                 
                              
                              (
                              t
                              )
                            be defined for 
                              t
                              ∈
                              1
                              ,
                              …
                              ,
                              n
                            then the sum of Laplacians of v is defined by:
                              
                                 (4)
                                 
                                    
                                       
                                          l
                                       
                                       
                                          v
                                       
                                    
                                    =
                                    ∑
                                    
                                       
                                          
                                             
                                                ∂
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                θ
                                             
                                             
                                                v
                                             
                                          
                                       
                                       
                                          ∂
                                          
                                             
                                                t
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                            and integral of absolute value of the intersection curve of v is defined by:
                              
                                 (5)
                                 
                                    
                                       
                                          i
                                       
                                       
                                          v
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    
                                       ‖
                                       
                                          
                                             (
                                             
                                                
                                                   θ
                                                
                                                
                                                   v
                                                
                                             
                                             (
                                             t
                                             +
                                             1
                                             )
                                             −
                                             
                                                
                                                   θ
                                                
                                                
                                                   v
                                                
                                             
                                             (
                                             t
                                             )
                                             )
                                             ⋅
                                             (
                                             
                                                
                                                   ϕ
                                                
                                                
                                                   v
                                                
                                             
                                             (
                                             t
                                             +
                                             1
                                             )
                                             +
                                             
                                                
                                                   ϕ
                                                
                                                
                                                   v
                                                
                                             
                                             (
                                             t
                                             )
                                             )
                                          
                                          2
                                       
                                       ‖
                                    
                                 
                              
                            then the saliency metric is given by a normalized weighted sum of 
                              
                                 
                                    l
                                 
                                 
                                    v
                                 
                              
                            and 
                              
                                 
                                    i
                                 
                                 
                                    v
                                 
                              
                           .

This formulation gives high saliency values both to features at local extrema/minima and also to features with great variation in their local neighborhood. In Fig. 2 the left feature is considered strong because of its sum of Laplacians value while the feature on the right is considered strong because of high integral of absolute value of the intersection curve value.

In our implementation we set 
                              n
                              =
                              128
                            and Laplacian aperture size to be 15. The weight of the components varies according to input characteristics. For example, for meshes of living creatures with limbs and edges of varying properties (see Fig. 12) only integral of absolute value of the intersection curve was used. Alternatively, for simple geometric meshes a weighted sum of integral of absolute value of the intersection curve and sum of Laplacians was used (see Fig. 1 and Fig. 11).

Since the intersection curve may or may not be a function in spherical coordinates, we first parameterize the curve to its components 
                           ϕ
                           (
                           t
                           )
                         and 
                           θ
                           (
                           t
                           )
                        . Each component separately is a function, so we then transform ϕ and θ curve functions into frequency domain using DFT and consider only coefficient magnitudes as they carry most of the information. Thus, by considering magnitudes, our descriptor becomes rotation invariant. Furthermore, we utilize the iterative nature of the feature detection phase to consider this formulation at multiple scales 
                           [
                           
                              
                                 r
                              
                              
                                 1
                              
                           
                           −
                           
                              
                                 r
                              
                              
                                 max
                              
                           
                           ]
                         thus providing a discrete sampling of co-centric intersection curves around a keypoint (see Fig. 3).

For a given vertex v we consider the following as a feature descriptor:
                           
                              (6)
                              
                                 
                                    SID
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    ‖
                                    F
                                    (
                                    
                                       
                                          ϕ
                                       
                                       
                                          v
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    )
                                    ‖
                                 
                                 ,
                                 
                                    ‖
                                    F
                                    (
                                    
                                       
                                          θ
                                       
                                       
                                          v
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    )
                                    ‖
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    ‖
                                    F
                                    (
                                    
                                       
                                          ϕ
                                       
                                       
                                          v
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                max
                                             
                                          
                                       
                                    
                                    )
                                    ‖
                                 
                                 ,
                                 
                                    ‖
                                    F
                                    (
                                    
                                       
                                          θ
                                       
                                       
                                          v
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                max
                                             
                                          
                                       
                                    
                                    )
                                    ‖
                                 
                              
                           
                        
                     

This descriptor is computed for each keypoint detected in the feature detection phase.

An additional advantage of using Fourier Transform is the control it gives us on the desired level of detail. We can take few coefficients from the result of the DFT to favor compactness or many coefficients to favor descriptiveness. We empirically chose to take more 
                           ‖
                           F
                           (
                           θ
                           )
                           ‖
                         coefficients since it carries more information then 
                           ‖
                           F
                           (
                           ϕ
                           )
                           ‖
                        .

In order to underline and clarify the rotation invariance of our descriptor we provide the following elaboration using both a figure and a formal discussion.


                           Fig. 4 and Fig. 7
                            demonstrate the rotational invariance. Features A and C in Fig. 4 are both similar in shape since they are both on a straight angle edge, but those features differ in rotation and in phase. The phase difference is observable in Fig. 4 in the graphs of A and C. Despite the rotation and phase shift between A and C, Fig. 7 clearly shows the final descriptor is similar (
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       ϕ
                                    
                                    
                                       A
                                    
                                 
                                 )
                                 ‖
                              
                              ≈
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       ϕ
                                    
                                    
                                       C
                                    
                                 
                                 )
                                 ‖
                              
                            and 
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       θ
                                    
                                    
                                       A
                                    
                                 
                                 )
                                 ‖
                              
                              ≈
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       θ
                                    
                                    
                                       C
                                    
                                 
                                 )
                                 ‖
                              
                           ) both in the ϕ (Fig. 7, upper right, A and C rows) and θ (Fig. 7, upper right, A and C rows) components.

For the general case, consider a surface 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                           , a point 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            on 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                           , a surface 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                              =
                              R
                              (
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                              )
                            where R is rotational transformation and a point 
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              =
                              R
                              (
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                              )
                           , notice that 
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                            is on 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           . For a given radius r we set a sphere around 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            and set another sphere with radius r around 
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                           . Next, let 
                              
                                 
                                    i
                                 
                                 
                                    1
                                 
                              
                            be the intersection curve of the first sphere with 
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                           , and correspondingly let 
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                            be the intersection curve of the second sphere with 
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           . The consistent normal (see Section 4.1.1 for definition) 
                              
                                 
                                    W
                                 
                                 
                                    1
                                 
                              
                            is the vector between 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            and the centroid of 
                              
                                 
                                    i
                                 
                                 
                                    1
                                 
                              
                           , 
                              
                                 
                                    W
                                 
                                 
                                    2
                                 
                              
                            is constructed similarly using 
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                           . Notice that 
                              
                                 
                                    W
                                 
                                 
                                    2
                                 
                              
                              =
                              R
                              (
                              
                                 
                                    W
                                 
                                 
                                    1
                                 
                              
                              )
                           . Next, 
                              
                                 
                                    U
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    1
                                 
                              
                            are the arbitrary, orthonormal axes to 
                              
                                 
                                    W
                                 
                                 
                                    1
                                 
                              
                            axis. 
                              
                                 
                                    U
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    2
                                 
                              
                            are the equivalent with respect to 
                              
                                 
                                    W
                                 
                                 
                                    2
                                 
                              
                           . Denote 
                              
                                 
                                    ϕ
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    θ
                                 
                                 
                                    1
                                 
                              
                            as 
                              
                                 
                                    i
                                 
                                 
                                    1
                                 
                              
                            transformed to spherical coordinates and broken down to components according to the 
                              
                                 
                                    U
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    W
                                 
                                 
                                    1
                                 
                              
                            coordinate system. Denote 
                              
                                 
                                    ϕ
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    θ
                                 
                                 
                                    2
                                 
                              
                            as 
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                            transformed to spherical coordinates and broken down to components according to the 
                              
                                 
                                    U
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    W
                                 
                                 
                                    2
                                 
                              
                            coordinate system. Since 
                              
                                 
                                    W
                                 
                                 
                                    2
                                 
                              
                              =
                              R
                              (
                              
                                 
                                    W
                                 
                                 
                                    1
                                 
                              
                              )
                           , we get similar but phase shifted functions: 
                              
                                 
                                    ϕ
                                 
                                 
                                    1
                                 
                              
                              (
                              t
                              )
                              =
                              
                                 
                                    ϕ
                                 
                                 
                                    2
                                 
                              
                              (
                              t
                              −
                              
                                 
                                    δ
                                 
                                 
                                    1
                                 
                              
                              )
                           , 
                              
                                 
                                    θ
                                 
                                 
                                    1
                                 
                              
                              (
                              t
                              )
                              =
                              
                                 
                                    θ
                                 
                                 
                                    2
                                 
                              
                              (
                              t
                              −
                              
                                 
                                    δ
                                 
                                 
                                    2
                                 
                              
                              )
                           . Performing DFT on each component: 
                              
                                 
                                    ϕ
                                 
                                 
                                    1
                                 
                              
                           , 
                              
                                 
                                    ϕ
                                 
                                 
                                    2
                                 
                              
                           , 
                              
                                 
                                    θ
                                 
                                 
                                    1
                                 
                              
                           , 
                              
                                 
                                    θ
                                 
                                 
                                    2
                                 
                              
                            and keeping only the magnitudes component eliminates exactly the phase shift. 
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       ϕ
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 ‖
                              
                              =
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       ϕ
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 ‖
                              
                           , 
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       θ
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 ‖
                              
                              =
                              
                                 ‖
                                 F
                                 (
                                 
                                    
                                       θ
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 ‖
                              
                           . Thus, using 
                              ‖
                              F
                              (
                              ϕ
                              )
                              ‖
                            and 
                              ‖
                              F
                              (
                              θ
                              )
                              ‖
                            as feature descriptors makes invariant feature descriptor.

We reduce shape similarity problem to the problem of finding a minimal cost matching in a bipartite graph. Given two shapes 
                           
                              
                                 m
                              
                              
                                 a
                              
                           
                        , 
                           
                              
                                 m
                              
                              
                                 b
                              
                           
                         and 
                           
                              
                                 F
                              
                              
                                 a
                              
                           
                        , 
                           
                              
                                 F
                              
                              
                                 b
                              
                           
                         are their detected features, we define the bipartite graph as the two sets 
                           (
                           
                              
                                 F
                              
                              
                                 a
                              
                           
                           ,
                           
                              
                                 F
                              
                              
                                 b
                              
                           
                           )
                        , whereas edge costs are computed by the 
                           
                              
                                 L
                              
                              
                                 1
                              
                           
                         distance of the magnitudes vector of features. The resulting minimal cost matching gives the best possible pairing of features, thus providing accurate similarity metric for shape matching.

Our implementation is written in C++ using OpenMesh (Bischoff et al., 2002), OpenCV (Bradski, 2000) and LEMON (Dezső et al., 2011) for min cost bipartite graph matching. We make our source code available for public to encourage experimentation and further exploration of the SID shape descriptor, http://sourceforge.net/projects/sphere-intersection-signature/.

We have tested our implementation on various polygonal models. Figs. 1, 8 and 9
                     
                      present a qualitative demonstration of our descriptor effectiveness where similar features are accurately matched together (i.e. colored by the same color).

To further evaluate our descriptors robustness against noise we performed the evaluation presented in Fig. 10
                     . This qualitative evaluation demonstrates that our descriptor handles noise well.

We experimented with different benchmarks in order to quantify the ability of our approach to measure similarity among various models and its robustness against various transformation types. To measure the robustness against non-isometries and noise we used a subset of the SHREC 12 – stability on abstract shapes benchmark (Biasotti et al., 2012). Fig. 11
                      shows that our method has performed successfully on this subset.

To thoroughly evaluate our descriptor against non-rigid deformations we have experimented with the SHREC 11 non-rigid benchmark (Boyer et al., 2011). In Fig. 12
                      we show a subset of our results on this database. The configuration used is presented in Table 1
                     .

Note that for this test we only used the integral of absolute value of the intersection curve since this DB consists mainly of animals with sharp features such as limbs. We perform our experiments on a PC machine with 2 GHz dual core 32bit CPU and 2 GB RAM. We compute shape features in 5 seconds on average for 9.5 K vertex meshes, comparing 2 models takes 14 milliseconds on average.

In Fig. 13
                         and Table 2
                         we provide a comparison of our method with state-of-the-art techniques running on the SHREC 11 non-rigid benchmark. HKS and Harris-3D are shown as examples for local feature detectors that extract meaningful interest points, as demonstrated in Tombari et al. (2013), and MeshSIFT is shown as an example for state-of-the-art local feature descriptor with high performance results.

We discuss our comparison with respect to each method in detail:

In SHREC11 (Boyer et al., 2011) the authors of Harris3D chose to use a geodesic map scheme. After detecting interest points by the Harris3D method, a geodesic map is constructed by considering normalized geodesic distances between all pairs of interest points. In contrast to considering mere scalar distances between keypoints, SID considers the geometry of the features themselves. We attribute the superiority of SID on Harris3D to the usage of fine feature geometry rather then distances.

HKS uses a descriptor comprised of samples along the continuous representation of the Heat Kernel Signature. SID also uses discrete sampling of functions (
                                 ϕ
                                 (
                                 t
                                 )
                                 ,
                                 θ
                                 (
                                 t
                                 )
                              ), but it compacts the descriptor even further by performing DFT. Thus, HKS takes a descriptor of size 100 whereas SID takes a descriptor of size 18 ((2ϕ coefficients + 4θ coefficients) ⁎3 radii taken). Using a descriptor of a larger size can indicate “unimportant” information carried in each descriptor, thus making the comparison between features more difficult. We suggest that SID outperforms HKS due to the descriptors distilled feature representation.

While SID intersects the surface at predefined radii, MeshSIFT uses the entire local neighborhood of a keypoint for computing the descriptor. Thus, MeshSIFT captures the entire area of the surface. It is up to the user of SID to manually choose correctly the predefined radii of the spheres, otherwise, some area of the shape might not be sampled.

In order to further explore the differences between SID and MeshSIFT we perform a comparison of features detected by each method on various classes of models (see Fig. 14
                              ). We used MeshSIFT (Smeets et al., 2013) source code supplied by the original authors with default parameter setting (other settings were experimented as well, but yielded poorer results). For the comparison we use several class of models – abstract shapes with round curves (a, b), biological models (c, d), abstract shapes with straight angles (e, f), and CAD models (g, h). MeshSIFT results are depicted in first and third columns as dark models, while SID results are depicted in second and forth columns as bright models. Although both methods are not symmetry-aware, SID detects same features on models with self symmetry while MeshSIFT does not, which makes SID more predictable and reproducible. This is particularly emphasized in (a), (e) and (f). Furthermore, SID chooses meaningful keypoints that are salient and generally not flat while MeshSIFT detects both sharp and flat features, this is particularly emphasized in (c) and (h). Another interesting observation is that on some models MeshSIFT can choose very few keypoints which may lead to sub-optimal description of a mesh, this is particularly emphasized in (b) and (g).

Another important advantage of SID over MeshSIFT are runtimes, Table 3
                               illustrates that SID is up to 100x faster than MeshSIFT.

To conclude our comparison with MeshSIFT we suggest the following, SID offers benefits over MeshSIFT such as speed, meaningful keypoint selection and consistency of keypoint selection. Nevertheless, we observed a slightly better performance of MeshSIFT over SID in a specific class of models (i.e, SHREC 11 models are biological with non-rigid transformations) where parameters may be carefully tuned.

Limitations of our method include taking only a single intersection curve even if the sphere-to-surface intersection results in several curves. We limit the negative effect of this limitation by choosing this curve consistently by choosing a small enough initial sphere radius and Δr (see Section 4.1.1). As an evidence, in all of our experiments we did not encounter a jitter of the intersection curve, namely, a situation in which the chosen intersection curve “jumps” between several possible intersection curves.

A further limitation is that feature matching false positives are possible, since we consider only the magnitudes and not the phases of the transformation of the intersection curve. However, we chose to use only the magnitudes since we aimed to minimize dimensionality of the descriptor and we observed empirically that the magnitude carry most of the important information.

Additional limitation of our implementation is support for watertight triangular meshes only.

We have presented a novel shape descriptor for efficient matching in large 3D databases and reported experimental analysis for its performance on various datasets. Our shape descriptor is highly distinctive, as it captures the entire (2π) relative curvature of the neighborhood of a point. It allows even a single feature to find a correct match with good probability in a large set of features. Our shape descriptor is compact as it represents the intersection of a sphere with a surface as 2 1D curves. The sphere intersection operation is simple and relies only on the point position, thus can be defined robustly everywhere on a surface. The use of a 2D image based representation allows efficient processing using image processing algorithms. Our experimental results show that our descriptor manages to capture the similarity among various dataset and is robust against various types of deformations.

The scope of future work includes exploring additional more feature detection schemes, incorporating different techniques that capture the topological relation among the features of the model to the graph matching, enhancing our method with smart selection of radii to achieve scale invariance, performing soft clustering for use of bag of features approach, handling many intersection curves for each sphere, extending the presented descriptor to handle non-watertight and point cloud datasets and evaluating the descriptor with respect to new applications.

@&#ACKNOWLEDGEMENTS@&#

This work was supported by grants from the Lynn and William Frankel Center for Computer Sciences, Ben-Gurion University, Israel 428/11, as well as a grant from the Israeli Science Foundation. The authors would also like to thank the anonymous reviewers for the helpful suggestions and comments.

@&#REFERENCES@&#

