@&#MAIN-TITLE@&#Mathematical programming time-based decomposition algorithm for discrete event simulation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a procedure for simulation with mathematical programming.


                        
                        
                           
                           The method decomposes a mathematical model into smaller submodels easier to solve.


                        
                        
                           
                           The decomposed submodels refer to subsets of consecutive simulated entities.


                        
                        
                           
                           The simulation time with the proposed method is linear in the number of entities.


                        
                        
                           
                           The method has been validated on a large set of different cases.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Simulation

Mathematical programming

Decomposition

@&#ABSTRACT@&#


               
               
                  Mathematical programming has been proposed in the literature as an alternative technique to simulating a special class of Discrete Event Systems. There are several benefits to using mathematical programs for simulation, such as the possibility of performing sensitivity analysis and the ease of better integrating the simulation and optimisation. However, applications are limited by the usually long computational times. This paper proposes a time-based decomposition algorithm that splits the mathematical programming model into a number of submodels that can be solved sequentially to make the mathematical programming approach viable for long running simulations. The number of required submodels is the solution of an optimisation problem that minimises the expected time for solving all of the submodels. In this way, the solution time becomes a linear function of the number of simulated entities.
               
            

@&#INTRODUCTION@&#

Mathematical programming has been proposed by Schruben (2000) as an alternative technique to simulating Discrete Event Systems (DESs). Schruben represents the behaviour of a G/G/1 system with a Linear Programming (LP) model that has, as its objective function, the sum of the start and completion times for all of the customers that enter the System. As constraints, the model has the set of temporal inequalities that model the precedence between two consecutive customers. The starting and finishing times are the decision variables of the problem. A simplified version (with finishing times as the only decision variables) of the original Schruben’s model for a G/G/1 system is as follows:
                        
                           (1)
                           
                              
                                 min
                              
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              s
                              .
                              t
                              .
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              ⩾
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              
                              ∀
                              i
                           
                        
                     
                     
                        
                           (3)
                           
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              ⩾
                              
                                 
                                    t
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                              i
                              =
                              1
                              ,
                              …
                              ,
                              N
                              -
                              1
                           
                        
                     where N is the number of customers that visit the system. The arrival time a
                     
                        i
                      and service time t
                     
                        i
                      of each customer i (with i
                     =1,…, N) are parameters of the model. Their values can be known from a given data set or can be randomly generated from probability distributions. The solution of this problem provides the values for the decision variables y
                     
                        i
                      that are the completion times of each customer. Once the problem has been solved, from the values of the decision and slack variables, it is possible to construct the simulated sample path and to calculate the system performance measures. To accomplish this goal, LP models for representing tandem queuing systems and scheduling problems (Chan and Schruben, 2003, 2008) and pull control systems (Alfieri and Matta, 2012) have been proposed in the literature.

The major drawback of mathematical programming models for simulation is the computational burden that is encountered in some cases. Some complex DESs, in fact, require integer variables to be easily modelled, but this requirement can result in unacceptable solution times because the model becomes a Mixed Integer Linear Program (MILP). In addition, a very large computational effort is necessary for long runs because of the relationship between the number of decision variables and the number of simulated entities. In this case, even if the model is an LP model, the time (i.e., the computational time to solve the mathematical programming model) is a non–linear function (exponential in the worst case) of the number of customers that are simulated in the system. For example, as N in the G/G/1 system increases, the number of variables y
                     
                        i
                      and the number of constraints in the inequalities (2) and (3) also increase. Hence, the mathematical programming approach appears to be applicable only for small instances. How to address long runs when mathematical programming is adopted for simulation is the topic of the current work.

This paper proposes an algorithm that allows extending the use of mathematical programming to long runs. We show its application by using two well-known systems, G/G/1 and tandem queues. We want to highlight that our aim is not to simulate such systems quickly; instead, our aim is to propose a way to speed up a completely different method of simulation, i.e., mathematical programming-based simulation. As is clear from the computational experiments, our approach is still slower with respect to standard simulation, but such a difference in terms of the computational time is compensated by several advantages (Chan and Schruben, 2008; Matta, 2008). Among these advantages, the most relevant are (1) the possibility of easily performing sensitivity analysis to evaluate the effect of parameter changes (instead of using gradient estimation, as in a standard simulation) and (2) the ease of integrating simulation and optimisation into a unique framework (thus allowing a faster convergence to a near-optimal solution).

The algorithm is a time-based decomposition that splits the mathematical programming (simulation) model into a number of submodels that are solved sequentially. To accomplish this goal, the key point is to create subsets of entities and solve a single model for each subset, thus exploiting the typical super-additivity of computational time functions. Specifically, the algorithm uses the solution of the first submodel to initialise the second submodel, and so forth, until the last submodel is solved. The number of submodels is the solution of an optimisation problem that minimises the expected time to solve all of the submodels. The main result is that the solution time is linearised, i.e., the time is a linear function of the number of simulated entities. Special time instants (such as regeneration points) can be used to decompose the overall model into submodels, thus further enhancing the efficiency of the approach.

The structure of this paper is as follows. The problem that we study and the developed solution method are reported in Sections 2 and 3, respectively. Sections 4 and 5 contain the application of the method to specific systems. Section 7 concludes the paper.

Given a DES for which we want to study the performance using a simulation approach, different mathematical programming models can be formulated to represent its dynamic behaviour (Chan and Schruben, 2008). Consider an LP or MILP model that simulates the evolution of N entities in a DES. The entities can represent parts in a manufacturing system, failures in a maintenance systems, etc. The objective function of the model is the sum of the starting and finishing events that occur in the system, regardless of the type of the event. These time occurrences are the decision variables of the optimisation problem. Decision variables are constrained to a set of inequalities that describe the systems behaviour. The mathematical programming model can be written in the following standard form:
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          
                                             min
                                          
                                          
                                       
                                    
                                    
                                       
                                          f
                                          (
                                          x
                                          )
                                       
                                    
                                 
                                 
                                    
                                       
                                          s
                                          .
                                          t
                                          .
                                          
                                       
                                    
                                    
                                       
                                          g
                                          (
                                          x
                                          )
                                          =
                                          0
                                       
                                    
                                 
                              
                           
                        
                     where g is a vector of functions that describes the system constraints. Functions in g depend on the decision variables x and on the duration of the activities in the system. The durations are assumed to be known in advance (Schruben, 2000).

Each constraint in the model is associated with at least one entity in the simulated system. Thus, it is possible to cluster inequalities using the entities as grouping factors. The first group of constraints (g
                     1) refers to entity one, the second (g
                     2) to entity two, and so on. Using this grouping concept, we can rewrite the mathematical programming model as follows:
                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          
                                             min
                                          
                                          
                                       
                                    
                                    
                                       
                                          f
                                          (
                                          x
                                          )
                                       
                                    
                                 
                                 
                                    
                                       
                                          s
                                          .
                                          t
                                          .
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                          
                                          (
                                          x
                                          )
                                          =
                                          0
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                          …
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                          
                                             
                                                g
                                             
                                             
                                                N
                                             
                                          
                                          (
                                          x
                                          )
                                          =
                                          0
                                       
                                    
                                 
                              
                           
                        
                     where g
                     
                        i
                      is the vector of the functions that represent the inequalities that are related to the ith entity. Depending on the system, there can be coupling constraints, i.e., there can be constraints that contain different entities, especially when finite capacity conditions are present. In this case, g
                     
                        i
                      is the vector of the functions that are mainly (but not only) related to the ith entity. In the G/G/1 model that is presented in Section 1, the vector of functions g
                     
                        i
                      is represented by Eqs. (2) and (3). The number of constraints increases as the number of simulated entities increases. The number of entities also affects the number of decision variables. Therefore, the complexity of the model is closely related to the length of the simulation.

As a consequence, as the system becomes more complex, the solution time increases due to the increase in the number of decision variables and constraints. We can thus say that, for long runs, using mathematical programming is not a viable approach for simulation because of the unaffordable computational time.

However, it is possible to notice that the model based on clustered inequalities has an interesting form. Indeed, the problem can be divided into several subproblems, each of which represents a portion of the original complete model; each subproblem is not related to a subsystem of the underlying DES but instead involves a specific time window. This property can be exploited to develop solution methods that are based on decomposition in submodels. The main benefit of this approach, as described in the following sections, is that solving the submodels is usually less time consuming than solving the whole mathematical programming model and does not lose accuracy in the results.

@&#METHOD@&#

This section describes the time-decomposition approach used to solve the mathematical programming model that is formulated in (5). The approach is based on the simple idea of decomposing the complete model into many simpler submodels that can be solved in a shorter amount of time.

As explained before, the proposed approach can be applied to mathematical programming models that can be used as an alternative way of simulating a specific class of DESs. The main characteristics that these DESs are assumed to have are the use of static rules for dispatching entities and the fixed, and known in advance, sequence of entities that move through the system (Alfieri and Matta, 2012). This class of DESs is large and contains several systems that are relevant in practices such as production lines, supply chains, assembly systems, etc.

Let us decompose the general model (5) into z different submodels. Theoretically, z can be chosen between one (no decomposition) and the number of simulated entities N. Each submodel s
                        =1,…, z refers to a batch that has a number b
                        
                           s
                         of entities. Differently from the definition of batch used in output simulation analysis (Law, 2007), in our case a batch refers to a set of entities derived from the time-splitting of the simulation. Let Ω
                        
                           s
                         be the set of entities that refer to submodel s. The union of the submodels must cover all of the entities, i.e., 
                           
                              
                                 
                                    ⋃
                                 
                                 
                                    s
                                    =
                                    1
                                 
                                 
                                    z
                                 
                              
                              
                                 
                                    Ω
                                 
                                 
                                    s
                                 
                              
                              =
                              {
                              1
                              ,
                              …
                              ,
                              N
                              }
                           
                        . Remember that each submodel s corresponds to a portion of the whole simulation, specifically the part of the simulation that is related to entities in the set Ω
                        
                           s
                        . Because the entity sequence is fixed and cannot be changed, each Ω
                        
                           s
                         must contain a set of consecutive entities.

Solving each submodel independently is not a good approach because the generic submodel s must consider the initial status of the system when the first entity in Ω
                        
                           s
                         enters the system. This initial status depends on the output of the already solved submodels, i.e., on how many entities of the previous submodel are still in the system. This dependence occurs because the constraints might contain different entities and, hence, might also contain the entities that were considered in the previous submodel. Therefore, the solution of a submodel must consider the information that comes from the previous submodels. This interrelationship is modelled by introducing a new set of constraints that is constructed based on the submodel that was previously solved. For example, when at the (simulated) time the first entity of submodel s enters the system, some entities of submodel s
                        −1 are still there some entities in s might be blocked and have to wait for the entities from s
                        −1 to leave the system. This new set of constraints is denoted by ϒ, and its construction depends on the specific structure of the modelled system.

The mathematical programming formulation for submodel s can be written as
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                min
                                             
                                             
                                             
                                                
                                                   f
                                                
                                                
                                                   s
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   s
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                             
                                             
                                                
                                                   g
                                                
                                                
                                                   s
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   s
                                                
                                             
                                             )
                                             =
                                             0
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   ϒ
                                                
                                                
                                                   s
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   h
                                                
                                                
                                                   s
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   s
                                                
                                             
                                             )
                                             =
                                             0
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        Both the objective function and the constraints refer only to the entities that are contained in the submodel. The additional constraint set ϒ
                           s
                         puts into a relationship the entities of the current portion of the simulation with the entities present in the previous submodels; the function h
                        
                           s
                         is specific for the modelled system. For the first submodel, the set ϒ1 is obviously empty if we assume an empty system at the (simulated) initial time.

As we clarify next, the instantiation of each set ϒ
                           s
                         requires a non-negligible time that can be avoided if the submodels are created based on regeneration points, i.e., the time instants at which the system returns to a predefined starting condition. In real systems, such points are not practical and easy to find; however, this structure can be considered an alternative way to partition into submodels.

Let ϕ
                        
                           s
                         be the time that is needed to solve submodel s (LP time in the following). Because each submodel is an LP, time ϕ
                        
                           s
                         is the time for solving a linear programming problem. Such a time is known to be, on the average, a polynomial function of the number of decision variables (Schrijver, 1998) that, in our problem, are related to the number of simulated entities. Most of the literature results report an average case efficiency of O(n
                        3) for the simplex methods and O(n
                        3.5) for the interior point methods. However, the shape and order of the LP time function strictly depend on the specific model to be solved and on the exact algorithm used. For example, Adler and Meggido (1985) proposed a simplex algorithm that requires a number of steps that are bounded by a quadratic function in the number of constraints or variables, depending on which of the two dimensions is the smallest.

Regardless of the order of the polynomial function that bounds the average-case performance, the LP time is a function of the number of entities b
                        
                           s
                         that are considered in the submodel. Indeed, as z increases, each submodel becomes simpler because it contains fewer entities, and the LP time should be smaller. The function ϕ
                        
                           s
                         is assumed to be random with an unknown distribution. In the case of an equal number of entities in each submodel, the LP times of the submodels are assumed to be independent and identically distributed. The total time to solve all of the submodels (i.e., the sum of all ϕ
                        
                           s
                        ) is denoted with ϕ
                        
                           T
                         and is a random variable that depends on b
                        
                           s
                         of each submodel s. As the number of submodels becomes sufficiently large, we know from the central limit theorem that ϕ
                        
                           T
                         can be approximated by a normal distribution.

In addition to the solution time, each submodel also requires a time φ
                        
                           s
                         for the input and output of the data (I/O time in the following). This time is a random variable and depends on the number of constraints in ϒ
                           s
                         that must be added to the submodel s before solving it and on the storage of the solution that is needed to create the set of constraints ϒ
                           r
                         (r
                        >
                        s) for the next submodels. The number of constraints in ϒ
                           s
                         also depends on the number of entities b
                        
                           s
                         in submodel s.

The I/O time strictly depends on the number of data manipulations that are executed to feed ϒ
                           s
                         to the submodel and to store its results. As the number of entities in the submodel increases, more constraints are contained in ϒ
                           s
                         and more time is required to provide inputs and store the results. However, because the I/O time is, in this case, a “reading & writing” time, the increase is reasonably assumed to be linear in b
                        
                           s
                        , i.e.,
                           
                              (6)
                              
                                 
                                    
                                       φ
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 
                                    
                                       α
                                    
                                    
                                       0
                                    
                                 
                                 +
                                 
                                    
                                       α
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       s
                                    
                                 
                                 +
                                 
                                    
                                       ∊
                                    
                                    
                                       φ
                                    
                                 
                                 ,
                              
                           
                        where coefficient α
                        1 is bounded to be non-negative, and ∊
                        
                           φ
                         is the random noise. The total I/O time φ
                        
                           T
                        , which is the sum of the single values φ
                        
                           s
                         of each submodel, is a random variable. In case of an equal number b of entities in each submodel, it can be written as
                           
                              (7)
                              
                                 
                                    
                                       φ
                                    
                                    
                                       T
                                    
                                 
                                 =
                                 
                                    
                                       α
                                    
                                    
                                       1
                                    
                                 
                                 N
                                 +
                                 
                                    
                                       α
                                    
                                    
                                       0
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       b
                                    
                                 
                                 +
                                 
                                    
                                       ∊
                                    
                                    
                                       φ
                                    
                                 
                                 .
                              
                           
                        Additionally in this case, for sufficiently large values of z, function φ
                        
                           T
                         can be approximated by a normal distribution.

If the decomposition exploits the presence of regeneration points, the I/O time reduces to zero; however, to find regeneration points can be difficult and time consuming. Hence, in complex real cases, the trade-off between the time to find the regeneration points and the time to find the best number of submodels plus the total I/O time must be carefully evaluated. Additionally, the dimensions of the submodels that are based on the regeneration points must be closely considered: if they are too large, then the savings in the total I/O time are overwritten by the larger total LP time. The case of regeneration point decomposition is not addressed hereinafter.

If no special decomposition points, such as regeneration points, are considered, then partitioning entities into subsets of different cardinality b
                        
                           s
                         for each s can be impractical and can make little sense in a real context. Thus, in the following, we consider only the special case in which all of the submodels have the same number of entities, i.e., b
                        
                           s
                        
                        =
                        b ∀s
                        =1,…, z.

Our aim is to find a partition of the N entities into z subsets that minimises the total time (i.e., the sum of the LP time and the I/O time). This goal can be achieved by finding a value of b that allows us to efficiently solve each submodel. For linear programs, it is known that the maximum efficiency (in terms of computational time) is reached for small complexity models, i.e., when the number of variables and constraints is small. In fact, when the complexity is small, the solution time of an LP model has an almost linear dependence with the number of variables. The reason for this behaviour relies on the fact that the solution time is, in general, a polynomial function. Any polynomial function f(x) changes its slope as the value of x increases and, then, the first order approximation will be less and less accurate as x becomes larger and larger.

Let us define b
                        
                           max
                         as the value of b such that, for any b
                        ⩽
                        b
                        
                           max
                        , the function ϕ
                        
                           s
                         is linear. In this case, any function ϕ
                        
                           s
                         can be well approximated as:
                           
                              (8)
                              
                                 
                                    
                                       ϕ
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 
                                    
                                       β
                                    
                                    
                                       0
                                    
                                 
                                 +
                                 
                                    
                                       β
                                    
                                    
                                       1
                                    
                                 
                                 b
                                 +
                                 
                                    
                                       ∊
                                    
                                    
                                       ϕ
                                    
                                 
                                 ,
                              
                           
                        and
                           
                              (9)
                              
                                 
                                    
                                       ϕ
                                    
                                    
                                       T
                                    
                                 
                                 =
                                 
                                    
                                       β
                                    
                                    
                                       1
                                    
                                 
                                 N
                                 +
                                 
                                    
                                       β
                                    
                                    
                                       0
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       b
                                    
                                 
                                 +
                                 
                                    
                                       ∊
                                    
                                    
                                       ϕ
                                    
                                 
                                 .
                              
                           
                        If b
                        >
                        b
                        
                           max
                        , Eqs. (8) and (9) are no longer valid. For this reason, it is necessary to choose b
                        ⩽
                        b
                        
                           max
                         to have the total LP time linear in N. Conversely, the batch length b cannot be very small because φ
                        
                           T
                         is an inverse relationship in b (as expressed by Eq. (7)), and solving z submodels requires a longer I/O time than solving the complete model. The best value for b is then exactly b
                        
                           max
                        .

An estimate of b
                        
                           max
                         can be found by solving the problem for different values of b and testing the adequacy of the linear model. The value b
                        
                           max
                         can be chosen as the last value of b after which a linear model is no longer valid.

The overall algorithm for finding the optimal solution to the LP model that represents the DES dynamic behaviour is the following:
                           
                              1.
                              
                                 Setting. Let b
                                 0, δ and r be positive integer parameters and assign to them each an initial value. Let γ be a non-negative continuous parameter in the interval (0,1), and assign it an initial value.


                                 Initial experiments. Solve r different submodels (using the equations in Section 3.1) for each batch length b
                                 =
                                 b
                                 0
                                 +(m
                                 −1)δ, with m
                                 =1, 2, 3. Collect the time to solve each LP problem ϕ
                                 
                                    s
                                 , with s
                                 =1,…, 3r. Set the batch length b
                                 =
                                 b
                                 0
                                 +2δ.


                                 Linear fitting. Assume that the regression linear model (8) fits the data pair (b,
                                 ϕ
                                 
                                    s
                                 ), and test the adequacy of this assumption with the Lack of Fit test at the γ confidence level (Montgomery and Peck, 1991). If a linear model is valid and the number of customers that remain to be simulated is larger than b, then increase the batch length b to b
                                 +
                                 δ, solve the other r different submodels, and re-test the linearity. If linearity does not fit with the data, then assign b
                                 
                                    max
                                 
                                 =
                                 b
                                 −
                                 δ and go to step 4.


                                 Solution. Solve sequentially one submodel at a time, with a constant batch length of b
                                 
                                    max
                                 .

At the beginning, the algorithm uses a three-level experiment for fitting a linear model with the Lack of Fit test. If the linearity assumption cannot be rejected, then a new experiment level is added until the null hypothesis of linearity is rejected.

In steps 2 and 3, no computational time is lost because the r submodels solved for level m are not different realisations of the same submodel; instead, they are distinct submodels that are solved one after the other. In this way, the simulation progresses as the submodels are successively solved.

The Lack of Fit test is based on partitioning the residual sum of squares into two components, the sum of squares due to pure error and the sum of squares due to lack of fit. The relative weight of these two components is then assessed using the Fisher statistic. More details can be found in Montgomery and Peck (1991).

The Lack of Fit tests that are executed at different iterations are not independent. This dependency increases the probability of stopping the iterations in the linear part because the probability of committing at least one Type I error over all of the tests increases iteration by iteration. Alternatively, sequential testing procedures could be adopted (Bechhofer et al., 1995).

We consider the classical G/G/1 queue with generally distributed random arrival and service times. A number N of customers that enter the system and are served is considered. Customer i
                        =1,…, N arrives at time a
                        
                           i
                        , waits in the queue if the unique server is busy, and then leaves the system at time y
                        
                           i
                        , when its service is finished. The queue can accommodate an infinite number of customers, and the First In First Out (FIFO) rule is adopted.

The LP model of this system is represented by Eqs. (1)–(3), which are introduced in Section 1. Given customer i, inequalities (2) and (3) together represent the vector of functions g
                        
                           i
                        . In the following, we refer to this model as the complete model.

The LP model of the G/G/1 system can be decomposed in a straightforward way because the interdependence between the submodels can easily be captured by simple initial conditions. Let us decompose the complete model into z submodels, with each submodel containing a set of customers Ω
                        
                           s
                        
                        ⊂
                        Ω. The customers that are in submodel s must follow, according to the FIFO rule, the customers in submodel s
                        −1. However, it can happen that a customer of submodel s arrives into the system when some customers of submodel s
                        −1 are still there. In this case, it is necessary to introduce an additional constraint that imposes that the starting time of the first customer in submodel s must be greater than or equal to the finishing time of the last customer in submodel s
                        −1.

The mathematical programming submodel s can be written as follows:
                           
                              (10)
                              
                                 
                                    min
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          
                                             
                                                Ω
                                             
                                             
                                                s
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 s
                                 .
                                 t
                                 .
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 ⩾
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 
                                 i
                                 ∈
                                 
                                    
                                       Ω
                                    
                                    
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 
                                 i
                                 ∈
                                 
                                    
                                       Ω
                                    
                                    
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       f
                                    
                                 
                                 ⩾
                                 d
                                 +
                                 
                                    
                                       t
                                    
                                    
                                       f
                                    
                                 
                              
                           
                        where parameter d is set to the departure time of the last customer of submodel s
                        −1. The set of the entities in the submodel is defined as 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    s
                                 
                              
                              =
                              
                                 
                                    
                                       ∀
                                       i
                                       :
                                       i
                                       =
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             s
                                             -
                                             1
                                          
                                       
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                       
                                       +
                                       1
                                       ,
                                       …
                                       ,
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                          
                                             s
                                          
                                       
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        , where b
                        
                           j
                         is the number of customers that are contained in submodel j. Constraint (13) models the dependence on the previous submodel and allows us to apply the proposed decomposition algorithm. Customer 
                           
                              f
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    =
                                    1
                                 
                                 
                                    s
                                    -
                                    1
                                 
                              
                              
                                 
                                    b
                                 
                                 
                                    j
                                 
                              
                              +
                              1
                           
                         is the first customer of submodel s. Referring to Section 3, constraints (11) and (12) represent the vector of functions g
                        
                           s
                        , which are related to the entities in Ω
                        
                           s
                        , while Eq. (13) is the set ϒ
                           s
                         of initial conditions.

In this section, we first consider a terminating simulation of a high traffic intensity single server queue with exponential interarrival and service times. The utilisation rate of the queue is ρ
                        =1. This case refers to an unstable queue, which is the typical situation that is studied when one is interested in traffic pulse behaviour.

This system has been simulated by solving the complete LP model that is described in Section 4.1 and the decomposed submodels described in Section 4.2. Linear programs have been solved using the dual simplex algorithm of IBM ILOG CPLEX.

The computational time for solving the complete model is a non-linear function of the batch length b. Fig. 1
                         reports the average total time (in seconds) as a function of a constant batch length for different levels of N. One hundred independent experiments were executed for each point shown in the graph. The batch length that minimises the total time function is independent of the number of customers, N. On the left of the minimum, the function assumes high values, which are mainly due to the behaviour of the term N/b in the I/O time. On the right, instead, the function increases linearly.

The graph in Fig. 2
                         shows the details for N
                        =100,000 and plots the average values of ϕ
                        
                           T
                         and φ
                        
                           T
                         as a function of b. The I/O time is an inverse function of b for small values of b; then, for increasing values of b, the I/O time tends asymptotically to a constant value, according to Eq. (7). The LP time behaves similarly, according to Eq. (9), but with a small weight on the term that contains the inverse relationship in b.


                        Fig. 3
                         shows the mean (top) and total (bottom) LP time and the number of simplex algorithm iterations; the mean values are calculated over the z submodels. The mean LP time and the mean number of iterations are quadratic and linear functions in b, respectively. It is easy to show that the total number of iterations (i.e., the total number of simplex algorithm iterations to solve the z submodel) asymptotically approaches the number of customers N multiplied by the constant slope of the mean number of iterations.

The decomposition algorithm has been applied in a second experiment in which we considered a system with interarrival times that are uniformly distributed between 1 and 10 time units and service times that are uniformly distributed between 1 and 5 time units. The algorithm has been executed with the following parameters: b
                        0
                        =100, δ
                        =100, γ
                        =0.95 and r
                        =50. These parameters were chosen on the basis of a preliminary design of experiments. Fig. 4
                         shows the average total time (in seconds) versus the batch length identified by the algorithm in the experiments, with the factor δ at levels 100 and 1000 and the factor r at levels 10 and 50. The number of independent replications were 10, N
                        =5,000,000 and b
                        0
                        =100. The chosen values of δ and r (i.e., 100 and 50, respectively) correspond to the minimum reached for small values of b (Fig. 4).

Once the parameters b
                        0, δ, γ and r were chosen, the algorithm was applied on 100 independent replications for different values of N, and the average total time is shown in Fig. 5
                        . The computational time becomes a linear function of the total number of customers in the system when the decomposition algorithm is applied.

Both the computational time components, i.e., the total LP time and total I/O time, are linear in N, and the total time for the I/O is higher than the total LP time. This is due to the higher efficiency of the simplex algorithm on the simulated system with respect to data manipulation.

Obviously, reducing the slope of the I/O time and LP time (i.e., increasing the manipulation and solution efficiency) increases the overall efficiency of the solution procedure. The I/O time can be improved by writing optimised routines for data manipulation, and the LP time can be reduced by changing the optimisation algorithm. For example, interior point methods are known to be more efficient than the simplex method for large problems.

We consider a tandem queuing network with J single–server stages, on which N identical customers must be processed. The FIFO policy is used to sequence customers at each stage of the line; hence, in practice, no scheduling problem must be solved. The arrival time a
                        
                           i
                         of customer i to the line and its processing time t
                        
                           ij
                         at each stage j are assumed to be known. Because of the FIFO policy, a
                        
                           i
                         
                        ⩽
                        a
                        
                           i+1 for each customer i. After having been processed at the first stage, customers proceed to the second stage and then move to the third stage, and so forth, until they visit the last stage and eventually leave the system. The completion time of customer i at stage j is denoted by y
                        
                           ij
                        .

We consider no balking rate for the system, which implies that the capacity of the first stage (the server and queue positions) is infinite. In contrast, the capacity of stage j (j
                        ⩾2) is bounded to be at a maximum c
                        
                           j
                        . If the server in stage j is busy with customer k, then customers i
                        >
                        k must wait in queue at stage j; because of the finite capacity of the queue, they eventually can block the server at stages j
                        −1, j
                        −2, and so on. With respect to the blocking phenomenon, the blocking before service control rule is assumed for the servers (Dallery and Gershwin, 1992).

The servers are perfectly reliable, and the transportation times are considered to be negligible or are already included in the service times. Finally, for the sake of simplicity, the last stage is never blocked; thus, customers that complete their processing in the last stage can always leave the system. These assumptions can be easily relaxed and do not limit the generality of the presented results.

This system can be simulated by the following linear programming model, which can be obtained from the formulation of Chan and Schruben (2003):
                           
                              (14)
                              
                                 
                                    min
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          J
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 s
                                 .
                                 t
                                 .
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       1
                                    
                                 
                                 ⩾
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       1
                                    
                                 
                                 
                                 ∀
                                 i
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       +
                                       1
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       1
                                       ,
                                       j
                                    
                                 
                                 
                                 ∀
                                 j
                                 ,
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 N
                                 -
                                 1
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 
                                 ∀
                                 i
                                 ,
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 J
                                 -
                                 1
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 N
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 J
                                 -
                                 1
                              
                           
                        
                     

The objective function, as in the case of the G/G/1 queue, is the minimisation of the completion times for each customer at each stage; in other words, the starting times of customers at each stage are not considered because they are implicitly minimised by the minimisation of the completion times.

Eqs. (15)–(18) describe the system dynamics. Specifically, constraints (15) state that parts i can be completed on the first server only if they have arrived at the system and have been processed. Constraints (16) and (17) impose that a server cannot process two different customers at the same time, and a part cannot be processed at two different stages at the same time. Constraints (18) prevent a customer from leaving a stage if the immediate downstream queue is full. The solution of the linear problem provides the optimal values for the decision variables y, i.e., the smallest finishing times. For each i, Eqs. (15)–(18) correspond to g
                        
                           i
                         of Section 2.

The model presented in the previous section can be decomposed into a set of submodels, which are to be sequentially solved. Because the working sequence of the customers is known a priori, the decomposition of the problem is equivalent to partitioning the sequence of customers into subsequences. Each subsequence of customers will be independently solved using the appropriate initial conditions.

The initial conditions are related to the temporal constraints that link the last customers of each submodel s (s
                        =1,…,
                        z) and the first customers of the next submodel (s
                        +1). Indeed, if some customers of submodel s are still in progress in some stages, the customers in submodel s
                        +1 must wait. In other words, the system at the beginning of a simulation can be not empty.

To find the number z of submodels, the procedure described in Section 3 can be used because the procedure is problem–independent. In this section, instead, we focus on the determination of the initial conditions, i.e., on the determination of ϒ.

We assume that we have already chosen the number b of customers in each submodel. The problem is then to identify which customers of the previous submodel are still in the system (and thus influence the initial conditions) when the first customer of a given submodel arrives.

Let s be the current submodel to be solved, and let I
                        
                           prev,j
                         be the number of customers of submodel s
                        −1 that are related to the customers in s at stage j. I
                        
                           prev,j
                         is bounded from above by the total available space in the line (the sum of the maximum queue and the server positions) and from below by 1 (the last customer of the previous submodel). Specifically, we consider the last customer k of submodel s
                        −1. When k enters stage j, only customers i
                        <
                        k that are still in queue at stage j
                        +1 must be considered because only they can cause blocking on k, thus interfering with the flow of customers in submodel s.

If the completion time of the last customer of s
                        −1 is smaller than the arrival time of the first customer of s, submodels s
                        −1 and s are independent, and no initial condition for s is necessary.

Given submodel s, I
                        
                           prev,j
                         can be identified according to the following procedure:
                           
                              1.
                              Solve the LP represented by submodel s
                                 −1, obtaining the completion time y
                                 
                                    ij
                                  for each customer i in s
                                 −1 and each stage j;

For each customer i in submodel s
                                 −1, proceeding backward from i
                                 = (s
                                 −1)b, check
                                    
                                       (a)
                                       if y
                                          
                                             i,j+1
                                          >
                                          y
                                          (s−1)b,j
                                           for at least a stage j, then customer i is constraining;

if y
                                          
                                             i,j+1
                                          <
                                          y
                                          (s−1)b,j
                                           for all stages, then customer i is non-constraining.

Condition (2.b) can be verified also for a number of customers that is smaller than the total number that can be accommodated in the system.

Each submodel must then consider its b customers plus the I
                        
                           prev,j
                         customers that belong to the previous submodel, for each stage j. We decided to consider a different number of influencing customers for each stage, I
                        
                           prev,j
                        , because in this way we can keep the complexity of the submodels low. In fact, if we would have considered a unique I
                        
                           prev
                         that is equal for each stage j, this value would have been the maximum of the I
                        
                           prev,j
                         overall stages.

The I
                        
                           prev,j
                         customers are the first customers of the sequence (because of the FIFO policy), and their service does not have to be considered either in the objective function or in the constraints because they were already optimised in the previous submodel.

Using the notation that was previously introduced, the LP for submodel s (s
                        =1,…,
                        z) is as follows:
                           
                              (19)
                              
                                 
                                    min
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          J
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                          +
                                          
                                             
                                                I
                                             
                                             
                                                prev
                                                ,
                                                j
                                             
                                          
                                       
                                       
                                          b
                                          +
                                          
                                             
                                                I
                                             
                                             
                                                prev
                                                ,
                                                j
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 s
                                 .
                                 t
                                 .
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       1
                                    
                                 
                                 ⩾
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       1
                                    
                                 
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 b
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       +
                                       1
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       1
                                       ,
                                       j
                                    
                                 
                                 
                                 ∀
                                 j
                                 ,
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 b
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 -
                                 1
                              
                           
                        
                        
                           
                              (22)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 J
                                 -
                                 1
                                 ,
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 b
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                       +
                                       1
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 J
                                 -
                                 1
                                 ,
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 b
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                              
                           
                        
                        
                           
                              (24)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       d
                                    
                                    
                                       i
                                       -
                                       1
                                       ,
                                       j
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 J
                                 -
                                 1
                                 ,
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                              
                           
                        
                        
                           
                              (25)
                              
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                       ,
                                       j
                                       -
                                       1
                                    
                                 
                                 -
                                 
                                    
                                       d
                                    
                                    
                                       i
                                       -
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 ⩾
                                 
                                    
                                       t
                                    
                                    
                                       i
                                       ,
                                       j
                                       -
                                       1
                                    
                                 
                                 
                                 j
                                 =
                                 2
                                 ,
                                 …
                                 ,
                                 J
                                 ,
                                 
                                 i
                                 =
                                 1
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       j
                                       -
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       I
                                    
                                    
                                       prev
                                       ,
                                       j
                                    
                                 
                                 ,
                                 
                                 i
                                 >
                                 
                                    
                                       c
                                    
                                    
                                       j
                                       -
                                       1
                                    
                                 
                              
                           
                        
                     

The objective function (19) and constraints from (20)–(23) are the same as the complete model and are solely limited to the customers in the submodel, i.e., they represent the g
                        
                           s
                         vector of functions introduced in Section 3. The last customer in the submodel, for each stage j, is customer b
                        +
                        I
                        
                           prev,j
                        , but both the objective function and the constraints do not consider the first I
                        
                           prev,j
                         customers (for each j). The reason is that they are customers from the previous submodel, and their completion times have already been computed and are represented by parameters d
                        
                           ij
                         for the current submodel. In detail, parameter d
                        
                           ij
                         is the completion time at stage j of customer i, which belongs to the previous submodel s
                        −1. Clearly, d
                        
                           ij
                         corresponds to the values of the variables y in the optimal solution of s
                        −1.

The ϒ constraints that contain the initial conditions are represented by Eqs. (24) and (25). Specifically, Eq. (24) allows the first customer of the current submodel (i.e., part 1+
                        I
                        
                           prev,j
                        ) to be processed in stage j only if stage j has already processed the last customer of the previous submodel (i.e., customer I
                        
                           prev,j
                        ). This condition must be forced in each stage j. Instead, constraints (25) forbid the first c
                        
                           j−1 customers of the current submodel (for each stage j from the second to the last) to leave the stage if the downward buffer is full. If s
                        =1 (the first submodel to be solved), then no initial condition is necessary, i.e., I
                        
                           prev,j
                        
                        =0 and ϒ1
                        =∅.

The decomposition algorithm for the tandem queue has been tested on randomly generated instances with the following characteristics: 5 servers; processing times exponentially distributed with the mean equal to 1 time units for each server; customer interarrival times are exponentially distributed with a mean equal to 0.9 time units; and the buffer capacities are all equal to 5. Linear programs have been solved using the dual simplex algorithm of IBM ILOG CPLEX.


                        Fig. 6
                         reports the average computational times for solving the sequence of submodels as a function of the number of customers b in each submodel; the average is calculated over 100 independent replications. In this case, we consider a single sample path, with N equal to 10,000 and b varying from 6 to 500 (from 6 to 10 b is increased with step equal 1, while from 10 to 500 the step is 5).

For small values of b, the total I/O time is higher than the total LP time, which is reasonable because it refers to data manipulations that are mainly independent of the number of entities in the submodel and are thus not reducible, while the time to solve the submodel is in the linear region. Increasing b, the number of subproblems to be solved decreases, which leads (at the beginning) to a decrease in the I/O time that is larger than the increase in the LP time. Increasing b further, the decrease in the I/O time slows down, while the increase in the LP time speeds up. The total time, hence, first decreases and then increases, which shows that the minimum is in the range of 25−50 customers. This point is toward the end of the linear behaviour of the LP time and also corresponds to the steepest decrease in the I/O time.

A second set of experiments was devoted to evaluating the influence of certain system characteristics on the total computational time. Specifically, we focused on the number of stages in the queue and on the processing time distribution. The algorithm was executed with the following parameters: b
                        0
                        =6, δ
                        =1, γ
                        =0.99 and r
                        =5.

In the first experiment, we increased the number of stages J from 5 to 500, with a step of 25 until J
                           =100 was reached; then, a step of 100 was used. Each stage has the same characteristics in terms of the processing time distributions and the buffer capacity, for the stages in the 5-stage line previously described. Additionally, the customer arrival process is exactly the same as the process observed for the 5-stage line. In fact, for each system, we considered N to be equal to 10,000, with the interarrival time exponentially distributed with a mean equal to 0.9 time units.

For each value of J, 100 replications were considered, and Fig. 7
                            reports how the optimal batch size, b
                           ∗, changes for the different values of J.

It is possible to notice how both the average and the variability of b
                           ∗ decrease as J increases (the figure reports the classical box-plot, with a minimum value, a maximum value, and the 25, 50 and 75 percentiles; the symbol ∗ represents outliers), as expected. In fact, as J increases, the model becomes more complex in terms of the dimensions; hence, to keep the solution time low, the number of entities in each submodel (i.e., b) must decrease.

In Fig. 8
                           , instead, the total solution time is reported (using b
                           ∗ as the batch size), always as a function of J. Hence each point, for each value of J, corresponds to one of the 100 replications for that value of J. It is possible to notice that, as J increases, the solution time also increases. In fact, as shown in Fig. 7, increasing J leads to a decrease in b
                           ∗, but because b
                           ∗ cannot become too small (to avoid that the I/O time increases too much), the system becomes progressively more complex. Additionally, the variability in the time appears to increase with J, which can be explained by considering that because b
                           ∗ decreases, the number of submodels to be solved becomes larger and larger, increasing in this way the variance of the total time.

In the second experiment, we considered the same 5-stage queue, each with a buffer capacity of 5, as the very first experiment of this section, but we change the distribution of the processing time at the five stages. We compared the exponential times of the base case with normal and uniform times. The normal distribution is a truncated one because processing times cannot be negative. For both distributions, we considered a mean time of 1 time unit for each stage, and two levels of variance: 1) high variance, equal to 0.577352; 2) a low variance of 0.0577352. The average exponential interarrival time has been chosen to be equal to 1.17647, to have a utilisation rate of the system of approximately 85%.

In this experiment, N was increased from 100,000 to 600,000, with a step increase of 100,000, and 25 replications for each value of N were performed. For each distribution and each level of variance, the optimal value of b
                           ∗ was determined for the different levels of N. Fig. 9
                            reports the result for the normal distribution with high variance. The number of customers N (i.e., the simulation length) does not influence the average value of b
                           ∗ or its variability. However, the high variance leads to a very high range of variation for b
                           ∗.

Given b
                           ∗, the total solution time has been computed. In Fig. 10
                           , we reported, for the normal case, the ratio (for each replication) between the total time and the length of the simulation N, given different values of b
                           ∗, which were determined using the algorithm. The case with low variance presents a higher concentration of b
                           ∗ values around the minimum, which are less spread out than for the case with high variance. This behaviour can be easily explained: a low variance implies very similar instances (replications) and hence a very stable b
                           ∗; when increasing the variance, replications can be very different from one another, with a possibly very different b
                           ∗.

Finally, how the total time varies as N increases is depicted in Figs. 11 and 12
                           
                           . Specifically, Fig. 11 reports the average total time over the 25 replications for each N. At each replication, the optimal b
                           ∗ is used to solve the problem. As expected, for each distribution, the total time increases as N increases because more or larger subproblems (depending on the value of b
                           ∗ that was determined) are to be solved. Among the tested distributions, the uniform distribution with the lowest variance appears to have, on the average, the smallest total time. Fig. 12 reports the coefficient of variation versus the mean of the total time calculated over the 25 replications; each point refers to a simulation with a different value of N. It is possible to notice that the variability of the total time increases as we decrease the variance of the processing time distribution. This relationship arises because some instances that have a low dispersion of the processing times can be solved in a very short time, such as the instances that have deterministic processing times.

The computational time that was achieved using our algorithm has been compared with the computational time of executing a standard simulation program in ARENA.


                     Fig. 13
                      reports, for the G/G/1 with exponential interarrival and service times studied in Section 4, the standard simulation time in ARENA and the total solution time of the proposed algorithm using the dual simplex and the barrier of IBM ILOG CPLEX.

The slope of the total computational function for the mathematical programming is steeper than the slope of the standard simulation linear time function. However, as a first consideration, all of the time functions are linear. Then, the time difference between the proposed algorithm and the simulation is not large as expected, especially if we consider that no special structure of the submodels has been exploited to develop an ad–hoc (or to use state-of-the art) optimisation algorithm. Additionally, data manipulation has not been optimised. Hence, the time difference could be further reduced. Furthermore, if all of the entities arrive at the system at simulated time zero, common simulation software would encounter big problems (either related to computational time or computer memory) as the number of entities largely increases.

However, despite the time difference, we want to note, once more, that time is not the key issue in using mathematical programming for simulation. First, the use of a mathematical programming-based simulation allows the analyser to perform sensitivity analysis easily, using slack variables. In a standard simulation, the influence of a parameter change can be evaluated only by estimating gradients, which is surely more intricate than sensitivity analysis.

A second advantage lies in the possibility of better integrating simulation and optimisation, using a unique framework. When using standard simulation in a simulation–optimisation context, the two modules are separate, and the search for an optimal system configuration (in a broad sense) can be achieved only by an iterative procedure. In the case of mathematical programming-based simulation, a single mathematical model can be used to both optimise and evaluate the performance of a system (i.e., to simulate the system), thus leading to a faster achievement of a (near) optimal solution. This unique framework is then an undeniable advantage for both practitioners and developers.

These advantages would not be exploitable, however, if only short–run simulations can be tackled using the mathematical programming approach because of the long computational times involved. The possibility of decomposing the overall model into submodels and solving them separately extends the use of the mathematical programming additionally for long-run simulations, which leads to the possibility of exploiting the advantages discussed above in practical cases, also.

Finally, a last observation is necessary. In standard simulation and standard simulation-optimisation, multiple replicates are, in many cases, used as an alternative to a long single run. This possibility can be exploited also in our approach, with the potential advantage that, if the runs are short enough, no decomposition will be necessary to speed up the problems solution. However, when using mathematical programming, there is an important difference between simulation and simulation–optimisation. In simulation, multiple replicates are addressed by simply solving the LP (sub) models several times, once for each sample path. There is no difference, in this case, with standard simulation. In optimisation, instead, each simulation run (i.e., each solution of LP models with different data) will yield a different solution. Hence, when solving for n sample paths, we obtain n different solutions, which cannot be easily averaged compared with when standard simulation is used in a simulation–optimisation framework. However, this difficulty can be overpassed by formulating simulation-optimisation problems under a stochastic programming framework in which each replicate corresponds to a scenario (Matta, 2008).

@&#CONCLUSIONS@&#

In this paper, we considered mathematical programming models for simulating DESs. A time-based decomposition algorithm was proposed to overcome one of the major drawbacks of using mathematical programming to simulate, i.e., the non-linear increase in the computational time as the length of the simulation increases.

The developed algorithm first estimates the best number of submodels into which the complete model should be partitioned and then solves the submodels sequentially, devising, from the solution of each submodel, the initial conditions necessary to solve the next submodel.

Partitioning the complete model into a number of submodels exploits the typical super–additivity of computational time functions and makes the mathematical programming approach usable for long-run simulations.

The algorithm has been tested on the G/G/1 queue system. Numerical results confirm that partitioning an LP model allows us to execute long runs in a computational time that is a linear function of the number of entities. This important result can extend the use of mathematical programming applied to the simulation of DESs. We also applied our algorithm to a tandem queueing system, and the results showed that, additionally in this case, the reduction in the solution time can be substantial.

When compared with a standard simulation, the mathematical programming approach still has a longer computational time. However, having a linearised solution time will allow the use of mathematical programming in a simulation–optimisation context in which different models that address simulation or optimisation or both must be used in a unique framework. Note that, in the simulation–optimisation context, standard simulation models are a black–box that differs from optimisation models in the mathematics that they use and in the software environments in which they are coded. Having a unique framework is undoubtedly an advantage for both practitioners and developers.

Finally, the concept of decomposition is valid for LP and MILP problems. However, the specific systems for which the proposed algorithm can be fully exploited must still be clearly defined. A fixed sequence of entities is a pre-requisite, but additional features can be requested. All of these issues can be subjects for future research.

@&#REFERENCES@&#

