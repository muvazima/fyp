@&#MAIN-TITLE@&#Line-based sunken relief generation from a 3D mesh

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We focus on the problem of direct generation of line-based sunken relief from a 3D mesh.


                        
                        
                           
                           We adopt clipping, chaining and smoothing to make the lines organized in good forms.


                        
                        
                           
                           We use a continuous pitting corrosion method to simulate the cutting paths.


                        
                        
                           
                           The object-based method is flexible for stroke stylization of the engraving lines.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Line drawing

Sunken relief generation

Line engraving

@&#ABSTRACT@&#


               
               
                  Sunken relief is an art form made by cutting the relief sculpture itself into a flat surface with a shallow overall depth. This paper focuses on the problem of direct generation of line-based sunken relief from a 3D mesh. We show how to extract, post-process and organize the messy feature lines in regular forms, applicable for lines engraving on the sculpture surfaces. We further describe how to construct a smooth height field from the input object, and derive a continuous pitting corrosion method to generate the cutting paths. The whole framework is conducted in object-space, making it flexible for stroke stylization and depth control of the engraving lines. We demonstrate the results with several impressive renderings and photographs used to illustrate the paper itself.
               
            

@&#INTRODUCTION@&#

Artists have for centuries studied the skills of using lines to represent, emphasize or exaggerate the shape of 3D objects. In the traditional media such as pencil drawings, cartoon shading, technical illustrations, one of the most fundamental elements of art is the line. Lines also play a critical role in forming engravings and sunken reliefs, the visual contours and shape details of the sculptures are often represented by perceptual salient lines.

Over the past few years, line-based shape depiction has been a popular topic in the area of non-photorealistic rendering (NPR). Researchers have made much progress in lines definition, stroke stylization, lines density control, and so on. In this paper, we adopt some ideas of NPR line drawing, and present a novel approach for line-based sunken relief generation. Sunken relief is largely restricted to the artwork of Ancient Egypt, as shown in Fig. 1
                     . To create a sunken relief, the artist carves the relief sculpture with impressive incised lines. As a whole, the sculpture is set within a sunken area shaped round the outlines. Lines in the sunken relief have the following features: (a) Outlines are carved deeply to describe the overall shape of the object. (b) Contour depth is variable, leading to the changing of shadow thickness under strong sunlight. (c) Decorative lines are engraved on the sculpture surface to represent the object details.

Our goal in this paper is to find a suitable way for the combination of lines extraction and sunken relief generation. The whole framework starts from the feature lines extraction of a 3D mesh. Then, we concentrate on the post-processing of the lines including clipping, chaining, and smoothing. On this basis, the lines are organized in good forms and appearance, appropriate for line engraving with the relief height field. Finally, the input 3D mesh is transformed into three basic layers: a contour line layer to strengthen the sense of outlines, a decorative line layer to represent the relief details, and a smooth base layer to convey 2.5D illusion of the depth. Using a continuous pitting corrosion method, we combine the three layers together and generate the sunken relief with desired line depth and stylization. Fig. 2
                      shows the pipeline of our algorithm.

@&#RELATED WORKS@&#

A variety of techniques dealing with NPR line drawings and relief generation have been investigated, and we will review some methods that are related to our work.

There exist extensive techniques for producing computer-generated line drawings, which can be roughly classified into two categories: image-space and object-space. In image-space, the object is firstly rendered to form an image, and then some filtering operations such as DoG detector and Canny edge detector are used to output the line drawing [1–4]. Image-based approaches do not require costly computation of surface information, and can be easily implemented in graphics hardware. However, image-based algorithms are usually difficult for shape stylization, as the lines are extracted as collections of pixels rather than as complete curves.

In object-space, feature lines are defined by differential equations that show directly on smooth 3D surfaces. Conventional examples include smooth silhouettes, ridges and valleys, suggestive contours, highlight lines, apparent ridges, photic extremum lines, demarcating curves, laplacian lines [5–12], and so on. Since these lines differ in definitions of surface properties, it is hard to say that one type is definitely better than the others. In fact, no single algorithm could match all the drawings perfectly because the line art is always different from one another. In this paper, we choose two simple types of feature lines, contours and suggestive contours, as the original sources of lines input. In NPR, they are familiar to most artists and yet expressive enough to depict shape.

As an artistic medium, relief creates a bridge between 2D painting and 3D sculpting in which shapes are carved on a relatively flat surface. According to the projection degree of the sculpted forms, reliefs can be classified into four types: high relief, mid-relief, bas-relief and sunken relief. Recently, Kerber [13] has presented a survey on computer assisted relief generation.

At present, most studies on digital relief generation are specifically related to bas-relief, and much of research focus has been on the technique of feature details preserving. Since straightforward height field compression on a limited depth range results in the loss of salient shape features in bas-relief [14], some image-based approaches manipulate the compression in gradient domain, followed by a Poisson reconstruction to achieve the final result [15–17], while others in object-space conduct compression directly on the range domain, with fine features extracted and individually recovered in the body [18–20]. However for sunken relief generation, this problem goes in an opposite direction. Note that the overall shape of the relief is emphasized by impressive outlines while detailed features engraved by decorative lines. To give the lines a great sense of impression, the sunken area of the relief should be conducted with little surfaces transition, smooth enough for the integration with engraving lines. In this paper, instead of recovering the fine details, we adopt Gaussian filter to smooth the mesh surfaces, and construct the height field based on Lamberian shading.

Before this work, there have been a few previous methods for line-based sunken relief generation. A close work was done by Sourin [21] on virtual embossing. The author simulates the process of embossing using a functionally based representation of the metal plate and the tools. Pasko et al. [22] also propose several procedural methods for reliefs caving and patterned lattices based on the function representation of geometric objects. The work of Wang et al. [23] is most relevant to ours. The authors propose an image-based framework to produce sunken relief from a known 3D geometry, which transforms the 3D objects into three layers of input to incorporate the contour lines seamlessly with the smooth surfaces. Our work also use 3D objects as the input, but the main difference is that we perform the whole procedures in object-space, which is more flexible for stroke stylization and shape control of the engraved lines. Several testing cases show that we have achieved impressive results.

Our work starts from the feature lines extraction on a smooth 3D mesh, and we focus on two types of lines: contours and suggestive contours [7]. Contours are used to illustrate the outlines of the sunken relief, while suggestive contours describe the interior details of the sculpture. Both of the two line types are generated in terms of the geometry of the surface and the camera.

Contour is known as a fundamental line type that refers to the surface points where the surface normal is perpendicular to the viewing direction. Let M be the input mesh with smooth surfaces, from a current viewpoint c, the contour is defined as the set of points that lie on this mesh and satisfy:
                           
                              (1)
                              
                                 n
                                 (
                                 p
                                 )
                                 ·
                                 v
                                 (
                                 p
                                 )
                                 =
                                 0
                                 
                                 and
                                 
                                 
                                    
                                       k
                                    
                                    
                                       r
                                    
                                 
                                 >
                                 0
                              
                           
                        where p
                        ∈
                        M is a point on the mesh, n(p) is the unit normal at p, v is the viewing vector: v(p)=
                        c
                        −
                        p, and kr
                         is the radial curvature of the surface under the current viewpoint. Different with contours, suggestive contours provide interior details to line drawings and are defined at points with radial curvature of zero that satisfy:
                           
                              (2)
                              
                                 
                                    
                                       k
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 0
                                 
                                 and
                                 
                                 
                                    
                                       D
                                    
                                    
                                       w
                                    
                                 
                                 
                                    
                                       k
                                    
                                    
                                       r
                                    
                                 
                                 >
                                 0
                              
                           
                        where w is the projection of the viewing direction v onto the tangent plane at p, and Dwkr
                         is the directional derivative of kr
                         applied to w.

We loop through all triangles of the mesh to find the contours and suggestive contours. Following Hertzmann and Zorin [5] in generating contours as a continuous path consisting of line segments that cross triangles, we extract lines using interpolated vertex normal. We first check whether n
                        ·
                        v (or kr
                        ) has a different sign at some vertex for each triangle. If so, we interpolate along edges connecting positive-value vertices and negative-value vertices to find zero crossings, then connect the two points to form a line segment.

Line visibility is a general problem in NPR, and many strategies have been proposed. One simple approach is to use ray casting, but the time-consumption is very expensive. OpenGL z-buffering is easy to implement in high performance hardware, but the rasterization from 3D objects to 2D pixels may lead to a loss of precision, resulting in obvious chopped artifacts. Some other hybrid algorithms [24,25] balance the speed and quality, but they compute line visibility with image-space precision.

Besides the lines on the back-facing triangles, part of visibility can be solved locally by checking the sign of kr
                         or Dwkr
                        . However, full visibility needs exact judgment of lines on the occluded front-facing triangle. In this paper, in order to identify visible lines with enough precision, we adopt ray casting algorithm. Firstly, a view-dependent coordinate mapping method [20] is used to map the lines and the mesh from 3D space to screen space. Then, the current scene is partitioned by regular 2D grids with a specified number of rows and columns, and each triangle is arranged in a corresponding 2D grid according to their planar coordinates (the triangles at the border are allowed to be placed in different grids repeatedly). After that, the visibility of the line endpoint can be confirmed by firing a ray from the point to the viewer and checking if it intersects with any triangle in its corresponding grid. In this way, the complexity of the visibility query is reduced to a reasonable level.

So far, we have extracted visible feature lines using the vertex-interpolated normal generator and visibility identification. These lines cannot be directly used for relief engraving despite they are visually smooth in projected screen space. As object-based lines generation algorithms are very sensitive to mesh noises and badly shaped triangles, some potential artifacts such as jagged contour, overlapped short marks and swallowtails (Fig. 3
                        ) often occur. To make the lines organized in good forms and appearances, we take several measures including clipping, chaining and smoothing to promote longer and smoother paths.

Theoretically, the line segments are intended to be linked together to form long, connected polylines in screen space. However, in local region of the polyline, self-intersection may occur among neighboring segments. In this case, we perform a clipping operation to separate the singular fragments from the main path. We loop over all the extracted visual lines, and check whether one segment is intersecting with another. If there exists one or more intersection points, we calculate the precise location and split the intersecting lines into several new segments. To improve the efficiency of data processing, line segment information (e.g. endpoints index, validity for relief generation) and the endpoint information (e.g. planer coordinates, degree, thickness) are stored in parallel list structures, and the degree of each endpoint is determined according to its neighboring segments.

Chaining is a procedural process of linking line segments into long paths, and we complete this task in two phases. In the first phase, we choose a point with degree 1 or 4 (intersection point) as the start point, and join its successive neighbor to form a new polyline, the terminal point degree of which should also be 1 or 4. We repeat this process and obtain new polylines until all the endpoints are traversed. Since the smoothing chains may be broken into several portions due to the clipping operation, we need to reconnect them together to form longer paths in the second phase. For each polyline, we first approximate the tangential direction of the endpoints. If the distance of two endpoints is less than a small ε, and the tangential directions are nearly parallel (the angle usually more than a predefined value 120°), we combine the corresponding polylines into one single chain.

Zigzag lines often occur in badly discrete meshes, as shown in Fig. 3. Inspired by Liu’s algorithm [26], we adopt a rough fairing method to improve the smoothness of the chain. Assuming that an open discrete chain 
                           
                              
                                 
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    N
                                 
                              
                              =
                              (
                              
                                 
                                    P
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    P
                                 
                                 
                                    N
                                 
                              
                              )
                           
                         represents the polygonal connection with N
                        +1 vertices in R
                        2, we define Ki
                         as the relative D-curvature of Pi
                         that can be calculated by:
                           
                              (3)
                              
                                 
                                    
                                       K
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 2
                                 Δ
                                 
                                    
                                       P
                                    
                                    
                                       i
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       P
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 /
                                 
                                    
                                       L
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       L
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 
                                    
                                       Q
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        where Li
                        
                        =||Pi
                        
                        −
                        Pi
                        
                        −1||, Qi
                        
                        =||Pi
                        
                        +1
                        −
                        Pi
                        
                        −1|| and ΔPi
                        
                        −1
                        PiPi
                        
                        +1 is the signed triangle area. When Pi
                        
                        −1, Pi
                         and Pi
                        
                        +1 run counter-clockwise, Ki
                         is defined as positive to indicate that Pi
                         is a convex point, and vice versa. For easy processing, we set the curvatures of two end points P
                        0 and PN
                         to zero. The “bad points” are identified by checking the successive change in the signs of the D-curvatures, which satisfy:
                           
                              (4)
                              
                                 
                                    
                                       K
                                    
                                    
                                       i
                                       -
                                       1
                                    
                                 
                                 ·
                                 
                                    
                                       K
                                    
                                    
                                       i
                                    
                                 
                                 <
                                 0
                                 
                                 and
                                 
                                 
                                    
                                       K
                                    
                                    
                                       i
                                    
                                 
                                 ·
                                 
                                    
                                       K
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 <
                                 0
                              
                           
                        
                     

As illustrated in Fig. 4
                        a, both point A and B are identified as bad points. However, different fairing strategies will be implemented on them. For each SBP (single-bad-point), we modify its position to the center of line Pi
                        
                        −1
                        Pi
                        
                        +1, but for MBP (multi-bad-point), we move the point Pi
                         to the gravity center of ΔPi
                        
                        −1
                        PiPi
                        
                        +1, given as:
                           
                              (5)
                              
                                 
                                    
                                       P
                                    
                                    
                                       c
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       i
                                       -
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       P
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 )
                                 /
                                 3.0
                              
                           
                        
                     


                        Fig. 4b shows a resultant chain after the rough fairing has been applied. It is apparent that the resultant shape (blue) is much smoother than the original one.

We adopt several strategies to control the lines density. In lines extraction phase, we eliminate lines based on a threshold of the view-dependent curvature. After chaining all the visible line segments, we roughly remove the short chains by a predefined segment number or total path length. Furthermore, the users are permitted to delete some useless chains manually. In this way, the number and the density of the chains are semi-automatically under control.

Stylization is a key feature of effective line rendering. In conventional line drawing, stroke styles are often used to give objects a greater sense of depth or dimension. Typical stroke attributes in NPR include thickness [24,27], orientations [5,28,29], density [30,31] and textures [25,32,33]. For sunken relief generation, stroke stylization plays an important role in conveying depth cues, creating varying thickness of contour shadows. In this section, we focus on 3D stroke generation for line engraving.

In 3D space, an engraving stroke can be defined in terms of a chain and a varying cross section at each point, and generated by a sequence of Boolean clipping operations on the background plane, as shown in Fig. 5
                     . To simplify the definition, we approximate the cross section shape using a regular semicircle, in which the maximum engraving depth is set to be half of the stroke thickness.

Determining stroke thickness still remains an open problem in NPR. Since artists draw strokes in many different ways and styles, no single computer-generated method provides a full explanation for the existing artworks [27,34,35]. Similar with Goodwin’s isophote distance approach, we determine stroke thickness as a function of depth z and radial curvature kr
                     . For each contour point p, the stroke thickness is approximated by:
                        
                           (6)
                           
                              T
                              (
                              p
                              )
                              =
                              clamp
                              (
                              z
                              ·
                              (
                              
                                 
                                    k
                                 
                                 
                                    r
                                 
                              
                              +
                              ε
                              )
                              )
                           
                        
                     where ε is a small constant and clamp(·) clamps the thickness to a user-defined range [Tmin
                     ,
                     Tmax
                     ].

We only apply the above function on contour points, but for some border points close to the suggestive contours, the radial curvature kr
                      may approach to zero, leading to stroke thickness frequently saturating at Tmax
                     . In this case, jumping singularities will inevitably occur on the projected 2D chains. To smooth the overall thickness of the chain, Goodwin et al. use a mesh traversal method for very small kr
                     , but the calculation is potentially expensive. We adopt a noise filtering method to improve the computation efficiency. We first construct a thickness path using accumulative chord length for each chain. Then, a fitting curve is approximated based on least-squares (fitting degree is usually from 3 to 5), and the singularity point is detected if its minimum distance to the fitting curve exceeds a given threshold. Finally, the singular thickness is modified to a normal value by linear interpolation on the nearest good points. Since decorative details in sunken relief are usually engraved in uniform style, we employ constant thickness for suggestive contours. To make the lines more visually pleasing, the endpoints thickness is scaled by a tapering factor, and a tapering effect is added to the contour tails, as shown in Fig. 3c.

Height field, also known as depth map, is a 2.5D description of the scene that encodes distance information on a 2D regular grid. To represent a relief, the height field should be constructed closely to the original shape from a given viewing direction. Generally, straightforward height compression will lead to the loss of salient features. To solve this problem, many existing algorithms usually perform compression in gradient domain, and recover the height field by solving a Poisson equation. But for sunken relief generation, details preserving is no longer a critical issue. Since fine details appear in the form of line strokes, what we really need, then, is to provide a smooth transition height field for line engraving. In this section, we construct the base height field of the sunken relief based on Lambertian shading. Before that, we first employ a mesh smoothing operator to decrease the shading discontinuity.

Inspired by exaggerated shading for 3D shape depiction [36], we smooth the mesh normal field instead of the geometric shape, avoiding geometric shrinkage of the contour vertices. The smoothing is performed by computing an average of nearby normal for each vertex weighted by a Gaussian falloff. Let M be the input mesh and nv
                      be the original normal of vertex v, for each round of smoothing, the update normal Nv
                      is calculated by:
                        
                           (7)
                           
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             w
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             w
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                     Here, nj
                      is the normal of neighbor vertex vj
                     , 
                        
                           
                              
                                 w
                              
                              
                                 j
                              
                           
                           =
                           
                              
                                 e
                              
                              
                                 -
                                 
                                    
                                       x
                                    
                                    
                                       2
                                    
                                 
                                 /
                                 2
                                 
                                    
                                       σ
                                    
                                    
                                       j
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                      is the Gaussian distance weight function, and x refers to the distance between the neighbor p and vertex v. In practice, the selection of Gaussian width σj
                      significantly influences the smoothing effect. We compute σ
                     0 by the minimum radius of the neighborhood. After that, σj
                      is set as a constant factor times the previous width σj
                     
                     −1 (a factor of 
                        
                           
                              
                                 2
                              
                           
                        
                      appears to work well in all cases). We usually apply 6–10 smoothing iterations for the mesh normal. Fig. 6
                      depicts the Lambertian shading comparison between the original mesh and the smooth mesh (eight rounds of smoothing). It is obvious that the fine details of the input model have been partly eliminated, and the surface smoothness has been significantly improved.

In computer graphics, Lambertian shading is often used to describe how the illumination varies from “dark” to “light” regions. For each vertex p of the input mesh, standard Lambertian shading is computed by:
                        
                           (8)
                           
                              I
                              (
                              p
                              )
                              =
                              n
                              (
                              p
                              )
                              ·
                              l
                              (
                              p
                              )
                           
                        
                     where n(p) is the smooth unit normal at p and l(p) is the light source direction. In practice, we set the light source aligned with the camera. On this condition, the darkest vertices are always located near the contours. We integrate the depth information with Lambertian shading to construct the height field. The height value for each vertex is defined as:
                        
                           (9)
                           
                              H
                              (
                              p
                              )
                              =
                              Depth
                              ·
                              [
                              a
                              +
                              (
                              1
                              -
                              a
                              )
                              
                                 
                                    clamp
                                 
                                 
                                    [
                                    0.0
                                    …
                                    1.0
                                    ]
                                 
                              
                              (
                              d
                              (
                              p
                              )
                              )
                              ]
                              ·
                              I
                              (
                              p
                              )
                           
                        
                     where Depth is the overall depth of the relief, and d(p) is the current depth of p with respect to the projecting plane. Note that the middle item of the formula can be regarded as a linear regulatory factor which is clamped in the range of a (usually 0.5) to 1.0. With this factor, more depth contrast is reflected in the final height values of H(p). Compared with using pure Lambertian shading, the final shape of the base height field is improved.

Thus far, we have achieved three layers of geometric features from the input object: chained contour lines, chained suggestive contour lines, and a base smooth height field. Now we will combine them together to generate the final sunken-relief. To support NC machining, we output the relief in the form of Z-Map data points.

A Z-Map is a discrete representation in which the height values at grid points on the domain plane are stored as a two-dimensional array. In this section, we restrict the grid resolution of the relief up to 1000×1000 pixels. We simulate the line cutting paths using continuous pitting corrosion, that is, we approximate the engraving lines by a mass of corrosion points. As shown in Fig. 7
                     , for each grid point inside the pitting corrosion circle, the engraving depth is computed by:
                        
                           (10)
                           
                              
                                 
                                    Z
                                 
                                 
                                    p
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          R
                                       
                                       
                                          2
                                       
                                    
                                    -
                                    
                                       
                                          d
                                       
                                       
                                          po
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        
                     where R is the corrosion radius, dpo
                      is the distance between corrosion center O and the grid point P. Note that consecutive corrosions are often set with small intervals to ensure the precision, the same grid will be repeatedly corroded. In this case, we determine the grid depth by the deepest value. Moreover, for the grid point inside the base height field, we calculate the depth by centroid interpolating its covering triangle.

We generate the sunken reliefs in a fixed order, first the base mesh, then the contour lines, and then suggestive contour lines, as shown in Fig. 2. The overall sunken depth of the base mesh is set to be equal with the maximum stroke thickness of the contours, while suggestive contours are engraved with a constant depth upon the base mesh surface. For the same input mesh, when its position and pose are changed, the corresponding computer-generated results will be created in short time, as shown in Fig. 8
                     . More examples can be found in Figs. 9–11
                     
                     
                     .

@&#EXPERIMENTS@&#

We implement the proposed algorithm in C++ using OpenGL. All experiments are tested on a 2.80GHz Intel Xeon CPU with 16GB of RAM assisted by a NVIDIA Quadro FX4800 graphics card. Table 1
                      shows the computation time for a few models ranging from 50k to 200k triangles. Under the same output resolution (1000*1000 pixels), mesh smoothing and relief output are relatively quick. As the visibility testing and lines chaining occupy the major cost of the algorithm (80–90% of total), we believe that better performance could be achieved with acceleration of these steps in the future.

To demonstrate the manufacturability of the computer-generated result, we produce a real-world sunken relief that is cut on a NC carving machine using epoxy tooling board (200*200mm). As shown in Fig. 10, the sculpture shape and depth transition (maximum depth 2.5mm) have been correctly depicted in the physical relief, and the machining result is nearly identical with the design model.

We also compare our method with that of Wang et al. [23], who have successfully produced sunken reliefs from known 3D objects. We adopt an experimental image of the authors and compare it with our generated result using the same 3D model and viewing direction, as shown in Fig. 11. From the relief appearance, both methods have presented fluent sculpture outlines and visually important features. But on many processing aspects, the two approaches are different in essence. Unlike Wang et al. who choose the Laplacian smooth operator to control the density of the strokes, we organize the line segments in chains and provide a flexible control on the presence of the stylized strokes. Thus, important geometric features of the relief can be accurately emphasized by engraved lines. From 2.5D illusion of the depth, the result of Wang et al. seems more pleasing than ours. The authors combine the line drawing, the Lambertian shading and the depth image together, and derive an energy function to maximize the presence of features. Due to the image gradient compression and relief surface recovery by computing the Poisson equations, the height deviation of the relief looks more visually salient. In contrast, we integrate the depth information with Lambertian shading in object space. Although the relief surface looks relatively flat, the whole process is easier to implement.

@&#CONCLUSIONS AND FUTURE WORK@&#

Sunken relief is a special sculpture art, in which both the overall shape and the local details are represented by lines. In this paper, we have presented an object-based method for sunken relief generation from a 3D mesh. Initially, we focus on the extraction and post-processing of the feature lines so that the messy line drawing can be converted into smooth line chains. After that, we construct a smooth transition height field based on Lambertian shading, and use a continuous pitting corrosion method to generate the engraving paths. Experimental results verify that the proposed method is effective to generate a sunken relief from a 3D mesh.

Compared with the image processing algorithms, one important advantage of our method is that it can produce varying thickness strokes for the relief contours. Since we have organized the lines in chains, it’s easy to convert them into editable B-splines. Thus, the users will have more flexibility to modify the shape of the relief contours. However, intuitive editing of a sunken relief is not an easy work. Once the outlines are changed, the overall shape of the sunken surfaces needs to be modified correspondingly. We wish to work on this challenging problem in the future.

One limitation of our work is the feature lines extraction. In this paper, we only use contours and suggestive contours to describe the relief shape and details. In future, we will explore more possible line types and produce a much broader space of appealing stroke styles for sunken relief generation.

@&#ACKNOWLEDGMENTS@&#

We would like to thank the anonymous reviewers for their careful reviews and valuable suggestions. We also thank AIM@SHAPE, Todd Goodwin and Meili Wang for providing the models used throughout this paper. This work has been supported by Higher Educational Science and Technology Program of Shandong Province, China (Grant No. J13LB01) and Young and Middle-Aged Scientists Research Awards Fund of Shandong Province, China (Grant No. BS2011ZZ015).

@&#REFERENCES@&#

