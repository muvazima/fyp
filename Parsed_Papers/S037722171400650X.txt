@&#MAIN-TITLE@&#A goal-driven prototype column generation strategy for the multiple container loading cost minimization problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Use prototypes solutions of subproblems when making high level decision.


                        
                        
                           
                           Model average capability of single container loading algorithms.


                        
                        
                           
                           Apply goal-driven search to improve feasible solutions.


                        
                        
                           
                           Significantly outperform existing approach on benchmark instances.


                        
                        
                           
                           Introduce new benchmark instances based on industrial data.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multiple container loading cost minimization problem

Prototype column generation

Integer programming

Goal-driven search

@&#ABSTRACT@&#


               
               
                  In the multiple container loading cost minimization problem (MCLCMP), rectangular boxes of various dimensions are loaded into rectangular containers of various sizes so as to minimize the total shipping cost. The MCLCMP can be naturally modeled as a set cover problem. We generalize the set cover formulation by introducing a new parameter to model the gross volume utilization of containers in a solution. The state-of-the-art algorithm tackles the MCLCMP using the prototype column generation (PCG) technique. PCG is an effective technique for speeding up the column generation technique for extremely hard optimization problems where their corresponding pricing subproblems are NP-hard. We propose a new approach to the MCLCMP that combines the PCG technique with a goal-driven search. Our goal-driven prototype column generation (GD-PCG) algorithm improves the original PCG approach in three respects. Computational experiments suggest that all three enhancements are effective. Our GD-PCG algorithm produces significantly better solutions for the 350 existing benchmark instances than all other approaches in the literature using less computation time. We also generate two new set instances based on industrial data and the classical single container loading instances.
               
            

@&#INTRODUCTION@&#

The efficient loading of items into containers is a fundamental problem in the shipping and logistics industries that arises whenever goods must be packed and transported. In many practical scenarios, choices of containers of different sizes and costs available, and the task is to select a set of containers that can hold all the goods while minimizing the cost. This problem is known as the multiple container loading cost minimization problem (MCLCMP).

The MCLCMP is formally defined as follows. We have M types of containers with dimensions 
                        
                           
                              
                                 L
                              
                              
                                 t
                              
                           
                           ×
                           
                              
                                 W
                              
                              
                                 t
                              
                           
                           ×
                           
                              
                                 H
                              
                              
                                 t
                              
                           
                           ,
                           
                           t
                           =
                           1
                           ,
                           …
                           ,
                           M
                        
                     . The cost of the t-th container is 
                        
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                        
                     , and there are 
                        
                           
                              
                                 m
                              
                              
                                 t
                              
                           
                        
                      containers available for container type t. We are also given N types of boxes. The dimensions of the i-th box type are 
                        
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                           ×
                           
                              
                                 w
                              
                              
                                 i
                              
                           
                           ×
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                           ,
                           
                           i
                           =
                           1
                           ,
                           …
                           ,
                           N
                        
                     , and there are 
                        
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                        
                      boxes of type i. The objective of the MCLCMP is to pack all boxes into a set of containers so that the cost of the used containers is minimized. We assume that the boxes can only be placed with sides parallel to the sides of the containers (commonly referred to as orthogonal packing), and no two boxes in the same container may overlap. In some applications, it is desirable that all boxes are fully supported from below for stability. This arrangement is called the full support constraint in literature. Our approach works with or without the full support constraint.

This paper primarily considers a special case in which there are an unlimited number of available containers for each type (i.e., 
                        
                           
                              
                                 m
                              
                              
                                 t
                              
                           
                           =
                           ∞
                           
                           ∀
                           t
                        
                     ). This is because the number of containers available is usually more than sufficient to contain all items to be loaded in practice, except in rare cases during peak periods. However, our technique can also be extended easily to handle a limited number of containers.

We build upon the prototype column generation (PCG) method proposed by Zhu, Huang, and Lim (2012) for the MCLCMP using a goal-driven strategy. Our goal-driven prototype column generation (GD-PCG) algorithm improves on PCG in three respects. First, the PCG algorithm carries out the search in two stages and each stage approaches good solutions to the MCLCMP in its own dimension, whereas GD-PCG searches in both dimensions at the same time. Second, we extend the set cover formulation in Section 4 by introducing a new parameter 
                        
                           γ
                        
                     , that reflects the estimated overall volume utilization of the containers in an MCLCMP solution. Third, once a solution is found, a goal-driven search described in Section 5.3 is applied in the neighborhood of the solution to improve it. Computational experiments reported in Section 6.1 suggest that all three enhancements are effective.

We compare our GD-PCG approach with existing MCLCMP approaches in the literature on the 350 benchmark instances proposed by Che, Huang, Lim, and Zhu (2011) in Section 6.2. The results show that GD-PCG outperforms all existing approaches in terms of solution quality and average computation time. We also generate two new set of instances based on real data from an international manufacturer of audio equipment and the classical single container loading instances.

@&#LITERATURE REVIEW@&#

Under the improved typology for cutting and packing problems introduced by Wäscher, Haußner, and Schumann (2007), the MCLCMP can be considered as a variant of either the multiple stock-size cutting stock problem (MSSCSP) or the multiple bin-size bin packing problem (MBSBPP), depending on the heterogeneity of the boxes, where the objective is to minimize the cost of the containers.


                     Eley (2003) proposed a bottleneck assignment approach to the MCLCMP and some possible variants. The author first generated packing patterns using a tree search based heuristic, then used a set cover formulation for linear integer programming using pre-generated packing patterns. Che et al. (2011) adapted this set cover formulation by adding a loading factor parameter to exploit the excess capacity of the chosen containers, used three fast heuristic strategies to generate packing patterns, and performed a binary search on the loading factor. Zhu, Huang, et al. (2012) presented a PCG strategy for this problem to speed up the process of column generation. In solving the pricing problem during column generation, the authors used prototypes that approximated feasible solutions to the pricing problem rather than actual columns.

A special case of the MCLCMP is the 3-D bin packing problem (3D-BPP), in which there is only one type of container. The 3D-BPP is a reasonably well-studied problem (Alvarez-Valdes, Parreño, & Tamarit, 2013; Crainic, Perboli, & Tadei, 2008, 2009; Faroe, Pisinger, & Zachariasen, 2003; Fekete & van der Veen, 2007; Lodi, Martello, & Vigo, 2002; Martello, Pisinger, & Vigo, 2000; Parreño, Alvarez-Valdes, Oliveira, & Tamarit, 2008a; Verweij, 1996; Zhu, Zhang, Oon, & Lim, 2012). However, 3D-BPP approaches generally assume that the items cannot be rotated, which is an unrealistic assumption since for most practical applications some items can at least be rotated by 90 degrees. Furthermore, the fact that containers come in multiple standard sizes which creates a trade-off between the size of the container and its cost, is not reflected in the 3D-BPP.

One of the subproblems of the MCLCMP is the single container loading problem (SCLP), which is also well-studied in the literature. The current best approaches for the SCLP include those of Eley (2002), Gehring and Bortfeldt (2002), Bortfeldt, Gehring, and Mack (2003), Mack, Bortfeldt, and Gehring (2004), Lim and Zhang (2005), Moura and Oliveira (2005), Parreño, Alvarez-Valdes, Tamarit, and Oliveira (2008b), Fanslau and Bortfeldt (2010), Parreño, Alvarez-Valdes, Oliveira, and Tamarit (2010), Zhu, Qin, Lim, and Zhang (2012), Zhu, Oon, Lim, and Weng (2012), Wang, Lim, and Zhu (2013), and Lim, Ma, Qiu, and Zhu (2013). The earlier literature often recommended ways to adapt procedures for the SCLP for multiple containers. Possible strategies include the sequential strategy, which fills single containers in turn using SCLP approaches (Ivancic, Mathur, & Mohanty, 1989; Eley, 2002; Lim & Zhang, 2005); the pre-assignment strategy, where boxes are assigned to containers before loading (Terno, Scheithauer, Sommerweiß, & Riehme, 2000); and the simultaneous strategy, where multiple containers are considered in the loading of boxes (Eley, 2002).

A solution to the MCLCMP can be defined by a list of packing patterns, where each pattern represents the packing configuration for one container. Let 
                           
                              P
                           
                         denotes a set of candidate packing patterns, indexed by 
                           
                              j
                              =
                              1
                              ,
                              …
                              ,
                              |
                              P
                              |
                           
                        . Each packing pattern j is represented by a column vector 
                           
                              
                                 
                                    A
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          1
                                          j
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          Nj
                                       
                                    
                                    )
                                 
                                 
                                    T
                                 
                              
                           
                        , where 
                           
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                           
                         is the number of boxes of type i used in the packing pattern. Let 
                           
                              A
                           
                         be the matrix formed by all the column vectors corresponding to the packing patterns in 
                           
                              P
                           
                        . If the container used by packing pattern j is of type t, then the cost associated with this pattern is 
                           
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    C
                                 
                                 
                                    t
                                 
                              
                           
                        . Let the vector 
                           
                              x
                           
                         be the integer decision variables, where 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                           
                         denotes the number of times the j-th packing pattern is used. A feasible solution to the MCLCMP can be obtained by solving the following model:
                           
                              (1)
                              
                                 SCP
                                 (
                                 P
                                 )
                                 :
                                 
                                 Minimize
                                 
                                 z
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          |
                                          P
                                          |
                                       
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 Subject
                                 
                                 to
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          |
                                          P
                                          |
                                       
                                    
                                 
                                 
                                    
                                       a
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ⩾
                                 
                                    
                                       n
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 N
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ⩾
                                 0
                                 
                                 and
                                 
                                 integer
                                 ,
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 |
                                 P
                                 |
                              
                           
                        where the objective function (1) seeks to minimize the total cost of all selected containers, and the inequalities (2) make sure that the selected patterns have packed enough boxes of each type where 
                           
                              
                                 
                                    n
                                 
                                 
                                    i
                                 
                              
                           
                         is the number of boxes of type i to be packed. This set cover formulation was first proposed by Eley (2003) and later employed by Che et al. (2011). The set cover formulation for both 1D and 2D bin packing problem has also been proposed by Monaci and Toth (2006).

Note that if the full-support constraint is not imposed and 
                           
                              A
                           
                         contains all possible feasible single container packing patterns, then we can solve the above integer program to find an optimal solution to the MCLCMP even though constraints (2) are inequalities rather than equalities. This is because if the selected packing patterns in the solution involve excess boxes of type i, then we can remove type i boxes from this solution until only the required number of boxes remains. The resulting packing patterns are still feasible, because the support of the boxes is not required.

One difficulty in using the above set cover formulation to solve the MCLCMP is constructing the matrix 
                           
                              A
                           
                         such that each column corresponds to a feasible packing pattern. A feasible packing pattern is a solution to the single container loading problem (SCLP), which is NP-hard, so finding these patterns can be very time consuming.


                        Zhu, Huang, et al. (2012) proposed to first ignore the 3D shape of items and only consider their volume. The resulting problem is a knapsack problem, and can be solved efficiently. A solution to the knapsack problem is called a prototype that approximates a packing pattern. A prototype can be realized into a packing pattern by invoking an SCLP algorithm. Since SCLP is relatively well studied and many algorithms are able to produce packing patterns with very high volume utilization, the discrepancy between a prototype and its realized packing pattern is expected to be small in terms of box count.


                        Zhu, Huang, et al. (2012) used prototypes rather than actual packing patterns to solve the set cover formulation 
                           
                              SCP
                              (
                              P
                              )
                           
                        . In general, the solution to the set cover formulation may not be a feasible solution to the MCLCMP due to the use of prototypes. However, it is close enough and can often be converted into a solution to the MCLCMP using a heuristic.


                        Zhu, Huang, et al. (2012) employed the column generation technique to solve the set cover formulation. At the end of the column generation, a subset of prototypes 
                           
                              Q
                           
                         is identified such that the cost of an optimal solution to the LP relaxation of 
                           
                              SCP
                              (
                              Q
                              )
                           
                         is the same as that of the LP relaxation of 
                           
                              SCP
                              (
                              P
                              )
                           
                        . In a sense, the subset 
                           
                              Q
                           
                         captures the essential information of set 
                           
                              P
                           
                        . All of the prototypes in 
                           
                              Q
                           
                         are replaced by the corresponding packing patterns.


                        Zhu, Huang, et al. (2012) repeated this column generation process several times. As more prototypes are replaced by packing patterns, the set cover formulation 
                           
                              SCP
                              (
                              P
                              )
                           
                         models the MCLCMP more accurately. The main advantage of this approach is that it avoids the costly construction of packing patterns that are unlikely to be used in a good solution to the MCLCMP. The authors named their approach the prototype column generation (PCG) technique. For full details, we refer the reader to Zhu, Huang, et al. (2012).

We adapt the prototype column generation (PCG) technique of Zhu, Huang, et al. (2012). In the process of PCG, we have both prototypes and packing patterns. The set 
                        
                           P
                        
                      can be split into two disjoint subsets 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                        
                      and 
                        
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                        
                     , where the subscript u standards for unrealized (prototype) and r standards for realized (packing pattern). Correspondingly, the coefficient matrix 
                        
                           A
                        
                      in the set cover formulation 
                        
                           SCP
                           (
                           P
                           )
                        
                      can be rearranged and partitioned into two submatrices 
                        
                           A
                           =
                           [
                           
                              
                                 A
                              
                              
                                 u
                              
                           
                           
                              
                                 A
                              
                              
                                 r
                              
                           
                           ]
                        
                     . We rearrange and partition the decision variables 
                        
                           x
                        
                      and cost coefficients 
                        
                           c
                        
                      accordingly. The decision variables associated with the prototypes and packing patterns are denoted by column vectors 
                        
                           
                              
                                 x
                              
                              
                                 u
                              
                           
                        
                      and 
                        
                           
                              
                                 x
                              
                              
                                 r
                              
                           
                        
                     , respectively. The cost coefficients associated with 
                        
                           
                              
                                 x
                              
                              
                                 u
                              
                           
                        
                      and 
                        
                           
                              
                                 x
                              
                              
                                 r
                              
                           
                        
                      are 
                        
                           
                              
                                 c
                              
                              
                                 u
                              
                           
                        
                      and 
                        
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                        
                     , respectively. We introduce two parameters 
                        
                           α
                        
                      and 
                        
                           γ
                        
                      and a new constraint, which will be explained shortly. We rewrite the set cover formulation in matrix form:
                        
                           (4)
                           
                              SCP
                              (
                              
                                 
                                    P
                                 
                                 
                                    u
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    r
                                 
                              
                              ,
                              α
                              ,
                              γ
                              )
                              :
                              
                              Minimize
                              
                              z
                              =
                              
                                 
                                    c
                                 
                                 
                                    u
                                 
                                 
                                    T
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    u
                                 
                              
                              +
                              
                                 
                                    c
                                 
                                 
                                    r
                                 
                                 
                                    T
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    r
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              Subject
                              
                              to
                              
                              [
                              
                                 
                                    A
                                 
                                 
                                    u
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    r
                                 
                              
                              ]
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      u
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      r
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              ⩾
                              α
                              ·
                              n
                           
                        
                     
                     
                        
                           (6)
                           
                              
                              x
                              ⩾
                              0
                              
                              and
                              
                              integer
                           
                        
                     
                     
                        
                           (7)
                           
                              
                              
                                 
                                    v
                                 
                                 
                                    u
                                 
                                 
                                    T
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    u
                                 
                              
                              +
                              
                                 
                                    v
                                 
                                 
                                    r
                                 
                                 
                                    T
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    r
                                 
                              
                              ⩾
                              
                                 
                                    1
                                 
                                 
                                    γ
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              
                                 
                                    n
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                           
                        
                     where the component 
                        
                           
                              
                                 v
                              
                              
                                 j
                              
                           
                        
                      in the vector 
                        
                           v
                        
                      is the volume of the container in a prototype or packing pattern j.

The loading factor 
                        
                           α
                        
                      was first introduced by Che et al. (2011) as a heuristic to speed up the process of finding a high-quality solution to the MCLCMP. The idea can be briefly summarized as follows. It is often the case that in an optimal solution to the set cover formulation some of the inequalities (5) are strict. A strict inequality means that the set of selected prototypes and packing patterns contain more boxes than are required for the corresponding box type. The presence of excessive boxes offers an opportunity to reduce the cost by selecting a set of containers with a smaller capacity. For example, if we set 
                        
                           α
                        
                      to 0.95, then a feasible solution to the set cover formulation will guarantee that at least 95% of each type of box (in terms of box count) can be loaded into the selected containers, but the remaining 5% has no guarantee of being loaded. It may be possible to load the remaining boxes into the selected containers after removing excessive boxes (of other types), whereupon we would obtain a feasible solution to the MCLCMP.

The gross volume utilization 
                     
                        
                           γ
                        
                      is a new parameter that we introduce based on the following idea. In any feasible solution to the MCLCMP, the total volume of the selected containers must be at least the total volume of all of the boxes. Furthermore, every selected container represents a packing plan, and in general the volume of the containers is seldom fully used. To account for this wastage, we require the total volume of the selected containers to be slightly increased (see constraint (7)).

In a typical execution of our PCG algorithm, hundreds or even thousands of prototypes are converted into packing patterns. Each conversion requires the execution of an SCLP algorithm. The time allocated to realize a prototype is very limited. Given that the SCLP itself is a very challenging optimization problem, we can safely assume that the volume utilization for the majority of cases will be less than 99%. If we have a feasible solution to the set cover problem where the overall volume utilization of the containers in the selected prototypes is above 99%, then it will be very unlikely that an SCLP algorithm will be able to convert the selected prototypes into packing patterns with no leftover boxes. In this case, setting 
                        
                           γ
                        
                      to 0.99 excludes such feasible solutions from consideration, thus saving CPU time that can be better used to explore more promising solutions. Reducing 
                        
                           γ
                        
                      will exclude more solutions from consideration. When 
                        
                           γ
                        
                      is close to 1.0, reducing 
                        
                           γ
                        
                      often leads to the more efficient allocation of CPU time.

High quality solutions to the MCLCMP tend to use the volume in the containers well. For example, the state-of-the-art SCLP algorithm can often find solutions that have a volume utilization in the range of 90–96%, depending on the assortment of items (Zhu & Lim, 2012). If we are too aggressive and set 
                        
                           γ
                        
                      to be too small, we may exclude high quality MCLCMP solutions from consideration, which lead to poor solutions. As the assortment of boxes varies across industries, we can determine the best value of 
                        
                           γ
                        
                      based on historical data.

By setting 
                        
                           γ
                        
                      to a value that is slightly smaller than 1.0, certain combinations of unrealized packing patterns that are unlikely to be realizable are removed from consideration. If 
                        
                           γ
                        
                      is too small, then we risk excluding optimal solutions. As the time allocated to realize a prototype is limited, we can safely assume that the volume utilization in the majority of cases will be less than 99%. Consequently, we can set 
                        
                           γ
                           =
                           0.99
                        
                      to speed up our algorithm with little sacrifice of solution quality.

Our Goal-Driven Prototype Column Generation (GD-PCG) algorithm can be considered as an iterative application of the column generation technique to solve the set cover formulation 
                        
                           SCP
                           (
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                           ,
                           α
                           ,
                           γ
                           )
                        
                     . The details of our GD-PCG are given in Algorithm 1.
                        Algorithm 1
                        Goal-Driven Prototype Column Generation 
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   GD
                                                   -
                                                   PCG
                                                   (
                                                   Inst
                                                   ,
                                                   SCLP
                                                   -
                                                   Solver,
                                                   γ
                                                   ,
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   ,
                                                   Δ
                                                   α
                                                   ,
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         pcg
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         gap
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         TL
                                                      
                                                      
                                                         CPLEX
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         TL
                                                      
                                                      
                                                         SCLP
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             // Input: Inst: the MCLCMP instance to be solved
                                       
                                       
                                          
                                             // SCLP-Solver: an SCLP algorithm
                                       
                                       
                                          
                                             // 
                                             γ: the gross volume utilization
                                       
                                       
                                          
                                             // 
                                             
                                                
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   ,
                                                   Δ
                                                   α
                                                
                                             : the initial loading factor and step length
                                       
                                       
                                          
                                             // 
                                             
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         pcg
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         gap
                                                      
                                                   
                                                
                                             : the number of iterations in outer and middle for-loop
                                       
                                       
                                          
                                             // 
                                             
                                                
                                                   
                                                      
                                                         TL
                                                      
                                                      
                                                         CPLEX
                                                      
                                                   
                                                
                                             : the time limit for each call to CPLEX (lines 7, 8 and 23)
                                       
                                       
                                          
                                             // 
                                             
                                                
                                                   
                                                      
                                                         TL
                                                      
                                                      
                                                         SCLP
                                                      
                                                   
                                                
                                             : the time limit for each call to SCLP-Solver
                                          
                                       
                                       
                                          
                                             // Output: The best solution to the MCLCMP
                                       
                                       
                                          
                                             
                                             1 
                                             
                                                
                                                   bestSol
                                                   =
                                                   NULL
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             2 Generate prototypes 
                                                
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         u
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                              for each type t (Zhu, Huang, et al., 2012, Section 5)
                                       
                                       
                                          
                                             
                                             3 Construct 
                                                
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                              s.t. each box type appears in some prototype 
                                                
                                                   p
                                                   ∈
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             4 Delete 
                                                
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                              from 
                                                
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         u
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             5 
                                             for 
                                             
                                                
                                                   l
                                                   =
                                                   1
                                                
                                              
                                             to 
                                             
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         gap
                                                      
                                                   
                                                
                                              
                                             by 1 // search in two dimensions
                                       
                                       
                                          
                                             
                                             6 
                                             
                                             
                                                
                                                   α
                                                   =
                                                   min
                                                   {
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   +
                                                   (
                                                   l
                                                   -
                                                   1
                                                   )
                                                   ·
                                                   Δ
                                                   α
                                                   ,
                                                   1.0
                                                   }
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             7 
                                             Solve the LP relaxation of 
                                                
                                                   SCP
                                                   (
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   1.0
                                                   ,
                                                   γ
                                                   )
                                                
                                              using column generation; update 
                                                
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                             , 
                                                
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         u
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                              accordingly
                                       
                                       
                                          
                                             
                                             8 
                                             Let 
                                                
                                                   x
                                                
                                              be the solution to 
                                                
                                                   SCP
                                                   (
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   α
                                                   ,
                                                   γ
                                                   )
                                                
                                              found by CPLEX
                                       
                                       
                                          
                                             
                                             
                                             // Create MCLCMP solution based on 
                                                
                                                   x
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                          
                                       
                                       
                                          
                                             
                                             9 
                                             Let RB be the set of boxes in Inst
                                          
                                       
                                       
                                          10 
                                             
                                             for each 
                                                
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   >
                                                   0
                                                
                                             
                                          
                                       
                                       
                                          11 
                                             
                                             
                                             if 
                                             
                                                
                                                   p
                                                   =
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   ∈
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          12 
                                             
                                             Remove p from 
                                                
                                                   
                                                      
                                                         Q
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          13 
                                             
                                             
                                             
                                                
                                                   p
                                                   =
                                                
                                              realize prototype p using SCLP-Solver
                                          
                                       
                                       
                                          14 
                                             
                                             Add p to 
                                                
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          15 
                                             
                                             Load 
                                                
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                              containers according to loading pattern p
                                          
                                       
                                       
                                          16 
                                             
                                             Remove loaded boxes from RB
                                          
                                       
                                       
                                          17 
                                             Let CList be the list of containers loaded
                                       
                                       
                                          18 
                                             Remove excess boxes from CList
                                          
                                       
                                       
                                          19 
                                             
                                             if 
                                             
                                                
                                                   RB
                                                   
                                                   ≠
                                                   
                                                   ∅
                                                
                                              
                                             then invoke Insert
                                             
                                                
                                                   (
                                                   RB
                                                   ,
                                                   CList
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   SCLP
                                                   -
                                                   Solver
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                          
                                       
                                       
                                          20 
                                             
                                             if 
                                             RB is empty
                                       
                                       
                                          21 
                                             
                                             GoalDrivenSearch
                                             
                                                
                                                   (
                                                   CList
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   SCLP
                                                   -
                                                   Solver
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          22 
                                             
                                             update bestSol if CList is a better solution
                                       
                                       
                                          
                                             
                                          
                                       
                                       
                                          23 
                                             Solve 
                                                
                                                   SCP
                                                   (
                                                   ∅
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   1.0
                                                   ,
                                                   1.0
                                                   )
                                                
                                              to obtain MCLCMP solution sol
                                          
                                       
                                       
                                          24 
                                             GoalDrivenSearch
                                             
                                                
                                                   (
                                                   sol
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   ,
                                                   SCLP
                                                   -
                                                   Solver
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          25 
                                             update bestSol if sol is a better solution
                                       
                                       
                                          26 Generate more prototypes and add them to 
                                                
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         u
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          27 
                                             return 
                                             bestSol
                                          
                                       
                                    
                                 
                              
                           
                        

Let 
                        
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                        
                      be a subset of 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                        
                      identified by the column generation technique such that the optimal solution to the LP relaxation of 
                        
                           SCP
                           (
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                           ,
                           α
                           ,
                           γ
                           )
                        
                      is the same as that of 
                        
                           SCP
                           (
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                           ,
                           α
                           ,
                           γ
                           )
                        
                     . We classify the prototypes in 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                           -
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                        
                      by container type, and use the notation 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                              
                                 t
                              
                           
                        
                      to denote the set of prototypes for container type t, that is,
                        
                           
                              
                                 
                                    P
                                 
                                 
                                    u
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                ⋃
                                             
                                             
                                                t
                                                =
                                                1
                                             
                                             
                                                M
                                             
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             u
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                              
                              ∪
                              
                                 
                                    Q
                                 
                                 
                                    u
                                 
                              
                              ,
                              
                              where
                              
                              
                                 
                                    P
                                 
                                 
                                    u
                                 
                                 
                                    t
                                 
                              
                              
                              and
                              
                              
                                 
                                    Q
                                 
                                 
                                    u
                                 
                              
                              
                              are
                              
                              pairwise
                              
                              disjoint
                           
                        
                     
                  

The outermost for-loop serves two purposes. First, it gradually converts the prototypes into packing patterns. That is, we are solving a series of set cover formulations 
                        
                           SCP
                           
                              
                                 
                                    
                                       
                                          P
                                       
                                       
                                          u
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          P
                                       
                                       
                                          r
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    α
                                    ,
                                    γ
                                 
                              
                           
                           ,
                           
                           l
                           =
                           1
                           ,
                           …
                           ,
                           
                              
                                 K
                              
                              
                                 gap
                              
                           
                        
                     , where 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                              
                                 l
                              
                           
                           ⊃
                           
                              
                                 P
                              
                              
                                 u
                              
                              
                                 l
                                 +
                                 1
                              
                           
                        
                      and 
                        
                           
                              
                                 P
                              
                              
                                 r
                              
                              
                                 l
                              
                           
                           ⊂
                           
                              
                                 P
                              
                              
                                 r
                              
                              
                                 l
                                 +
                                 1
                              
                           
                        
                     , and 
                        
                           
                              
                                 K
                              
                              
                                 gap
                              
                           
                        
                      is a user-defined parameter. As more prototypes are converted into packing patterns, we can expect the set cover formulation to become a more accurate model for the MCLCMP. An optimal solution to the set cover formulation is more likely to lead to a higher quality MCLCMP solution.

Second, the outermost loop adjusts the loading factor 
                        
                           α
                        
                     . Che et al. (2011) demonstrated that applying a binary search on 
                        
                           α
                        
                      may help to find better MCLCMP solutions. Three searching strategies can be applied by setting appropriate values for 
                        
                           
                              
                                 α
                              
                              
                                 0
                              
                           
                        
                      and 
                        
                           δ
                           α
                        
                     . For example, 
                        
                           
                              
                                 α
                              
                              
                                 0
                              
                           
                           =
                           1.0
                           ,
                           
                           δ
                           α
                           =
                           -
                           0.01
                        
                      corresponds to downward linear search. In this example, our algorithm tries the loading factors 
                        
                           1.00
                           ,
                           0.99
                           ,
                           0.98
                           ,
                           …
                        
                      in turn.

There are two inner loops. The first inner loop on line 7 is a direct application of column generation to find the optimal solution to the LP relaxation of 
                        
                           SCP
                           (
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                           ,
                           1.0
                           ,
                           γ
                           )
                        
                     .

Column generation is a standard and effective technique for handling LP with very large numbers of variables. It works as follows. We first solve a restricted master problem (RMP) that includes only a subset of the columns from the original LP. In this case the RMP is 
                        
                           SCP
                           (
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                           ,
                           1.0
                           ,
                           γ
                           )
                           ,
                           
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                           ⊆
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                        
                     . We then try to formulate a pricing problem to identify columns with a negative reduced cost. If such columns exist, then they can be added to the RMP as columns to improve the quality of the optimal solution. This procedure is repeated until no such columns exist, whereupon the optimal solution to the RMP is also an optimal solution to the original LP.

In our case, the pricing problem is to find a prototype in 
                        
                           
                              
                                 P
                              
                              
                                 u
                              
                           
                           -
                           
                              
                                 Q
                              
                              
                                 u
                              
                           
                        
                      with a negative reduced cost. Let 
                        
                           
                              
                                 π
                              
                              
                                 i
                              
                           
                        
                      be the value of the dual variable associated with the constraint (5) that corresponds to type i items. Let 
                        
                           μ
                        
                      be the value of dual variable associated with the constraint (7). We denote a packing pattern by a triplet 
                        
                           (
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 t
                              
                           
                           ,
                           y
                           )
                        
                     , where 
                        
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 t
                              
                           
                        
                      is the cost and volume of the container associated with a packing pattern, and 
                        
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                        
                      is the number of type i items in the packing pattern. The reduced cost of a packing pattern is given by:
                        
                           
                              
                                 
                                    C
                                 
                                 
                                    t
                                 
                              
                              -
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              
                                 
                                    π
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              -
                              μ
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                           
                        
                     
                  

The column generation process on line 7 essentially solves a series of LP relaxations of 
                        
                           SCP
                           
                              
                                 
                                    
                                       
                                          Q
                                       
                                       
                                          u
                                       
                                       
                                          (
                                          l
                                          ,
                                          r
                                          )
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          r
                                       
                                       
                                          (
                                          l
                                          ,
                                          r
                                          )
                                       
                                    
                                    ,
                                    1.0
                                    ,
                                    γ
                                 
                              
                           
                           ,
                           
                           r
                           =
                           1
                           ,
                           2
                           ,
                           …
                        
                      such that the optimal solutions are monotonically non-increasing and will eventually converge to an optimal solution of the LP relaxation of 
                        
                           SCP
                           (
                           
                              
                                 P
                              
                              
                                 u
                              
                              
                                 l
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 r
                              
                              
                                 l
                              
                           
                           ,
                           1.0
                           ,
                           γ
                           )
                        
                     .

The second inner loop (line 8–19) converts prototypes that are useful into packing patterns. We first find a solution 
                        
                           x
                        
                      to the integer program 
                        
                           SCP
                           
                              
                                 
                                    
                                       
                                          Q
                                       
                                       
                                          u
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          r
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    α
                                    ,
                                    γ
                                 
                              
                           
                        
                      using the commercial solver CPLEX. We try to realize each prototype that appears in the solution by solving the corresponding SCLP instance using SCLP-Solver. We then load containers according to the loading patterns. As we are solving set cover formulations rather than of set packing, for some box types there may be more boxes loaded than are required by the original MCLCMP instance. We remove these excess boxes (line 18). If there are leftover boxes, we try to “squeeze” them into the loaded containers by invoking Insert, as described in Section 5.2, which has the side effect of producing new loading patterns.

If all of the leftover boxes are loaded, then CList represents a feasible solution to the MCLCMP instance. At this point, we immediately invoke GoalDrivenSearch to search for a better solution (line 21). New loading patterns produced in the process are then added to 
                        
                           
                              
                                 P
                              
                              
                                 r
                              
                           
                        
                     . The details of GoalDrivenSearch are given in Section 5.3.

Line 23 solves the set cover formulation for the MCLCMP to find a feasible solution. Note that as only packing patterns are included, a feasible solution to the set cover formulation is automatically a feasible solution to the MCLCMP. Once again, GoalDrivenSearch is invoked to improve the solution found (line 24).

Realizing a prototype is equivalent to solving an SCLP instance. We adapt the ID-GLTS algorithm by Zhu and Lim (2012) for this purpose, with two major modifications. First, as there are multiple container types, we generate a candidate block list for each type of container in advance. Whenever an instance of SCLP needs to be solved, we select the blocks that are feasible subject to the availability of boxes to be retained as the candidate blocks for that SCLP instance. In this way, we avoid redundant computations when generating blocks. Second, we retain a few best solutions instead of only one.

As the CPU time allocated to realize a prototype is usually very short (a few seconds at most), we employ only the Single-Best-Space scheme when ranking the placements. The depth limit of the look-ahead tree search is set to 2.

The Insert procedure is applied to pack leftover boxes into existing containers. Given the set of leftover boxes BoxList, the Insert procedure first sorts the containers in descending order of volume utilization, and then considers each container in order. For each container c, we first unload all of the boxes in c and add them to B and then attempt to load the boxes in B as much as possible into c by invoking our SCLP-solver. If the resulting packing pattern has a higher volume utilization than the original solution then we replace the old pattern with the new pattern. If the new pattern has not been previously found then we add it to the set of realized patterns 
                           
                              
                                 
                                    P
                                 
                                 
                                    r
                                 
                              
                           
                        .
                           Algorithm 2
                           Pack leftover boxes into existing containers 
                                 
                                    
                                       
                                       
                                          
                                             Insert
                                                
                                                   
                                                      (
                                                      B
                                                      ,
                                                      CList
                                                      ,
                                                      P
                                                      ,
                                                      SCLP
                                                      -
                                                      Solver
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                1 Sort CList in descending order of volume utilization
                                          
                                          
                                             
                                                
                                                2 
                                                for each loaded container 
                                                   
                                                      c
                                                      ∈
                                                      CList
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                3 
                                                Let 
                                                   
                                                      
                                                         
                                                            B
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                   
                                                 be the set of boxes loaded into c
                                             
                                          
                                          
                                             
                                                
                                                4 
                                                
                                                
                                                   
                                                      SCLPInst
                                                      =
                                                   
                                                 the SCLP instance with container c and boxes 
                                                   
                                                      B
                                                      ∪
                                                      
                                                         
                                                            B
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                5 
                                                Invoke SCLP-Solver to solve SCLPInst; let p be the resulting loading pattern, and let 
                                                   
                                                      
                                                         
                                                            B
                                                         
                                                         
                                                            p
                                                         
                                                      
                                                   
                                                 be the set of boxes in p
                                             
                                          
                                          
                                             
                                                
                                                6 
                                                
                                                if 
                                                p has a higher volume utilization
                                          
                                          
                                             
                                                
                                                7 
                                                
                                                Reload the container c according to p
                                             
                                          
                                          
                                             
                                                
                                                8 
                                                
                                                
                                                
                                                   
                                                      B
                                                      =
                                                      B
                                                      ∪
                                                      
                                                         
                                                            B
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            B
                                                         
                                                         
                                                            p
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                9 
                                                
                                                
                                                   
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            r
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            r
                                                         
                                                      
                                                      ∪
                                                      {
                                                      p
                                                      }
                                                   
                                                
                                             
                                          
                                          
                                             10 
                                                
                                                if 
                                                B is empty, then break
                                          
                                       
                                    
                                 
                              
                           

The Insert subroutine potentially helps to improve the solution quality in two ways. First, the unloading–reloading process may result in a solution that loads all boxes into the containers, which corresponds to a feasible MCLCMP solution with a potentially lower cost than the best solution found so far. Secondly, the side effect of introducing new packing patterns into 
                           
                              
                                 
                                    P
                                 
                                 
                                    r
                                 
                              
                           
                         may improve the solutions generated in later iterations.

The goal-driven search is a simple but effective techniques which could be used to speed up the search procedure. Wei, Oon, Zhu, and Lim (2013) used this technique to effectively solve the 2D variable size bin packing problem. We introduce the goal-driven procedure GoalDrivenSearch to further improve the solution whenever we find a solution to the MCLCMP. Our GoalDrivenSearch procedure considers each used container and replaces it with a cheaper container if possible, thereby producing a better MCLCMP solution.

The GoalDrivenSearch process is shown in Algorithm 3. We first sort the list of used containers CList in decreasing order of cost. We then consider each loaded container C in turn, and attempt to replace it with a cheaper container. To do so, we first compute the list of containers with individual costs that are less than C in increasing order of cost. Then, for each cheaper container 
                           
                              
                                 
                                    C
                                 
                                 
                                    ′
                                 
                              
                           
                        , we replace the container C by 
                           
                              
                                 
                                    C
                                 
                                 
                                    ′
                                 
                              
                           
                         and call the procedure Insert. If the resulting solution contains all boxes (i.e., BoxList is empty), then we have found a superior solution with reduced cost using container 
                           
                              
                                 
                                    C
                                 
                                 
                                    ′
                                 
                              
                           
                         instead of C.
                           Algorithm 3
                           Improve solution by replacing containers 
                                 
                                    
                                       
                                       
                                          
                                             GoalDrivenSearch
                                                
                                                   
                                                      (
                                                      CList
                                                      ,
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            r
                                                         
                                                      
                                                      ,
                                                      SCLP
                                                      -
                                                      Solver
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             1 Sort the containers in CList in decreasing order of cost
                                          
                                          
                                             2 
                                                for each loaded container 
                                                   
                                                      C
                                                      ∈
                                                      CList
                                                   
                                                
                                             
                                          
                                          
                                             3 
                                                
                                                
                                                   
                                                      BoxList
                                                      =
                                                   
                                                 all boxes in C
                                             
                                          
                                          
                                             4 
                                                
                                                
                                                   
                                                      
                                                         
                                                            CList
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      =
                                                   
                                                 the list of containers with individual costs are less than C in increasing order of cost
                                          
                                          
                                             5 
                                                
                                                for each container 
                                                   
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ∈
                                                      
                                                         
                                                            CList
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             6 
                                                
                                                Insert
                                                
                                                   
                                                      (
                                                      BoxList
                                                      ,
                                                      CList
                                                      ⧹
                                                      {
                                                      C
                                                      }
                                                      ∪
                                                      {
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      }
                                                      ,
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            r
                                                         
                                                      
                                                      ,
                                                      SCLP
                                                      -
                                                      Solver
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             7 
                                                
                                                
                                                if 
                                                BoxList is empty
                                          
                                          
                                             8 
                                                
                                                
                                                
                                                   
                                                      CList
                                                      =
                                                      CList
                                                      ⧹
                                                      {
                                                      C
                                                      }
                                                      ∪
                                                      {
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Our goal-driven prototype column generation strategy (GD-PCG) builds upon the PCG by Zhu, Huang, et al. (2012) by employing a goal-driven approach. It enhances the PCG in three ways.

First, we introduce the gross volume utilization 
                        
                           
                              γ
                           
                         into the set cover formulation, which models the inevitable waste of container volume either due to the capability of the SCLP solver or the data characteristics. Our formulation is more accurate and can be calibrated to specific applications.

Second, once a solution is found, a goal-driven search is carried out in the neighborhood of the solution to improve it.

The third enhancement can be summarized as follows. We can approach good solutions to the MCLCMP from two directions: (1) by introducing more columns into the set cover formulation so that it models the MCLCMP more accurately and (2) by introducing loading factor 
                           
                              α
                           
                         into the set cover formulation to minimize the volume occupied by excess boxes. The execution of PCG can be divided into two stages. The first stage (Zhu, Huang, et al., 2012, steps 2-4, Section 4) improves the accuracy of the set cover formulation: the outer loop introduces new prototypes and the middle loop gradually realizes the prototypes into actual loading patterns. In the second stage (Zhu, Huang, et al., 2012, steps 5, Section 4) a binary search is carried out on loading factor 
                           
                              α
                           
                        . The searches performed in the two stages are carried out along two independent directions. If we think of the search space as a two-dimensional plane and plot the trail of the search, we will find that the search proceeds along one line in the first stage, and then turns 90 degrees and proceeds along another line in the second stage. In contrast, our GD-PCG searches both directions simultaneously, and is thus more versatile.

GD-PCG involves various strategies and parameters that may affect the performance of the algorithm, so each algorithm must be carefully calibrated to maximize its effectiveness. We perform a series of computational experiments based on small samples of the test instances to identify the best combination of strategies and parameter values for our algorithm. The main reason for using a small sample for the calibration is to avoid overfitting the algorithm to the given test data. If the parameters of GD-PCG are determined by a small sample of instances, and these parameters also work well for the full set of test data, we can then reasonably conclude that they are likely to work well for the unknown actual instances that arise in practice.

We then compare the performance of our calibrated GD-PCG with existing approaches based on 350 benchmark instances (see Section 6.2). The 350 MTC instances with known optimal solution were generated specifically for the MCLCMP by Che et al. (2011). Three container types with dimensions equivalent to shipping containers of standards sizes (namely, 20-foot, 40-foot, and 40-foot high cube containers) are used in these instances. The cost of three container types is set to 900, 1700 and 1800 respectively. They are divided into seven classes with 50 instances each. The classes are labeled MTC3,
                     MTC4,…,
                     MTC9, where the digit indicates the number of box types. As these instances are generated by partitioning the container into rectangular sub-regions and each sub-region is then filled by only one type of box. Che et al. (2011) verified that the optimal of this solution by solving a linear integer program. The reader may refer to Che et al. (2011) for details of these test instances.

We proceed to generate a set of new instances based on real data from an international manufacturer of audio equipment and report our computational results for future reference in Section 6.3. The new instances are available at http://www.computational-logistics.org/orlib/topic/MCLCMP%20III together with the detailed experiment results.

Our GD-PCG approach is implemented as a sequential algorithm in Java with Sun Microsystem’s JDK 1.6.0 update 17, and with no explicit multi-threading. The experiments are performed on an Intel Xeon E5430 with a 2.66gigahertz (Quad Core) CPU and 8gigabytes RAM running the CentOS 5 Linux operating system. The commercial integer linear programming solver used is ILog CPlex 11.0 is used with its default settings.

There are a few parameters in our algorithm that control the trade-offs between solution quality, robustness, and execution time. We attempt to identify the best configuration as follows. Starting with a base configuration, we vary one parameter while keeping the other parameters unchanged to create alternative configurations. We then conduct experiments on a small set of test data to compare the performance of the various configurations. The experiments in this subsection are conducted on 21 out of the 350 MTC instances. Recall that the MTC instances are grouped into seven test sets, each consisting of three types of instances. We randomly select one instance of each type from each test set to form the sample.

After an experiment, we analyze the results to evaluate the impact of the parameter on the algorithm’s performance, and then pick a configuration that achieves the best balance of performance and robustness. We then use this configuration as the new basis and proceed to decide the best value for the next parameter. We perform this series of experiments such that the parameters that are expected to have the greatest impact to performance are decided first.

Note that most parameters are interdependent, that is, the best value for a parameter depends on the values of the other parameters. Hence, after we pick the “best values” for a few parameters, it is necessary to verify that the choices we made for earlier parameters remain the best choices. The entire process is essentially a manual search for the best configuration in the parameter space by trial and error. Our calibration process ends once a locally optimal configuration is found. If we vary any parameter in our final configuration, the performance or robustness of the algorithm deteriorates.

Our experiments establish that the following configuration for GD-PCG achieves a good balance of effectiveness and robustness for the test data.
                           
                              •
                              The initial prototypes 
                                    
                                       
                                          
                                             Q
                                          
                                          
                                             u
                                          
                                       
                                    
                                  includes 20 for each container type.

The number of iterations of the middle loop of GD-PCG 
                                    
                                       
                                          
                                             K
                                          
                                          
                                             gap
                                          
                                       
                                       =
                                       10
                                    
                                  (line 5, Algorithm 1, page 9).

The time limit for each invocation of CPLEX 
                                    
                                       
                                          
                                             TL
                                          
                                          
                                             CPLEX
                                          
                                       
                                       =
                                       15
                                       
                                       seconds
                                    
                                 .

The search is to be performed by increasing 
                                    
                                       α
                                    
                                 , specifically 
                                    
                                       
                                          
                                             α
                                          
                                          
                                             0
                                          
                                       
                                       =
                                       0.85
                                       ,
                                       Δ
                                       α
                                       =
                                       0.02
                                    
                                 .

The Gross volume utilization 
                                    
                                       γ
                                       =
                                       0.99
                                    
                                 .

The time limit to realize a prototype by ID-GLTS 
                                    
                                       
                                          
                                             TL
                                          
                                          
                                             SCLP
                                          
                                       
                                       =
                                       5
                                       
                                       seconds
                                    
                                 .

We will use this “locally optimal” configuration as the base configuration to illustrate how we vary one parameter at a time in order to pick the best value for each parameter. For each configuration of the GD-PCG algorithm, we invoke it once for each instance and record the best solution after each iteration of the middle loop. Since we know the optimal solutions for the MTC test set, we can compute the percentage gap to optimal for the produced solutions. After all 21 instances are solved, for each iteration of the middle loop, we compute the average gap over the 21 instances and use it as the performance indicator for that iteration. Finally, we plot the performance of each configuration over the iterations. This allows us to easily visualize both the convergence behavior and the overall performance of each configuration.

In the base version of GD-PCG, the value of 
                              
                                 α
                              
                            is initially set to 
                              
                                 
                                    
                                       α
                                    
                                    
                                       0
                                    
                                 
                                 =
                                 0.85
                              
                            and increased by 
                              
                                 Δ
                                 α
                                 =
                                 0.02
                              
                            in each iteration of the middle loop (line 5, Algorithm 1). This corresponds to an upward linear search. We configured the following two additional versions of GD-PCG:
                              
                                 •
                                 
                                    downward linear search: where 
                                       
                                          
                                             
                                                α
                                             
                                             
                                                0
                                             
                                          
                                          =
                                          1.0
                                       
                                     and 
                                       
                                          Δ
                                          α
                                          =
                                          -
                                          0.02
                                       
                                    ,


                                    fixed 
                                    
                                       
                                          α
                                          =
                                          1.0
                                       
                                    : where 
                                       
                                          Δ
                                          α
                                          =
                                          0
                                       
                                    . This resembles the strategy used by the PCG algorithm.


                           Fig. 1
                            plots the overall performance of the three configurations over the iterations. Either an upward (line labeled 
                              
                                 0.85
                                 
                                 ↑
                              
                           ) or downward (line labeled 
                              
                                 1.0
                                 
                                 ↓
                              
                           ) linear search on 
                              
                                 α
                              
                            performs consistently better than using a fixed loading factor 
                              
                                 α
                                 =
                                 1.0
                              
                            throughout all 10 iterations. Since fixing the loading factor at 
                              
                                 α
                                 =
                                 1.0
                              
                            resembles the strategy used by the PCG algorithm, we can conclude that the strategy by GD-PCG is better.


                           Table 1
                            compares the performance of the three configurations on individual test set. We can see that gap to optimal increases as the number of box types increases when 
                              
                                 α
                              
                            is set to 1.00. However, the performance of upward and downward strategies is less affected by the heterogeneity of the test instances. As we explained in Section 4, it is often the case in an optimal solution to the set cover formulation of SCP some of the inequalities (5) are strict, which means that the set of selected prototypes and packing patterns contain more boxes than required. This case happens more often when there is more boxes type and result in larger optimality gap. Using loading factor smaller than 1 forces us to consider container combinations with a smaller capacity and help reduce the cost of the solution. It is more effective at improving solution when the number of boxes is larger. As a result, varying loading factor improves robustness of our GD-PCG.

We prefer a linear upward search on 
                              
                                 α
                              
                            in our final GD-PCG algorithm since it performs better than both a linear downward search and a fixed loading factor.

In the base version of GD-PCG, we set 
                              
                                 γ
                                 =
                                 0.99
                              
                           , which indicates that we expect to utilize up to 99% of the total volume of all containers in an MCLCMP solution. We created two additional configurations with 
                              
                                 γ
                                 =
                                 1.0
                              
                            and 
                              
                                 γ
                                 =
                                 0.98
                              
                            for comparison. Fig. 2
                            plots the performance of these three versions of GD-PCG over the iterations.

We can see that 
                              
                                 γ
                                 =
                                 0.99
                              
                            outperforms 
                              
                                 γ
                                 =
                                 1.0
                              
                           . This is mainly because, given the short time frame, the underlying SCLP algorithm is unlikely to produce loading patterns with volume utilization higher than 99%. Hence, setting 
                              
                                 γ
                                 =
                                 0.99
                              
                            eliminates those prototypes that are very unlikely to be realized from consideration and improves the overall efficiency.

As we further reduce 
                              
                                 γ
                              
                            to 0.98, we eliminate more prototypes from consideration. It happens that in the optimal solutions to the MTC instances, the average volume utilization of the containers is as high as 99%. Therefore, this setting eliminates the optimal solutions and possibly many near-optimal solutions, which explains why 
                              
                                 γ
                                 =
                                 0.98
                              
                            is worse than 
                              
                                 γ
                                 =
                                 0.99
                              
                            after five iterations.

This experiment shows that if we can guess the expected volume utilization, we can improve the quality of the solutions. For instance, in a real application we do not know the expected overall volume utilization in advance. However, we can still gather some form of knowledge using statistics. For example, we can record the average volume utilization of the solutions found by our SCLP solver over a series of trial runs and then set 
                              
                                 γ
                              
                            accordingly after a sufficient number of problem instances have been solved. If we observe that the average is 95%, we can be somewhat conservative and set 
                              
                                 γ
                                 =
                                 0.97
                              
                           . As the assortment of boxes in some applications (for example in factories) are expected to be stable, this method of estimating the capability of the SCLP solver may be effective because the volume utilization of containers is also likely to remain reasonably stable in the same application environment.

In the base version of GD-PCG, once a feasible solution is found, the GoalDrivenSearch procedure is invoked to try to find an improved solution. We implemented another version of GD-PCG where this goal driven search is disabled. The comparison of these two versions of GD-PCG is plotted in Fig. 3
                           .

When GoalDrivenSearch is disabled (line labeled no GD), GD-PCG can still converge to good results eventually, but it does not perform as well in earlier iterations. When we compare the total execution time and time-to-best (Table 2
                           ), it becomes clearer that GD-PCG converges much faster when GoalDrivenSearch is enabled. Hence, we can conclude that the GoalDrivenSearch procedure introduced in GD-PCG is indeed useful.

In the base version, we set the time limit for each invocation of CPLEX at 15seconds. That is, when solving the LP and IP models, if an optimal solution cannot be found before the time limit, then the best solution found so far is returned when the time limit is reached. We vary the time limit to be 2seconds, 5seconds, 10seconds, 15seconds, 20seconds, and 25seconds. The overall performance over the iterations is plotted in Fig. 4
                           . In general, there is not much difference.

Although setting the CPLEX time limit to 15seconds seems to achieve slightly better results than the other settings, the difference is slight. When we look at the final solutions at iteration 10, the difference is even smaller (column avg. gap in Table 3
                           ).

However, the time limit for CPLEX does impact both the total execution time and how quickly we can find the best solutions. Table 3 reports the total execution time in column avg. t (second) and the time when the best solution is found in column avg. ttb (second); both values are averaged over the 21 test instances. As expected, as the time limit for CPLEX decreases, the total execution time decreases. The increase in total execution time is not proportional to the increase in the CPLEX time limit. This is mainly because the set cover problem is well studied and CPLEX is able to find an optimal solution for many instances in a short time. Only a few large instances cause CPLEX to eventually reach the time limit.

The time-to-best ttb shows an interesting trend that is different from the total execution time. As the time limit for CPLEX decreases, the time-to-best first decreases and then increases, with the minimum achieved when the CPLEX time limit is set to 15seconds. This indicates a change in the behavior of GD-PCG. One possible explanation for this change is that when the time limit for CPLEX is reduced, the quality of the solution found is also reduced (the average gap to optimal is enlarged). Initially, the reduced time limit does not lead to much deterioration of the solution quality by CPLEX, which leads to a net reduction in time-to-best. However, when the time limit is very short, the solutions found by CPLEX are comparatively poor, so GD-PCG must rely more on the Insert and GoalDrivenSearch procedures to improve the solution. Furthermore, the inner loop that iteratively adds columns until an optimal solution to LP is found may also require more iterations. The final result is an increased time-to-best on average.

Based on these observations, we prefer to set the CPLEX time limit to 15seconds for two reasons. First, we feel that time-to-best is a more meaningful indicator of the speed of an algorithm, as the total execution time can be easily adjusted by changing the number of iterations 
                              
                                 
                                    
                                       K
                                    
                                    
                                       gap
                                    
                                 
                              
                           . When we set the CPLEX time limit to 15seconds, the average time-to-best is shortest. Second, there is a possible change of behavior in GD-PCG when the CPLEX time limit is further reduced, whereby the algorithm shifts from relying on solving the set cover formulation, in order to identify high quality solutions, to relying more on the ad hoc GoalDrivenSearch procedure to improve solutions. We feel that solving the set cover formulation represents a higher level decision in solving the MCLCMP, and thus focusing on solving set cover is more reliable.

In the base version, the time limit for solving one instance of the SCLP is set to 5seconds. We also try 2.5seconds and 10seconds, and plotted the results in Fig. 5
                           .

We can see that both 5seconds and 10seconds outperform 2.5seconds. This is because increasing the SCLP time limit always improves (though not monotonically) the quality of the loading patterns produced, and hence the probability of finding better final solutions increases. When the time limit for the SCLP is sufficiently large, the quality of the SCLP solution is no longer the bottleneck, and a further increase of time allocated does not result in significant improvements in the overall solutions.

From Table 4
                           , we can see that increases in the SCLP time limit have a very significant impact on the total execution time (column avg. t (second)) and time-to-best (column avg. ttb (second)). Although with time limits of 10seconds and 5seconds, the SCLP converges to similar solutions after the same number of iterations (7 iterations), from the point of view of execution time the time-to-best for the 10seconds version is 60% more than that for the 5seconds version. This is not surprising, as the former takes twice the time to solve each SCLP instance.

Based on these observations, we select 5seconds as the time limit for the SCLP, as increasing it from 5seconds to 10seconds does not improve the overall solutions but does significantly increase the total execution time and time-to-best.

We compare our GD-PCG approach against the Prototype Column Generation (PCG) approach by Zhu, Huang, et al. (2012) based on the existing 350 MTC instances. The computational environments of the PCG and our GD-PCG are identical.

Compared with PCG, GD-PCG employs the state-of-the-art SCLP solver to convert prototypes into packing patterns. To understand how much performance improvement is due to the new SCLP solver and how much is due to the enhancements that we have introduced in GD-PCG search framework, we obtained a copy of the source code of PCG from Zhu, Huang, et al. (2012) and replaced its SCLP solver with ours. Our implementation of PCG is otherwise identical to that of Zhu, Huang, et al. (2012) and we denote this version as PCG(new).


                        Table 5
                         compares the PCG, PCG(new) and GD-PCG results for the 350 MTC instances, where GD-PCG(FS) is GD-PCG with full support constraint enforced. All of the figures reported in the table are averaged over the 50 instances of each test set except for the last column SN. Given the cost of the solution found and the optimal solution for an instance, the gap to optimal for an algorithm is calculated as 
                           
                              (
                              cost
                              -
                              opt
                              )
                              /
                              opt
                           
                        . The columns gap report the average gap to optimal over the 50 instances, and the columns t (second) give the average time taken in CPU seconds by the corresponding algorithm. For the GD-PCG approach, the column ttb (second) is the average amount of computation time in CPU seconds required for GD-PCG to first find its final best solution. The column SN is the value of the step number parameter SN that controls the number of candidate prototypes generated.

Comparing PCG with PCG(new), we can see that upgrading the SCLP solver indeed improves the performance of PCG. It greatly reduces the total computation time and also slightly improves the solution quality.

The gap between GD-PCG and the optimal solution is significantly smaller than for PCG(new). As both algorithms utilize the same SCLP solver, we conclude that the increase in solution quality is mainly due to the enhancements introduced in GD-PCG rather than the SCLP solver.

Although the problem sizes (in terms of number of boxes per instance) are approximately the same across all seven test sets, the gap to optimal for the PCG and PCG(new) increases as the number of box types increases. This observation is in line with the common understanding that strongly heterogeneous container packing instances are generally harder to solve than weakly heterogeneous instances. However, the performance of GD-PCG is less affected by the heterogeneity of the test instances, as both the gaps to optimal and the total execution times of GD-PCG are more consistent across the seven test sets than those of PCG. This suggests that our GD-PCG is more robust across a wide range of application scenarios.

The full support constraint, which requires all boxes are fully supported from below for stability, is important in practical applications. Although Zhu, Huang, et al. (2012) described how their algorithm can be modified to handle the full support constraint, they did not report computational results with the full support constraints. GD-PCG(FS) in Table 5 gives our GD-PCG for the 350 MTC instances with the full support constraint enforced. The results are similar to those for the MTC instances without full support.

To handle the full support constraint, we first require the single container solver to produce only solutions fulfilling full support constraint. The solver ID-GLTS (Zhu & Lim, 2012) we employed can handle the full support constraint. Because we use greater or equal inequalities 2 instead of equality in 
                           
                              SCP
                              (
                              P
                              )
                           
                         model, the MCLCMP solution found by our approach may include more boxes than required. We have to remove excess boxes from the solution while ensuring remaining boxes are still fully supported. When removing excess boxes violates full support constraint for some boxes in a container, we try to resolve the violation by unloading all the boxes in the container and reload them (this operation rarely fails, since removing boxes introduce extra space). We get a feasible solution if we can successfully resolve all violations. In rare, case if we fail to resolve any violation, we can simply discard the solution and try next one.

We generated a new set of MCLCMP instances using data from an industrial project for an international acoustics equipment manufacturer, divided into 190 instances with between 2 and 10 box types. Each instance of the data we obtained from this manufacturer corresponds to an order of audio speakers to be shipped in standard 20-foot, 40-foot or 40-foot high cube containers (their prices are the same as for the MTC instances). The original data describes relatively small orders that can be entirely loaded into one container. Consequently, to convert this data into MCLCMP instances, we multiplied the number of boxes of each type by 15. For each new generated instance, a lower bound of the cost can be found by solving the following IP model using CPLEX:
                           
                              (8)
                              
                                 Minimize
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          =
                                          1
                                       
                                       
                                          M
                                       
                                    
                                 
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 Subject
                                 
                                 to
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          =
                                          1
                                       
                                       
                                          M
                                       
                                    
                                 
                                 
                                    
                                       L
                                    
                                    
                                       t
                                    
                                 
                                 
                                    
                                       W
                                    
                                    
                                       t
                                    
                                 
                                 
                                    
                                       H
                                    
                                    
                                       t
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 ⩾
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       n
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 ⩾
                                 0
                                 
                                 and
                                 
                                 integer
                                 ,
                                 
                                 t
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 M
                              
                           
                        where inequalities (9) ensure selected containers offer sufficient volume to accommodate all boxes.


                        Table 6
                         reports the results obtained by PCG and GD-PCG for the 190 GP instances, where GD-PCG(FS) is the GD-PCG with full support constraint. The test data is classified into sets by the number of box types as given by the column N, and the number of instances in each set is given by the column count. The results with and without the full support constraint are reported under the headings GD-PCG (FS) and GD-PCG, respectively. The columns gap provide the average gap to lower bound of the test sets. The columns t (second) give the average time taken in CPU seconds, and the column SN shows the value of the step number parameter SN that controls the number of candidate prototypes generated. We can see that the GD-PCG outperforms PCG in terms of both the solution quality and the time.

In order to further investigate the performance of our approach, we generate another set of instances based on the classical single container loading instances introduced by Bischoff and Ratcliff (1995) and Davies and Bischoff (1999) (known as BR instances). The original data are classified into 15 groups of 100 instances and different groups contain instances with a different number of box types. Similar as the GP instances, to convert this data into MCLCMP instances, we multiplied the number of boxes of each type by 15. The container types are set same as for the MTC instances. As the instances in one group have similar characteristic, we only use the first 10 instances in each group. The number of initial generated prototype grows exponentially as the number of box type. Based on the preliminary experiment, our method can only handle the cases when the number of box type does not exceed 30. So we only use the first eight groups, namely, BR1,…,BR8. The final transformed instances are denoted as MTCBR1,…,MTCBR8, and each group contains 10 instances.


                        Table 7
                         reports the results obtained by PCG and GD-PCG for the 80 MTCBR instances, where GD-PCG(FS) is the GD-PCG with full support constraints. All of the figures reported in the table are averaged over the 10 instances of each test set except for the last column SN. We can see that GD-PCG outperforms PCG in each group. A similar phenomenon as MTC instances can be found that the gap of PCG increases as the number of box types increases. However, the performance of GD-PCG is less affected by the number of box types. This suggests again that our GD-PCG is more robust than PCG.

@&#CONCLUSIONS@&#

In this paper, we propose an algorithm for the MCLCMP that combines the prototype column generation method with a goal-driven strategy. The GD-PCG algorithm improves on PCG in three respects. First, the PCG algorithm carries out the search in two stages and each stage approaches good solutions to the MCLCMP in its own dimension, whereas GD-PCG searches in both dimensions at the same time. Second, we introduce gross volume utilization 
                     
                        
                           γ
                        
                      into the set cover formulation for that MCLCMP which roughly estimates the expected overall volume utilization of the containers in a solution. Third, once a solution is found, a goal-driven search is carried out in the solution’s neighborhood to improve the solution.

Computational experiments suggest that all three enhancements are useful. Our approach outperforms all existing MCLCMP approaches on benchmark data in terms of both solution quality and computation time.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the National Nature Science Foundation of China (Grant no. 71401065).

@&#REFERENCES@&#

