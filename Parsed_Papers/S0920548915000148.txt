@&#MAIN-TITLE@&#A technique for sharing a digital image

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A true color secret image can be concealed into two meaningful cover images.


                        
                        
                           
                           5 algorithms are proposed to share a secret color image.


                        
                        
                           
                           Our schemes can achieve both the benefits of smaller share size and good visual quality.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Visual cryptography

Secret image sharing

Color image

Information hiding

@&#ABSTRACT@&#


               
               
                  A new information hiding scheme for color images based on the concept of visual cryptography and the Boolean exclusive-or (XOR) operation is proposed. Three different schemes with noise-like, meaningful and binary shares are presented. Meaningful shares may reduce suspicion that something is concealed there. Binary shares can achieve both the benefits of smaller share size and good visual quality. Our model can be easily extended from 256 colors to 65,536 or true color images simply by expanding the block size from 3×3 to 4×4 or 5×5, respectively.
               
            

@&#INTRODUCTION@&#

The combination of computer and communication technology has led to the rapid development and maturity of digital media usage. More and more digital data (text, voice, and image) are transmitted and exchanged over the Internet. It is now very easy to spread, duplicate, capture and modify multimedia data. However, the convenience of sharing digital data over the Internet has produced problems such as misappropriation of data, illegal data usage and other problems regarding intellectual property rights. How to protect important data from attacks becomes a very critical issue. A secure information sharing technique to protect transmitted data from illegal interceptors is needed. Recently, a number of intellectual property protection schemes have been proposed. In all of them, encryption is still the fundamental method used to protect important data files for the purpose of copyright protection, integrity checking and captioning. However, the computation needed for the encryption and decryption processes is quite complex and noise-like encrypted results may tempt an interceptor to break it. To avoid these problems, researchers have developed information hiding techniques to conceal the secret image in a cover image. The result is the so called stego image. The secret image can be delivered with the help of the stego image where the hidden information is not immediately apparent, which enhances the security of the secret information being transmitted. Even if the stego image is captured by illegal interceptors, there is still a good chance to avoid giving rise to suspicions that some secret information may be hidden inside.

Generally speaking, the research studies related to information hiding can be categorized into two schools — the spatial domain [1–6] and the frequency domain [7–12]. The spatial domain methods employ the property where a tiny change of pixels cannot be detected by the human eye; therefore, secret information is embedded by directly modifying the pixel's gray value. The Least Significant Bit (LSB) [1] is the simplest and the most commonly used of the spatial domain techniques. In the frequency domain methods, the host image is mainly turned into frequency space; the secret information is embedded by modifying the coefficients of the frequency space, and then transformed back to form a watermarked image. The main transformation techniques include the Fast Fourier Transform (FFT), Discrete Cosine Transform (DCT), and Discrete Wavelet Transform (DWT) techniques.

Cryptography is a technology that transforms plaintext into meaningless or disordered messages through mass and complicated computing. As a result, ciphertext is produced. Without knowing the correct key, this transformation process cannot be reversed under confined resources (e.g., time) to ensure the safety of the secret data. In conventional cryptography, the encryption/decryption algorithms require complex computations, which mean that they are not suitable for an environment without computers. Naor and Shamir [13] introduced a perfectly secure method called visual cryptography (VC) for protecting the secret images. Compared with other traditional encryption/decryption processes, the visual secret sharing (VSS) scheme possesses the advantages of needing only human visual perception to decrypt the secret images, without the need of any complex mathematical operations. The basic model of VC consists of “splitting” the image or watermark into two transparencies (shares). One share can be regarded as the ciphertext and the other one as the secret key (called the key share). Each share looks like random noise, without any clue disclosing the outlines of the secret image. The original image can be revealed simply by superimposing these two shares. Due to its simplicity, the model can be used by anyone, even those without knowledge of cryptography and without the help of a computer to perform any complex computations.

The basic operation used to restore the secret image in VC is by stacking the shares [14–21]. The action of stacking transparencies works like a logical “OR” operation, in which 0 stands for a white pixel and 1 stands for a black pixel. When a black pixel appears in the corresponding position of any share of the stacked images, the result of stacking those pixels will be black. Only when the pixels of all shares for the corresponding position are white, will the result be white. Therefore, as long as the shares are arranged so that the stacked blocks corresponding to white pixels in the secret image remain half black and half white, and those corresponding to black pixels remain all black, the stacked blocks will provide enough contrast for the human eye to identify the secret image without the aid of a computer.

However, the OR operation is the main reason that the white pixels will be reconstructed as half-white-and-half-black blocks. The contrast in the stacked image is reduced to 50%. Therefore, some researchers [10,12,22–24] tried to change the default OR operation of VC into another operation, such as “XOR” to perfectly reconstruct the secret image during the decoding phase if a light-weight device is available. However such VC-like method can only handle pictures with limited colors.

In this study, a new VC-like scheme for digital color images based on XOR is proposed. Our scheme improves upon the drawbacks of [10,12,22–24], i.e., it can handle true color images, using only one operator (XOR) and a mask share is not needed to help in the generation of secured shares. The remainder of this paper is organized as follows. In the next section, we offer a concise introduction of related works. In Section 3, three different information hiding schemes with noise-like, meaningful and binary shares are presented. The experimental results are discussed in Section 4. Finally, a discussion and some conclusions are given in Section 5.

@&#LITERATURE REVIEW@&#

In Naor and Shamir's VC scheme [13], two n
                        ×
                        m matrices named C
                        0 and C
                        1 are used, in which n is the number of participants and m is the pixel expansion ratio; C
                        0 represents the splitting and sharing model for the white pixels, and C
                        1 for the black ones. Without loss of generality, we take the case where (k, n)=(2, 2). Only two out of two shares are needed to recover the secret image in this example. The dispatch matrix is shown in Table 1
                        . Each row of the matrix indicates the content dispatched (0 for white, 1 for black) to each participant. No matter what the pixel value is on the secret image, the blocks in each share appear as one-black-and-one-white blocks. The share's safety is ensured because the interceptor cannot find any secret information from any one share. When sharing a white pixel, the block content in each share is the same type, otherwise it is a complementary type. After superimposing shares, the white pixels in the secret image will be half-white-and-half-black, while the black pixels will display as fully black. Although the contrast in the stacked shares is reduced to 50%, it is still easy to decode the confidential data with the human visual system.

Look at the example in Fig. 1
                        . A cartoon (Fig. 1a) is used as the secret image. The cartoon is decomposed into two noise-like transparencies, named share 1 and share 2 (Fig. 1c and d). The two transparencies are superimposed to obtain the restored image (Fig. 1b). Although there is a 50% degradation in the contrast of the restored image (Fig. 1b) compared to the original (Fig. 1a), the secret image can still be easily identified with the human eye.

If the shares are noise-like images, even though interceptors will not be able to obtain any information about the secret image from any single share, they will suspect that something might be concealed there, which increases the risk of being attacked. Therefore, having meaningful content on the shares provides a double layer of protection. The first layer of security is that attackers are not so likely to suspect that there is secret information concealed in the shares, so the possibility of attack is reduced. The second layer of security arises from the visual cryptographic mechanism itself. The attacker cannot perceive anything regarding the secret message from a single share because of the random dispatching scheme. Consequently, the adoption of meaningful-image shares can improve the security of secret information.

Ateniese, Blundo, Santis, and Stinson [14] extended the capability of the visual secret sharing mechanism and proposed a visual cryptography technique using an ordinary image as the cover image. In this dispatching model (Table 2
                        ), the shares have black and white contrast (e.g., a black pixel is replaced by a 3-black-and-1-white block, while white pixels are replaced by a 2-black-and-2-white block). Therefore, the shares show the contents of the cover image. When shares are stacked together, 4-black spots represent a black pixel, while 3-black-and-1-white stand for a white pixel. In this way, the contents of the secret images can be clearly identified (Fig. 2
                        ). However, in Ateniese's sharing method, the secret image is limited to black and white.

Hou and Wu [15] extended Ateniese's visual cryptography model by applying the color decomposition and halftone techniques to decompose a secret color image into three monochrome (cyan, magenta, and yellow) halftone images, to finally produce colored, meaningful shadow images.

Hwang and Chang [16] modified Ateniese's visual cryptography model by extending each block from 2×2 sub-pixels to 3×3 sub-pixels. They use 5 and 7 black sub-pixels to represent the white and black pixels of the cover image; while 7 and 9 black sub-pixels are used to represent the white and black pixels of the restored secret image. Chang, Tai, and Lin [17] extended Hwang and Chang's scheme [16] to a color image. The common drawback for both schemes is that the contrast in the shares and the recovered image is always 2/9 which is worse than with Ateniese's method (1/4). With the help of the halftone technique, Zhou, Arce, and Crescenzo [18] and Wang, Arce, and Crescenzo [19] produced better contrast in the recovered image, but the shares were at least four times larger in size than the secret image.

Tsai, Chen, and Horng [20] proposed a scheme that could generate meaningful shares, but the whole cover image could not be concealed from the stacked shares, which makes for a poor quality restored image. Nakajima and Yamaguchi [21] proposed an extended visual cryptography scheme for natural images. Unfortunately, the size of the shares was at least nine times larger than that of the secret image.

All the above research studies are related to visual cryptography, i.e., the decoding method is based on the human visual system, when k or more than k shares are stacked. The stacked image will display meaningful contrast to disclose the secret image, and hence no knowledge of cryptography is needed. However, the reconstruction ability of VC is not flawless because the white pixels are reconstructed as half-white-and-half-black blocks which reduce the contrast in the stacked image to 50%. This is why several researchers have tried to find ways to change the default OR operation of VC to another operation, such as AND or XOR to perfectly reconstruct the secret image during the decoding phase if a light-weight device is available (Table 3
                        ).

Chen et al. [10] and Lou et al. [12] used the wavelet transformation, by comparing the coefficients of the medium frequency and the low frequency to produce the share image with a size two times larger. Due to the fact that the low frequency coefficients must be larger than the coefficients of the medium frequency, the comparison results are inclined to be one-sided. To be specific, the results of f(i, j) and f′(i, j) calculated in [10,12] are always equal to 0, so that before and after attacks the public image and the original secret image are well matched, which completely lost the sense of verification. Since Chen et al. adopted the 3-level wavelet transformation, the size of the watermark can only be M
                        1/8×
                        M
                        2/8 times of the original image.

Chang, Tsai, and Chen [22] proposed a VC-based technique for sharing a secret color image. In their scheme, a color index table (CIT) is created first, with each index of the CIT related to a unique color. It is assumed that index K is used to represent the color of the corresponding pixel in the secret image. Then, each pixel of the secret image is expanded to a block with m
                        ×
                        m sub-pixels in which K of them are randomly filled up with the corresponding color of the secret pixel. As for the shares, any randomly chosen ⌊m
                        ×
                        m/2⌋+1 sub-pixels in each block are filled up with the corresponding color of the cover image, and the rest of the sub-pixels are filled up with white. The selection criterion for choosing these ⌊m
                        ×
                        m/2⌋+1 sub-pixels is as follows: exactly K colored sub-pixels must be put at the same positions for both shares. Although Chang's approach can handle color images, the number of distinct colors in the secret image is limited. Take m
                        =3 for example, where at most 5 colors can be displayed in the secret image. This is quite restrictive, especially in the multimedia environment.

Lin [23] proposed a new color VC-based scheme that could solve the limited color problem. Lin gave a different interpretation of the bit pattern for the m
                        ×
                        m sub-pixels. In this method, m
                        ×
                        m bits are used to represent 2
                           m
                           ×
                           m
                         different encoded numbers which can be used to represent 2
                           m
                           ×
                           m
                         different color indices. Therefore, Lin's scheme allows the sharing of a secret image with much more colors than was possible with Chang's scheme. Take m
                        =3 for example. In this case a secret image with 512 colors can be shared. Lin used two operators, AND and OR, to compute the binary code for the overlapping blocks in the stacked image. In order to prevent the leaking of the outlines of the secret image on each share, a mask share is used to generate more secure shares.

Jin, Yan and Kankanhalli [24] proposed a multi-resolution approach for the sharing of secret images. They expanded the pixels to 3×3 blocks within which eight pixels represent the gray value of each pixel and the remaining one is used to store the halftone value of the secret image. In order to take advantage of visual effects, they used a “look-up table” to adjust the value so that pixels with a greater gray value in the secret image would have more “1”s (1 represents black) in their 8 bit-planes. The eight adjusted binary digits were handled by conventional visual cryptography and the obscured secret image could be directly obtained by stacking shares. The halftone secret image could be perfectly reconstructed by utilizing a computer to perform the logical XOR operation on the 9th digit of the shares. In fact, Jin et al.'s method did not progressively disclose the secret image, as mentioned in their title. At most, we can say that they proposed a multi-resolution scheme that utilized different approaches to share secret images. Their method expanded every secret pixel to a 3×3 block. However, by using a pixel-expansion scheme, the shares will be further expanded to 6×6 times larger, which causes a severe waste of storage and transmission time.

In this paper, a new information hiding scheme for the transmission of digital color images based on the concept of VC is proposed. We use XOR to compute the binary code for the overlapped blocks in the stacked image. Our scheme improves upon the drawbacks mentioned in [22–24], i.e., we can handle true color images using only one operator (XOR) and we do not need a mask share to guarantee the generation of noise-like shares.

As illustrated in Fig. 3
                     , the proposed scheme consists of two phases. We first generate two noise-like shares using the techniques described in Section 3.1. The dispatch algorithms for 256 colors and true color images are presented in Sections 3.2 and 3.4, respectively. Then, the blocks on the shares created by Sections 3.1, 3.2 and 3.4 are filled with the corresponding color of the cover image. This will transform the noise-like shares into meaningful ones. The transformation procedures are discussed in detail in Sections 3.5 and 3.6. In the decoding phase, the XOR operation is performed on the binary codes which are embedded in the pixels of the shares. The color of the secret pixel at that location is easy to find using the algorithm which will be described in Sections 3.3 and 3.7.

For a 256 colors secret image, we need 8 bits (B1–B8) to record the corresponding color index in the color index table (CIT). Therefore, every pixel of the image is expanded to become a 3×3 sub-pixel block, as shown in Fig. 4
                        . The 9th sub-pixel (B9) is used to store the palette data to avoid separately transmitting them in an unsafe environment.

We first give an example to illustrate the basic idea. When we want to dispatch a secret pixel to the shares, we first count the number of 1s in B1–B8. Suppose there are n 1s in B1–B8; now randomly choose ⌈(n
                        −
                        B
                        9/2)⌉ locations of 1s to fill with a 1 in share 1, and a 0 in share 2. On the other hand, the remaining ⌊(n
                        +
                        B
                        9/2)⌋ locations of 1s are filled with a 0 in share 1, and a 1 in share 2. For the rest of the (8−
                        n) 0 locations, we randomly choose 5−⌈(n
                        +
                        B
                        9/2)⌉ locations to fill with a 1 in share 1 and share 2. And finally, we fill in the rest of the locations with 0. In this way, we can hide every pixel of the secret image in the shares.

As for the value of B9, we put the color bit (palette data) into the 9th position on share 1. The 9th position on share 2 is used to adjust the number of 1s in the corresponding block. If n is odd and the color bit is 0, or n is even and the color bit is 1, then we fill the 9th position of share 2 with a 1. Otherwise, if n is odd and the color bit is 1, or n is even and the color bit is 0, then we fill the 9th position of share 2 with a 0. In this way, every block on both shares has 4 white and 5 black sub-pixels in it, which means that regardless of what the color of the secret image is, the probability for them to appear as 1 on each share is the same as 5/9. Therefore, no clue of the content of the secret image is given in the shares. This indistinguishable property ensures the security of the shares.
                           Example 1
                           For a secret pixel with a color index of 171 (the binary code is 10101011) and the palette data to be stored at B9 is 0, there are 5 1s at the locations, B1, B3, B5, B7 and B8. We first randomly choose ⌈(n
                              −
                              B
                              9)/2⌉=3 locations (say, B1, B3 and B5) in share 1 to fill with 1s and the rest of 1s are placed at B7 and B8 in share 2. As for the rest of the locations of 0s (B2, B4 and B6), we randomly choose 5−⌈(n
                              +
                              B
                              9)/2⌉=2 locations (say, B2 and B4) to fill with 1s in both share 1 and share 2. The remaining unassigned locations in both share 1 and share 2 are filled with 0s.

For the value of B9, the color bit, which is assumed to be 0 in this example, is placed in the 9th position on share 1. Since n is 5 and the color bit is 0, we place a 1 at the 9th position of share 2. In this way, the blocks on both shares contain 4 white and 5 black sub-pixels, which means that secret information is not leaked from the shares. Given the values of n and the color bit, some dispatching examples are given in Table 4
                        .

The information sharing algorithm is detailed below.
                           Algorithm 1
                           
                              
                                 
                                    Step 1:
                                    Get the binary code of the secret pixel and 1 bit of the palette data and put them in B1–B9.

Count the number of 1s in B1–B8 and store it in n.

Randomly choose ⌈(n
                                       −
                                       B
                                       9)/2⌉ locations of 1s to fill with 1s in share 1, and 0 s in share 2. The remaining ⌊(n
                                       +
                                       B
                                       9)/2⌋ locations of 1s are filled with 0s in share 1 and 1s in share 2.

In the rest of the (8−
                                       n) 0 locations, randomly choose 5−⌈(n
                                       +
                                       B
                                       9)/2⌉ locations to fill with 1s in share 1 and share 2. Fill the rest of the (8−
                                       n)−(5−⌈(n
                                       +
                                       B
                                       9)/2⌉) locations in both share 1 and share 2 with 0s.

If n mod 2=1
                                          
                                             If B9
                                                =1, then B9
                                                1
                                                =1, B9
                                                2
                                                =0

Else if B9
                                                =0, then B9
                                                1
                                                =0, B9
                                                2
                                                =1

Else
                                          
                                             If B9
                                                =1, then B9
                                                1
                                                =1, B9
                                                2
                                                =1

Else if B9
                                                =0, then B9
                                                1
                                                =0, B9
                                                2
                                                =0.

For every 1 in share 1 and share 2, fill that location with black. For every 0 in both shares, just leave them blank (white).

Repeat steps 1–6, until every pixel in the secret image is processed.

The recovery algorithm is detailed below.
                           Algorithm 2
                           
                              
                                 
                                    Step 1:
                                    Divide the shares generated from Algorithm 1 into 3×3 blocks.

Take the 9th bit of each block from share 1. If it is white (transparent), we record it as 0; otherwise, we record it as 1. When all the color bits are collected, we can set up the palette table.

Take the first 8 bits of each block from both shares. If the color of that bit is white (transparent), we record it as 0; otherwise, we record it as 1. By doing so, we can get the binary code from share 1 and share 2.

Perform the XOR operation on these binary codes. The result is the index number on the CIT. Checking with the CIT, we can get the color code of the secret pixel at that location.

Repeat steps 3–4, until every block in the shares is processed.

The same algorithm 1 and algorithm 2 can be used to hide and recover a true color secret image. In this case, we use 24 bits to record the R, G, and B color of that pixel. Thus, every pixel is expanded to form a block with 5×5, as shown in Fig. 5
                        . Since there is no need to record the palette data, the 25th bit B25 can be abandoned, randomly assigned, or used to conceal additional data, like secret information or digital watermarks.

Although the scheme described in Section 3.2 can be used to dispatch a color image into two shares, the generated shares are noise-like images, whose appearance will easily attract the attention of interceptors. Steganography is the art and science of concealing secret messages in other multimedia in order to enhance the security of secret image transmission. Before being transmitted, the sensitive information is concealed in a meaningful cover (or camouflage) image. As long as the change is small, the modified camouflage image (called the stego image) will look like an ordinary innocent image. When the stego image is sent over the transmission channel, people may not suspect that it possesses important secret information, which enhances the level of security. Besides, an increase in the number of the indistinguishable noise-like shares for the different secret images means that the method is neither user-friendly nor easy to manage. To overcome the above problems, the scheme described in Section 3.2 is extended from noise-like shares to create meaningful ones.

The simplest way to generate meaningful share from a noise-like one is to transfer the color of the cover image to the corresponding blocks on the shares. Since every block contains 4 white and 5 black sub-pixels, if we substitute a black sub-pixel for the color of the cover image at that pixel location, we can get a meaningful share with 55.56% (=5/9) of the region showing the content of the cover image.

The meaningful share generation algorithm is detailed below.
                           Algorithm 3
                           
                              
                                 
                                    Step 1:
                                    Divide the shares generated from Algorithm 1 into 3×3 blocks.

Fill in 1s in the blocks of both shares with the corresponding color of the cover pixel at that location. Just leave 0s in both shares blank (transparent).

Repeat step 2, until every block in the shares is processed.

The only difference between generating noise-like shares (Algorithm 1) and meaningful shares (Algorithm 3) is the way the color is added to the sub-pixels with values equal to 1. In Algorithm 1, all sub-pixels with a value equal to 1, which are not related to the cover image, are filled in with black, which creates noise-like shares. However, in Algorithm 3, all of the corresponding sub-pixels with a value equal to 1, are filled with the color of the cover image, which will therefore create meaningful shares. All 0s in shares are treated as blank (transparent) in both schemes. The algorithm used for information recovery for meaningful shares is the same as that described in Section 3.3. To save space, the algorithm is not repeated here. Readers may refer to Section 3.3.

The method of pixel expansion is used to create shares just as has been done in most past research studies. A pixel is expanded into a 3×3 sub-pixel block, which makes the share nine times as large as the secret image. If a color image is used as the cover image, storage requirements will be a big problem. Therefore, in practice, a binary image should be used as a cover image in order to reduce the storage requirements needed for the shares. However, the scheme described in Section 3.5 cannot be used for binary cover images. Since we use a transparent color (white) to represent the 0 value in the blocks and use the color of the cover image at that position to represent the 1s, this will cause a serious problem at the positions where the color of the cover images happens to be white. We cannot differentiate between white sub-pixels that represent white in the cover image, and white sub-pixels that represent the transparent parts of the block. A different dispatching scheme is needed to generate shares for binary cover images.

The basic idea is that a block with 5-black-and-4-white spots will be darker than a block with 4-black-and-5-white spots. If we use a block with 5-black-and-4-white (4-black-and-5-white) spots to represent the black (white) color of the cover image, it can create a 1/9 contrast in each share and the content of the cover image will be naturally disclosed.

The meaningful share generating algorithm for a binary cover image is detailed below.
                           Algorithm 4
                           
                              
                                 
                                    Step 1:
                                    Divide the shares generated from Algorithm 1 into 3×3 blocks.

Fill in all 1s in the blocks of both shares with the corresponding color of the cover pixel at that location. Fill in all 0s in both shares with the complementary color of the cover pixel at that location.

Repeat step 2, until every block in the shares is processed.

The difference between generating meaningful color shares (Algorithm 3) and binary share (Algorithm 4) is the method of assigning the color to sub-pixels with a value equal to 0. In Algorithm 3, they are left as blank (transparent); therefore, the cover image will naturally emerge from the blank background. However, in Algorithm 4, they are assigned the color complementary to the cover pixel; therefore there will get 4 1s (or 0s) in the corresponding block when the cover pixel is white (or black). The remaining 5 sub-pixels with a value equal to 1 in each block are filled with the corresponding color of the cover pixel at that location. In this way, we can get a share where the black (white) regions are represented by 5-black-and-4-white (4-black-and-5-white) blocks. The contrast is 1/9, enough to allow the content of the cover image to be revealed by the human eye.


                        Algorithm 4 changes the shares generated with Algorithm 1 by assigning the color (1 or 0) of the cover pixel to every 1 in the corresponding 3×3 blocks. When the cover pixels are black, there is no problem; each block still has 5 1s and 4 0s in it. However, the block corresponding to each white cover pixel changes to 4 1s and 5 0s in it. In order to correctly perform the recovery algorithm, the contents of the blocks with 4 1s and 5 0s have to first be adjusted to their complementary values. Then, the procedures of Algorithm 2 can be applied to generate the desired results.

The recovery algorithm is detailed below.
                           Algorithm 5
                           
                              
                                 
                                    Step 1:
                                    Divide the shares generated from Algorithm 4 into 3×3 blocks.

Count the number of 1s in each block and store it in n. If n
                                       =4, change the value of each sub-pixel to its complement (i.e., 0 ↔ 1).

Repeat step 2, until every block in the shares is processed.

Take the 9th bit of each block from share 1. If it is white (transparent), we record it as 0. Otherwise, we record it as 1. When all the color bits are collected, we can set up the palette table.

Take the first 8 bits of each block from both shares. If the color of that bit is white (transparent), we record it as 0. Otherwise, we record it as 1. In this way, we can obtain the binary code from share 1 and share 2.

Perform the XOR operation on these binary codes. The result is the index number on the CIT. Check with the CIT to get the color code for the secret pixel at that location.

Repeat steps 5–6, until every block in the shares is processed.

@&#EXPERIMENTAL RESULTS@&#

The experiments are run on an Intel Core i7 860 2.8GHz CPU with 2GB of memory. The operating system is Windows 7, and Java (JDK 1.6.0_34) is used as the development tool. The superiority of our three schemes is discussed in Sections 4.1–4.3. Six 512×512 images are used in our experiment, as shown in Fig. 6
                     . Fig. 6(a, b) shows color cover images with 256 colors, Fig. 6 (c, d) shows binary cover images, and Fig. 6 (e, f) illustrates the 256 colors and true color secret images.

The secret image used in this experiment is shown in Fig. 6(e). Share 1, share 2 and the stacked result are shown in Fig. 7
                        . Since share 1 and share 2 are binary images, only 1 bit is used to encode each sub-pixel. The share size is 288K bytes (=(1×9×512×512)/(8×1024)), almost the same size as the secret image (256K bytes).

In order to overcome the problem of noise-like shares, the algorithm described in Section 3.5 is performed in this experiment. The cover images used appear in Fig. 6(a, b) and the results obtained with share 1, share 2 and the stacked image are shown in Fig. 8
                        . The shares are 256 color images, with 1 byte needed to encode each sub-pixel. The share size is 2304K bytes. It is much larger than the secret image (256K bytes).

In Fig. 9
                        , we select a true color image (Fig. 6(f)) as the secret image. The shares need to be expanded to be 5×5 larger; hence the size is expanded to 6400K bytes, which is much larger than the secret image (768K bytes). The only good thing is that this method generates meaningful shares, not noise-like ones in these experiments.

The algorithm used to overcome the problem of the large storage requirement for color shares, described in Section 3.6, is performed in this experiment. Binary images (Fig. 6 (c, d)) are used as the cover images and the results for share 1, share 2 and the stacked image are shown in Fig. 10
                        . Since the shares are binary images, each sub-pixel can be encoded with only 1 bit. The share size is only 288K bytes, as compared to 2304K bytes in Fig. 8, which is almost the same size as the secret image (256K bytes). To the best of our knowledge, this is the best results as compared with those obtained in previous related studies.

@&#DISCUSSION AND CONCLUSIONS@&#

@&#DISCUSSION@&#

A summary of the comparison of our experimental results with other related works is listed in Table 5
                        . Although Chang et al.'s method [22] can handle color images, the number of distinct colors in the secret image is limited. Only 5 colors can be displayed in the secret image. This is quite restrictive especially in a multimedia environment. Lin's method [23] can handle 256 color images but uses two operators, AND and OR, to compute the binary code for the overlapped blocks in the stacked image. In addition, they need a mask share to generate more secured noise-like shares to avoid the leaking problem. Jin et al. [24] proposed a multi-resolution scheme based on different approaches aimed towards sharing secret images. A 256 color image becomes visible to the human eye from the stacked shares. A halftone secret image can be reconstructed utilizing a computer to perform the logical XOR operation on the 9th digit of the shares. However, their method uses the pixel-expansion scheme so the shares are expanded to be 6×6 times larger.

We use XOR to compute the binary code for the overlapped blocks in the stacked image. Our model can be easily extended from 256 color image to 65,536 or true color images simply by expanding the block size from 3×3 to 4×4 or 5×5, respectively.

@&#CONCLUSIONS@&#

In this paper, information hiding techniques are used to conceal a color secret image within two meaningful cover images. Every pixel is expanded into a 3×3 block. The binary index code of the secret pixel and 1 bit of the palette data are randomly dispatched to the shares. The only criterion is to make the results of the XOR operation on the corresponding block equal to the binary color code of the secret pixel. Every block in the shares contains 4 white and 5 black sub-pixels, meaning that regardless of the color of the secret image, the probability to appear 1 on each share is 5/9, which gives no clue to the content of the secret image from the shares alone. This indistinguishable property ensures the security of the shares.

In addition, all 1s in share 1 and share 2 can be filled with the corresponding color of the cover pixel at that location. This makes the shares meaningful. If the shares are noise-like, even though interceptors will not be able to obtain any information about the secret image from any single share, they will suspect that something might be concealed there, which increases the risk of attack. Therefore, having meaningful content on the shares provides a double layer of protection. Our model can easily extend a 256 colors image to 65,536 or true color images, simply by expanding the block size from 3×3 to 4×4 or 5×5, respectively.

Visually pleasing shares are generated using color images as the cover image (Algorithm 3) which may reduce suspicion that something is concealed there. However, the storage requirements for these shares will be large. To solve this problem, Algorithm 4 is proposed, using a binary image as the cover image. This can achieve both the benefits of smaller share size and good visual quality.

Our secret image sharing scheme can be applied to cover the transmission of confidential images. Therefore, it can be used as a confidential transmission means in the area of key exchange, key predistribution, or group key distribution for existing standards. For example, as a supplementary aid to existing symmetric cryptography standards like DES which require a preshared key, our secret image sharing scheme remains a safe and less risky means for key distribution. In the future, we will pay more attention to applications of our scheme in secret protection and transmission.

@&#ACKNOWLEDGMENT@&#

This research was partly supported by the National Science Council of the Republic of China under contract NSC-97-2221-E-032-024.

@&#REFERENCES@&#

