@&#MAIN-TITLE@&#Building binary orientation octree for an arbitrary scattered point set

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We extend the binary orientation tree (BOT) data structure by extending the ‘in/out’ labels to ‘front/back/NA’ labels.


                        
                        
                           
                           Apply a global propagation process to get the consistent labels.


                        
                        
                           
                           It’s useful for both open and closed point sets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Incomplete point cloud

Surface reconstruction

Binary orientation tree

Label propagation

@&#ABSTRACT@&#


               
               
                  The binary orientation tree (BOT), proposed in [Chen, Y.-L., Chen, B.-Y., Lai, S.-H., and Nishita, T. (2010). Binary orientation trees for volume and surface reconstruction from unoriented point clouds. Comput. Graph. Forum, 29(7), 2011–2019.], is a useful spatial hierarchical data structure for geometric processing such as 3D reconstruction and implicit surface approximation from an input point set. BOT is an octree in which all the vertices of the leaf nodes in the tree are tagged with an ‘in/out’ label based on their spatial relationship to the underlying surface enclosed by the octree. Unfortunately, such a data structure in [Chen, Y.-L., Chen, B.-Y., Lai, S.-H., and Nishita, T. (2010). Binary orientation trees for volume and surface reconstruction from unoriented point clouds. Comput. Graph. Forum, 29(7), 2011–2019.] is only valid for watertight surfaces, which restricts its application. In this paper, we extend the ‘in/out’ relationship to ‘front/back/NA’ relationship to either a closed or an open surface, and propose a new method to build such a spatial data structure from a given arbitrary point set. We first classify the edges of the leaf nodes into two different categories based on whether their two end points are in the same side of the surface or not, and attach respective labels to the edges accordingly. A global propagation process is then applied to get the consistent labels of those end points that are in the same side of the surface. Experiments show that our BOT building method is much more robust, efficient and applicable to various input compared to existing methods, and the applications of BOT when doing RBF reconstructions and envelope surface computations of given 3D objects are shown in the experimental part.
               
            

@&#INTRODUCTION@&#

Spatial hierarchical structures, such as the octree and the Binary Space Partition (BSP) tree, play an important role in computer graphics, geometric modelling, geometric processing, etc, as they provide an efficient way for analysing data sets locally and iteratively. Octrees were proposed by Jackins and Tanimoto [11], and have been extensively used to process scattered point cloud in the last decade. Algorithms about building an octree of a given scattered point set abound, and octrees are then used for 3D reconstruction Cheng et al. [7], Kazhdan et al. [15,16]. However, the information in octrees is not enough for many tasks such as reconstructing surfaces with sharp features. Kobbelt et al. [17] assigned directed distances to leaf node vertices of the octree, and Ju et al. [13] extended the octree by attaching hermite data to each edge of the octree to get sharp features when performing reconstruction using the octree, Liu et al. [19] then combined hermite data and octree to do manifold-guaranteed out-of-core simplification of large meshes.

Considering the importance of awareness of the orientation of the underlying surface for a scattered point cloud, Chen et al. [5] proposed the BOT, by tagging each vertex of a leaf node in the octree with an ‘in/out’ label to classify the grid points of the octree into two disjoint inside/outside groups, and it was proved that such a data structure improved both quality and efficiency in 3D reconstruction, consistent normal computation and implicit surface approximation from scattered points. However, the method only works for closed surfaces represented by a well captured point set due to its use of space carving, which relies on the direct visibility detection for point set in Katz et al. [14], to determine the side a grid point belongs to. This is a big disadvantage since large holes often occur in deep, hard to reach cavities of the object, or places where object parts are too close to each other. These impose serious adverse effects on the quality of the captured point set and subsequently affect the quality of reconstruction, particularly in terms of its topology. To remedy this problem, a new method was proposed in Chen et al. [6] by the same group of the authors in Chen et al. [5], for getting two mutually invisible sets lying in the opposite sides of underlying surface by doing bipartite Voronoi poles classification. The method could deal with small holes on the surface of a shape, but it still has the limitation that the point cloud must explicitly separate the ambient space into two opposite sides, which implies that the method is still sensitive to big size holes. Further, both of the two methods proposed by  Chen et al. [5] and  Chen et al. [6] demand to find a set of viewpoints from one of which every point in the input is visible. This leads to a very large computational consumption and non-robustness when there are loops or cavities on the surface of a shape, and it will be worse when scattered points are non-uniformly distributed. Several different approaches have been investigated to solve the problem. For instance, in  Carr et al. [4] dipole off-surface points were created by offsetting the input points along their estimated normal directions on either side of the underlying surface. The method needs estimates of normal directions which tends to be unreliable for incomplete point sets. Shalom et al. [22] proposed a cone carving method to carve out the exterior space of a shape to acquire an accurate measurement of distance to surface for surfaces even with the presence of large holes or missing data. However, the high computational complexity is its main issue.

In this paper, what we want to do is to extend the BOT for either closed surface or so called open surface, which is maybe the underlying surface of a point set with big holes or missing data, or a surface of a shape with boundaries, such as a pipe in Fig. 5(a). The difficulty encountering in building such a BOT is that the ‘in/out’ relationship of a point to an open surface is inapplicable, we must find a new representation of the space relationship in BOT. Furthermore, due to lack of the intrinsic inside/outside subspaces and its orientation for an open surface, even when we can test whether two points are in the same side or in the opposite side of the surface, we still don’t know which side each of them belongs to. This leads to another problem about how to classify the grid points of the octree into two disjoint groups lying on different sides of the open surface.

To solve the problems above, we extend the ‘in/out’ relationship in the BOT to ‘front/back/NA’, in which points labelled with ‘front’ and ‘back’ are just relative position to the surface, means those vertices lying in the same of opposite sides of the surface. The points labelled with ‘NA’ are those non-applicable points for determining which side they are located. It is meaningful since we define the ‘NA’ points as the grid points of empty cells in the octree, they are far away from the underlying surface of the input, hence few applications use the information. The three kinds vertices are depicted in this paper by red, green and blue disks respectively, for instance, as shown in Fig. 1
                     (e). Based on the extension of the definition of BOT, we develop an approach based on label propagation instead of space carving to differentiate the grid points of the octree into two disjoint groups lying on different sides of the given surface.

In summary, the main contributions of the paper are as follows: first we devise a unified method to build a BOT, which is robust for various input, either an open or closed surface represented by a point cloud, complete or incomplete, uniformly distributed or not. Second, we propose a label propagation method on octree, to achieve a label consistent algorithm for those grid points in the same side of the surface with high efficiency and robustness compared to the previous methods. The data structure we build can facilitate implicit surface approximation and envelope computation, as we shown in the experimental results.

The rest of the paper is organized as follows: firstly we review some related work in Section 2, then illustrate our method in Section 3. Sections 4 and 5 demonstrates the experimental results and some applications of our BOT respectively, finally we conclude this paper in Section 6.

@&#RELATED WORK@&#

Spatial hierarchical structures are very useful in organizing scattered points and thus have many applications in 3D point cloud processing, especially for 3D reconstruction Alliez et al. [1], Jalba and Roerdink [12], Kazhdan et al. [15,16], Manson et al. [20], Ohtake et al. [21], Xie et al. [25]. The outer-normal of point as well as off-surface points around the underlying surface play important roles in 3D reconstruction. The intuitive method to get off-surface points around the input is by offsetting the input points along their estimated normal directions, as proposed in Carr et al. [4]. However, the normal estimation method tends to be unreliable for those point sets with big holes or missing data, so it is an egg-chicken problem with that of getting the off-surface points. Voronoi based methods such as in Amenta and Bern [2] and Amenta et al. [3] estimate point normal from voronoi poles, although variants provide in Dey and Goswami [10] and Kuo and Yau [18] improve resilience to noise, this kind of methods need to compute Voronoi diagram, leading to the expensive time and memory consuming.

The most related work to ours is the work proposed in Chen et al. [5]. They use all the visible grid points of the octree to carve the input object exterior space out and thus distinguish those grid points inside/outside the object. To detect all visible grid points of the octree, they need to find all possible view points to make sure every point in the point cloud must be visible from those view points. They apply the technique direct visibility detection of point set proposed in Katz et al. [14], which is not so suitable for doing this task especially when the point cloud is not evenly distributed. It is hard to determine the distance of the view point to the point cloud being watched since the relative density of the scattered points is different when the view distance changed and thus affects the correctness of visibility detection. Moreover, it is time consuming to find a set of view points to do the visibility detection of all scattered points.

The other related work is about extracting two disjoint groups of points distributed around the ambient space of input point set by voronoi cell poles classification proposed in Chen et al. [6], for those incomplete point cloud with big holes or non-even distributed points. The purpose of their work is very similar to the method in Chen et al. [5] on getting off-surface points in the two opposite sides of the underlying surface. The main idea is also using space carving, but they use voronoi positive poles to carve the exterior space out instead of using the grid points of the octree, and simultaneously the corresponding negative poles are taken as the counterpart inside points. The limitation is about its inapplicable to the input with big holes or those point set that cannot explicitly separate the ambient space into two disjoint subspaces. In this paper, what we mainly focus on is how to deal with such scattered points with low scanning quality.

For the method proposed in Shalom et al. [22], its novelty is mainly about its globally carving ability for carving those exterior space when the boundary of the space is with big holes or sparse points in the input. However, its high computational complexity is not suitable for building such a primitive data structure as BOT which is supposed to be more efficient.

@&#OVERVIEW@&#

In this paper, we just classify those grid points that are close to the underlying surface into two disjoint sets according the side they are located to the surface respectively. Given a scattered point cloud and its corresponding octree, first we classify leaf cells of the octree into empty and non-empty cells based on whether the cell contains point data or not. We assign the ‘NA’ label to the grid points of empty cells, since they are relatively far away from the underlying surface of the input point set. We just need to assign different labels to the grid points of non-empty cells according to their spatial relationship to the surface. Unlike existing methods that detect outer normals or visibilities of the input points, we use a completely different way to avoid high computation and robustness problems. The whole process is divided into the following two steps:

In the first step, we differentiate all the edges of non-empty cells into two categories by detecting whether their end points are in the same side of the surface or not, and then label them accordingly. We define the label of an edge to be ‘1’ if its two end points are in the same side of the surface, or else ‘0’. To depict them clearly, as shown in Fig. 1(d), we draw those edges labelled by ‘1’ and ‘0’ with dark red color and green color respectively. We call this step Edge labelling.

In the second step, we randomly select a non-empty cell of the octree as a seed, we label its corner points according to the type of corresponding edges, as shown in Fig. 1(d) the cell with a circle inside. Then we use a Label propagation process as shown in Algorithm 1
                         to get all the grid points of the non-empty cells in the same side with same label, thus classify them into two disjoint groups lying on the opposite sides of the surface, as shown in Fig. 1(e). We compare the whole process of our method with that of  Chen et al. [5] in Fig. 1.

In this section we explain how to classify edges of the non-empty cells into different categories by local geometric information near the edge. For doing the classification, we project two end points of the edge to the closest points on the surface and get two projected vectors emanating from the two end points respectively. The two points of an edge are in the same side if the two projecting vectors are in the same direction, that means the angle between them is less than 
                           
                              
                                 π
                                 2
                              
                              ,
                           
                         or else they are in the opposite sides.

For doing the projection from an end point, first we find a set of local input points nearest to the end point in the input data and approximate a plane using these points, then we project the end point to the approximated plane and get a projecting vector from the end point to the foot point on the plane. Since it is not so strict in precision for computing the angle between two projection vectors in our algorithm, we choose an efficient way, Weighted Least Squares (WLS), to approximate the plane. The projection method is shown in 2D in Fig. 2
                        . The detailed computations are as follows:

First we find neighbors from point set for an end point vi
                         in an range of circle (sphere in 3D) whose radius is hi
                         and center is vi
                        , the neighbor points are 
                           
                              
                                 P
                                 ′
                              
                              =
                              
                                 {
                                 
                                    p
                                    1
                                    ′
                                 
                                 ,
                                 
                                    p
                                    2
                                    ′
                                 
                                 ,
                                 
                                    p
                                    3
                                    ′
                                 
                                 .
                                 .
                                 .
                                 
                                    p
                                    i
                                    ′
                                 
                                 .
                                 .
                                 .
                                 
                                    p
                                    m
                                    ′
                                 
                                 }
                              
                              ,
                           
                         then the fitting plane can be represented by

                           
                              
                                 
                                    
                                       H
                                       i
                                    
                                    
                                       =
                                       {
                                       <
                                    
                                    
                                       n
                                       i
                                    
                                    ,
                                    x
                                    >
                                    −
                                    D
                                    =
                                    0
                                    ,
                                    x
                                    ∈
                                    
                                       R
                                       3
                                    
                                    
                                       ,
                                       |
                                    
                                    
                                       n
                                       i
                                    
                                    
                                       |
                                       =
                                       1
                                       }
                                    
                                    ,
                                 
                              
                           
                        in which 
                           
                              n
                              i
                           
                         is the unit normal of Hi. Hi
                         can be derived by minimizing

                           
                              (1)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       
                                          (
                                          <
                                          n
                                          ,
                                          
                                             p
                                             i
                                             ′
                                          
                                          >
                                          −
                                          D
                                          )
                                       
                                       2
                                    
                                    
                                       θ
                                       (
                                       ∥
                                    
                                    
                                       p
                                       i
                                       ′
                                    
                                    −
                                    
                                       v
                                       i
                                    
                                    
                                       ∥
                                       )
                                    
                                    ,
                                    i
                                    ∈
                                    
                                       {
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       .
                                       .
                                       .
                                       m
                                       }
                                    
                                 
                              
                           
                        where the weighting function is in such form: 
                           
                              θ
                              
                                 (
                                 d
                                 )
                              
                              =
                              
                                 e
                                 
                                    −
                                    
                                       
                                          
                                             (
                                             d
                                             )
                                          
                                          2
                                       
                                       
                                          h
                                          2
                                       
                                    
                                 
                              
                           
                         is a Gaussian function. Once we get the fitting plane Hi
                        , we project vi
                         to Hi
                         to get the corresponding foot point qi
                        . The projecting vector for vi
                         is 
                           
                              
                                 n
                                 i
                              
                              ,
                           
                         the direction is from vi
                         to qi
                        .

After edge labelling, for those edges of non-empty cells, they are classified into two categories depending on their end points being in the same or opposite side of the surface. In this section, we discuss how to get consistent labels for those grid points lying in the same side as shown in Fig. 1(e).

Inspired by flood-fill algorithm in computer graphics for filling a connected, similarly-colored area with a different color, we design a recursive method, called Seed propagation, to traverse all the connected non-empty cells from a seed cell. The pseudo-code of the algorithm is shown in Algorithm 1. Unlike the flood fill algorithm designed for evenly partitioned grid cells, the propagation process between two adjacent cells becomes more complicated since the hierarchical structure of octree, as shown in Fig. 3
                        . The figure illustrates three different cases when doing propagation between two cells with same level, from a fine level to coarse level and the inverse, respectively in (a)–(c). Without loss of generality, we use the Fig. 3(a) to explain the propagation procedure. We call the procedure Cell labelling. For simplifying the explanation below, we denote the label of grid points in octree with ‘0’ and ’1’ respectively according to the side one point is located to.

The left and right figures in Fig. 3(a) illustrate the input and the process of the procedure of cell labelling. The green cell below is a visited cell, with the labels of its corner points are determined definitely, the upper red cell is a cell will be visited, the labels of its edges are determined in edge labelling and the labels of its corner points are to be propagated. The two cells share the blue face. We propagate the point labels in a following way along a propagating edge, which is identified by an arrow drawn in its middle point. Suppose the propagating edge e has two end points denoted by ei
                         and ej
                        , the label of the edge e and its two end points are le, li
                         and lj
                         in respective, and suppose we propagate the point label from ei
                         to ej
                        . Then we propagate the label of ej
                         as follows:

                           
                              
                                 
                                    
                                       l
                                       j
                                    
                                    :
                                    =
                                    
                                       l
                                       i
                                    
                                    ⊗
                                    
                                       l
                                       e
                                    
                                 
                              
                           
                        
                     

Apparently there are redundant edges in the being visited cell for propagation. We use such edges to do the label consistent checking. The checking on an edge is passed if 
                           
                              
                                 l
                                 j
                              
                              =
                              
                                 l
                                 i
                              
                              ⊗
                              
                                 l
                                 e
                              
                              ,
                           
                         or else we call the checking failed. As shown in the right figure in Fig. 3(a), we identify those edges passed or failed in checking with ○ and × respectively. If there are one or more edges failed in checking, we know the propagation in this cell having conflict. We will not propagate the labels from this cell, as the instruction listed in Algorithm 1.

@&#EXPERIMENTAL RESULTS@&#

We perform our experiments on a desktop PC with a configuration of Intel dual core 2.33 GHz CPU and 2 GB main memory, and use the Approximating Nearest Neighbours (ANN) library designed by  David and Sunil [9] to find neighbors for a given point. We evaluate our method in two group experiments, one is the time performance and memory consumption comparisons with previous methods, the other is to demonstrate the ability of our method for building BOT for open surfaces with low quality scattered points as input.

Since BOT is a primitive data structure for many potential applications, it is important to build it in an efficient and memory saving way. We do experiments on closed models as shown in Fig. 4
                         and compare the timing performance and memory consumption for building octree implemented by ourselves, building BOT in Chen et al. [5] and ours in Table 1
                        . From the data in the table we can see that the time performance of our method for building BOT is much faster than that of the method in Chen et al. [5], using around 
                           
                              1
                              5
                           
                         to a half of the time used by the method in Chen et al. [5], while the memory consumption is in the same magnitude. However, both of the two methods are relatively slow compared with the time performance for building octree only.

In this group of experiments, we show the ability of our method to build BOT with various input point cloud with big holes or boundaries caused by poor lighting or self-occlusion when doing scanning. Sometimes even only one side of the model can be obtained as shown in Figs. 6
                         and  7
                        . In each experiment, the BOT of each shape is built first by the proposed method, then a signed distance for each grid point of the BOT is computed based on which side it is lying provided by BOT. The classical Marching cube algorithm is then applied to get the 3D reconstruction result consequently based on the signed distance in each grid point. The rendered images of all the inputs prove the correctness of distance signs explicitly and hence prove the grid points labels in BOT are also classified correctly. When the surfaces have big holes as shown in Fig. 5(c) or boundaries as shown in  5(a), our method is still robust enough to get the right results.

Besides for unifying unorganized normal direction for point set as described in Chen et al. [5], we provide the other two applications here. First one is about using BOT to do Radial Basis Function (RBF) surface approximation of the point cloud. As we know, in those RBF surface reconstruction approaches such as in Carr et al. [4], Cuomo et al. [8] and Turk and O’Brien [24], they need three kinds of points to be as the constrain points: inner points, outer points and the surface points. It is easy to get inner or outer points of an object once its BOT is established even the input point set without normals. We demonstrate the RBF reconstruction results aided by BOT in Figs. 8
                      and 9
                      for closed and open surface respectively, the RBF reconstruction method we use here is the method in Carr et al. [4].

Second, application of BOT is about the problem of envelope computation of 3D point cloud, as discussed in Tiwari et al. [23]. It is also straightforward to compute a tight envelope of a mesh model once the BOT of the object is obtained. We just need to extract the octree’s vertices outside of the input object, then we can get the envelope of the point set , which is represented by a discrete 3D mesh model, as shown in Fig. 10
                     . In Fig. 10, we could easily get envelopes with different enclosing tightness by using BOTs with different height, as discussed in Tiwari et al. [23], which is used in a set of 3D objects packing or layout.

@&#CONCLUSION@&#

We propose a BOT reconstruction algorithm suitable for both open and closed surfaces represented by incomplete point clouds without normals. We do edge labelling by local geometric information to avoid time consuming on detecting the visibility of all the input cloud and make our method more robust with the low quality input. The quick labelling propagation ensures all the grid points of non-empty cells are classified correctly and efficiently. How to automatically distinguish whether a shape is an open shape, such as the pipe, or with big holes from scanned data points, and how to fill the holes automatically will be the future work.

@&#ACKNOWLEDGEMENT@&#

The authors would like to thank AIM@Shape Repository and the Stanford 3D Scanning Repository for the mesh models and point set models in this paper. The authors will express their appreciations for the reviewers, they provide valuable and great helpful suggestions for our work. The work is supported by the NSFC Key Project (61332015) and NSFC project (61272242) and also supported in part by the 973 Program of China under Grant 2015CB352502.

@&#REFERENCES@&#

