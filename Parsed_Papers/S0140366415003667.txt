@&#MAIN-TITLE@&#CSAR: A Content-Scent based Architecture for Information-Centric mobile ad hoc networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A Content-Scent based Architecture is designed for mobile ad hoc networks.


                        
                        
                           
                           We define content-scent, Scent-Table, and operation of Scent-Tables.


                        
                        
                           
                           Broadcast-based and scent-based routing principle is proposed.


                        
                        
                           
                           An in-network caching mechanism is designed based on content-scent emitting.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Future Internet

Information-Centric Networking

Mobile ad hoc networks

Routing scheme

Content-scent

@&#ABSTRACT@&#


               
               
                  Information-Centric Networking (ICN) is regarded as one of the representative network architectures of Future Internet. In this paper, an information-centric architecture called Content-Scent based Architecture (CSAR) will be proposed for mobile ad hoc networks. In CSAR, each content has its special content-scent and can be found by tracing the scent it spreads over the network. The content-scent has the property similar to the natural scent that can spread over air, mix with other scents, decay with distance and time, and strengthen with fresh supplement. Using this property, scent-based routing and reliable content delivery functionalities are provided for the mobile ad hoc environment. Simulation results show that CSAR has an efficient route discovery procedure with less routing overhead and better in-network caching for the mobile ad hoc networks.
               
            

@&#INTRODUCTION@&#

A mobile ad hoc network (MANET) [1] is a collection of mobile nodes without fixed infrastructure. It is a multi-hop wireless network, in which mobile nodes can be either end points or routers. MANETs can be established quickly at emergency scenarios, such as, battlefield communications and disaster relief.

Inherited from wired network protocol stack, mobile nodes are usually assigned IP addresses. A single determined path which contains a series of nodes between source and destination nodes is set up by IP based routing protocols. However, IP based routing solutions are not suitable for the wireless networks because of their high degree of topological dynamics [2]. It is difficult to maintain IP addresses for mobile nodes. And point-to-point transmissions at MAC layer in these solutions do not utilize the broadcast nature of the wireless environment.

TCP/IP architecture was designed over 40 years ago with certain design principles [3]. New functionalities and services are difficult to add to the network core, which is called the ossification of Internet [4]. Hence, there are many clean slate redesign architectures for Future Internet recently. Information-Centric Networking (ICN) [5–8] is one of the most prominent architectures among them. An information-centric network [9] is a communication network in which content is treated as the first-class citizen rather than host. Although many ICN architectures are designed for wired networks originally, they can be particularly beneficial in wireless environment, since it does not need to maintain end-to-end connections. The recent years’ works [10–12] have shown that ICN idea can be applied into the design of MANET architecture.

Based on ICN architecture, a Content-Scent based Architecture (CSAR) is proposed for mobile ad hoc networks. CSAR assumes that content has its special content-scent. This makes it possible that consumers find a content by tracing its content-scent over the network. The content-scent is assumed having the property similar to the natural scent that can spread over air, mix with other scents, decay with distance and time, and strengthen with fresh supplement. The spreading nature is more appropriate to the broadcast environment and allows content providers to publish contents by broadcasting content-scents over the network. The mixing nature provides a mechanism to store a lot of content-scents in a compact data structure, and to reduce size of routing tables. This reduction is extremely important for the information-centric networks (including wired and wireless networks) because the amount of contents in the networks is huge. Finally, the decaying and strengthening natures are most suited for mobile ad hoc environment.

The main contributions of this paper include:

                        
                           •
                           A Content-Scent based Architecture is designed for mobile ad hoc networks. It provides routing and reliable content delivery functionalities.

Content-scent of a content is defined and the mixed content-scents of different contents are stored in a compact data structure called Scent-Table. In addition, a content-scent emitting and attenuation mechanism for content-scents is proposed.

According to the content-scent emitting mechanism, an in-network caching mechanism for content is designed in the procedure of data delivery.

The rest of the paper is organized as follows. In Section 2, we present the related work. Then, content-scent and Scent-Table are defined in Section 3. Broadcast-based and scent-based routing principles are presented in Section 4. Detail of procedures in CSAR is presented in Section 5; the architecture is evaluated and results are showed in Section 6; in Section 7, we conclude the paper.

@&#RELATED WORK@&#

Traditional IP based routings for mobile ad hoc networks can be classified as: proactive, reactive and hybrid approaches. Proactive routing protocols [13,14] leverage periodic network flooding for the advertisement of all available destination nodes. It keeps an up-to-date topological structure for the entire network. These protocols are only applied to small scale networks due to the periodic network flooding. Instead of maintaining up-to-date routing information at all of the nodes, reactive routing protocols [15,16] establish routing paths in an on-demand manner. These protocols need less routing control overhead than proactive approaches, and they are in general more scalable. AODV [15] is a classic reactive routing algorithm for mobile ad hoc networks. It uses an on-demand approach for finding routes, that is, a route is established only when it is required by a source node for transmitting data packets. Because AODV does not require global periodic routing advertisements, the demand on the overall bandwidth available to the mobile nodes is substantially less than in proactive protocols that do necessitate such advertisements. A disadvantage of this approach is a possible large delay from the moment the route is needed until the time the route is actually acquired. Hybrid approaches [17,18] have the former two components in order to combine the best of both routing ideas.

However, these IP based routing schemes do not fit the wireless environment well [2] because, for examples, IP assignment and management are difficult and point-to-point transmissions at the MAC layer do not utilize the broadcasting in nature property in wireless ad hoc networks.

There is a new design direction for wireless networks recently, which are information-centric mobile ad hoc networks. Listen First, Broadcast Later (LFBL) [19] is a topology-agnostic information centric forwarding protocol under high dynamics. It is composed of two phases: a request phase and a data phase. A request packet is flooded through the network in the request phase. Intermediate nodes overhear packets to discover if they are eligible forwarders. Receivers make the forwarding decision and only keep a minimal amount of state. A distance based forwarding procedure with collision avoidance is presented in the data phase. Simulations show LFBL significantly outperforms AODV [15] under highly dynamic environments.

In [20], the authors propose an energy-efficient content retrieval scheme for mobile cloud to decrease the traffic overhead of the Interest dissemination and save the transmission energy. A direction-selective forwarding scheme for the Interest dissemination phase is proposed. The experiment results show that this content retrieval scheme is capable of retrieving any content in the large scale MANET with high hit rate and low traffic overhead.

CCN (also known as NDN [6]) is a representative ICN architecture in recent years. It contains three components: content name advertisement by some routing protocols (an ongoing research) to build FIB tables in the network, an interest packets flooding phase to search the required content, and a data comes back procedure. In [28], the authors propose NAIF, a named data MANET forwarding protocol aiming at reducing the high overhead of NDN forwarding design. Work [21] is a survey which focuses specifically on the CCN paradigm, and it provides a comprehensive overview and a clear identification of the applicability, potentialities, weaknesses and future challenges of this paradigm in wireless networks. Works [10–12,22,23] are extended from CCN architecture for mobile ad hoc networks.

In [12], CCN is implemented on emergency wireless ad hoc environments. Interest aggregation and collision avoidance mechanisms are added to cope with the disruptive networks. Its performance benefits and superiority over Optimized Link State Routing Protocol (OLSR) [14] is demonstrated. In [22], the authors design a set of analytical to evaluate performance of several candidate routing protocols for content-centric MANET, including reactive flooding, proactive flooding, and geographic hash tables. A surprising result of this analysis is the competitive performance of unstructured flooding compared to more sophisticated techniques. LACMA [23] is a Location-Aided Content Management Architecture for a content-centric MANET. It tries to keep a content copy within a specified geographic boundary based on the location information make available by GPS and by proactively replication the content as necessary.

CHANET [10] is a content-centric mobile ad hoc network. It built on a connectionless layer designed on top of IEEE 802.11 protocols to provide content-based routing. In CHANET, interest and data packets are broadcasted, and nodes take local forwarding decisions based on packet overhearing. The same authors design enhanced architecture called E-CHANET [11] based on [10]. E-CHANET implements routing, forwarding, and transporting functions on top of the IEEE 802.11 wireless access. Interest and Data forwarding exploits a packet suppression technique to avoid redundancy and to control scalability, and ad hoc designed mechanisms to cope with node mobility. In addition to the basic routing and forwarding functionalities from CHANET, a new content-centric transport function which regulates the Interest transmission rate from mobile consumers is designed.

Simulated annealing [27] is an optimization procedure, aiming at converging to the global optimum. To reach the global optimum, it accepts a worse solution with a slow decrease probability at each iteration step. In contrast, CSAR does not accept a worse solution in the procedure of rebroadcasting request packet, and accept either the global optimal or a local optimal solution, because the content can be provided by any provider node.

In CSAR, content has its special content-scent, and mixed content-scents of different contents can be stored in a Scent-Table. In this section, we define content-scent, Scent-Table, and operation of Scent-Tables.

Our purpose is to map each content name to its content-scent, and extend the name-based routing of ICN to a scent-based routing. The content-scent strength arrived at a node is related to the capability of the original provider node and the distance away from it. The capability of the original provider node indicates the ability of the provider to supply this content, such as processing capacity and bandwidth. The distance between nodes can be defined, such as, geographic distance, hop count, transmission delay and link cost etc.

Suppose a content in node A has a name id. If node B receives the scent packet emitted from node A, then the Content-Scent Strength (CSS) emitted to node B is defined as:

                        
                           (1)
                           
                              
                                 CSS
                                 
                                    
                                       (
                                       i
                                       d
                                       )
                                    
                                    
                                       A
                                       →
                                       B
                                    
                                 
                                 =
                                 
                                    Q
                                    A
                                 
                                 /
                                 
                                    D
                                    
                                       
                                          
                                          
                                             A
                                             →
                                             B
                                          
                                       
                                    
                                    2
                                 
                              
                           
                        
                     where QA
                      is the capability of node A providing the content, and DA→B
                      is the distance from node A to node B.

We define a compact data structure, called Scent-Table, to record mixed content-scents or content names. As shown in Fig. 1
                     , a Scent-Table contains a set of vectors {D
                     1, D
                     2, … , Dk
                     } and the corresponding hash functions hashi
                     (), for i = 1, 2, … , k. Each vector Di
                      has M components: Di,j
                      (i = 1, 2, … , k, j = 1, 2, … , M). The Scent-Table can be real or binary depending on requirements. In its real number form where Di,j
                      is a real number, it can record the mixed content-scents of contents. The content-scent strength of each content can be obtained from this real number Scent-Table. In CSAR, each node has a real number Scent-Table to record content-scents. In its binary form where Di,j
                      = 1 or 0, it can express the content names similar to a bloom filter [24]. The binary form Scent-Table is used in the scent packet in CSAR (see Section 5.1).

The function values of the k hash functions are satisfied: hashi
                     () ∈ {1, … , M}, for i = 1, 2, … , k. We use a unique vector of integers to represent the scent of a content. Suppose the content name is id, then its scent is defined by (hash
                     1(id), … , hashk
                     (id)), where each hash function hashi
                     () maps the name id into an integer hashi
                     (id) ∈ {1, … , M}, for i = 1, …, k. Let m = hashi
                     (id) and Di,m
                      be the (i, m)th element of the Scent-Table (this Scent-Table can be considered as a sparse k × M matrix), then the scent of the content can be uniquely represented by k non-zero elements, {Di,m
                      > 0: m = hashi
                     (id), i = 1, …, k}, of the sparse matrix. Based on the bloom filter theory, if id
                     1 ≠ id
                     2, it is most probably (hash
                     1(id
                     1), … , hashk
                     (id
                     1)) ≠ (hash
                     1(id
                     2), … , hashk
                     (id
                     2)). This means that different content names almost sure have different scents. The sparse k × M matrix can be used to record a lot of scents of contents if the hash functions are properly chosen. Hence, if the name, id, of a content is known, we can check if its scent is contained in the Scent-Table by finding if min{Di,m: m = hashi
                     (id), i = 1, … ,k} > 0.

To record the strength, CSS(id), of a content scent into the Scent-Table, we let Di,m
                      = max{Di,m, CSS(id)}, for m = hashi
                     (id), i = 1, …, k. Therefore, the Scent-Table records the strength of mixed scents. A specific scent's strength is thus equal to min{Di,m: m = hashi
                     (id), i = 1, …, k}.

We use an example to explain the operation mechanism of Scent-Table. Suppose node A is a provider node and has two contents with names id and id'. It generates a binary Scent-Table with D′
                        i,j
                      = 0 (i = 1, 2, … , k, j = 1, 2, … , M) before emitting scent packet. Node A adds these two content names into the binary Scent-Table. The adding method is similar to a bloom filter, i.e., setting D′
                        i,x
                      = 1 and D′
                        i,y
                      = 1 where x = hashi
                     (id) and y = hashi
                     (id'), i = 1, 2, … , k. Then, node A emits a scent packet containing this binary Scent-Table. Once node B receives a valid scent packet broadcasting from node A, it calculates the Content-Scent Strength by Eq. (1): CSS = QA
                     / (DA→B
                     )2. The CSS value is the same for all the contents (i.e., id and id') in node A, the values of capability QA
                      and distance DA→B
                      are calculated from the information in scent packet (see Section 5.1). Suppose the real number Scent-Table in node B is Di,j
                     , for i = 1, 2, … , k, j = 1, 2, … , M. Then, the operation of adding the content-scent into the real number Scent-Table is:

                        
                           (2)
                           
                              
                                 
                                    D
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ←
                                 max
                                 
                                    {
                                    
                                       D
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    ,
                                    
                                       D
                                       
                                          i
                                          ,
                                          j
                                       
                                       ′
                                    
                                    ·
                                    CSS
                                    }
                                 
                                 ,
                                 
                                 for
                                 
                                 i
                                 
                                 =
                                 
                                 
                                    1
                                    ,
                                 
                                 
                                 
                                    2
                                    ,
                                 
                                 …
                                 ,
                                 k
                                 ,
                                 j
                                 =
                                 
                                    1
                                    ,
                                    2
                                    ,
                                 
                                 …
                                 ,
                                 
                                 M
                              
                           
                        
                     where Di,j
                      is the real number Scent-Table in node B and D′
                        i,j
                      the binary Scent-Table in the received scent packet. Obviously, if k and M are large enough, and the hash function hashi
                     () is uniformly distributed in between 1 and M, then exists a very low probability that (hash
                     1(id), … , hashk
                     (id)) = (hash
                     1(id'), … , hashk
                     (id')) if id ≠ id'. From Eq. (2) we can see that for content id, its content-scent strength CSS(id) is most probably:

                        
                           (3)
                           
                              
                                 CSS
                                 
                                    (
                                    i
                                    d
                                    )
                                 
                                 ←
                                 min
                                 
                                    {
                                    
                                       D
                                       
                                          1
                                          ,
                                          
                                             h
                                             1
                                          
                                       
                                    
                                    ,
                                    
                                       D
                                       
                                          2
                                          ,
                                          
                                             h
                                             2
                                          
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       D
                                       
                                          k
                                          ,
                                          
                                             h
                                             k
                                          
                                       
                                    
                                    }
                                 
                              
                           
                        
                     where hi
                      = hashi
                     (id), for i = 1, 2, … , k.

The content-scent strength can be decayed with time. That is, at each time the attenuating operation is multiplying each element of the Scent-Table with an attenuation factor α ∈ [0,1]:

                        
                           (4)
                           
                              
                                 
                                    D
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ←
                                 α
                                 ·
                                 
                                    D
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                                 
                                 
                                 for
                                 
                                 i
                                 =
                                 
                                    1
                                    ,
                                    2
                                    ,
                                 
                                 …
                                 ,
                                 
                                 k
                                 ,
                                 
                                 j
                                 =
                                 
                                    1
                                    ,
                                    2
                                    ,
                                 
                                 …
                                 ,
                                 
                                 M
                              
                           
                        
                     
                  

To fully utilize the broadcasting nature of the mobile ad hoc network, we use a broadcast-based routing principle instead of conventional hop-to-hop routing mechanism. Because we use broadcast to send all packets, addresses of nodes become unnecessary.

When a request packet is used to seek a content, we let it have a field scentStrength to record the maximum content-scent strength of the requesting content found along its delivery path. According to the content-scent definition (i.e., Eq. (1)) and the scent emitting mechanism (see Section 5.1), an intermediate node with higher content-scent strength is probably closer to a strong capability provider node. Hence, the request packets should be rebroadcasted by the intermediate node with higher content-scent strength. An exception is that an intermediate node with zero content-scent strength receives a request packet. In this case, this node rebroadcasts the request packet only when the field scentStrength in this packet also equals to zero.

                        
                           
                              
                              
                                 
                                    
                                       Algorithm 1. Request packet rebroadcasting in an intermediate node A.

                                 
                              
                              
                                 
                                    1: if (no other requester has requested the content) then
                                    
                                 
                                 
                                    2:  if ((sA
                                        > 0, s
                                       1 >= sA
                                       ) or (sA
                                        == 0, s
                                       1 > sA
                                       )) then
                                    
                                 
                                 
                                    3:   Discard the request packet and the following copies
                                 
                                 
                                    4:  else
                                    
                                 
                                 
                                    5:   Wait for a random period timeout and receive the possible
                                 
                                 
                                        
                                       m (m >= 1) request packet copies with: s
                                       1, s
                                       2, … , sm
                                        and d
                                       1, d
                                       2, … , dm
                                       .
                                 
                                 
                                    6:   if ((sA
                                        > 0, max{s
                                       1, s
                                       2, … , sm
                                       } < sA
                                       ) or (sA
                                        == 0, max{s
                                       1, s
                                       2, … , sm
                                       } == 0)) then
                                    
                                 
                                 
                                    7:    Rebroadcast the request packet with: d = d
                                       1 + 1, scentStrength = sA
                                       
                                    
                                 
                                 
                                    8:    Record d
                                       1 and d
                                       min = {d
                                       1, d
                                       2, … , dm
                                       } in this node
                                 
                                 
                                    9:   else
                                    
                                 
                                 
                                    10:    Discard all of the request packet copies
                                 
                                 
                                    11: else
                                    
                                 
                                 
                                    12:  Add a (d
                                       1, d
                                       min) value for this new requester
                                 
                                 
                                       and do not rebroadcast the request packet
                                 
                                 
                                    13: return
                                    
                                 
                              
                           
                        
                     
                  

Suppose node A is an intermediate node in the network. Let sA
                      be the content-scent strength of the requesting content recorded in node A's real number Scent-Table. (1) In the case of sA
                      > 0. Once node A receives a request packet, it checks the field scentStrength value of the request packet. If scentStrength > sA
                     , it means the request packet was rebroadcasted by a node, say node B, that has higher content-scent strength sB
                     . Therefore, node A can conclude that node B is closer to a provider node than node A, and at least one copy of the request packet rebroadcasted by node B can arrive at the provider. Node A thus does not need to rebroadcast the request packet and its copies received in the following period. If scentStrength = sA
                     , that means the request packet has rebroadcasted by a node with the same content-scent strength. To reduce the redundant rebroadcasting, node A also discards the received request packet as well as the following copies of this packet. If scentStrength < sA
                     , then, in order to reduce contention and collision of the wireless environment [25], instead of rebroadcasting the request packet immediately, we let node A wait for a short random period time. Since the request packet is broadcasted into the network, a node may receive multiple copies of the request packet. Suppose node A sequentially receives m copies of the request packet with the field scentStrength equals to s
                     1, s
                     2, … , sm
                      during the waiting time. Then if max{s
                     1, s
                     2, … , sm
                     } < sA
                     , it rebroadcasts the request packet with scentStrength being replaced with sA
                     ; otherwise, it drops all of the m copies received. (2) In the case of sA
                      = 0. In this case, node A is out of the area of the content-scent spreading or its record in node A's Scent-Table has been decayed into zero. Therefore, node A must rebroadcast one copy of the request packet only when max{s
                     1, s
                     2, … , sm
                     } = sA
                      = 0. To avoid broadcast storm, each node in the network rebroadcasts at most one copy of the request packet.

Let each request packet also carry a hop count d, and this count be increased by one while passing through a node. Suppose node A sequentially receives m copies with count d
                     1, d
                     2, … , dm
                     , respectively. In order to forward the request to the provider as soon as possible, node A sets the random period timeout only when it receives the first valid request copy (i.e., the scentStrength field of this request packet satisfies the above analysis). If Node A rebroadcasts this request packet, it records the first received count d
                     1 and the minimum count d
                     min = {d
                     1, d
                     2, … , dm
                     }. It rebroadcasts the first received copy of the request packet with an increased count d = d
                     1 + 1.

There may be many requesters search for the same content. In CSAR, intermediate nodes maintain a (d
                     1, d
                     min) value for each requester. When a request packet is received by an intermediate node, it checks whether there is another requester's request packet has already rebroadcasted by this node. If so, this node just adds a (d
                     1, d
                     min) value for this new requester and do not rebroadcast the request packet.

CSAR assumes that all the links are symmetric links, i.e., if node A sees B, then B also sees A. Corresponding to the request, the response packet is designed to have a field r to indicate the remaining hop count back to the requester. The response packet is also broadcasted into the network. In order to reduce contention and collision of the wireless environment [25], a node receiving a response packet also sets a random timeout. Suppose node A receives m copies of the response with r = r
                     1, r
                     2, … , rm
                     , respectively. If there exists j such that rj
                      = d
                     1 + 1, then node A rebroadcasts a copy of the response with r = d
                     min and drops all other copies. We note that node A only rebroadcasts one of the copies of the response even if rj
                      = d
                     1 + 1 is satisfied multiple times. Obviously, letting r = d
                     min can make the response most probably follow the shortest path back to the requester. There are many metrics for response packet to choose the route to requester, such as, minimum hop-count, ETX [26] and so on. We let the response packet tend to select the shortest path back to the requester. Because the response packet is broadcasted over the network, its copies may simultaneously take multiple “shortest paths” back to the requester. Due to the limitation of the rebroadcast condition rj
                      = d
                     1 + 1, the number of the simultaneously took paths is expected to be as few as possible. This is important for mobile ad hoc networks because of the contention and collision of wireless environment [25].

                        
                           
                              
                              
                                 
                                    
                                       Algorithm 2. Response packet forwarding for only one requester.

                                 
                              
                              
                                 
                                    1: if (receiving a response packet) then
                                    
                                 
                                 
                                    2:  Wait for a random period timeout and receive the possible
                                 
                                 
                                      
                                       m (m >= 1) response packet copies with: r
                                       1, r
                                       2, … , rm
                                       .
                                 
                                 
                                    3:  if (existing j such that rj
                                        = d
                                       1 + 1) then
                                    
                                 
                                 
                                    4:    Forwarding a copy of the response with r = d
                                       min and drops all other copies
                                 
                                 
                                    5:  else
                                    
                                 
                                 
                                    6:    Drop all of the response copies
                                 
                                 
                                    7: return
                                    
                                 
                              
                           
                        
                     
                  

We let the content/data carried in the response packet be cached in the nodes along the path(s) according to a content-scent-emitting-based in-network caching mechanism. In this case, if node A is a caching node and receives a new request for the content, it responses the request using the cached copy instead of rebroadcasting the request.

A six nodes example is shown in Fig. 2. Suppose a requester is 1 hop away to A and F, and 2 hops away to E. It broadcasted a request to the network, and the copies of the request arrived at A, E, and F, respectively. Suppose nodes A, E and F receive only one request packet copy, so, they record (d
                     1 = 1, d
                     min = 1), (d
                     1 = 2, d
                     min = 2) and (d
                     1 = 1, d
                     min = 1), respectively. Then, they rebroadcast the request with d = d
                     1 + 1 = 2, d = d
                     1 + 1 = 3 and d = d
                     1 + 1 = 2, respectively. Node B receives two request copies coming from node A and E with (d
                     1 = 2, s
                     1 = 0) and (d
                     2 = 3, s
                     2 = 0), respectively. The request copy coming from node A with (d
                     1 = 2, s
                     1 = 0) is received earlier. Since sB
                      = 0 and si
                      = 0, for i = 1, 2, node B will rebroadcast a request copy with (d = d
                     1 + 1 = 3, scentStrength = sB
                      = 0), and it records the first received count d
                     1 = 2 and the minimum count d
                     min = d
                     1 = 2 in this node. Node C receives two request copies coming from node B and F with (d
                     1 = 3, s
                     1 = 0) and (d
                     2 = 2, s
                     2 = sF
                     ), respectively. The request copy coming from node B with (d
                     1 = 3, s
                     1 = 0) is received earlier. Since max{sB, sF
                     } < sC
                     , node C will rebroadcast a request copy with (d = d
                     1 + 1 = 4, scentStrength = sC
                     ), and it records the first received count d
                     1 = 3 and the minimum count d
                     min = d
                     2 = 2 in this node.

After provider node D receives the request copy coming from node C with d
                     1 = 4, s
                     1 = sC
                     , it will return a response packet initialized with r = d
                     1 = 4. Node C receives the response packet and finds the packet that carries r = 4, which satisfies: r = d
                     1 + 1 (d
                     1 = 3 in node C), then it rebroadcasts the response packet with r = d
                     min = 2 (d
                     min = 2 in node C). Both of nodes B and F can receive the response packet rebroadcasted from node C. Node B receives the response packet that carries r = 2, and finds that r ≠ d
                     1 + 1 (d
                     1 = 2 in node B), so it will not rebroadcast the response packet. While node F receives the response packet and finds that r = d
                     1 + 1 (d
                     1 = 1 in node F), so it rebroadcasts the response packet. In this way, the response packet can probably follow the shortest path back to the requester and the number of the simultaneous rebroadcasting nodes is expected to be as few as possible.

If the intermediate node contains more than one (d
                     1, d
                     min) value, i.e., more than one requester has requested the same content. In this case, the response packet should also contain the same number of remaining hop count field in each forwarding node. We use an example to explain the mechanism when there is more than one requester requesting for the same content. As shown in Fig. 3
                     , a response packet with r = 5 is received by node A. Because r = d
                     1 + 1 in node A, it forwards the response packet with r = d
                     min = 3. Then, node B receives the response packet. Because there is a (d′′
                     1 = 2, d′′
                     min = 2) satisfies: r = d′′1
                      + 1 in node B, it should forward this response packet too. In addition to (d′′1
                      = 2, d′′
                     min = 2), there are (d
                     1 = 4, d
                     min = 3) and (d′
                     1 = 3, d′
                     min = 3) in node B, i.e., there are another two requesters request for the same content. Therefore, in addition to r′′ = 2, node B also adds r = 3 and r′ = 3 in the response packet before forwarding it. Then, node C receives the response packet with: r = 3, r′ = 3 and r′′ = 2. Because there is a (d
                     1 = 2, d
                     min = 2) satisfies: r = d
                     1 + 1 in node C, it also should forward this response packet. There are two requesters requesting the content from this node, so, the response packet is forwarded with r = 2, r′ = 1.

We first define four types of packets used in CSAR: scent packet (SCENTP), request packet (REQ), acknowledgment packet (ACK) and data packet (DATA), as shown in Fig. 4. The content-scent strength is broadcasted using SCENTP packet. A requester broadcasts a REQ packet to seek for a content or uses this packet to re-request unsuccessfully received content packets. A provider received the REQ packet supplies the content by sending back DATA packets. The ACK packet is used for providers (ACKprov) to inform the existence of content or for a requester (ACKreq) to select an optimal provider. The details of the packet fields are explained in the following sections.

Each content has a unique Name/ID which is a string or bit series with variable length. Instead of using IP addresses to identify nodes, we utilize contentName, requestID and providerID to identify a content, a requester and a provider node, respectively.

As shown in Fig. 4(a), Q is the quality value used for calculating content-scent strength, which is a constant value determined by the provider node. A seqNum field is used to prevent message duplication. A TTL field gives the number of hops that the packet can cross, which is decreased by each node forwarding the SCENTP packet until it equals to zero. The TTL value is originally equals to the maximum number of hops field RADIUS.

Every provider node periodically broadcasts a SCENTP packet. It carries a binary Scent-Table that recording all content names of contents the provider can provide. When a node receives a SCENTP packet, to reduce the contention and collision in the network, it will rebroadcast the SCENTP packet after a random waiting time. Nodes in the network process only the first received SCENTP packet copy and discard the following ones.

A node B receiving a SCENTP packet will update its Scent-Table. Without loss of generality, we use the hop counts as the distance, i.e., DA→B
                         = RADIUS-TTL + 1, where node A is the provider node. According to Eq. (1), the content-scent strength is: Q/(DA→B
                        )2. Then as defined in Eq. (2), the node updates its Scent-Table by letting

                           
                              (5)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                D
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                             
                                             ←
                                             max
                                             
                                                {
                                                
                                                   D
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                
                                                ,
                                                
                                                
                                                
                                                   D
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                   ′
                                                
                                                ·
                                                Q
                                                /
                                                
                                                   
                                                      (
                                                      
                                                         D
                                                         
                                                            A
                                                            →
                                                            B
                                                         
                                                      
                                                      )
                                                   
                                                   2
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             for
                                             
                                             i
                                             
                                             =
                                             
                                             
                                                1
                                                ,
                                             
                                             
                                             
                                                2
                                                ,
                                             
                                             …
                                             ,
                                             k
                                             ,
                                             
                                             j
                                             =
                                             
                                                1
                                                ,
                                                2
                                                ,
                                             
                                             …
                                             ,
                                             
                                             M
                                          
                                       
                                    
                                 
                              
                           
                        where Di,j
                         represents the node's Scent-Table, and D′i,j
                         the received binary Scent-Table.

The content-scent will be decayed with time. A time attenuation factor α ∈ [0,1] is used for reducing the strength of all the content-scents stored in all of the Scent-Tables. That is, every node periodically uses Eq. (4) to decay all the components of its Scent-Table.

The content discovery phase in CSAR is a three way handshake procedure. A requester broadcasts a REQ packet when it seeks for a content. It is possible that more than one provider are found by the REQ packet. Each provider node will send back an ACKprov packet to inform the requester. At last, the requester sends an ACKreq packet to choose one of the providers.

As shown in Fig. 4(b), a requester broadcasts a REQ packet with contentName and its requesterID to seek for the content and waits for reply from any provider. If the requester does not receive any reply after timeout, a new REQ packet is scheduled with a different seqNum value. Requester considers that the required content is unreachable after a given number of failed attempts. The TTL field contains the maxHop number of hops this packet can cross, which is decreased by each node forwarding this packet until it equals to zero. The scentStrength field contains the maximum scent-strength of the content, which is updated by each node forwarding this REQ packet and is supposed to be increased as approaching to the provider. There are some OPTION fields used to re-request unsuccessfully received content packets.

There is a request packet message table (RPMT) in each node, which records the nodes that REQ packet has traveled. RPMT table contains entries: requesterID, DISTANCE, DISTANCEmin and providerID(s) for every content. The requesterID in RPMT table is read from the requesterID field of the REQ packet. The DISTANCE in RPMT table is calculated by maxHop − TTL + 1 based on the information provided in the REQ packet copy which is rebroadcasted by this node. The DISTANCEmin in RPMT table is the minimum DISTANCE value among all the REQ packet copies. The providerID(s) in RPMT table is the node ID(s) of the provider found in the ACKprov/DATA packet responding to the REQ packet. In order to purge the entries from those nodes that do not receive any reply (ACKprov or DATA packets), a timer associated with the entry of RPMT table is set. The expiration time depends upon the size of the mobile ad hoc networks and can be estimated from historical experience value. For example, if the longest round trip time from this node to any other node is RTTmax, this expiration time can be 2* RTTmax. If there is no experience value, it can be initialized with a relatively large number (for example, 10s). ACKprov and DATA packets are delivered to requester based on these RPMT tables.

In the content discovery phase, a provider node responds the REQ packet only when it has the entire content. It can distinguish whether it is a REQ packet in the content discovery phase or is a REQ packet used to re-request the unsuccessfully received data packets by checking whether the REQ packet has OPTION fields (Section 5.4). A node receiving the content discovery phase REQ packet checks the caching state in this node. It schedules a response procedure, if there is an entire content in the cache and this request packet has not been responded. Otherwise, the node checks the scentStrength field of the REQ packet. Let s is the content-scent strength of the target content obtained from the node's Scent-Table. If scentStrength ≥ s, then the node drops this REQ packet copy as well as the following REQ packet copies. Otherwise, it waits for a random time period to decide whether it should rebroadcast the REQ packet copy. Suppose si
                        , for i = 1, 2, … , m, are the content-scent strength values from the REQ packet copies during the waiting time. If the following relation is satisfied:

                           
                              (6)
                              
                                 
                                    {
                                    
                                       
                                          
                                             
                                                max
                                                {
                                                
                                                   s
                                                   1
                                                
                                                ,
                                                
                                                   s
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   s
                                                   m
                                                
                                                }
                                                =
                                                0
                                             
                                          
                                          
                                             
                                                if
                                                
                                                s
                                                =
                                                0
                                             
                                          
                                       
                                       
                                          
                                             
                                                max
                                                {
                                                
                                                   s
                                                   1
                                                
                                                ,
                                                
                                                   s
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   s
                                                   m
                                                
                                                }
                                                <
                                                s
                                             
                                          
                                          
                                             
                                                if
                                                
                                                s
                                                >
                                                0
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Then, this node rebroadcasts the first REQ packet copy, whose scentStrength field is replaced with s and TTL field is decreased by one. Its RPMT table is correspondingly updated with the information of these REQ packet copies. In this way, the REQ packet is rebroadcasted toward to the content's provider (Fig. 5).

Once a provider node receives a REQ packet, it responds with an ACKprov packet to the requester. The provider gets the target content name in the received REQ packet and puts this information in the contentName field of the ACKprov packet shown in Fig. 4(c). It also includes the node IDs of requester and itself in the requesterID and providerID fields, respectively. The DISTANCEACK
                         field is a hop distance from this provider to the requester, which is calculated by maxHop − TTL + 1 based on the information provided in the received REQ packet.

The ACKprov packet will be forwarded by the intermediate nodes according to their RPMT tables. A node having the corresponding RPMT entry waits for a random time period after it receives the first ACKprov packet copy. Suppose it receives m copies of the ACKprov packet with DISTANCEACK
                         field values: di
                        , for i = 1, 2, … , m, respectively. Then, it checks whether there exists a j ∈ {1, 2, … , m} such that

                           
                              (7)
                              
                                 
                                    
                                       d
                                       j
                                    
                                    =
                                    D
                                    I
                                    S
                                    T
                                    A
                                    N
                                    C
                                    E
                                    +
                                    1
                                 
                              
                           
                        where DISTANCE is the corresponding entry value in the RPMT table. If so, it rebroadcasts the jth copy of the ACKprov packet with DISTANCEACK
                         = DISTANCE
                        min and adds the providerID in the corresponding entry of RPMT table. The node only rebroadcasts one of the copies of the ACKprov packet even if Eq. (7) is satisfied multiple times. If there does not exist any j such that Eq. (7) is satisfied, or the related RPMT entry simply does not exist, the ACKprov packets are discarded. In this way, the ACKprov packet can probably follow the shortest path back to the requester. The number of the simultaneous rebroadcasting nodes is expected to be as few as possible.

The requester may receive more than one ACKprov packet from different providers for one content. It selects an optimal provider based on some metric. For instance, its ACKprov packet is the first arrival or the distance to the provider is the smallest. We choose the later metric in CSAR. After an optimal provider is chosen, the requester sends a confirm ACKreq packet in which providerID field is the node ID of selected optimal provider, as shown in Fig. 4(c). The DISTANCEACK
                         value is initialized equivalent to zero and updated at each forwarding node.

The confirm ACKreq packet is only forwarded by the forwarding nodes. A node is called a forwarding node if it has the related RPMT entry and it has the selected optimal provider's ID in the RPMT entry, i.e., this node has rebroadcasted the selected optimal provider's ACKprov packet. A forwarding node waits for a random time period after it receives the first ACKreq packet copy. Let di, for i = 1, 2, … , m, are the DISTANCEACK
                         values in the confirm ACKreq packet copies during the waiting time. If it satisfies:

                           
                              (8)
                              
                                 
                                    max
                                    {
                                    
                                       d
                                       1
                                    
                                    ,
                                    
                                    
                                       d
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                    
                                       d
                                       m
                                    
                                    }
                                    <
                                    D
                                    I
                                    S
                                    T
                                    A
                                    N
                                    C
                                    E
                                 
                              
                           
                        Then, this node will updates the DISTANCEACK
                         field in the confirm ACKreq packet with DISTANCE value and rebroadcast the confirm ACKreq packet; otherwise, it drops all of the copies. In this way, the confirm ACKreq packet will be finally forwarded to the selected optimal provider.

A provider schedules content delivery procedure if it is selected as the optimal one by requester. The DATA packets are broadcasted by the provider successively without waiting for any acknowledgment packet. They are forwarded by the forwarding nodes until they arrive at the requester.

As shown in Fig. 4(d), the content contentName is divided into many DATA packets with different sequence number seqNum. According to the RPMT entry, the provider node gets its hop distance to the requester and puts this information in the DISTANCEDATA
                         field. The provider node also includes its node ID in the providerID field. There are some OPTION fields in the first DATA packet of a content: DATA_NUM, DISTANCECACHE
                         and (nodeID, distance) pair(s). The value DATA_NUM is a constant integer. It is used to inform the requester that the content is divided into DATA_NUM data packets by this provider. The DISTANCECACHE
                         field is used to select the caching nodes in the content delivery procedure. The (nodeID, distance) pair field is empty when the DATA packet is generated by the provider. A (nodeID, distance) pair indicates a caching node and its distance to the requester. They are inserted by the caching nodes in the content delivery procedure.

Requester can obtain content from any provider, since it is the content itself but provider node that is meaningful to the requester. This property makes in-network caching become an important characteristic of ICN. There are many in-network caching schemes in Information-Centric Networking. For example, all of the nodes along the content delivery path can be considered as caching nodes, which is the current default implementation of CCN.

We propose a Content-scent-Emitting-based Selective Caching (CESC) mechanism. Our purposes of this caching mechanism are: saving caching space, supporting reliable content delivery functionality and making the requesters in the network select optimal providers nearby. To make requesters obtain content nearby and save the network bandwidth, it is better for each requester to locate at a content-scent emitting area of at least one provider.

Whether a forwarding node is a caching node is determined by the first DATA packet in the content delivery procedure. Provider node generates a random integer D whose value is between RADIUS and 3*
                        RADIUS, while RADIUS is the emitting radius in the scent emitting mechanism. It puts this D in the DISTANCECACHE
                         field of the first DATA packet. The DISTANCECACHE
                         value in the first DATA packet is decreased by one at each forwarding node. A node is selected as a caching node when it detects this value equals to zero. It will cache the DATA packets which are received in the following content delivery phase. Then, a new integer D is generated and the field DISTANCECACHE
                         is updated. The node ID of the selected caching node and its distance to the requester is added into the first DATA packet as a (nodeID, distance) pair field. In this way, some forwarding nodes are chosen as caching nodes. DATA packets are cached in these nodes in the content delivery procedure.


                        DATA packets will be forwarded by the forwarding nodes. A forwarding node waits for a random time period after it receives a DATA packet copy. Suppose it receives m copies of the DATA packet with DISTANCEDATA
                         field values: di
                        , for i = 1, 2, … , m, respectively. Then, it checks whether there exists a j ∈ {1, 2, … , m} such that

                           
                              (9)
                              
                                 
                                    
                                       d
                                       j
                                    
                                    =
                                    D
                                    I
                                    S
                                    T
                                    A
                                    N
                                    C
                                    E
                                    +
                                    1
                                 
                              
                           
                        If so, it rebroadcasts the jth copy of the DATA packet with DISTANCEDATA
                         = DISTANCE
                        min; otherwise, it drops all of the DATA packet copies. The node only rebroadcasts one of the copies of the DATA packet even if Eq. (9) is satisfied multiple times. In this way, the DATA packet can probably follow the shortest path back to the requester. The number of the simultaneous rebroadcasting nodes is expected to be as few as possible.

It is more effective in the content delivery procedure that the providers do not need to wait for acknowledgment packets for the previously sending DATA packets. However, requester may fail to receive all of the DATA packets sending from the optimal provider since the wireless medium is unreliable. In order to realize reliable transmission for content, a re-request unsuccessfully received data packets procedure based on Content-scent-Emitting-based Selective Caching mechanism is proposed.

As shown in Fig. 4(b), there are some OPTION fields in REQ packet are used for re-requesting unsuccessfully received data packets. These OPTION fields include: a contentNodeID field and a seqNumPair(s) field. The seqNumPair(s) field in REQ packet is used to record the absent data packets. A seqNumPair is a sequence number pair: (seqNumLeft, seqNumRight). It indicates that the DATA packets with sequence number from seqNumLeft to seqNumRight are unsuccessfully received. There is only one DATA packet unsuccessfully received if seqNumLeft equals to seqNumRight. The contentNodeID field is filled with a caching node ID or the optimal provider node ID. The TTL field of this REQ packet is initialized with the distance value from node contentNodeID to this requester. Requester maintains the node IDs and the distance of the caching nodes. This information is obtained from the (nodeID, distance) pair field of the first DATA packet sending from the optimal provider.

The chosen provider is an optimal one and the caching nodes are nearer to requester than the optimal provider in the content delivery phase. Hence, it is reasonable to request the absent DATA packet from these caching nodes at first.

When
                         to send a REQ packet by the requester to re-request unsuccessfully received data packets is an important problem. In CSAR, requester records the arriving time of the valid DATA packets and calculates the average arriving time interval Tavg-i
                         of every two consecutively receiving DATA packets. For example, let the requester receives the provider ACKprov packet at time t0
                         and n DATA packets at time ti
                         (i = 1, 2, … , n). Then, the average arriving time interval is:

                           
                              (10)
                              
                                 
                                    
                                       T
                                       
                                          a
                                          v
                                          g
                                          −
                                          i
                                       
                                    
                                    =
                                    
                                       1
                                       n
                                    
                                    ×
                                    
                                       ∑
                                       
                                          x
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       (
                                       
                                          t
                                          x
                                       
                                       −
                                       
                                          t
                                          
                                             x
                                             −
                                             1
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        If the requester has not received any DATA packet over a period of 2Tavg-i
                        , it will schedule a re-request procedure. If the first DATA packet has not received, the requester puts the optimal provider's ID and distance in the contentNodeID and TTL field; otherwise, it puts the nearest caching node ID and distance in the contentNodeID and TTL field. It records the unsuccessfully received DATA packets with seqNumPair(s) field of a REQ packet. Then, the requester sends this REQ packet to the node contentNodeID. The REQ packet is rebroadcasted by the forwarding nodes until it arrives at node contentNodeID. Then, this node will return the DATA packets to the requester if it has these DATA packets. If there are still some DATA packets that are not received from the new provider node, the seqNumPair(s) field is updated and a new REQ packet with the second nearest caching node information is sent. This procedure is continued until the requester receives the entire content or the optimal provider node is re-requesting again. If there are still some DATA packets that are not received, a new content discovery procedure is scheduled.

@&#EVALUATION@&#

In order to evaluate the performance of CSAR architecture, simulations are implemented in a network simulator OMNeT++ [29]. Simulations are conducted using 50 randomly placed mobile nodes and one or three fixed nodes as original content provider nodes. The grid represents an area with a size of 500 m × 500 m, 1000 m × 1000 m. The mobile nodes move with a speed being uniformly distributed in between 1 m/s to 1.5 m/s, 1 m/s to 10 m/s, and no pause time according to the Random Waypoint mobility model. Each individual simulation ran for 50 s of simulated time. We ran every simulation five separate times with different random seeds. The results presented in the following subsections are the median of the five means from the different simulation runs.

The simulations compare CSAR with E-CHANET [11] and a traditional classic MANET solution, i.e., AODV [15] and TCP protocols. E-CHANET is an architecture that performs routing, forwarding and reliable transport functions, which is extended from the prominent information-centric architecture CCN. Interest and Data forwarding exploits a packet suppression technique to avoid redundancy and to control scalability, and ad hoc designed mechanisms to cope with node mobility. Its performance is better than basic CCN and TCP/IP architecture, which is evaluated through simulations. The AODV [15] routing protocol is a traditional classic reactive routing protocol. It finds a path between the source and the destination only when the path is needed. However, once established a route is maintained as long as it is needed.

The nodes’ physical and MAC layer parameters are based on IEEE 802.11 g specifications. The simulations use radios operating at a fixed rate of 54 Mbps. The MAC layer uses no retransmissions, acknowledgments, RTS/CTS, etc. Table 1 summarized the parameters in the simulations.

There
                     
                      are 200 different contents in the fixed node(s) at the beginning of the simulations. The size of each content is the same: 20 Kbytes. Mobile nodes request content with content name in CSAR and E-CHANET, while the traditional solution request content only randomly from one of the fixed nodes with its IP address. The interval time of two consecutive requesters request content according to an exponential distribution with mean 1/λ = 1. In CSAR and E-CHANET, the content requesting rate follows a zipf-like distribution [30]. The requesting probability of the ith content is:

                        
                           (11)
                           
                              
                                 
                                    P
                                    N
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 
                                    (
                                    1
                                    /
                                    
                                       i
                                       α
                                    
                                    )
                                 
                                 /
                                 
                                    ∑
                                    
                                       x
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    (
                                    1
                                    /
                                    
                                       x
                                       α
                                    
                                    )
                                 
                              
                           
                        
                     
                     N = 200 is the number of different contents in the network, and α is zipf exponent suggested as 0.8 in [30]. The traditional solution has no notion of the zipf-like distribution, it just request content from the fixed node without caring about what content is carried.

We evaluate the simulations using three evaluation metrics: download time, data throughput and network overhead. The download time is the amount of time elapsed from when a request is sent by a requester until it receives the last data packet. The data throughput is defined as the amount of data packet payload bytes received by a requester divided by the time it downloads the content. The network overhead is the amount of all bytes except the data packet payload forwarded by all nodes in the network over the entire duration of the simulation.

In order to obtain a reasonable value of parameter RADIUS, we ran the simulations with different RADIUS values. These simulations are under different network sizes: 500 m × 500 m, 1000 m × 1000 m and different original provider nodes: 1 and 3. In the simulations, the fixed host(s) emits SCENTP packets periodically; the mobile hosts emit SCENTP packets when there are five new contents in their caches since the last SCENTP packet. The period of emitting SCENTP packet in the fixed original node(s) in this simulation is set to 10 s. We study different period value in the following simulations.

As shown in Fig. 6, the network overheads varying with RADIUS are shown for different number of requesters, No. = 5, 10, 15, 20, 25, 30. It can be observed that the network overhead increases with the network size and the number of original provider nodes. However, all of the results show that the network overhead increases when the parameter RADIUS→0 or RADIUS→4. And the network overhead is smallest when the parameter RADIUS = 2. When RADIUS→0, nodes need to issue more REQ packets to account for the lack of scent information on the network, what increases the overhead in terms of REQ packets. On the other hand, when the RADIUS is bigger than 2, we increase the number of SCENTP packets, as the nodes need to rebroadcast the scent of newly received information. The shown overhead accounts for all the issued packets, on the performed evaluation the best trade-off between REQ and SCENTP packets was having the RADIUS = 2, what will be the adopted value for the remind experiments.

In this simulation, we analyze the download time performance of the three mechanisms under different network sizes, speeds of mobile nodes and number of original provider nodes. We evaluate the performance of CSAR with different SCENTP packet emitting period: 10 s, 20 s and ∞ s. In the case of ∞ s, the original provider node(s) emits SCENTP packet only one time at the beginning of the simulation.

As shown in Fig. 7, in CSAR, the download time is almost the same under the three SCENTP packet emitting periods: 10 s, 20 s and ∞ s. It is because when the period is small, the SCENTP packet is broadcasted more frequently. Therefore, content-scent strengthen in the Scent-Table is more precise, which makes REQ packets find target content faster. However, too many broadcasting of the SCENTP packets will increase the possibility of the potential contention and collision with other packets (for example, REQ). It also can be observed that the download time increases with the network size and the mobile node speed, while decreases with the number of original provider node. This is reasonably that small network size or more original provider nodes make requesters obtain content nearby and high mobility speed causes more re-requesting of the data packets. However, all the results show that the information-centric architectures CSAR and E-CHANET outperform the AODV solution with less download time. It is because that the information-centric architectures can benefit of the in-network caching property and obtain the content or re-request the unsuccessfully received data packets from the caching nodes, while the AODV solution can only obtain the content from the original node.

Our architecture CSAR outperforms E-CHANET with less download time. In CSAR, REQ packets are rebroadcasted according to the content-scent, which greatly reduces the redundant rebroadcast of REQ packets as well as the probability of contention and collision. This makes the requester find an optimal provider as soon as possible and need not to broadcast REQ packet more times due to the potential contention and collision. In addition, the optimal provider sends data packets consecutively without waiting for acknowledgment, and the requester re-requests the unsuccessfully received data packets from the caching nodes which are selected by the Content-scent-Emitting-based Selective Caching mechanism. These mechanisms also reduce the download time.

The network overhead is the amount of the control part of the packets forwarded by all nodes over the simulation. In CSAR, network overhead contains the bytes of REQ, SCENTP, ACKprov, ACKreq and DATA header. The SCENTP packets have a significant size, it contains a binary Scent-Table and the packet header. The size of a binary Scent-Table is 100 bytes, it has k = 8 vectors, and each vector has M = 100 bits. Therefore, the total size of a SCENTP packet is 124 bytes (where SCENTP packet header is 24 bytes). In E-CHANET, network overhead contains the bytes of Interest, Int-Ack and Data-Object header. In AODV, network overhead contains the bytes of RREQ, RREP and RERR.

As shown in Fig. 8
                        , in CSAR, although the SCENTP packets have a significant size, the network overhead is almost the same under the three SCENTP packet emitting periods: 10 s, 20 s and ∞ s. When the period is small, it should broadcast more SCENTP packets. However, more SCENTP packets make the content-scent strength in the Scent-Table be more precise. It makes REQ packets find target content easier and reduce the redundant rebroadcasting of REQ packet. It also can be observed that the network overhead increases with the network size and the number of original provider node. This is reasonably that large network size makes the REQ packet be rebroadcasted more times and more original provider nodes generate more SCENTP packets. However, all of the results show that the information-centric architectures outperform the AODV solution with less network overhead. The reason is similar to the download time situation. Our architecture CSAR generates more (or almost the same in (b) and (c)) network overhead than E-CHANET when there are fewer requesters. It is because that a SCENTP packet is emitted at the beginning of the simulation and account for the largest part of the network overhead bytes. However, as the number of requesters increases, REQ packets generate more network overhead bytes than that of SCENTP packets. CSAR reduces the redundant rebroadcast of REQ packets because of the content-scent, and therefore it generates less network overhead.

As shown in Fig. 9, in CSAR, the data throughput is almost the same under the three SCENTP packet emitting periods: 10 s, 20 s and ∞ s. It also can be observed that the data throughput decreases with the network size and the mobile node speed, while increases with the number of original provider node. The reason is similar to the download time situation. However, all of the results show that our architecture has the highest data throughput. The content delivery procedure in CSAR makes the data packet be forwarded along the shortest path to requester, which can transmit the data packets as soon as possible. The number of simultaneous rebroadcasting forwarding nodes in this procedure is expected to be as few as possible. This property can greatly reduce the contention and collision of wireless environment. So, the data packets can be transmitted successfully with a higher possibility. In addition, provider node sends data packets consecutively without waiting for acknowledgment in CSAR. It re-requests the unsuccessfully received data packets from the caching nodes which are selected by the Content-scent-Emitting-based Selective Caching mechanism. These mechanisms reduce the download time of the content, which also produces higher data throughput because of the efficient data transmission procedure.

In this simulation, there are 200 different contents in the only fixed original provider node and the other mobile nodes have a caching size of five contents. Cached content removal is managed with a least frequently used policy. The mobile node deletes a least used content in its caching if it already has 5 contents when a new content is required to cache.

Because the CCN's caching mechanism makes all of the forwarding nodes cache the content, the CSAR's caching mechanism has larger network overhead and average download time than the CCN when the number of requesters is small, as shown in Fig. 10. However, as the number of requesters increases, the CSAR's caching mechanism becomes better than the CCN, though it needs less forwarding nodes to cache content than the CCN. The reason is that CCN's caching mechanism causes more frequent content replacements in caches as the number of requesters increases, and so some popular contents may be replaced more frequently in CCN's caching mechanism.

@&#CONCLUSION@&#

Information-Centric Networking is one of the most prominent architectures of Future Internet. It is particularly beneficial in wireless environment, since it does not need to maintain end-to-end connection.

In this paper, we proposed a Content-Scent based Architecture for mobile ad hoc networks. In this architecture, the content-scent is defined and mapped from the content name, and the mixed content-scents of different contents can be stored in a compact data structure called Scent-Table. The content-scent is emitted using a scent emitting mechanism over the network. A three phases of process is designed in the architecture to provide routing, forwarding, reliable delivery and content caching functionalities.

We have experimentally evaluated CSAR and compared it to E-CHANET and AODV. Simulation results show that our architecture outperforms those MANET solutions across three different metrics. In addition, the in-network caching mechanism in CSAR outperforms the default caching mechanism in CCN as the number of requesters increases with less forwarding nodes to cache content.

@&#ACKNOWLEDGMENT@&#

This work is supported by the Key Program of NSFC-Guangdong Joint Funds (grant no. U0735002).

Supplementary material associated with this article can be found, in the online version, at doi:10.1016/j.comcom.2015.09.024.


                     
                        
                           Image, 1
                           
                        
                     
                     
                        
                           Image, 2
                           
                        
                     
                     
                        
                           Image, 3
                           
                        
                     
                     
                        
                           Image, 4
                           
                        
                     
                     
                        
                           Image, 5
                           
                        
                     
                  

@&#REFERENCES@&#

