@&#MAIN-TITLE@&#A novel two-fold state skip logic Built-In Self-Test scheme for digital circuits

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Two fold state skip logic determines the next consecutive useful states.


                        
                        
                           
                           Minimizes the test sequence length, which, in turn, helps to reduce the memory size.


                        
                        
                           
                           Usage of a reduced test sequence minimizes power dissipation during testing period.


                        
                        
                           
                           Achieved low scan power by skipping long scan switching activities.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

DFT

BIST

Low power

Fault coverage

Test sequence length

Testing time

@&#ABSTRACT@&#


               
               
                  Recent developments in the field of very-large-scale integration (VLSI) testing have led to a demand for fault diagnosis in very-large-scale integration circuits. However, the problem of test pattern generation becomes very difficult as the size of circuits increases. Proficient techniques for test pattern generation are necessary to reduce the test sequence length and testing time. In conventional methods, Automatic Test Pattern Generation (ATPG) and Design for Test (DFT) are used for test pattern generation and fault insertion in netlist files. The complexity faced in Automatic Test Pattern Generation exponentially increases with respect to the circuit size. In circuits with a large number of stuck-at-fault errors, the conventional verification sequence fails to provide acceptable fault coverage and low power consumption. A twofold state skip (TFSS) logic is developed to achieve a low scan power by skipping long scan chains to reduce switching activities. This work addresses the above-mentioned issues faced in Automatic Test Pattern Generation in VLSI circuits and examines all detectable faults using a twofold state skip logic. The proposed approach is efficient and verified on ISCAS 89 & 85 benchmark circuits; the results indicate a considerable reduction in the test data volume and thus a significant reduction in power consumption.
               
            

@&#INTRODUCTION@&#

An enormous number of failures have been experienced during the manufacture of integrated circuits (ICs); as a result, it is not feasible to analyse each failure individually. Thus, failures are clustered according to the effect of logical faults on the functionality of a circuit, enabling the construction of logical fault models. Faults that occur in an IC can be classified into three types, namely, permanent faults, temporary faults (consisting of a transient or intermittent problem), and delay faults. Permanent faults exist long enough in a circuit that they can be observed. In contrast, temporary faults appear and disappear within a short time interval. Delay faults reduce the operating speed of circuits. High fault coverage is particularly valuable during the manufacture of ICs; such coverage is achieved using techniques such as Design for Test (DFT) and Automatic Test Pattern Generation (ATPG). Built-In-Self-Test (BIST), a DFT methodology, has many advantages over other testing schemes because of its testability, testing speed and independence of the automatic test equipment used.

The Built-In Self-Test plays an important role in the testing of complex and large circuits [1–2]. The BIST forms a self-testable circuit by combining the Circuit Under Test (CUT), a Test Pattern Generator (TPG), a Test Response Verifier and a BIST controller on a chip. Minimum test application time and hardware overhead as well as minimum performance degradation are necessary in many BIST applications. Conventional systems on chips (SoCs) and IP cores are limited by power dissipation. A complex block for the test vector and pattern generation represents a burden in VLSI testing in terms of the amount of power that is dissipated. A BIST technique based on a multiplier–accumulator pair for the data path architecture to overcome the problem of power consumption was proposed [3]. Another low-power test pattern generation model [4] was developed based on cellular automation for combinational circuits. Zorian proposed a distributed BIST control scheme to simplify the testing of complex ICs [5]. Two different types of Linear Feedback Shift Registers (LFSRs) based on speed performance were developed [6] for a circuit that has inputs with high transition densities. A circuit-dependent nature and fault-coverage efficiency are the major drawbacks of the above-described BIST schemes. A new type of Linear Feedback Shift Register, called a State Skip LFSR, was presented. Apart from their linear feedback structure, which corresponds to their characteristic polynomial, State Skip LFSRs also incorporate a small linear circuit called a State Skip Circuit. The state of a State Skip LFSR can be preceded by either the polynomial feedback structure, called the Normal mode, or the State Skip Circuit, called the State Skip Mode. In the State Skip Mode, the LFSR performs consecutive jumps of a constant length in its state sequence because the State Skip Circuit excludes a predetermined number of states by directly determining the state after them. State Skip LFSRs significantly shorten the test sequences of LFSR-reseeding-based test set embedding methods, as they can function in a State Skip Mode in the useless parts of the test sequence. By indicating the high compression efficiency of test set embedding with largely reduced test sequences, State Skip LFSRs link the test sequence-length gap between test data compression and test set embedding techniques and provide the latter with a very attractive testing approach for IP cores [7].

Hellebrand et al. [8] developed a new scheme for the Built-In-Test (BIT) that makes use of Multiple-Polynomial Linear Feedback Shift Registers (MP-LFSRs). The seeds are developed by solving systems of linear equations connecting the seed variables for the positions, in which the test cubes have specified values.

Savir and McAnney [9] described the design of a LFSR that can effortlessly contain a change-of-seeds feature. This novel LFSR is activated by two separate clocks, one operates the normal LFSR, and another operates the change of seeds option. The change of seeds is fast because it is performed by a pair of clock pulses rather than by long scan operations. Over the years, many schemes based on LFSR have been proposed as the best test pattern generator for the circuit under test. For mobile operation, many modified LFSR schemes have been developed for low-power VLSI testing.

In general, a Linear-Feedback Shift Register (LFSR) is a shift register that has an input bit that is a linear function of its previous state, as shown in Fig. 1
                        . The conventional linear function of single bits is exclusive-ored (XORed). The initial value of the LFSR is called the seed; because the operation of the register is deterministic, the sequence of values generated by the register is completely determined by its current or previous state.

As the register has a finite number of feasible states, it must enter a recurring cycle. However, an LFSR with a suitable feedback function can create a sequence of bits that appears to be random and has a very long cycle. Koenemann [10] presented a system that has a maximum number of linear equations matched with a test cube that has the maximum number of specific bits. The disadvantage of this scheme is that the majority of the variables remains unspecified, thus wasting the potential of the LFSR encoding. Fig. 2
                         shows the flow of the detection of faults in a circuit under test.

ATPG (Automatic Test Pattern Generation and Automatic Test Pattern Generator) is an electronic design automation technology that is used to obtain an input or test sequence. When the test sequences are applied to a digital circuit, they enable automatic test equipment to differentiate between the correct circuit behaviour and the faulty circuit behaviour caused by defects. The generated patterns are utilized to test semiconductor devices after manufacture and in some cases to assist in identifying the cause of failure. ATPG’s efficiency is another important factor. The efficiency is determined by the fault model under consideration; the type of circuit under test, such as a full scan, synchronous sequential, or asynchronous sequential; the level of abstraction, such as the gate, register-transistor, or switch used to represent the circuit under test; and the required test quality [11,12]. Chakrabarty et al. [13] designed a built-in pattern generator based on the reseeding of twisted-ring counters (TRCs). The proposed technique inserted a recomputed deterministic test set for the Circuit Under Test (CUT) in a short test sequence formed by a TRC. Chiusano et al. [14] designed various functional modules and proved that the modules can be used for a deterministic test pattern generator. Stroele and Mayer [15] proposed a test pattern generator using an accumulator based on different techniques. Kalligeros et al. [16] developed an algorithm for selecting a proper seed for LFSR to provide maximum fault coverage.

A modified 2D LFSR algorithm was used to achieve fault coverage, and the generated patterns were used to detect faults [17]. Tehranipoor et al. [18] invented a new test-data compression technique using nine code words that aimed to reduce the test data volume and the test application time. Chandra and Chakrabarty [19] developed a test data compression method and a decompression architecture using variable-length Golomb codes. The authors used a deterministic Built-In Self-Test. A reconfigurable interconnection network was located between the outputs of a pseudorandom pattern generator and the scan inputs of the circuit under test [20]. The modular form of the LFSR construction was presented in [21]. VinodChandra and Ramasamy developed a customized LFSR algorithm to detect the fault coverage and patterns to find the faults, and they concluded that the LFSR technique appears to be superior to the ATPG tool used for small- and medium-sized circuits [22]. All of the above-discussed techniques involved generating optimal test patterns with reduced switching transitions and with maximum fault coverage. This work presents an algorithm called a twofold state skip that implements the TF-LFSR (Twofold-LFSR) architecture to reduce test sequences, which in turn significantly reduces memory utilization and power dissipation.

The rest of the paper is organized as follows. In Section 2, the test sequence reduction method is discussed. Section 3 describes the algorithm used in the proposed twofold state skip logic. In Section 4, the decompression architecture for the proposed twofold state skip logic is described. In Section 5, the implementation details and results are discussed. Section 6 presents the conclusion.

By using twofold State Skip LFSR algorithm, the length of the test sequence generated from the conventional LFSR can be reduced. When four different seeds are used as input to the LFSR, it generates (2n
                     −1) test vectors for each seed. Valid test vectors are generated during the functional mode, whereas useless test vectors are reduced by using the twofold State Skip Mode. The group counter contains all possible test vectors and the selected vectors are stored in the seed counter. Each test vector from both the seed counter and group counter are processed in the decoder block and generates signal to the mode select unit. Based on the signal, the mode select unit activates the twofold State Skip LFSR to generate the reduced test sequence.

This work presents twofold state skip logic (Fig. 3
                     ) for reducing the test sequence compared with that of the conventional LFSR. As the conventional LFSR architecture corresponds to its characteristic polynomial, this state skip logic is based on a set of instructions that perform successive jumps between states. Scan inserting via this scheme requires minimum test data storage, as the test vectors are selected by skipping the useless parts of the test sequence. Depending on the algorithm implementation, the LFSR scheme switches from the standard mathematical model to a modular form. Switching from the modular form to the dual standard form is executed by reversing the direction of all of the data flows between the latches, removing the XORs between the latches and performing an XOR on all of the feedbacks into the first latch. The resultant state sequence is presented in Table 1
                     .

In the modular LFSR, the XOR gates are placed between adjacent flip-flops. The modular LFSR can run faster than the standard LFSR.

In Table 1, X
                     0, X
                     1, X
                     2, and X
                     3 represent the bit positions (X); 0, 1, 2, 4, and 8 are the cycle counts (Y); 1000, 0100, 0010, 0001, …, 1010, 0101, 1110, and 0111 are shifted between the states (Z).

A lookup table with cycles for I
                     =0, 1, 2, and 3 is derived from the sequences generated from the LFSR with the characteristic polynomial P(X)=
                     X
                     4
                     +
                     X
                     +1, as shown in Fig. 4
                     . For skip-state (N′) estimation, all of the cycle rows must be binary and added to the remainder of the modulo (2n
                     −1) division. For example, the cycle rows 2 and 8 are selected from Table 1, which results in hex 10. Each bit set is identified in the skip state (N′). For individual bits in N′, the state S
                     fc-row (first cycle-row) for each single bit set in Si
                      is calculated from the lookup table. Similarly, for each bit set in the state S
                     fc-row, state S
                     nc-row (next cycle-row) is calculated. In the final step, all of the S
                     lc-row (last cycle-row) states are XORed to determine the nth state for bit N′. When all of the bits in the skip states are completed, a XOR operation is performed for all of the nth states of all of the bits to determine the machine’s nth state. The resultant states are available for use in the LFSR decompression architecture. For example, in the presented illustration (Fig. 5
                     ), the segment of Cycle 2 (Y
                     2) is obtained from the lookup table {0010, 0001, 1100, and 0110}. In X
                     0
                     , Y
                     2, the second bit holds ‘1’ and the other bits hold ‘0’. At this stage, the next cycle is estimated as X
                     2, Y
                     8. In the other case of X
                     2, Y
                     2, the first and second bits hold ‘1’ and the others hold ‘0’. Using the same estimation routine, X
                     1, Y
                     8 and X
                     2, Y
                     8 are estimated from the lookup table. The resultant column vector represents the skip state N′ (Cycle Count N
                     =10).

A novel twofold state skip logic is incorporated in the decompression architecture shown in Fig. 6
                      which skips the pre-calculated number of states. It shows that whenever a new seed value is loaded in the decompression architecture, the Group Counter is initialized to count the total number of useful segments generated for each seed.

The Seed Counter counts the seeds of every seed group. When a useful pattern is generated, the Seed Counter increments and loads a new seed. Similarly, the Group Counter is incremented when all of the seeds of a group have been processed. When the Group Counter is incremented, a new group is chosen for the subsequent operations. To determine the quality of the generated pattern (i.e., the Useful patterns), the Mode Select unit is used here. For this assessment, the values of the Seed Counter and Group Counter are decoded. The decoded output is then given to the Mode Select unit to drive the proposed TFSS LFSR logic. The TFSS LFSR logic is driven only when the mode signal equals logic ‘1’ (i.e., the Processed segment is useful).

@&#EXPERIMENTAL RESULTS@&#

Testing was conducted for selected versions of ISCAS 89 & 85 benchmark circuits with TSMC 45nm low-power standard cell libraries. A standard cell library is a group of low-level electronic logic functions. The key feature of these libraries is that they are of a fixed height, which permits them to be placed in rows, easing the automated digital layout procedure. In this case, the cell libraries represent the standard processing technology, which is recognized by the research community for the Tape-out process. To estimate the fault diagnosing ability of the proposed scheme, various fault models were injected in the experiment. TetraMAX® ATPG automatically produces high-quality test patterns. TetraMAX® ATPG provides an optimized solution for an extensive range of test methodologies and is integrated with Synopsys’ patented DFTMAX™ and DFTMAX Ultra, which are the leading test synthesis tools. Test patterns were generated using an industrial standard testing tool (Synopsys – TetraMAX) and had 100% fault coverage.

The netlist file was generated using the design vision compiler; this netlist file was used in the TetraMAX to determine the fault coverage, test coverage, and power consumption. The power was analysed for the ISCAS 89 benchmark circuits before and after inserting the scan cells. The estimated parameters are shown in Fig. 7
                     . The fault coverage and test coverage for collapsed and un-collapsed faults were determined, and test generation for these benchmark circuits was performed. These results are presented in Tables 2 and 3
                     
                     . The Twofold State Skip-LFSR and the Single State Skip-LFSR (SSS-LFSR) are compared in Table 4
                      and Fig. 8
                     . Simulation and synthesis were performed on S27 benchmark circuit using the XILINX tool and the Spartan 3E device to measure the testing time. The results are represented in Table 5
                     .

@&#CONCLUSION@&#

Twofold state skip logic determines the next useful state after the current state by leaving a precalculated number of states with respect to the clock cycles. By applying this logic, the useless parts of the test sequences are rejected. The presented algorithm reduces hardware overhead and can be applied to larger circuits. Additionally, the overall system can be adapted to standard fault coverage oriented ATPG with minimal computation and reduced area and power consumption. The presented technique minimizes the test sequence length, which, in turn, helps to reduce the required memory size. Additionally, using a reduced test sequence minimizes power dissipation during the testing of the CUT. In this study, the need to optimize test data compression methods and test set embedding methods was addressed based on the proposed reduced test sequences. Through this smart approach, testing of IP cores was mostly performed using test set embedding methods. The netlist was generated using the design vision compiler, and the netlist was used in TetraMAX for determining the fault coverage, test coverage, and power consumed. The fault coverage and test coverage for collapsed and un-collapsed faults were determined, and the test generation for these benchmark circuits was performed. Area and power were analysed and compared between TFSS-LFSR and SSS-LFSR. Additionally, simulation and synthesis were performed using the XILINX tool and the Spartan 3E device to measure the testing time. The performance was improved to 29% during minimum period and 45% during maximum period when the analysis was performed for time constraint.

@&#REFERENCES@&#

