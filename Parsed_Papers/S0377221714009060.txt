@&#MAIN-TITLE@&#Search with evolutionary ruin and stochastic rebuild: A theoretic framework and a case study on exam timetabling

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper presents a new search method which tries to learn and adapt to the changing environments during the search.


                        
                        
                           
                           It improves the original R&R idea by implementing a phase of Evolutionary Ruin to mimic an evolution within single solutions.


                        
                        
                           
                           It achieves optimisation by an iterative process of component evaluation, solution disruption and stochastic constructive repair.


                        
                        
                           
                           It presents a formal framework and implements a Markov chain analysis on some theoretical properties of the approach.


                        
                        
                           
                           Experimental results on exam timetabling benchmark problems have demonstrated the strength of the approach.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Metaheuristics

Evolutionary algorithm

Stochastic process

Combinatorial optimisation

Exam timetabling

@&#ABSTRACT@&#


               
               
                  This paper presents a state transition based formal framework for a new search method, called Evolutionary Ruin and Stochastic Recreate, which tries to learn and adapt to the changing environments during the search process. It improves the performance of the original Ruin and Recreate principle by embedding an additional phase of Evolutionary Ruin to mimic the survival-of-the-fittest mechanism within single solutions. This method executes a cycle of Solution Decomposition, Evolutionary Ruin, Stochastic Recreate and Solution Acceptance until a certain stopping condition is met. The Solution Decomposition phase first uses some problem-specific knowledge to decompose a complete solution into its components and assigns a score to each component. The Evolutionary Ruin phase then employs two evolutionary operators (namely Selection and Mutation) to destroy a certain fraction of the solution, and the next Stochastic Recreate phase repairs the “broken” solution. Last, the Solution Acceptance phase selects a specific strategy to determine the probability of accepting the newly generated solution. Hence, optimisation is achieved by an iterative process of component evaluation, solution disruption and stochastic constructive repair. From the state transitions point of view, this paper presents a probabilistic model and implements a Markov chain analysis on some theoretical properties of the approach. Unlike the theoretical work on genetic algorithm and simulated annealing which are based on state transitions within the space of complete assignments, our model is based on state transitions within the space of partial assignments. The exam timetabling problems are used to test the performance in solving real-world hard problems.
               
            

@&#INTRODUCTION@&#

By definition, a solution to a combinatorial problem is always made of components which are elaborately interlocked together. Not only should each solution component be a strong candidate in its own right but also it has to fit well with other components in the surrounding environment or current setting. To deal with these components, Schrimpf, Schneider, Stamm-Wilbrand, and Dueck (2000) proposed a technique called Ruin and Recreate (R&R) principle for some classical problems (including the traveling salesman problem, vehicle routing and network optimisation), and claimed that it could be a general approach for various combinatorial optimisation problems. Since then, R&R has been successfully applied to many different types of discrete optimisation problems, such as quadratic assignment (Misevicius, 2003), paratransit scheduling (Häll & Peterson, 2013), the permutation flow shop problem and one-dimensional bin packing problem (Burke et al., 2009), etc.

The R&R method uses the concepts of simulated annealing (Kirkpatrick, Gelatt, & Vecchi, 1983) or threshold accepting (Dueck & Scheuer, 1990) with large moves instead of smaller ones. The method is sometime called very large neighbourhood search, and thus bears some resemblance to variable neighbourhood search (Hansen & Mladenović, 1999) which obtains better results by a perturbation of an existing solution and a following improvement procedure. High quality solutions are obtained by applying this type of treatment frequently. Hence, R&R method can be thought of as an iterative process of reconstructions and improvements applied to solutions. The advantage of the method over the well-known random multi-start method is that, instead of generating new solutions from scratch, a better idea is to reconstruct a portion of the current solution to make use of the information gained from the previous search.

For simple structured problems such as the traveling salesman problem, the need of using large moves is not obvious, because there is no/little feasibility issue, and small moves are usually sufficient for the algorithms to generate near optimal solutions. Of course, the larger the size of moves, the better the results would be but at the cost of much higher computation time. For instance, Iterated Lin-Kernighan, one of the best approaches for the traveling salesman problem, does use large local moves. However, for complex problems such as exam timetabling problems, difficulties arise if we always use such small moves, because local moves do not give small changes in the objective function: if taking one move from a current solution to its neighbouring solution, the qualities of the resulting solutions might be significantly different due to the ruggedness of the landscapes in these problem areas. The situation may be alleviated by a better choice of solution representation and neighbourhood function, but this study is beyond the scope of this paper.

Solutions of complex problems usually come with a number of soft and/or hard constraints, which makes it difficult to get just feasible solutions. Neighbouring solutions of complex schedules, for instance, are mostly infeasible solutions. Walking in such a complex fitness landscape from one feasible solution to another feasible neighboured solution would be hard. The common method of avoiding the infeasibility problem for many classical algorithms in the literature is to impose artificial penalty functions, but this method would typically make the algorithms stuck in solutions which are nearly feasible but are not allowed at all.

Naturally, one will think in such as paradigm: Ruin and Recreate. Unlike a local search which implements search by doing perturbation on a small number (usually up to 3) of components, we ruin a large portion of the solution and try to rebuild the solution as best as we can, with the hope that the new solution is improved. The R&R approach is based on this idea. Of course, the R&R can also destroy a small portion of the solution (say 1–2 components), then under this circumstance it behaves the same as an ordinary local search algorithm. Hence, it is reasonable to believe that problems with many side conditions, or with complex objective functions, are more tractable using special-designed large moves.

Based on the R&R principal, in this paper we embed some evolutionary features into the decision process and present a more advanced technique called Evolutionary Ruin and Stochastic Recreate (ER&SR). Its general idea is to break a solution down into its components and assign a score to each component by an evaluation function which works under dynamic environments. The scores (or fitness values) determine the chances for the components to survive in the current solution.

The ER&SR applies two operators of Selection and Mutation as the ruining strategies, trying to mimic the survival-of-the-fittest mechanism happening on single individuals (or solutions). Each component in the solution has to continuously demonstrate its worthiness to remain in the current solution (or environment). Hence in each iteration, some components would be treated not worth keeping. The evolutionary strategy adopted may also remove some worthy components with fixed or variable low probabilities. The removed component is then reintroduced by using a specific algorithm. The addition of a new component is determined by a dynamic evaluation function, which computes how well the candidate component would fit in with others that already exist in the current solution. The above processes are repeated together with the remainder of the classical R&R. Hence, search is based on an iterative improvement process of components evolution, solution disruption and reconstructive process.

The proposed ER&SR algorithm comprises the following four phases: Solution Decomposition, Evolutionary Ruin, Stochastic Recreate and Solution Acceptance. It executes these phases in sequence on a single solution until a predefined stopping criterion is met. The first Solution Decomposition phase is based on the fact that solutions of the combinatorial optimisation problems all consist of components which are intricately woven together. Each component in a current solution may not only be a strong candidate in its own right, but also need to fit well with other components. Hence, the key problem in this phase is about what measurement to use to evaluate the fitness of individual components. To address this, we may employ an expert's domain knowledge to break a solution down into components and assign a score to each. The higher the score, the fitter the associated component is.

The second Evolutionary Ruin phase is based on the consideration that the incumbent solution must be changed not only locally but also over a macroscopic scale, depending on the solution composition defined by the proceeding Solution Decomposition phase. This phase employs two evolutionary operators of Selection and Mutation to destroy a certain portion of the entire solution. The Selection operator removes some components based on Darwin's survival of the fittest mechanism, while the Mutation operator further removes a small number of components at random. Hence, the destroyed part of the solution would sometimes be large enough such that the impact of the “bomb” that is thrown on the solution will be noticeable not only locally but in the whole system. On the other hand, the destroyed part would sometimes be small enough so that at least a main portion of the solution (i.e. a skeleton) remains to ease the rebuild for the next solution.

The third Stochastic Recreate phase follows to reintroduce the removed components by a somewhat stochastic method in order to have a better chance to jump out of the local optima. The fourth Solution Acceptance phase selects a specific strategy to determine the probability of accepting the newly generated solution.

This paper presents a probabilistic model based on the state transition process between the abovementioned phases, and implements a Markov chain analysis to derive some theoretical properties of the approach. The well-known exam timetabling problems are used to test the availability of the approach in solving real-world hard problems.

The remainder of the paper is structured as follows. Section 2 elaborates a formal framework of the ER&SR, from the state transition point of view. Section 3 introduces an implementation of the ER&SW for exam timetabling, and Section 4 presents the computational results of this approach. Section 5 contains some concluding remarks and possible future work.

Following the general introduction of the ER&SR in Section 1, this section presents its formal framework in a similar way to that of the evolutionary squeaky wheel optimisation (Li, Parkes, & Burke, 2011b), and then presents a Markov chain model for a simplified version of the algorithm. The basic idea of the algorithm was initially and briefly presented in Li, Qu, and Shen (2012b). The session brings a deeper insight on the working mechanism of the algorithm.

Four phases are performed in sequence at each iteration of the ER&SR algorithm. They are Solution Decomposition, Evolutionary Ruin, Stochastic Recreate and Solution Acceptance (see the flow chart in Fig. 1
                        ).

The first phase, Solution Decomposition, does not change the current state on its own, since it only collects information about the local fitness value of each component of the current state. The Evolutionary Ruin phase (comprising two operators of Selection and Mutation) changes the present state by removing a set of selected components from a current solution, based on the results of the preceding Solution Decomposition phase. Neither the Selection operator nor the Mutation operator can directly result in a destination state, that is, a state in which each of the componential variables is assigned a value. What is obtained after an Evolutionary Ruin is an intermediate state in which at least one component is removed. An intermediate state corresponds to an incomplete assignment, with a set of unassigned components.

A source state Xt, t = 1, 2,…, |S|, corresponds to a complete solution in the state space S. Xt
                         consists of m componential variables xi
                         denoted as Xt
                         = (x
                        1, …, xm
                        )
                           t
                        , and each (xi
                        )
                           t
                         takes one of its domain values, i.e. 
                           
                              
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 t
                              
                              ∈
                              
                                 {
                                 
                                    j
                                    1
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 
                                    j
                                    2
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 
                                    j
                                    3
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 …
                                 }
                              
                           
                        . The assignment of a value 
                           
                              j
                              k
                              
                                 (
                                 i
                                 )
                              
                           
                         to a variable is denoted as 
                           
                              
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 t
                              
                              =
                              
                                 j
                                 k
                                 
                                    (
                                    i
                                    )
                                 
                              
                           
                        . A solution is a complete assignment if each variable xi
                         has a domain value assigned, regardless of the satisfiability on the constraint set. For each iteration, the value of m may be fixed or not, depending on the nature of the problem. For example, for the assignment problem it is usually fixed, while for the set covering problem it is changing if the objective is just to minimise the number of components in the solution.

Let f((xi
                        )
                           t
                        , (xi
                        )
                           t
                         ∈ Xt
                        ) ∈ (0, 1) be the local fitness value of component (xi
                        )
                           t
                         in a solution Xt
                         calculated by the Solution Decomposition phase. The larger the f((xi
                        )
                           t
                        , (xi
                        )
                           t
                         ∈ Xt
                        ), the smaller the chance that (xi
                        )
                           t
                         is selected for removal. The probabilities, pS
                        ((xi
                        )
                           t
                        ), at which component (xi
                        )
                           t
                         is selected from Xt
                         to convert to a ‘#’ (i.e. the unassigned situation) is calculated as

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                S
                                             
                                             
                                                (
                                                
                                                   
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      )
                                                   
                                                   t
                                                
                                                ,
                                                
                                                   
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      )
                                                   
                                                   t
                                                
                                                ∈
                                                
                                                   X
                                                   t
                                                
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   1
                                                   −
                                                   f
                                                   (
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   ,
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   ∈
                                                   
                                                      X
                                                      t
                                                   
                                                   )
                                                
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      m
                                                   
                                                   
                                                      (
                                                      1
                                                      −
                                                      f
                                                      
                                                         (
                                                         
                                                            
                                                               (
                                                               
                                                                  x
                                                                  k
                                                               
                                                               )
                                                            
                                                            t
                                                         
                                                         ,
                                                         
                                                            
                                                               (
                                                               
                                                                  x
                                                                  k
                                                               
                                                               )
                                                            
                                                            t
                                                         
                                                         ∈
                                                         
                                                            X
                                                            t
                                                         
                                                         )
                                                      
                                                      )
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                             ∀
                                             i
                                          
                                       
                                       
                                          ∈
                                       
                                       
                                          
                                             
                                                {
                                                1
                                                ,
                                                …
                                                ,
                                                m
                                                }
                                             
                                             ,
                                             
                                                X
                                                t
                                             
                                             ∈
                                             S
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

An intermediate state X'
                           t
                         corresponds to a partial solution with at least one of m components unassigned. Let PS
                        (X'
                           t
                        |Xt
                        ) be the conditional probability that intermediate state X'
                           t
                         = (x'1, …, x'
                           m
                        )
                           t
                         is generated from a present state Xt
                         = (x
                        1, …, xm
                        )
                           t
                         by the Selection operator. We may obtain

                           
                              (2)
                              
                                 
                                    
                                       P
                                       S
                                    
                                    
                                       (
                                       
                                          X
                                          t
                                          ′
                                       
                                       |
                                       
                                          X
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                   if
                                                   
                                                   ∃
                                                   i
                                                   ∈
                                                   
                                                      {
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      m
                                                      }
                                                   
                                                   ,
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   ≠
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  ′
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   
                                                   and
                                                   
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  ′
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   ≠
                                                   `
                                                   #
                                                   "
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      ∏
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      m
                                                   
                                                   
                                                      
                                                         p
                                                         S
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               (
                                                               
                                                                  x
                                                                  i
                                                               
                                                               )
                                                            
                                                            t
                                                         
                                                         )
                                                      
                                                      
                                                         
                                                            (
                                                            1
                                                            −
                                                            
                                                               p
                                                               S
                                                            
                                                            
                                                               (
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        x
                                                                        i
                                                                     
                                                                     )
                                                                  
                                                                  t
                                                               
                                                               )
                                                            
                                                            )
                                                         
                                                         
                                                            1
                                                            −
                                                            H
                                                            (
                                                            
                                                               
                                                                  (
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                                  )
                                                               
                                                               t
                                                            
                                                            ,
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        
                                                                           x
                                                                           ′
                                                                        
                                                                     
                                                                     i
                                                                  
                                                                  )
                                                               
                                                               t
                                                            
                                                            )
                                                         
                                                      
                                                      ,
                                                      
                                                      otherwise
                                                      .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where

                           
                              (3)
                              
                                 
                                    H
                                    
                                       (
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                             
                                             )
                                          
                                          t
                                       
                                       ,
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                                ′
                                             
                                             )
                                          
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               x
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      ≠
                                                      `
                                                      #
                                                      "
                                                      
                                                      and
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     ′
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      =
                                                      `
                                                      #
                                                      "
                                                      ;
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               x
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      =
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     ′
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      ≠
                                                      `
                                                      #
                                                      "
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The Mutation operator further transforms the present intermediate state X'
                           t
                         to another intermediate state X''
                           t
                         by removing the set of mutated components from X'
                           t
                        . The probabilities that component (x'
                           i
                        )
                           t
                         is selected from tuple X'
                           t
                         = (x'1, …, x'
                           m
                        )
                           t
                         to re-instantiate by the later Stochastic Recreate operator is denoted as 
                           
                              p
                              M
                              
                                 (
                                 t
                                 )
                              
                           
                        , where 
                           
                              
                                 p
                                 M
                                 
                                    (
                                    t
                                    )
                                 
                              
                              ∈
                              
                                 (
                                 0
                                 ,
                                 1
                                 )
                              
                           
                         is the same for each component x'
                           i
                         and can be either fixed or changing for each iteration. Let pM
                        (X''
                           t
                        |X'
                           t
                        ) be the transition probability that tuple X''
                           t
                         = (x''1, …, x''
                           m
                        )
                           t
                         is generated from tuple X'
                           t
                         = (x'1, …, x'
                           m
                        )
                           t
                         by Mutation. Then we have

                           
                              (4)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                P
                                                M
                                             
                                             
                                                (
                                                
                                                   X
                                                   t
                                                   
                                                      ′
                                                      ′
                                                   
                                                
                                                |
                                                
                                                   X
                                                   t
                                                   ′
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            0
                                                            ,
                                                            
                                                            if
                                                            
                                                            ∃
                                                            i
                                                            ∈
                                                            
                                                               {
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               m
                                                               }
                                                            
                                                            ,
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        
                                                                           x
                                                                           ′
                                                                        
                                                                     
                                                                     i
                                                                  
                                                                  )
                                                               
                                                               t
                                                            
                                                            ≠
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        
                                                                           x
                                                                           
                                                                              ′
                                                                              ′
                                                                           
                                                                        
                                                                     
                                                                     i
                                                                  
                                                                  )
                                                               
                                                               t
                                                            
                                                            
                                                            and
                                                            
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        
                                                                           x
                                                                           
                                                                              ′
                                                                              ′
                                                                           
                                                                        
                                                                     
                                                                     i
                                                                  
                                                                  )
                                                               
                                                               t
                                                            
                                                            ≠
                                                            `
                                                            #
                                                            "
                                                            ;
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               ∏
                                                               
                                                                  i
                                                                  =
                                                                  1
                                                               
                                                               m
                                                            
                                                            
                                                               
                                                                  
                                                                     
                                                                        (
                                                                        
                                                                           
                                                                              (
                                                                              
                                                                                 p
                                                                                 M
                                                                                 
                                                                                    (
                                                                                    t
                                                                                    )
                                                                                 
                                                                              
                                                                              )
                                                                           
                                                                           
                                                                              H
                                                                              (
                                                                              
                                                                                 
                                                                                    (
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                             ′
                                                                                          
                                                                                       
                                                                                       i
                                                                                    
                                                                                    )
                                                                                 
                                                                                 t
                                                                              
                                                                              ,
                                                                              
                                                                                 
                                                                                    (
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                             
                                                                                                ′
                                                                                                ′
                                                                                             
                                                                                          
                                                                                       
                                                                                       i
                                                                                    
                                                                                    )
                                                                                 
                                                                                 t
                                                                              
                                                                              )
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              (
                                                                              1
                                                                              −
                                                                              
                                                                                 p
                                                                                 M
                                                                                 
                                                                                    (
                                                                                    t
                                                                                    )
                                                                                 
                                                                              
                                                                              )
                                                                           
                                                                           
                                                                              1
                                                                              −
                                                                              H
                                                                              (
                                                                              
                                                                                 
                                                                                    (
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                             ′
                                                                                          
                                                                                       
                                                                                       i
                                                                                    
                                                                                    )
                                                                                 
                                                                                 x
                                                                              
                                                                              ,
                                                                              
                                                                                 
                                                                                    (
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                             
                                                                                                ′
                                                                                                ′
                                                                                             
                                                                                          
                                                                                       
                                                                                       i
                                                                                    
                                                                                    )
                                                                                 
                                                                                 t
                                                                              
                                                                              )
                                                                           
                                                                        
                                                                        )
                                                                     
                                                                     
                                                                        1
                                                                        −
                                                                        λ
                                                                     
                                                                  
                                                                  ,
                                                               
                                                               
                                                               otherwise
                                                               .
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where

                           
                              (5)
                              
                                 
                                    H
                                    
                                       (
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                                ′
                                             
                                             )
                                          
                                          t
                                       
                                       ,
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                                
                                                   ′
                                                   ′
                                                
                                             
                                             )
                                          
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     ′
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      ≠
                                                      `
                                                      #
                                                      "
                                                      
                                                      and
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     
                                                                        ′
                                                                        ′
                                                                     
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      =
                                                      `
                                                      #
                                                      "
                                                      ;
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     ′
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      =
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     x
                                                                     
                                                                        ′
                                                                        ′
                                                                     
                                                                  
                                                               
                                                               i
                                                            
                                                            )
                                                         
                                                         t
                                                      
                                                      ≠
                                                      `
                                                      #
                                                      "
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       λ
                                       i
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  ′
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   =
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  
                                                                     ′
                                                                     ′
                                                                  
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   =
                                                   `
                                                   #
                                                   "
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The Stochastic Recreate phase then generates a new destination state X
                        
                           t + 1 from the present intermediate state X''
                           t
                        , by carrying out probabilistic moves among different possible destination states. Let PS
                        (X
                        
                           t + 1|X''
                           t
                        ) be the transition probability that tuple X
                        
                           t + 1 = (x
                        1, …, xm
                        )
                           t + 1 is generated from tuple X''
                           t
                         = (x''1, …, x''
                           m
                        )
                           t
                         by the Stochastic Recreate. We have

                           
                              (7)
                              
                                 
                                    
                                       P
                                       S
                                    
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                          
                                             ′
                                             ′
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                   if
                                                   
                                                   ∃
                                                   i
                                                   ∈
                                                   
                                                      {
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      m
                                                      }
                                                   
                                                   ,
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  
                                                                     ′
                                                                     ′
                                                                  
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   ≠
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                      
                                                      
                                                         t
                                                         +
                                                         1
                                                      
                                                   
                                                   ≠
                                                   `
                                                   #
                                                   "
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   1
                                                   ,
                                                   
                                                   if
                                                   
                                                   ∀
                                                   i
                                                   ∈
                                                   
                                                      {
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      m
                                                      }
                                                   
                                                   ,
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  x
                                                                  
                                                                     ′
                                                                     ′
                                                                  
                                                               
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                      t
                                                   
                                                   =
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         )
                                                      
                                                      
                                                         t
                                                         +
                                                         1
                                                      
                                                   
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         F
                                                         (
                                                         
                                                            X
                                                            
                                                               t
                                                               +
                                                               1
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         
                                                            ∑
                                                            
                                                               X
                                                               ∈
                                                               N
                                                               (
                                                               
                                                                  
                                                                     
                                                                        X
                                                                        
                                                                           ′
                                                                           ′
                                                                        
                                                                     
                                                                  
                                                                  t
                                                               
                                                               )
                                                            
                                                         
                                                         
                                                            F
                                                            (
                                                            X
                                                            )
                                                         
                                                      
                                                   
                                                   ,
                                                   
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where F(·) is the objective function (for a maximisation problem in this context) for destination states, and N(X''
                           t
                        ) is the set of all reachable destination states from intermediate state X''
                           t
                        . The first two cases of Equation (7) are automatic constraints which ensure that the constructor can only assign values to unassigned componential variables (i.e. variables with ‘#’ values). The third case defines a Stochastic Recreate whose purpose is to introduce some randomness but still to favour the construction of fitter solutions. However, when applying the constructor in practice, there is a computational difficulty due to the size of N(X″) which is

                           
                              (8)
                              
                                 
                                    
                                       |
                                       
                                          N
                                          (
                                          
                                             
                                                X
                                             
                                             t
                                             
                                                ′
                                                ′
                                             
                                          
                                          )
                                       
                                       |
                                    
                                    =
                                    
                                       ∏
                                       
                                          k
                                          =
                                          1
                                       
                                       l
                                    
                                    
                                       n
                                       k
                                    
                                    ,
                                 
                              
                           
                        where l is the number of unassigned componential variables in X″, and nk
                         is the number of domain values that the kth unassigned componential variable may take.

One may see from Equation (8) that the number of one-step reachable states from X''
                           t
                         increases exponentially with the number of variables having ‘#’ values in X''
                           t
                        . To reduce the amount of computation, we add one more case to Equation (7) which says that all the neighbouring states have the same chance to be reached if the number of ‘#’s is larger than a pre-defined threshold value t, t ≥ 2. The extra case is formulated as

                           
                              (9)
                              
                                 
                                    
                                       P
                                       S
                                    
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                          
                                             ′
                                             ′
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       1
                                       
                                          
                                             ∏
                                             
                                                k
                                                =
                                                1
                                             
                                             l
                                          
                                          
                                             n
                                             k
                                          
                                       
                                    
                                    ,
                                    
                                    if
                                    
                                    l
                                    >
                                    t
                                    ;
                                 
                              
                           
                        
                     

Recall that Xt
                         denotes the source state that the Stochastic Recreate previously reaches. The fourth Solution Acceptance phase accepts the new complete state X
                        
                           t + 1 at probability PA
                        (X
                        
                           t + 1|Xt
                        ). For the simplest situation where each of the resulting solutions is accepted, PA
                        (X
                        
                           t + 1|Xt
                        ) = 1. If using simulated annealing with a time-varying parameter T called temperature, then

                           
                              (10)
                              
                                 
                                    
                                       P
                                       A
                                    
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                   
                                                   if
                                                   
                                                   (
                                                   F
                                                   
                                                      (
                                                      
                                                         X
                                                         
                                                            t
                                                            +
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                   −
                                                   F
                                                   
                                                      (
                                                      
                                                         X
                                                         t
                                                      
                                                      )
                                                   
                                                   )
                                                   ≥
                                                   0
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                   exp
                                                   
                                                      (
                                                      
                                                         
                                                            F
                                                            
                                                               (
                                                               
                                                                  X
                                                                  
                                                                     t
                                                                     +
                                                                     1
                                                                  
                                                               
                                                               )
                                                            
                                                            −
                                                            F
                                                            
                                                               (
                                                               
                                                                  X
                                                                  t
                                                               
                                                               )
                                                            
                                                         
                                                         T
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                   if
                                                   
                                                   
                                                      (
                                                      F
                                                      
                                                         (
                                                         
                                                            X
                                                            
                                                               t
                                                               +
                                                               1
                                                            
                                                         
                                                         )
                                                      
                                                      −
                                                      F
                                                      
                                                         (
                                                         
                                                            X
                                                            t
                                                         
                                                         )
                                                      
                                                      )
                                                   
                                                   <
                                                   0
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

A Markov chain is a sequence of random variables X
                        1, X
                        2,…, Xt
                         with the Markov property, that is, given the present state, the future and past states are independent (Tijms, 2003). A discrete-time Markov chain is denoted as

                           
                              (11)
                              
                                 
                                    Pr
                                    
                                       {
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       x
                                       |
                                       
                                          X
                                          1
                                       
                                       =
                                       
                                          x
                                          1
                                       
                                       ,
                                       
                                          X
                                          2
                                       
                                       =
                                       
                                          x
                                          2
                                       
                                       ,
                                       …
                                       ,
                                       
                                          X
                                          t
                                       
                                       =
                                       
                                          x
                                          t
                                       
                                       }
                                    
                                    =
                                    Pr
                                    
                                       {
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       x
                                       |
                                       
                                          X
                                          t
                                       
                                       =
                                       
                                          x
                                          t
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

At each step, the system may transit its state from state i to state j according to a probability distribution. For state transitions within a space of finite set S, the transition probability distribution can be represented by a matrix P, whose (i, j)th entry is

                           
                              (12)
                              
                                 
                                    
                                       p
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    Pr
                                    
                                       {
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       j
                                       |
                                       
                                          X
                                          t
                                       
                                       =
                                       i
                                       }
                                    
                                    ,
                                    
                                    i
                                    ,
                                    j
                                    ∈
                                    S
                                    .
                                 
                              
                           
                        
                     

For the search space of the ER&SR algorithm, assume a solution Xt
                         consists of m componential variables xi
                         denoted as Xt
                         = (x
                        1, …, xm
                        )
                           t
                        , and each xi
                         takes one of the domain values, i.e. 
                           
                              
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 t
                              
                              ∈
                              
                                 {
                                 
                                    j
                                    1
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 
                                    j
                                    2
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 
                                    j
                                    3
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 ,
                                 …
                                 }
                              
                           
                        . For the Evolutionary Ruin phase, its Selection operator may be deemed as a linear map from space S of cardinality 
                           
                              
                                 ∏
                                 
                                    k
                                    =
                                    1
                                 
                                 m
                              
                              
                                 n
                                 k
                              
                           
                         to space S
                        # of cardinality 
                           
                              
                                 ∏
                                 
                                    k
                                    =
                                    1
                                 
                                 m
                              
                              
                                 (
                                 
                                    n
                                    k
                                 
                                 +
                                 1
                                 )
                              
                           
                        , as each variable after Selection can take an additional ‘#’ value denoting that the variable is marked as “selected” for later instantiation. The Mutation operator transits states within space S
                        #, and the Stochastic Rebuild phase transfers a partial assignment (i.e. a state with a mixture of # and non-# symbols) in S
                        # back to a complete assignment in space S.

For each iteration of the ER&SR algorithm, a state transition (or a one-step move) is carried out from a source state to a destination state. For a given present state, the probability of its future state is conditionally independent of the past states. Hence, each step of transitions between states of complete solutions (i.e. Xt
                         and Xt
                        
                        +1) has the Markov property.

After defining the state transitions after each phase of Selection, Mutation, Stochastic Recreate and Solution Acceptance, we may give an expression for the overall transition probability between any two connected states. The transition probability from a source state Xt
                         to a destination state Xt
                        
                        +1, via two intermediate states X'
                           t
                         and X''
                           t
                        , can be expressed as

                           
                              (13)
                              
                                 
                                    P
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                       
                                       )
                                    
                                    =
                                    
                                       P
                                       S
                                    
                                    
                                       (
                                       
                                          X
                                          t
                                          ′
                                       
                                       |
                                       
                                          X
                                          t
                                       
                                       )
                                    
                                    ·
                                    
                                       P
                                       M
                                    
                                    
                                       X
                                       t
                                       
                                          ′
                                          ′
                                       
                                    
                                    
                                       |
                                       
                                          X
                                          t
                                          ′
                                       
                                       )
                                    
                                    ·
                                    
                                       P
                                       S
                                    
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                          
                                             ′
                                             ′
                                          
                                       
                                       )
                                    
                                    ·
                                    
                                       P
                                       A
                                    
                                    
                                       (
                                       
                                          X
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       |
                                       
                                          X
                                          t
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

Hence, we may see that these four phases work as a whole to implement a linear transformation from state space S to itself, by an overall transition matrix P whose entries are defined by Equation (13). If a fixed rate of mutation pM
                         is used, the Markov chain formed by the ER&SR algorithm is homogeneous as the transition matrix does not depend on time. Accordingly, we can apply some of the standard results on Markov Chain analysis straightaway.

                           Definition 1
                           A Markov chain is called an ergodic chain if it is possible to go from every state to every state (not necessarily in one move). Ergodic Markov chains are also called irreducible.

For a transition matrix P = (pij
                              ), if π = (π
                              1, …, πj
                              , …) is a probability distribution such that 
                                 
                                    
                                       π
                                       j
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                    
                                       
                                          π
                                          i
                                       
                                       
                                          p
                                          
                                             i
                                             j
                                          
                                       
                                       ,
                                       
                                       ∀
                                       j
                                       ∈
                                       S
                                    
                                 
                              , then π is a stationary distribution.

(Koralov & Sinai, 2007) Given a Markov chain with an ergodic transition matrix 
                              P, there exists a unique stationary probability distribution π. The n-step transition probabilities converge to the distribution π, i.e.
                              
                                 
                                    
                                       lim
                                       
                                          n
                                          →
                                          ∝
                                       
                                    
                                    
                                       p
                                       
                                          i
                                          j
                                       
                                       
                                          (
                                          n
                                          )
                                       
                                    
                                    =
                                    
                                       π
                                       j
                                    
                                 
                              . The stationary distribution satisfies πj
                               > 0 for all j ∈ S.

For our ER&SR algorithm, we can easily verify that its P is positive (i.e. every element in P is a positive number), and thus the corresponding Markov chain is ergodic. By Theorem 1, there exists a unique stationary probability distribution π = (π
                        j) and πj
                         > 0. Hence, the ER&SR algorithm visits a global optimum of the optimisation problem after a finite number of transition steps with probability one. However, it does not converge to the optimal solutions because of πj
                         > 0, i.e. each of the states has a non-zero probability value.

In real-world implementation, an ER&SR algorithm always retains the best solution. Under this circumstance, a state does not correspond to a single solution, rather, it corresponds to a tuple of two solutions (x*, x), where x
                        * and x denote the previous best and the current solution, respectively. If x
                        * = s
                        * where s
                        * is the only optimal solution, then obviously all the solution pairs containing s
                        * consist of a single closed set from which no external state is reachable. Therefore, by the extension of Theorem 1 on reducible Markov chain, the probability of staying in the set of non-closed states converges to zero. That is, the ER&SR algorithm maintaining the best found solution converges to the global optimum of the problem.

We then study the condition on which the stationary probabilities are equally distributed. We can easily prove that, for any finite Markov chain with a positive matrix P, the stationary probabilities (πi
                        |j ∈ S) are uniformly distributed, at a value of 1/|S|, on each state if P is symmetric. For an ER&SR algorithm, the symmetric requirement on P is satisfied if the local fitness value f((xi
                        )
                           t
                        , (xi
                        )
                           t
                         ∈ Xt
                        ) is the same for each componential variable (xi
                        )
                           t
                         in the solution. In this case, the ER&SR reduces to a simple algorithm where its phases of Evolutionary Ruin and Stochastic Rebuild are purely randomised.

Naturally, for real-world problem solving, one would like to seek an algorithm where the stationary probabilities are not always uniformly distributed. For the ER&SR algorithm, we may observe that the stationary distribution π = (πi
                        |j ∈ S) on each state is controllable through a proper combination of the Selection function, the Mutation rate, the Stochastic Recreate method and Solution Acceptance strategy. This suggests that, even if we do not keep the best solution found during the algorithm execution, it is still possible to get a stationary probability close to one on the optimal solution of the given problem. The above statement is, however, just a conjecture. To confirm this, a much deeper study is needed to further explore and understand the interactions among the various phases in an ER&SR algorithm.

This section presents an application of the ER&SR algorithm to the exam timetabling problem which is well studied but is open (no optimal solution known). Starting from an initial timetable generated by any method, the steps described in Sections 3.2–3.4 are repeatedly executed in sequence until a user specified termination condition is met. Throughout the iterations, the best is retained and finally returned as the preserved timetable.

Exam timetabling occurs frequently throughout an institution's academic calendar, and needs to be tackled on a regular basis. The problem has attracted a significant level of research interest since the 1960’s. The general timetabling problem comes in many different guises such as nurse rostering (Aickelin, Burke, & Li, 2007; Burke, Li, & Qu, 2010b; Cheang, Li, Lim, & Rodrigues, 2003; Li, Burke, Curtois, Petrovic, Qu, 2012a), sports timetabling (Easton, Nemhauser, & Trick, 2004), transportation timetabling (Furini & Kidd, 2013) and educational timetabling (Carter, Laporte, & Lee, 1996; Petrovic & Burke, 2004; Qu, Burke, McCollum, Merlot, & Lee, 2009b; Schaerf, 1999). Educational timetabling problems are probably the most widely studied.

Since exam timetabling problems are generally NP-hard, meta-heuristics have attracted the most attention, including genetic algorithms (Erben, 2001; Paquete & Fonseca, 2001), tabu search (Burke, Kendall, & Soubeiga, 2003; White, Xie, & Zonjic, 2004), ant algorithms (Dowsland & Thompson, 2005), simulated annealing (Thompson & Dowsland, 1998). Various other methods have also been studied, such as knowledge-based systems (Burke, Petrovic, & Qu, 2006), local search-based heuristics (Burke & Newall, 2003; Casey & Thompson, 2004), and hyper-heuristics (Qu & Burke, 2009).

Exam timetabling can be considered as the process of assigning a set of exams into a certain number of timeslots subject to a set of hard and soft constraints. A hard constraint is the one that cannot be violated, for example, two exams attended by the same students cannot be scheduled to the same timeslot. A soft constraint is one that should be satisfied if possible, for example, exams taken by the same students should be spread out over the available timeslots to get some break. Solutions that satisfy hard constraints are called feasible solutions. The more soft constraints are satisfied, the better the timetables would be.

In terms of assessing the quality of potential schedules, to favour schedules in which exams are well spaced out or in which the number of undesirable assignments is low, Carter et al. (1996) proposed a proximity cost ws
                         whenever a student has to attend two exams scheduled s periods apart: these weights are w
                        1 = 16, w
                        2 = 8, w
                        3 = 4, w
                        4 = 2 and w
                        5 = 1. The following objective function is therefore used in a number of benchmark problems to calculate the cost of violations F(X) within a resulting feasible solution X (Burke, McCollum, Meisel, Petrovic, & Qu, 2007), in which exams of s timeslot away actually means “s slot in between, or s + 1 period apart”:

                           
                              (14)
                              
                                 
                                    Min
                                    
                                    F
                                    
                                       (
                                       X
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          s
                                          =
                                          0
                                       
                                       4
                                    
                                    
                                       (
                                       w
                                       
                                          
                                          s
                                       
                                       ×
                                       S
                                       
                                          t
                                          s
                                       
                                       )
                                    
                                    /
                                    S
                                    t
                                    ,
                                 
                              
                           
                        where, ws
                         = 2
                           s
                        , s ∈ {0, 1, 2, 3, 4}, is the weight that represents the importance of scheduling exams with common students either 4, 3, 2, 1, or 0 timeslots away in timetable X; Sts, s ∈ {0, 1, 2, 3, 4}, is the number of students that sit two exams of j timeslots away; St is the number of students in the problem.

This phase evaluates the current assignment for each exam ei, i ∈ [1, …, m], in a timetable, by computing the fitness of each exam allocation. Its purpose is to determine which exams are assigned in positions that contribute more toward the overall cost reduction for the resulting schedule. We design a normalised evaluation function f((ei
                     )
                        t
                     ), k ∈ (1, …, m), to evaluate ei
                      at the tth iteration as follows:

                        
                           (15)
                           
                              
                                 f
                                 
                                    (
                                    
                                       
                                          (
                                          
                                             e
                                             i
                                          
                                          )
                                       
                                       t
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       max
                                       
                                          (
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      1
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          ,
                                          …
                                          ,
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      m
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          )
                                       
                                       −
                                       C
                                       
                                          (
                                          
                                             
                                                (
                                                
                                                   e
                                                   i
                                                
                                                )
                                             
                                             t
                                          
                                          )
                                       
                                    
                                    
                                       max
                                       
                                          (
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      1
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          ,
                                          …
                                          ,
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      m
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          )
                                       
                                       −
                                       min
                                       
                                          (
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      1
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          ,
                                          …
                                          ,
                                          C
                                          
                                             (
                                             
                                                
                                                   (
                                                   
                                                      e
                                                      m
                                                   
                                                   )
                                                
                                                t
                                             
                                             )
                                          
                                          )
                                       
                                    
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (16)
                           
                              
                                 C
                                 
                                    (
                                    
                                       
                                          (
                                          
                                             e
                                             i
                                          
                                          )
                                       
                                       t
                                    
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       r
                                       =
                                       1
                                    
                                    
                                       i
                                       −
                                       1
                                    
                                 
                                 
                                    (
                                    
                                       w
                                       j
                                    
                                    ×
                                    
                                       S
                                       
                                          i
                                          r
                                       
                                    
                                    )
                                 
                                 +
                                 
                                    ∑
                                    
                                       r
                                       =
                                       i
                                       +
                                       1
                                    
                                    m
                                 
                                 
                                    (
                                    
                                       w
                                       j
                                    
                                    ×
                                    
                                       S
                                       
                                          i
                                          r
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (17)
                           
                              
                                 
                                    j
                                    =
                                    |
                                 
                                 
                                    t
                                    r
                                 
                                 −
                                 
                                    t
                                    i
                                 
                                 
                                    |
                                    −
                                    1
                                    ,
                                    
                                    j
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       ,
                                       4
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     where, C((ei
                     )
                        t
                     ) is the cost value caused by exam (ei
                     )
                        t; wj
                      takes the same definition as in Equation (14); tr
                      and ti
                      are the timeslots of (er
                     )
                        t
                      and (ei
                     )
                        t
                     , respectively; Sir
                      is the number of students involved in both exams (ei
                     )
                        t
                      and (er
                     )
                        t
                     , if j = |tr
                      − −ti
                     | < 5.

This phase determines if an exam of a current timetable should be removed or not. For the tth iteration of the Evolutionary Ruin, a single random number 
                           
                              
                                 r
                                 S
                                 
                                    (
                                    t
                                    )
                                 
                              
                              ∈
                              
                                 (
                                 0
                                 ,
                                 1
                                 )
                              
                           
                         is generated. The Selection operator then compares the fitness value f((ei
                        )
                           t
                        ) to 
                           
                              r
                              S
                              
                                 (
                                 t
                                 )
                              
                           
                        . If 
                           
                              f
                              
                                 (
                                 
                                    
                                       (
                                       
                                          e
                                          i
                                       
                                       )
                                    
                                    t
                                 
                                 )
                              
                              ≥
                              
                                 r
                                 S
                                 
                                    (
                                    t
                                    )
                                 
                              
                           
                        , then (ei
                        )
                           t
                         will stay in its current timetable Xt
                        , otherwise it will be removed. By Selection, an exam (ei
                        )
                           t
                         with larger f((ei
                        )
                           t
                        ) value has a higher probability to survive. On the other hand, the Mutation operator follows to mutate the retained exams, i.e. randomly discarding them from the partial timetable at a small rate 
                           
                              p
                              M
                              
                                 (
                                 t
                                 )
                              
                           
                         to help a quicker convergence. Another random number 
                           
                              r
                              M
                              
                                 (
                                 t
                                 )
                              
                           
                         is generated. If 
                           
                              
                                 p
                                 M
                                 
                                    (
                                    t
                                    )
                                 
                              
                              ≥
                              
                                 r
                                 M
                                 
                                    (
                                    t
                                    )
                                 
                              
                           
                        , then (ei
                        )
                           t
                         will stay in its current timetable Xt
                        , otherwise it will be removed.

The Stochastic Recreate phase rebuilds a partial timetable by assigning unscheduled exams to their available timeslots. For a specific exam waiting for rescheduling, the following two steps are executed: Step 1 finds all its available timeslots without any conflict exams; Step 2 chooses the timeslot with the smallest increase on the overall cost defined by Equation (14).

One of the basic construction approaches is to construct the timetable by sequentially placing exams into timeslots according to some heuristic measure of how difficult the exams are to schedule. Carter et al. (1996) used some graph colouring heuristics to achieve the task, based on the fact that a simplified timetabling problem without taking into account soft constraints can be reduced to a graph colouring problem, where vertices of the graph represent exams and edges represent the conflicts between exams (i.e. with common students). However, it should be note that the simplified graph colouring model where the goal is to minimise the number of colours is not a good model for our exam timetabling problem since the number of colours (timeslots) is fixed at the start and thus is not minimised in the problems used for the numerical results. We only use some of those simple graph colouring heuristics to determine an order in which the exams are rescheduled although many other heuristics can also be applied.

Here we use the following four graph colouring heuristics: Largest Degree first (LD), Largest Weighted Degree first (LWD), Largest Colour Degree first (LCD) and Least Saturation Degree first (LSD). Let p
                        
                           i1, p
                        
                           i2, p
                        
                           i3 and p
                        
                           i4 be the probabilities of using heuristics LD, LWD, LCD and LSD to reschedule exam ei
                        , respectively. These heuristics are alternatively used in each step of construction process, satisfying 
                           
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 4
                              
                              
                                 p
                                 
                                    i
                                    j
                                 
                              
                              =
                              1
                           
                        .

The LD heuristic orders exams in a descending order by the number of conflicts they have with other exams. It schedules first the exams which have the most conflicts in the following way: going through the pre-calculated conflict values for the unscheduled exams and then proceeding to Steps 1 and 2 mentioned above.

The LWD heuristic orders exams in a descending order by the number of conflicts, each of which is weighted by the number of students involved. Among exams with the same degree, it schedules first those with a larger number of students involved. Like LD, LWD first goes through the weighted conflict values for the unscheduled exams, and then executes Steps 1 and 2.

The LCD heuristic orders exams in a descending order according to the number of conflicts with the other exams that have already been placed in the timetable. The degrees of the exams not yet scheduled are changing according to the situations encountered at each step of the solution construction. Unlike LD and LWD, the conflict value for each exam is firstly updated before an exam is scheduled. This involves the update of an ancillary matrix containing the conflict values between any pairs of an unscheduled exam and a scheduled exam. LCD then goes through the new conflict values for the unscheduled exams, and implements Steps 1 and 2.
                        
                     

The LSD heuristic orders exams in an ascending order according to the number of available timeslots without violating hard constraints. The priorities of exams to be ordered and scheduled are changing during the construction process. The number of available timeslots for each exam is firstly calculated before an exam is rescheduled. LSD then goes through the saturation degree numbers for all the unscheduled exams, and proceeds to Steps 1 and 2 as the other heuristics do.

The criterion for Solution Acceptance is not problem specific, and thus any of the strategies available in the literature (such as hill-climbing, simulated annealing, threshold acceptance, great deluge, or falling tide) can be used to determine whether the newly resulting solution by the Stochastic Recreate phase is accepted or not.

@&#EXPERIMENTAL RESULTS@&#

The most widely used benchmark problems were first presented in Carter et al. (1996) for the uncapacitated exam timetabling problem. Over the years, two versions of the datasets have circulated using the same names, which has caused some confusion in comparing results of different approaches reported in the literature (Schaerf, 1999). These datasets were renamed and the issue was discussed in Qu, Burke, & McCollum (2009a). A web site was set up to include all the different datasets with new distinct names, together with an API evaluation function (see http://www.cs.nott.ac.uk/~rxq/data.htm). The new naming conventions are used in this paper.

In these problem instances, the number of timeslots is fixed beforehand and the aim is to spread clashing exams around the timetable as much as possible. Graph density is calculated based on the conflict matrix C of the problem, where each of its entry cij
                      = 1 if exam ei
                      conflicts with exam ej
                      (i.e. having students in common), or cij
                      = 0 otherwise. It is the ratio between the number of elements of value “1” to the total number of elements in matrix C. The objective function, i.e. Equation (14), is used. The key features of these test problems are presented in Table 1, which includes the number of exams (ranged from 81 to 682), the number of students (ranged from 611 to 18,419), the number of enrollments (ranged from 5751 to 56,877), the number of available timeslots (ranged from 10 to 35) and the graph density of the problem (ranged from 0.06 to 0.42).





                     Table 2 presents the best and average results of 20 runs on the 10 benchmark problems, from the ER&SR algorithm. The programming language is C++, executing on an Intel Core 2 Duo 1.86 gigahertz machine with 2.0 gigabyte RAM under Window XP. The algorithm stops when no improvement has been made for 1000 iterations, or a maximum 50,000 iterations has been reached. Our aim with these experiments is not to beat the state-of-the-art approaches in the literature, but to present the potential of this generic methodology to be easily employed and to perform adaptively on a range of different exam timetabling problems.

Hence, we try to keep the parameter setting of the algorithm as simple as possible although an advanced setting by a systematic method for the fine tuned parameters would improve the system performance further. For the Evolutionary Ruin phase, its mutation rate 
                        
                           p
                           M
                           
                              (
                              t
                              )
                           
                        
                      is set to 0.05 for all iterations t and all instances, and its selection operator always makes comparisons with a randomly generated number 
                        
                           r
                           S
                           
                              (
                              t
                              )
                           
                        
                      which does not take into account the actual range of fitness of the components f((ei
                     )
                        t
                     ) in a current solution Xt
                     . For example, generating a 
                        
                           r
                           S
                           
                              (
                              t
                              )
                           
                        
                      of 0.59 and using this value to classify the components of Xt
                      with f((ei
                     )
                        t
                     ) values scattered between 0.10 and 0.60 is obviously inefficient as this probably removes almost all the components which means that a new solution has to be recreated nearly from scratch. For the Solution Acceptance strategy, we use a simplified version of threshold acceptance algorithm with a fixed threshold value, that is, a new solution is accepted as long as its objective value is no 1 percent worse than the current solution. Of course, better solutions may be obtained if a more sophisticated acceptance criterion (e.g. simulated annealing) is used, but we deliberately make the criterion simple as it is problem independent and thus does not reflect the real performance of the proposed ER&SR.
                  

It is worth mentioning that, unlike most local search algorithms, recycling through the previous solutions is not an issue for the ER&SR due to its ability of making large-sized solution disruption by the Evolutionary Ruin and making moves with certain randomness during the Stochastic Rebuild process. A sequence of solutions obtained under such mechanism is unlikely to be exactly the same as the previous ones.





                     Table 2 then gives the comparison results of our ER&SR algorithm with a number of Graph-based Hyper-Heuristic (GHH) algorithms which also use the same four graph colouring heuristics (i.e. LD, LWD, LCD and LSD) as the low level heuristics for solution construction. These algorithms are listed as follows:

                        
                           •
                           Multi-stage Graph-based Hyper-Heuristics (M-GHH): It uses different number of low level heuristics in two stages (Burke et al., 2007).

Graph-based Hyper-Heuristic (GHH): Tabu search is employed to search for the list of low level heuristics (Burke et al., 2007).

Steepest Descent Method (SDM): The best heuristic sequence among neighbourhoods is always selected if it is better than or the same as the current one (Qu & Burke, 2009).

Iterated Local Search (ILS): The search is re-started after a certain number of iterations of SDM (Qu & Burke, 2009).

Tabu Search (TS): The TS employed here is similar to that of GHH. The difference is that no greedy local search is further carried out on the complete solutions at each step (Qu & Burke, 2009).

Variable Neighbourhood Search (VNS): The VNS employed is an iterative process where search is re-started after a certain number of walks are made by a standard VNS (Qu & Burke, 2009).

Local Improvement upon Complete Solutions (GHH1): After a complete solution is generated by a heuristic sequence, a greedy search is implemented to make improvement (Qu & Burke, 2009).

Local Improvement during the Solution Construction (GHH2): During the solution construction by a heuristic sequence, at each step, the first event in the ordered list is scheduled into the partial solution, upon which a greedy search is implemented (Qu & Burke, 2009).

Adaptive GHH (AGH): It is similar to the GHH, but focusing on developing an adaptive approach where heuristics are dynamically hybridised during solution construction (Qu et al., 2009a).

AGH-SDM: An AGH, followed by the steepest descent method to make improvement (Qu et al., 2009a).


                     Table 2 shows that the best results of our ER&SR are generally better than the best results of any previous proposed GHH related algorithms. A comparison on the best results gives useful, albeit not conclusive, information about the general performance of the ER&SR. In terms of the relative percentage deviation, the ER&SR's result is 0.4 percent better than the best performed AGH-SDM and 9.5 percent better than the least performed TS. The times to obtain our results are ranged from less than 1 minute for small instances (e.g. Sta83) to several hours for large instances (e.g. car91 and car92), which are at the same levels of those GHH related algorithms.

To gain a better insight of the ES&SR's performance, Table 3 lists the results of the state-of-the-art approaches which include a selection of appropriate methods that generate the best results among all of the approaches in the literature. These algorithms do not use any of the four graph colouring heuristics as the low level heuristics for solution construction. They generally use another class of techniques which implement local search (such as swaps and moves) to achieve improvement from a refined initial solutions. Since the solution disruption is restricted to just one or two units, these algorithms are very quick to generate each single new solution, but in theory they should be generally easy to get stuck in local optima. A brief description of these approaches is given below:

                        
                           •
                           
                              Caramia, Dell'Olmo, and Italiano (2001). A mixture of elaborately designed local search algorithms, with the stopping criterion of executing a fixed number of iterations without improvement.


                              Gaspero and Schaerf (2001). A Tabu search, with the stopping criterion of executing 200 seconds without improvement.


                              Merlot, Boland, Hughes, and Stuckey (2002). A hybrid algorithm which uses a constraint programming for initial solution generation, 350,000 simulate annealing iterations for search and a 10 hill climbing iterations for further improvement.


                              Burke and Newall (2003). A great deluge algorithm starting from good quality initial solutions and executing 20,000,000 iterations.


                              Yang and Petrovic (2005). A case based reasoning method to select an appropriate hybridisation of great deluge metaheuristic with a sequential construction heuristic. The termination condition is running the retrieved sequential heuristic and GDA successively for 200,000,000 iterations.


                              Abdullah, Ahmadi, Burke, and Dror (2007a). An Ahuja-Orlin's large neighbourhood search approach, with a fixed running time of 12 hours for each instance.


                              Burke, Eckersley, McCollum, Petrovic, and Qu (2010a). Descent-ascent biased variable neighbourhood search, whose stopping condition is 2500 iterations without improvement.

One may observe from Tables 2 and 3 that, at least for the exam timetabling problems, results by the class of hyper-heuristic (i.e. GHH relative algorithms) and the ER&SR which use a set of graph colouring heuristics for solution construction are generally worse than those by the class of local search algorithms. This is not a surprise due to the computational complexity of these low level heuristics (Li, Burke, & Qu, 2011a). Let m be the number of exams, n be the number of available timeslots, and α be the graph density of the problem. Both heuristic LD and heuristic LWD have computational complexity of O(m
                     2
                     n) to construct a complete solution, For heuristic LCD, its complexity is O(αm
                     3 + m
                     2
                     n). For heuristic LSD, empirical studies have shown that it performs the best among all the graph colouring heuristics. However, as a cost its complexity is as high as O(αm
                     3
                     n + m2n) which means constructing a solution by this heuristic is likely to be thousands times slower than a simple swap/move heuristic used for local search.

To see how far one can achieve with the ES&SR, further tests are done with a simple local search embedded. That is, for every resulting solution by the ES&SR, each exam assigned to timeslot i is assigned to timeslot j, followed by swaps of timeslots between any pairs of two exams. The move will be accepted if the solution is improved. The best solution obtained in such a way for all exams will be used as the input for the next iteration of the ER&SR search. For 3 larger instances of car91, car92 and kfu93, the best solutions are improved by 4.0 percent, 5.9 percent and 1.1 percent, respectively. However, the improvements for the remaining 7 smaller instances are not obvious even if a much longer time is allowed. The above results support our motivation of developing the ER&SR, which is indeed something flexibly standing in between the construction method and the local search method. To maximise the system performance, more sophisticated design and parameter setting at each step of its implementation are still required.

In this paper, we present an improved version of the R&R algorithm, by incorporating two additional operators of Selection and Mutation into its Evolutionary Ruin phase. In our proposed ER&SR, a cycle of Solution Decomposition, Evolutionary Ruin, Stochastic Recreate and Solution Acceptance is executed until a pre-defined stopping condition is reached. The approach can be applied to any combinatorial problems (especially the ones with many constraints) as long as we have some knowledge about what makes a solution good or not before/during the solution building process. We may then transfer the knowledge to specific rules to evaluate the quality of individual components which is the key to make the algorithm work.

Taken as a whole, the ER&SR implements evolution within single solutions and carries out iterative search by component evaluation, solution perturbation and stochastic reconstruction. The ER&SR has some similarity to the Iterated Greedy or the Greedy Randomized Adaptive Procedures (GRASP) as these algorithms all consist of constructive and perturbation steps. However, there is a significant difference in terms of working principal of the algorithms especially on the perturbation step. For the Iterative Greedy, perturbation is achieved by eliminating some solution components at random (Ruiz & Stützle, 2007), not in an evolutionary way as proposed in our ER&SR. For the GRASP originally presented in Feo and Resende (1995), perturbation does not happen on the components of a current solution as its constructive step always builds a new solution from scratch. Rather, at each decision point of its constructive step, perturbation happens on its Restricted Candidate List (RCL) containing a number of best components, from which just one component is selected to join the current partial solution. For the later extension called Reactive GRASP (Prais & Ribeiro, 1998) in which the RCL length parameter α is automatically adjusted during the search, an advanced perturbation is designed but still on the determination of which candidate component should be added to the RCL. The GRASP can certainly be extended to build new solutions from partial solutions, but as far as we are aware, there has been no/little attempt to do perturbation on the components of a current solution in a systematic way as proposed in our ER&SR. To some extent, our ER&SR can be deemed as a type of Reactive Search procedure (Batiti & Brunato, 2007), if the Selection operator compares each of the component fitness values with a random number generated in between the minimum and maximum of all the component fitness values for a current solution.

Experimental results on 10 exam timetabling benchmark problems have demonstrated the strength of the proposed approach. Our results are presented in terms of the uncapacitated problem. In fact, exam timetabling instances in the real world are mostly capacitated, that is, with an additional hard constraint on classroom capacity for the total number of students in each timeslot. Some comparative results on capacitated instances are reported in Abdullah, Ahmadi, Burke, Dror, and McCollum (2007b) although they are not as extensively tested as the uncapacitated instances. Our initial observation is that the ER&SR should be able to address the capacitated problem by using the same graph colouring heuristics but with a different evaluation function on the solution feasibility. However, to achieve a better efficiency and effectiveness, search by new low-level heuristics with some elements of focusing on the issue of room capacity should be in parallel with the search by the current graph colouring heuristics. We will do further work to investigate this.

To gain a deeper insight on the ER&SR's working mechanism, we present its state transition based probabilistic model and implement a Markov chain analysis on a simplified version of the algorithm, in which Stochastic Recreate allows probabilistic moves towards all possible destination states according to the objective function values of the neighbouring solutions. We study the ER&SR's convergence behaviour and confirmed that, without keeping the best solution found over time, the ER&SR can reach the global optimum after a finite number of steps with probability one, the algorithm however does not converge to the global optimum. In addition, we study the property of the stationary probability distribution on individual states, and suggest that, if properly implementing the ER&SR algorithm, the optimal solution of the problem still may have a good chance to be found even if the best solution is not kept. As the principal novelty of the theoretical framework, our Markov chain model is based on state transitions within the space of partial assignments, and thus is significantly different from the models used for genetic algorithms and local search (e.g. simulated annealing) which are all based on state transitions within the space of complete assignments.

The SE&RE approach may be regarded as a general framework, in which many well-known search methods belong to its special case. For example, assume at each iteration x components are removed from an m-component solution. We have the following:

                        
                           •
                           If x = 0, then it is a non-iterative method as only one single solution will be generated;

If x ≤ 3, then it is a local search method that uses small moves to change the configurations;

If x = m, then it is a constructive method with randomised starting points;

If (no Solution Decomposition) & (no Selection), then it equals to the R&R principle;

If (no Selection) & (no Mutation) & (Stochastic Recreate at specific orders), then it equals to the squeaky wheel optimisation.

The architecture of the ER&SR algorithm is innovative, and thus there is still some room for further improvement. With regard to the Solution Decomposition phase, we will study the formulation of domain knowledge for different types of other problems and the influence of different evaluation rules. With regard to the Evolutionary Ruin phase, we will study the suitable range for the number of components to be destroyed and the condition on which to make a large move or a small move. With regard to the Stochastic Recreate phase, apart from applying a more advanced algorithm like GRASP, we will study the types of reconstruction methods that are unsuited for generating optimal or near-optimal results. Furthermore, we will evaluate the ES&SR with different implementations (or parameter settings) of its four phases and study what the best combination is.




@&#ACKNOWLEDGMENT@&#

The work was supported by Engineering and Physical Sciences Research Council (under grant EP/J017515/1), Ningbo Natural Science Foundation (under grant 2012A610026) and Natural Science Foundation of China (under grants 70971044 and 71171087).

@&#REFERENCES@&#

