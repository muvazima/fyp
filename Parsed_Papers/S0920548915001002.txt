@&#MAIN-TITLE@&#A real-time feedback scheduler for environmental energy with discrete voltage/frequency modes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We address the problem of real-time scheduling inherent to energy harvesting real-time systems.


                        
                        
                           
                           We propose a feedback scheduler for energy harvesting systems (FS-EH) in a soft real-time context on a DVFS processor.


                        
                        
                           
                           This solution computes the CPU speed with taking into account the energy levels and the executions time variability.


                        
                        
                           
                           The proposed approach shows experimentally a good compromise between the available energy and the processor workload.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Embedded real-time systems

Scheduling algorithms

Feedback scheduling

Energy harvesting

Dynamic Voltage Frequency Selection

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

Because of their constraints in terms of computational power, and thereafter for their energy consumption, today's embedded systems (e.g. wireless sensors) see the availability of their services limited by the amount of energy available in the batteries over time. An efficient energy management is needed to conserve and optimize energy consumption through scheduling methods. Although these methods are proposed for reducing the system energy dissipation, any embedded system will eventually exhaust the battery. In this case and before the device can continue functioning, replacing or recharging the battery is required. However, in some applications, replacing battery is either costly or impractical. One of such applications is the wireless sensor network. The sensor nodes are deployed in a wide area for surveillance. The deployment of these sensor contributes the majority of the cost for building the networked sensor nodes. Hence, ideally such a system should be designed to achieve perpetual functioning without replacing or recharging batteries. To overcome limitations due to the batteries life, the alternative energy sources present in our environment could be exploited to achieve a perpetual operating of these systems: this is energy harvesting.

In this paper, we propose an environmental energy aware feedback scheduler for energy harvesting real-time embedded systems. The objective is to set a technique for optimizing the Quality of Control (QoC), according to the Earliest Deadline First (EDF) [1] scheduling policy, while preventing any energy shortage that would result in the destabilization of the controlled process. We are interested in QoC, in soft real-time applications, which is different from the problem of meeting deadlines (matching to the so called hard real-time applications). Our solution takes into account the available energy, the variability of actual execution times and the actual processor needs.

In earlier work, as later described in the related works section, the energy harvesting scheduling techniques consider the Worst-Case Execution Time (WCET). As a consequence, the solutions lead to use the energy reservoir (battery) in an approximate manner (over-estimation of the energy requirements) so that task deadlines be met. In addition, the solutions presented in those works do not take into account the variability of actual execution times. Jobs of the same periodic tasks have unknown execution times until the job completes [2]. The contribution and singularity of our work lie in this new central working hypothesis.

The rest of the paper is organized as follows. We give background materials in Section 2. Related works are described in Section 3. In Section 4, we present the computing model, then we give the discrete and continuous energy consumption models. We also present the energy source model which is used to supplement the battery. We discuss our contribution concerning the real-time feedback scheduling under energy harvesting with discrete voltage/frequency modes in Section 5. Performance results are included and discussed in Section 6. The main conclusions and some future directions are highlighted in Section 7.

Real-time systems (RTS) are defined as those systems in which correctness depends not only on the correct result, but they must also consider time constraints, mainly deadlines, to deliver this result. Those systems are classified as hard, soft, or firm systems, depending on the degree of missed deadlines that the system can tolerate. In hard RTS, any deadline violation may lead to a system failure and a catastrophic consequence. In soft RTS, some deadline violations are allowed but they may lead to a system performance degradation without inducing serious consequences. When a system has periodic soft tasks, in which the many consecutive losses instances need to be explicitly specified, it is characterized as a firm RTS. Our work focuses on soft real-time control tasks i.e. tasks that may miss deadlines from time to time (in contrast to the so called hard real-time tasks).

We use the scheduling theory in order to check temporal constraints. The EDF algorithm [1] is probably the most known fixed-job priority assignment scheduler in real-time systems. It is optimal regarding schedulability in the context of independent tasks and preemptive uniprocessor scheduling [3]. In most known EDF implementation, job priority is proportional to its urgency (absolute deadline): the shorter the absolute deadline, the higher the priority. Nevertheless, our aim in using EDF is to improve the QoC.

A feedback scheduling system (FBS), used in soft real-time applications, start with a schedule based on the nominal assumptions of the tasks (start time, WCET and deadline). Then, the FBS monitors the actual performance of the scheduler, compares it to the system requirements and detects differences. The system call control functions to assess the impact of these differences and apply a correction to keep the system within an acceptable range of performance.

The underlying idea of feedback scheduling is that for tasks integrating a control loop, meeting the deadlines does not necessarily imply achieving the best quality of the process control since practical control applications are usually designed with the capability of tolerating some deadline misses [4,5]. An example is the control of an inverted pendulum: task periodically calculates the next action to perform to keep the pendulum in the position of stable equilibrium. It can be tolerated if some samples (deadlines) of this task were missed (the pendulum remains in equilibrium position, but with more vibration) but if several consecutive instances of this task miss their deadlines, the pendulum will fall. This paper focuses on soft real-time control tasks.

The conventional power management techniques are classified into two categories based on the nature of energy dissipation reduction [3]. One of them is Dynamic Power Management (DPM). It aims to reduce the static energy dissipation by switching the active component to the low power state or shutting down the idle components. The other technique is Dynamic Voltage and Frequency Selection (DVFS) which aims to reduce the dynamic energy dissipation by lowering the operating frequency of the processor. In our work, we consider the DVFS capabilities.

@&#RELATED WORK@&#

As known in the literature of real-time scheduling, the algorithms proposed after the seminal paper of [1] that introduced Rate Monotonic (RM) and Earliest Deadline First (EDF), are built on precisely known and fixed timing constraints and depend on workload to provide performance guarantees in predictable environments. Nevertheless, the Worst-Case Execution Time (WCET) which is taken into account in the task models and in schedulability analysis is the upper bound of a highly volatile parameter [2]. Additionally, these scheduling algorithms may perform poorly when the environmental conditions may change (e.g. variation in task's actual execution times) since they do not have feedback mechanisms in order to take into account the unpredictability [6]. In order to overcome both limitations previously cited, the feedback scheduling (FBS) [4,7], offers a promising approach to flexible resource management in dynamic environments (i.e., task actual execution times are not fixed and unknown until the task completes) with variable CPU workload. In this case, a resource manager (FBS task) is inserted upstream of a conventional scheduler to exploit feedback. In this case, significant efforts have been made on feedback scheduling of control systems [5,8,9]. An integrated feedback scheduler, based on codesign of control and scheduling, is developed in [10] to enable flexible QoC management in dynamic environments.

Several authors have treated the problem of power and scheduling, with the objective of reducing energy consumption under timing constraints [11–14]. Nevertheless, these solutions assume that the voltage/frequency of the CPU can be adjusted continuously. Considering the discrete case, a solution has recently been proposed in [15]. The authors use elastic scheduling with limited number of voltage/frequency operating modes. However, this solution is not adapted to the dynamic environment, does not consider the energy harvesting, overestimates the required resources and overuses the batteries since they are based on the WCET.

Other works combine feedback control methods (to take into account the effective task duration) and DVFS strategy in order to minimize power. For instance, the popular PID (Proportional-Integral-Derivative) control has been integrated into several DVFS algorithms [16]. Solutions for integrated optimization of sampling periods and CPU speed have been presented in [17,18]. However, these algorithms have been used without considering energy harvesting capabilities and most consider a fixed WCET parameter in their solutions.

Taking into account the harvesting energy, Moser et al. proposed LSA (Lazy Scheduling Algorithm) [19] to optimally schedule tasks with deadlines and battery usage. However, it needs an exponential complexity for periodic task sets, as well as a high complexity for some kinds of complex energy harvesting curves [20]. In our work, we are concerned with the DVFS technique that we apply in the so-called real-time energy harvesting systems. Closely related to our work, Liu et al. [21] proposed a DVFS algorithm (called EA-DVFS) to enhance the performance of LSA. EA-DVFS adjusts the processor behavior according to the stored energy and the energy prediction (harvested energy in future). Particularly, if the system has a sufficient amount of energy, the tasks are executed at full speed; otherwise, the processor slows down to save energy. However, EA-DVFS is based on WCET and considers one task at a time instead of considering all tasks together. In addition, since the EA-DVFS algorithm uses the energy prediction, it schedules the task at full speed if there may be just as little as 1% energy left in the energy storage while the system can operate at full speed for a task without depleting the energy [22]. That is not the desired behavior. Let us mention that in [21], tasks are assumed to execute at full speed if the system has sufficient energy which causes rapid discharge of the battery and induces changes in processor frequency. Such approach needs to be provided with a highly predictive model which necessarily has high computation complexity and memory requirement. This may be a serious problem for embedded systems with small memory space. In addition, the solutions proposed assume negligible overhead due to processor voltage and frequency switching. In a previous work [23], we have proposed a real-time feedback scheduler algorithm (noted EDfbs-eg) for environmental energy harvesting, in which we assume that the processor speed can be adjusted continuously and in which we did not take into account the available energy when the processor speed is selected. Nevertheless, the proposed algorithm needs rapid changes in processor speeds and induces missed deadlines which affects the QoC (quality-of-control).

To summarize, we think that the models presented in the literature are not realistic since the related work considers continuous frequency change, zero cost switch overhead or tasks executed using their full WCET.

In this paper, we consider that the system is powered by rechargeable battery and it evolves in a dynamic environment in which the tasks parameters (mainly their execution times) are not fixed. Within these assumptions, we aim to propose, under discrete voltage/frequency modes, a heuristic in order to take into account the CPU load and the available energy to select a discrete frequency.

This section describes the computing model, energy source and consumption model which will be used throughout the remainder of this paper.

Assume that the CPU has M discrete operating frequencies f
                        
                           m
                        
                        :{f
                        
                           m
                        |1≤
                        m
                        ≤
                        M,
                        f
                        
                           min
                        
                        =
                        f
                        1
                        <
                        f
                        2
                        <…<
                        f
                        
                           M
                        
                        =
                        f
                        
                           max
                        }. We define the scaling factor (processor speed) Sm
                         as the normalized frequency of fm
                         compared to the maximum frequency fmax
                        , that is:
                           
                              (1)
                              
                                 
                                    S
                                    m
                                 
                                 =
                                 
                                    
                                       f
                                       m
                                    
                                    
                                       f
                                       max
                                    
                                 
                                 .
                              
                           
                        Consider a dynamic voltage and frequency selection (DVFS) processor on which run, concurrently, a set of N independent control tasks Γ={τ
                        
                           i
                        |1≤
                        i
                        ≤
                        N} which do not communicate, or share resources and never suspend themselves. Each task is responsible for controlling an independent physical process. The DVFS aims at the dynamic adaptation of processor voltage and thus, its frequency, to the current needs of the application in terms of performance.

The classical timing parameters [1] of each control task τ
                        
                           i
                         are described as follows:
                           
                              •
                              
                                 WCET
                                 
                                    i,1 is the Worst-Case Execution Time of every job of τ
                                 
                                    i
                                  at full processor speed. On a S-processor speed (i.e., S is a scaling factor); we make the assumption for simplification, that WCET
                                 
                                    i,S
                                 
                                 =
                                 WCET
                                 
                                    i,1
                                 /
                                 S.


                                 Ti
                                  the release period of the task τ
                                 
                                    i
                                 : every subsequent job τ
                                 
                                    i,k
                                  is released at the date r
                                 
                                    i,k
                                 
                                 =(k
                                 −1)×
                                 T
                                 
                                    i
                                 , k
                                 >0. By default, we consider a soft implicit deadline;

We will assume the FBS to be executed periodically. For the FBS part, we use, like in [5], the following notations:
                           
                              •
                              
                                 C
                                 
                                    i,1 estimated execution time at full CPU speed;


                                 C
                                 
                                    i,S
                                  actual estimated execution time of the task τ
                                 
                                    i
                                  when the CPU speed is scaled by S. C
                                 
                                    i,S
                                 
                                 =
                                 C
                                 
                                    i,1
                                 /
                                 S;


                                 ci
                                  actual execution time of the job τ
                                 
                                    i,k
                                  at actual CPU speed;

In the sequel, we use the term “actual” to designate a measured quantity (typically the execution time at the end of a job), and the term “estimated” is used to denote a predicted value based on an historical function (e.g. Eq. (6)).

A wide range of commercial processors supports variable voltage and frequency levels which are tightly coupled. A processor is an integrated circuit of the CMOS family, wherein dissipation dynamic power is the dominant component of power consumption due to switching [24]. The dynamic power is given as:
                           
                              (2)
                              
                                 P
                                 =
                                 C
                                 ×
                                 
                                    v
                                    2
                                 
                                 ×
                                 f
                              
                           
                        where C denotes the effective switch capacitance related to the processor type, v is the voltage and f is the frequency.

For M discrete operating frequencies and in order to approximate the analytical power function to the actual power, Xu et al. in [25] derived a relation to describe the power consumption as a polynomial function of the speed S as: P
                        =
                        a
                        ×
                        S
                        
                           γ
                        
                        +
                        b, where γ(γ
                        >1) reflects the convex power–frequency relationship, b denotes the system power consumption when the processor is idle (i.e., when the system is not executing any task), and a reflects the effective switching capacitance. In our study, we consider the XScale processor [26] where time and energy parameters are given in Table 1
                         
                        [25]. Several power models of XScale are cited in the literature [27,25]. We chose to use the one recently proposed by Chen et al. in [15] in which the active power function is written as:
                           
                              (3)
                              
                                 P
                                 =
                                 1543.28
                                 ×
                                 
                                    S
                                    2.87
                                 
                                 +
                                 63.58
                                 .
                              
                           
                        
                     

We can see in Fig. 1
                         that the power function passes through the points expressed in discrete mode on Table 1.

In this paper, we consider a processor with discrete modes but we want to compare discrete vs. continuous algorithms so we need a model of continuous consumption.

The energy consumption E(t
                        1,t
                        2) on a time interval [t
                        1,t
                        2] is given as: 
                           E
                           
                              
                                 
                                    t
                                    1
                                 
                                 ,
                                 
                                 
                                    t
                                    2
                                 
                              
                           
                           =
                           
                              
                                 ∫
                                 
                                    t
                                    1
                                 
                                 
                                    t
                                    2
                                 
                              
                              
                                 P
                                 
                                    
                                       S
                                       
                                          t
                                       
                                    
                                 
                                 d
                                 t
                              
                           
                        , where S(t) is the processor speed at time t.


                        Fig. 1 shows that the continuous approximation of the discrete power over frequencies fits well with the constructor chart.

We assume that the environmental energy, such as solar energy, is harvested and converted into electrical power to supplement embedded systems batteries. To model the solar energy source behavior, we use the following model [19]:
                           
                              (4)
                              
                                 P
                                 s
                                 
                                    t
                                 
                                 =
                                 
                                    
                                       0.9
                                       ×
                                       R
                                       
                                          t
                                       
                                       ×
                                       cos
                                       
                                          
                                             t
                                             
                                                0.7
                                                ×
                                                π
                                             
                                          
                                       
                                       ×
                                       cos
                                       
                                          
                                             t
                                             
                                                0.1
                                                ×
                                                π
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where R(t) denotes a uniform distributed random variable between 0 and 1. The values of Ps have been cut off at the value Ps, max
                        =0.9.

As illustrated in Fig. 2
                        , the obtained power trace Ps(t) is simulating day and night periods similar to those experienced by solar cells in an outdoor environment.

In this energy source model, the input power Ps(t) has excluded the loss incurred by the auxiliary circuitry. In other words, Ps(t) is the net power to feed the storage. The harvested energy Es(t
                        1,t
                        2,) with respect to the battery capacity by Ps(t) on a time interval [t
                        1,t
                        2,] is given as:
                           
                              (5)
                              
                                 E
                                 s
                                 
                                    
                                       
                                          t
                                          1
                                       
                                       ,
                                       
                                       
                                          t
                                          2
                                       
                                    
                                 
                                 =
                                 
                                    
                                       ∫
                                       
                                          t
                                          1
                                       
                                       
                                          t
                                          2
                                       
                                    
                                    
                                       P
                                       s
                                       
                                          t
                                       
                                       d
                                       t
                                    
                                 
                                 .
                              
                           
                        
                     

The system uses an energy storage unit that has a nominal capacity (noted E), corresponding to a maximum energy (expressed in Joule or Watts-hour). The energy level, denoted as El(t) at a given time t, has to remain between two boundaries Emin
                         and Emax
                        . If the storage is fully discharged, no task can be executed. In contrast, if the storage is fully charged, and we continue to charge it, energy is wasted. To reduce this waste and to ensure the QoC, it would be useful to perform tasks with the maximum speed of the CPU when the battery is fully charged.

This section proposes a real-time feedback scheduler. We are interested in cases where the reduction of the processor energy consumption is performed under environmental energy with discrete voltage/frequency modes. Our approach is based on the instantaneous processor utilization and the level of energy available in the battery through the use of FBS task.

We use a low-pass filter to estimate the execution time Ci
                        ,1 as proposed in [5] with a forgetting factor λ
                        ∈[0,1]. We initialize the estimator of a task as its worst case execution time (WCET):
                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             C
                                             
                                                i
                                                ,
                                                1
                                             
                                          
                                          
                                             0
                                          
                                          =
                                          WCET
                                       
                                    
                                    
                                       
                                          
                                             C
                                             
                                                i
                                                ,
                                                1
                                             
                                          
                                          
                                             k
                                          
                                          =
                                          λ
                                          ×
                                          
                                             C
                                             
                                                i
                                                ,
                                                1
                                             
                                          
                                          
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          +
                                          
                                             
                                                1
                                                −
                                                λ
                                             
                                          
                                          ×
                                          frequency
                                          
                                          adjust
                                          
                                             
                                                c
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where, index k refers to the kth
                         job of task τ
                        
                           i
                         i.e τ
                        
                           i,k
                         when parameter C
                        
                           i,1(k) is updated. In the remainder of this paper, we define 
                           
                              C
                              
                                 i
                                 ,
                                 1
                              
                           
                           
                              t
                           
                           
                              =
                              
                                 d
                                 e
                                 f
                              
                           
                           
                              C
                              
                                 i
                                 ,
                                 1
                              
                           
                           
                              k
                           
                         where the term C
                        
                           i,1(k) is equal to the latest computed value at time t according to (6). ci
                         represents the actual execution time of job τ
                        
                           i,k
                        . Function frequency adjustment(ci
                        ) will be discussed in the next section.

Let us consider a system with feedback scheduling and let us define the instantaneous processor utilization as:
                           
                              (7)
                              
                                 
                                    U
                                    inst
                                 
                                 
                                    t
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          
                                             
                                                C
                                                
                                                   i
                                                   ,
                                                   1
                                                
                                             
                                             
                                                t
                                             
                                          
                                          
                                             T
                                             i
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

We can adapt the classical offline EDF schedulability test, at the invocation of the feedback scheduler at current time t as Uinst
                        (t)≤1.

In a previous work reported in [23], the scaling factor at current time t, S(t), is given by the instantaneous utilization factor: S(t)=
                        Uinst
                        (t). However, this solution introduces deadline misses since the actual execution times ci
                         of the subsequent jobs τ
                        
                           i
                         can be higher than the estimated execution time C
                        
                           i,1(t) under speed S(t). In this situation, the system becomes overloaded and the deadline of the job will be missed. This degrades the overall QoC and the plant (combination of process, actuator and sensor) may even become unstable.

The FBS task has the highest priority (preempting any other task) and is responsible of calculating and change the CPU speed, therefore any job τ
                        
                           i,k
                         preempted by the FBS task can be performed with two or more frequencies of the processor.

Let us assume that τ
                        
                           i,k
                         starts at time a
                        1 and finishes at time bj
                         (see Fig. 3
                        ), the FBS may change the frequency several times during the execution of τ
                        
                           i,k
                        . Those changes occur between the instants b
                        1 and a
                        2, b
                        2 and a
                        3, etc. Let us denote by Si
                         the unique processor frequency in time interval [ai
                        ,bi
                        ]. The actual execution time of τ
                        
                           i,k
                         is given by:
                           
                              (8)
                              
                                 exact
                                 
                                 frequency
                                 
                                 adjust
                                 
                                    
                                       c
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       j
                                    
                                    
                                       
                                          
                                             ∫
                                             
                                                a
                                                k
                                             
                                             
                                                b
                                                k
                                             
                                          
                                          
                                             
                                                S
                                                k
                                             
                                             d
                                             t
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The use of the exactfrequencyadjust(c
                        
                           i
                        ) function requires the FBS to store the instants bk
                         in the tasks at every frequency change. However, the number of changes is unknown and could be large, which may be a problem for embedded systems with small memory space.

In order to avoid storing more than 1 value in every job τ
                        
                           i,k
                        , each job is assumed to be executed at the highest S-speed used by the processor for this job. We consider the current frequency 
                           
                              S
                              
                                 m
                                 a
                                 
                                    x
                                    i
                                 
                              
                           
                           =
                           S
                           
                              t
                           
                         at the starting time t of the task. At each execution of the FBS, the highest S-speed for each time t when a job is preempted takes the value 
                           
                              S
                              
                                 m
                                 a
                                 
                                    x
                                    i
                                 
                              
                           
                           =
                           max
                           
                              
                                 
                                    S
                                    
                                       m
                                       a
                                       
                                          x
                                          i
                                       
                                    
                                 
                                 ,
                                 
                                 S
                                 
                                    t
                                 
                              
                           
                        . We define, therefore, the actual execution time of job τ
                        
                           i,k
                        , as follows:
                           
                              (9)
                              
                                 frequency
                                 
                                 adjust
                                 
                                    
                                       c
                                       i
                                    
                                 
                                 =
                                 min
                                 
                                    
                                       
                                          c
                                          i
                                       
                                       ×
                                       
                                          S
                                          
                                             m
                                             a
                                             
                                                x
                                                i
                                             
                                          
                                       
                                       ,
                                       
                                       W
                                       C
                                       E
                                       
                                          T
                                          i
                                       
                                    
                                 
                                 .
                              
                           
                        
                        
                           Lemma 5.1
                           
                              The frequencyadjust(c
                              
                                 i
                              ) (see Eq. 
                              
                                 (9)
                              
                              ) of job τ
                              
                                 i,k
                               
                              cannot be lower than its exact actual execution time (i.e., exactfrequencyadjust(c
                              
                                 i
                              )).
                           

The 
                                 frequency
                                 
                                 adjust
                                 
                                    
                                       c
                                       i
                                    
                                 
                                 ≤
                                 
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       j
                                    
                                    
                                       
                                          
                                             ∫
                                             
                                                a
                                                k
                                             
                                             
                                                b
                                                k
                                             
                                          
                                          
                                             
                                                S
                                                
                                                   m
                                                   a
                                                   
                                                      x
                                                      i
                                                   
                                                
                                             
                                             d
                                             t
                                          
                                       
                                    
                                 
                               because 
                                 
                                    S
                                    
                                       m
                                       a
                                       
                                          x
                                          i
                                       
                                    
                                 
                                 ≥
                                 
                                    S
                                    k
                                 
                              , ∀
                              k
                              ∈1..
                              j. However WCETi
                               is the upper bound, therefore, hypothetically, frequencyadjust(c
                              
                                 i
                              )≤
                              WCET
                              
                                 i
                              .


                        Fig. 3 shows the multiple executions and preemptions of the job τ
                        
                           i,k
                        . The parameter Si
                         denotes the unique processor frequency with which the job τ
                        
                           i,k
                         is executed in time interval [ai
                        ,bi
                        ].

The framework of the proposed scheme is shown in Fig. 4
                        . The considered system consists of a computing element, a set of control tasks, an energy source, an energy storage unit (battery) which includes an energy harvesting unit and by the independent physical processes (plants) controlled by the control tasks.

Aside from the control loops, an outer feedback loop is introduced to implement feedback scheduling. The basic role of the feedback scheduler is to use the amount of available energy and the estimated utilization (see Eq. (7)) as the feedback information in order to compute a discrete frequency for the processor.

The objective of our work is to propose a heuristic noted FS-EH (Feedback Scheduler for Energy Harvesting) (see Algorithm 1). This solution enables us to execute tasks with maximum processor speed if the amount of available energy is greater than a threshold (set offline). This is to reduce the chance of missing deadlines, thus improving QoC. If the available energy is below this threshold, the discrete processor speed in return is proportionally to the available energy and to the instantaneous processor utilization. First, this is to favor battery charge. Second, to reduce the chance of missing deadlines, since the proportion available energy can be often greater than the processor load. Assuming El(t) the quantity of available energy at time t, we consider L(L
                        ≤
                        E) the threshold energy level. The discrete speed factor S taking into account the portion of the available energy and estimated processor utilization is given by the algorithm below:


                        
                           
                        
                     

The input–output surface of the real-time feedback scheduling with discrete modes system is depicted in Fig. 5
                         corresponding to threshold value L
                        =1.0 (Fig. 5(a)) and L
                        =2.5 (Fig. 5(b)), which describes the mapping between the inputs and the output. Our goal is to observe how the threshold impacts on the QoC. From Fig. 5, we can see that when the threshold takes the value 0.1, a small change in energy level in the battery involves a variation of the processor frequency compared to the case where the threshold is set to 2.5.

This section shows conducted simulations using TrueTime [28], a Matlab toolbox used to evaluate our proposed algorithm regarding QoC. We consider an embedded control system that consists of three independent control loops. Each plant is controlled using a PID algorithm whose parameters are well designed and remain the same as those used in [28]. The transfer function of each plant is G(s)=1000/(s
                        2
                        +
                        s). The reference input is a square waveform with a 1Hz frequency and a unit amplitude 1. We consider the set of three control tasks Γ={τ
                        
                           i
                        |1≤
                        i
                        ≤3} and τ
                        
                           i
                        
                        =(WCET
                        
                           i
                        ,
                        D
                        
                           i
                        ,
                        T
                        
                           i
                        ) with WCETi
                        
                        =3ms for each task τ
                        
                           i
                        . In our simulations, the nominal sampling periods of the three loops are set to be T1=19ms, T2=20ms, and T3=21ms, respectively. The relative deadline for each control task is considered equal to its sampling periods. The power consumption of the task τ
                        
                           i
                         under the processor speed S is given in Eq. (3). The time and energy penalties for each speed change are reported in [25] as 12μs and 1.2μJ, respectively. The processor idle power is equal to 63.58mW. We assume that the energy storage capacity is Emax
                        
                        =2.5J at t
                        =0. We have implemented in the same toolbox a power generator source which supplies a battery according to the model given in Eq. (4).

We designed two cases of simulations.
                           
                              1.
                              The first case: is designed to show the comparison between the proposed FS-EH algorithm with EA-DVFS algorithm proposed in [21], under the assumption that every job of τ
                                 
                                    i
                                  is executed with its Worst-Case Execution Time (WCET). We note that under EA-DVFS the tasks are executed at full speed if there is sufficient available energy; otherwise, the processor slows down to save energy. For this, EA-DVFS calculates and compares two parameters s
                                 1 and s
                                 2. If s
                                 1 and s
                                 2 are equal, it is assumed that there is sufficient available energy in the system, and the task is executed at the full speed. Otherwise, the available energy is considered to be nearly depleted; so the task is executed at power Pi
                                  and frequency fi
                                  between s
                                 1 and s
                                 2; the task is executed at the full speed after s
                                 2 if the task has not been finished. We conclude that EA-DVFS slows down the processor only if the available energy is considered to be nearly depleted. However, FS-EH slows down the processor if the available energy is below the threshold.

The second case: is designed to compare the proposed feedback scheduling algorithm (FS-EH) to the EDFbs-eg proposed in [23] in which the scaling factor S takes a value S
                                 =
                                 Uinst
                                 (t) at each execution of the FBS task. In this case, we assume that the execution times are not fixed and unknown until the task completes. For this, we have implemented a random task execution time generator according to a Weibull law given below in Eq. (10), with k
                                 =3, β=0.0015, and R a uniformly distributed random variable between 0 and 1. We choose these parameters so that the max of ci
                                  is less or equal to the WCETi
                                 .

The goal of this generator is to simulate a typical distribution (see Fig. 6
                        ) of actual execution times which is close to the distribution given in [2].

For the FBS part, we choose a forgetting factor λ
                        =0.9 (see Eq. (6)) and the FBS task period is equal to 200
                        ms. The duration of each experiment is equal to 50
                        s.

@&#RESULTS AND DISCUSSIONS@&#

According to the specifications listed above, we evaluate the performance of the proposed FS-EH algorithm based on simulation. In the first time, we show the effect of the choice of the threshold values on the average and minimum energy available under FS-EH algorithm when tasks execute with its WCET and its actual execution time. In the second time, we compare between FS-EH, EA-DVFS and EDFbs-eg algorithms according to the two case given above in terms of the energy consumption, the processor speed and quality-of-control.

We chose 25 different values for the threshold L from 0.1 to 2.5 (battery nominal capacity). Fig. 7(a) shows the average and the minimum energy available under different threshold value when FS-EH is used considering that the tasks use their whole WCET. Since the processor is set at maximal frequency when the battery level is higher than the threshold, the higher the threshold, the higher the average and minimum battery level. These values are linearly increasing with the threshold, except when the minimum energy is zero. Indeed, in this case, the system, at some point, could not be executed at all, therefore some battery is saved, but the controlled plants are not controlled.

Comparatively, the case where FS-EH is used with the actual execution times of tasks (rather than their WCET) implies a higher battery utilization. We can see in Fig. 7(b) that when the threshold takes values less than 0.4, the minimum energy available is equal to 0 and the experiment stops because of the total discharge of the battery. We can see also, that from 0.4 to 2.5 (maximum battery capacity), the increase in average and minimum energy available becomes linear to the augmentation of threshold. In the sequel, we give the results obtained when the threshold takes values greater than or equal to 0.4.

In this subsection, we present the comparison between FS-EH with EA-DVFS algorithms under the assumption that every job of τ
                        
                           i
                         is executed with its Worst-Case Execution Time (WCET). This comparison relates to energy consumption and changes in processor speed with each algorithms


                           Fig. 8(a) and (b) show the energy available with FS-EH and EA-DVFS. We can see that FS-EH protects against a total discharge of the battery where the minimum energy available is equal to Emin
                           
                           =0.013J with threshold L
                           =0.1 and Emin
                           
                           =1.48J with L
                           =25. According to these results (green curve on Fig. 8(a)), we can see that when the threshold equals the battery capacity, meaning the frequency is adjusted only considering the processor utilization, FS-EH provides a high level of available energy in the steady state of the system (around 1.5J). On the contrary, when the processor is set at full frequency unless battery is not higher than 0.1J, the available energy tends to zero but is not zero (blue curve on Fig. 8(a)). Comparatively, EA-DVFS discharges the battery after t
                           =13.73
                           s (see Fig. 8(b)), causing the execution of the system to stop, and the controlled plants to diverge. These results indicate that power consumption is greatly reduced by FS-EH, even when on the experiments we consider the tasks to use their whole WCET.

We present now the simulations results showing the variation of the processor frequencies (i.e the scaling factor) under FS-EH and EA-DVFS. We note that there is an overhead in time and energy for every frequency change (see Table 1). As observed in Fig. 9
                           , the processor running with the maximum frequency (S
                           =1) before t
                           =8.07. After this time, the processor speed is changing rapidly between S
                           =0.15 and S
                           =1. We note that the simulation stops at t
                           =13.73 due to the discharge of the battery which causes the destabilization of controlled processes. We explain the cause of discharge of the battery by the fact that the EA-DVFS algorithm schedules the task at full speed if there may be just as little as 1% energy left in the energy storage unit [29]. So EA-DVFS slows down the processor only if the available energy is considered to be nearly depleted which is not the desired behavior. Comparatively, we can see in Fig. 10(a) and (b) that under FS-EH, the simulation never stops. We can see also in Fig. 10(a) that the processor speed is changing between S
                           =0.6 and S
                           =0.8 when threshold L
                           =0.11 which favors the battery charge. When the threshold takes value equal to L
                           =0.1, the processor speed is changing between S
                           =1 and S
                           =0.6 as shown in Fig. 10(b). We note also that under EA-DVFS the rate of missed deadlines is equal to 5.6% while it is equal to 0% on these simulations for FS-EH.

In this section, we compare FS-EH to EDFbs-eg: these two scheduling algorithms make use of the actual execution time of the tasks in order to account for the overestimation of the WCET compared to the average execution time.


                           Fig. 11(a) and (b) show the energy consumption respectively under FS-EH and EDFbs-eg. Results show that the average (resp. minimum) energy available is equal to Eaverg
                           
                           =0.34J (resp. Emin
                           
                           =0.002J) with threshold value equal to L
                           =0.4 and equal to Eaverg
                           
                           =1.42J (resp. Emin
                           
                           =1.2J) with L
                           =2.5. We note that EDFbs-eg exhibits the lowest energy consumption where the average energy available is equal to Eaverg
                           
                           =2.38J, while the minimum energy available is equal to Emin
                           
                           =2.01J. However, EDFbs-eg induces more missed deadlines where the rate is equal to 0.18% which is equal to 0% under FS-EH knowing that the important real-time system performance metric is the deadline miss rate [22].

In this subsection, we present simulations results showing the processor frequency variation under FS-EH and EDFbs-eg. Fig. 12
                            shows that when EDFbs-eg algorithm is used, the processor frequency is changing rapidly. However, EDFbs-eg induces a higher deadline miss ratio, with a rate of 0.18%, than FS-EH which is achieving 0% of deadline miss ratio.


                           Fig. 13(a) and (b) shows the selected scaling factor with the chosen values of threshold L
                           =0.4 and L
                           =2.5 respectively. We note that the choice of a value for the threshold near the capacity battery (L
                           =2.5) generates less frequency changes (see Fig. 11(a)). This gives good results in terms of the average and minimum energy available and of the rate of missed deadlines which is equal to 0%.

From a control standpoint, the error between the reference signal and the measured signal should mirror how good is the control strategy. If we include a decay constraint on the error we impose by the same way a relative degree of stability. It is more appropriate to impose an exponential decay on the error by forcing the absolute value of the error to lie inside an envelope limited by a function of the form k
                           0
                           e
                           −
                              αt
                           , where the parameters k
                           0 and α have to be chosen appropriately. k
                           0 and α define the desired relative stability degree.

In our setting, we have 3 closed loop systems. Each closed loop is monitored by a square reference signal whose period is 2
                           T. The half period T is chosen around 1.5 the maximum settling time of the three closed loop systems. This choice allows that each loop will attain its steady state if the controller plays its assigned role. The reference signal is run during Nr
                            periods.

To appropriately measure the QoC, we define the cost error:
                              
                                 (11)
                                 
                                    
                                       I
                                       
                                          s
                                          y
                                          s
                                       
                                    
                                    
                                       
                                          i
                                          ,
                                          
                                          k
                                       
                                    
                                    =
                                    
                                       
                                          ∫
                                          
                                             
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             T
                                          
                                          
                                             k
                                             T
                                          
                                       
                                       
                                          
                                             I
                                             
                                                i
                                                ,
                                                
                                                k
                                             
                                          
                                          
                                             t
                                          
                                          d
                                          t
                                       
                                    
                                 
                              
                           with
                              
                                 (12)
                                 
                                    
                                       I
                                       
                                          i
                                          ,
                                          
                                          k
                                       
                                    
                                    
                                       t
                                    
                                    =
                                    s
                                    up
                                    
                                       
                                          0
                                          ;
                                          
                                          
                                             e
                                             
                                                i
                                                ,
                                                
                                                k
                                             
                                          
                                          
                                             t
                                          
                                          −
                                          
                                             k
                                             0
                                          
                                          
                                             e
                                             
                                                −
                                                α
                                                
                                                   
                                                      t
                                                      −
                                                      
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      T
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           for t∈[(k–1)T kT], 1≤
                           k
                           ≤2Nr
                           .

The error e
                           
                              i,j
                           (t) is defined as the absolute difference between the reference input x(t) and the ith
                            system output yi
                           (t), i.e., e
                           
                              i,
                              k
                           (t)=|x(t)−
                           y
                           
                              i
                           (t)| during the kth
                           -half period.

Note that Isys
                           (i,k) allows to measure how far is the system from an acceptable behavior. It provides enough information about system stability and system bandwidth.

For an experiment, we define the maximum cost error as
                              
                                 (13)
                                 
                                    
                                       I
                                       
                                          s
                                          y
                                          s
                                       
                                    
                                    =
                                    
                                       
                                          Max
                                          
                                             1
                                             ≤
                                             k
                                             ≤
                                             2
                                             
                                                N
                                                r
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   M
                                                   ax
                                                
                                             
                                             
                                                
                                                   1
                                                   ≤
                                                   i
                                                   ≤
                                                   3
                                                
                                             
                                          
                                          
                                          
                                             I
                                             
                                                s
                                                y
                                                s
                                             
                                          
                                          
                                             
                                                i
                                                ,
                                                
                                                k
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

In our simulation, the reference signal was run during Nr
                           
                           =50 periods. The parameters of the stability degree are k
                           0
                           =3 and α
                           =5.


                           Fig. 14
                            shows the obtained results in terms of error cost Isys
                            with respect to the threshold L. We get the best results of QoC for high values of the threshold L. From Fig. 14, notice that we obtain Isys
                           
                           =18.28 for L
                           =0.4 and Isys
                           
                           =0 for L
                           =2.5. Comparatively, with EDFbs-eg algorithm the cost error value is Isys
                           
                           =2.4585×1010. The high cost error value observed under EDFbs-eg degrades the overall QoC (quality-of-control) and the plant may even become unstable. We note that under EDFbs-eg (resp. under EA-DVFS) the rate of missed deadlines is equal to 0.18% (resp. equal to 5.6%) and 0% when FS-EH is used which gives better QoC for all simulations.

@&#CONCLUSION@&#

Environmental energy, such as solar energy, has recently been explored to supplement or even replace batteries in embedded systems. We are interested in the problem of real-time scheduling soft real-time systems executed in ambient energy harvesting systems, using a feedback scheduler. We proposed a scheduling algorithm based on a feedback scheduler for energy harvesting systems (FS-EH), that takes into account variability of actual execution times of tasks. For this, we have presented theoretical foundations concerning the solution of the execution time estimation. FS-EH sets the processor at full speed if the available energy is greater than a chosen threshold; otherwise, the processor speed is set proportionally to the available energy and to the instantaneous processor utilization, obtained using a low pass filter on the previous execution times. In order to evaluate our solution, we compared FS-EH to EA-DVFS under the assumption that every job is using its whole WCET. Then, we compared FS-EH to EDFbs-eg which is also using the actual execution of the tasks. Simulation results show that FS-EH performs better in terms of energy consumption, processor speed change overhead, quality-of-control and deadline miss rate. For the proposed FS-EH algorithm, we found that when the threshold value is equal to battery capacity, the real-time system provides less energy consumption, less frequency changes and a better quality-of-control.

In the near future, we plan to improve and test our solution on a real hardware. We also plan to take into account the control error and the available energy in order to minimize power usage and ensure greater stability of controlled systems in ambient energy harvesting systems. In order to help the designer, we intend to study the choice of the threshold for a particular application. We also intend to to study the problem of scheduling hybrid tasks (hard and soft real-time tasks) under harvesting energy constraints. The objective is to guarantee, with energy saving, the hard real-time constraints and at the same time reduce the rate of missed deadlines for the soft real-time tasks.

@&#REFERENCES@&#

