@&#MAIN-TITLE@&#A work stealing based approach for enabling scalable optimal sequence homology detection

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Comprehensive solution to scalable optimal homology detection.


                        
                        
                           
                           First implementation of suffix tree construction using distributed work stealing.


                        
                        
                           
                           Evaluation of many dynamic load balancing strategies for optimal homology detection.


                        
                        
                           
                           Parallel efficiency of 75%–100% for 2.56 M sequences on 8 K cores in 33 s.


                        
                        
                           
                           Peak rate of protein sequence alignments per second (PSAPS) of 2 M.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Homology detection

Pairwise sequence alignment

Protein family identification

Dynamic load balancing

Work stealing

Distributed task counters

Parallel suffix tree construction

@&#ABSTRACT@&#


               
               
                  Sequence homology detection is central to a number of bioinformatics applications including genome sequencing and protein family characterization. Given millions of sequences, the goal is to identify all pairs of sequences that are highly similar (or “homologous”) on the basis of alignment criteria. While there are optimal alignment algorithms to compute pairwise homology, their deployment for large-scale is currently not feasible; instead, heuristic methods are used at the expense of quality. Here, we present the design and evaluation of a parallel implementation for conducting optimal homology detection on distributed memory supercomputers. Our approach uses a combination of techniques from asynchronous load balancing (viz. work stealing, dynamic task counters), data replication, and exact-matching filters to achieve homology detection at scale. Results for 2.56 M sequences on up to 8K cores show parallel efficiencies of 
                        ∼
                        75
                        %
                        –
                        100
                        %
                     , a time-to-solution of 33 s, and a rate of 
                        ∼
                        2.0
                        
                        
                           M
                        
                      alignments per second.
               
            

@&#INTRODUCTION@&#

The field of bioinformatics and computational biology is currently experiencing a data revolution. The exciting prospect of making fundamental biological discoveries is fueling the rapid development and deployment of numerous cost-effective, high-throughput next-generation sequencing (NGS) technologies that have cropped up in a span of three to four years  [5,47,21,37,27]. Touted as next-generation sequencing, to now “3rd generation” technologies, these instruments are being aggressively adopted by large sequencing centers and small academic units alike. The result is that the DNA and protein sequence repositories are being bombarded with both raw sequence information (or “reads”) and processed sequence information (which could be in the form of DNA and amino acid/open reading frames types of data). Traditional databases such as the NCBI GenBank  [46] and UniProt  [8] are continuing to report a Moore’s law-like growth trajectory in their database sizes, roughly doubling every 18 months. In what seems to be a paradigm-shift, individual projects are now capable of generating billions of raw sequence data that need to be analyzed in the presence of already annotated sequence information. Path-breaking endeavors such as personalized genomics  [40], cancer genome atlas  [33], and the Earth Microbiome Project  [16] foretell the continued explosive growth in genomics data and discovery.

While it is clear that the field of computational life sciences is becoming a Big Data field, the algorithmic advancements essential for implementing complex data analytics at scale have lagged behind  [11,35]. With a few notable exceptions in sequence search routines  [41,29,14,34] and phylogenetic tree construction  [36], bioinformatics continues to be largely dominated by serial tools originally designed for desktop computing.

In this paper, we visit the problem of sequence homology detection—more specifically, given a set of 
                        n
                      sequences, detect all pairs of sequences that share a high degree of sequence homology as defined by a set of alignment criteria. The sequences are themselves typically short—typically a few hundred to few thousand characters in length.

Also sometimes referred to as the “all-against-all” sequence comparison model of sequence analysis, the use-case for sequence homology detection arises routinely in the context of a number of bioinformatics applications. For instance, it arises in the context of genome sequencing projects, where the goal is to reconstruct an unknown (target) genome by aligning the short DNA sequences (aka. “reads”) originally sequenced from the target genome  [13]. The expectation is for reads sequenced from the same genomic location to exhibit significant end-to-end overlap, which can be detected using sequence alignment computation. A similar use-case also arises in the context of transcriptomics studies  [49] where the goals are to identify genes, and measure their level of activity (aka. expression) under various experimental conditions. A third, emerging use-case arises in the context of functionally characterizing metagenomics communities  [19]. Here, the goal is to identify protein families  [6,45] that are represented in a newly sequenced environmental microbial community (e.g., human gut, soil, ocean). This is achieved by first performing sequence homology detection on the set of predicted protein sequences (aka. Open Reading Frames (ORFs)) obtained from the community, and subsequently identifying groups of ORFs that are highly similar to one another  [53,51].

At its core, the sequence homology detection problem involves the computation of a large number of pairwise sequence alignment (PSA) operations. A brute force computation of all 
                        
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                        
                      pairs is not only infeasible but also generally not needed as with the sequence diversity expected in most practical inputs only a small fraction of pairs tend to survive the alignment test with a high quality alignment. The key is in identifying such a subset of pairs for PSA computation, using computationally less expensive means, without missing out on valid pairs. To this end, there are several effective filtering techniques using exact matching data structures  [2,23]. Yet, even after deploying some of the most effective pair filters, several billions of PSAs remain to be computed even for modest input sizes of 
                        n
                        ≈
                        
                           
                              10
                           
                           
                              6
                           
                        
                     . The most rigorous way of computing a PSA, which is to use optimality guaranteeing dynamic programming algorithms such as Smith–Waterman  [17,31,44], is also computationally expensive—the algorithm takes 
                        O
                        
                           (
                           m
                           ×
                           n
                           )
                        
                      time for aligning two sequences of lengths 
                        m
                      and 
                        n
                      respectively. In practice, each alignment task takes up to a few milliseconds on modern day CPUs. In the interest of saving time, current methods resort to faster, albeit approximation heuristic techniques such as BLAST  [2], FASTA  [39], or USEARCH  [12]. This has been the approach in nearly all the large scale genome and metagenome projects conducted over the last 4–5 years, ever since the adoption of NGS platforms. On the other hand, several studies have shown the importance of deploying optimality-guaranteeing methods for ensuring high sensitivity (e.g.,  [38,43]). For example, a recent study of an arbitrary collection of 320 K ocean metagenomics amino acid sequences shows that a Smith–Waterman-based optimal alignment computation could detect 36% more homologous pairs than was possible using a BLAST-based run under similar parameter settings  [52]. Improving sensitivity of homology detection becomes particularly important when dealing with such environmental microbial datasets  [35] due to the sparse nature of sampling in the input.

In this paper, we evaluate the key question of feasibility of conducting a massive number of PSAs through the more rigorous optimality-guaranteeing dynamic programming methods at scale. To define feasibility, we compare the time taken to generate the data to the time taken to detect homology from it. Consider the following calculation: The Illumina/Solexa HiSeq 2500,
                           1
                        
                        
                           1
                           While there are other faster technologies, we use Illumina as a representative example.
                         which is one of the more popular sequencers today, can sequence 
                           ×
                           
                              
                                 10
                              
                              
                                 9
                              
                           
                         reads in ∼11 days  [21]. A brute-force all-against-all comparison would imply 
                           ×
                           
                              
                                 10
                              
                              
                                 18
                              
                           
                         PSAs. Whereas using an effective exact matching filter such as the suffix tree could provide 99.9% savings (based on our experiences  [52,22,24]). This would still leave 
                           ×
                           
                              
                                 10
                              
                              
                                 15
                              
                           
                         PSAs to perform. Assuming a millisecond for every PSA, this implies a total of 277 M CPU hours. To complete this scale of work in time comparable to that of data generation (11 days), we need the software to be running on 106 cores with close to 100% efficiency. This calculation yields a target of 109 PSAPS to achieve, where PSAPS is defined as the number of Pairwise Sequence Alignments Per Second.

In addition to achieving large PSAPS counts, achieving fast turn-around times (in minutes) for small- to mid-size problems also becomes important in practice. This is true for use-cases–in which a new batch of sequences needs to be aligned against an already annotated set of sequences, or in analysis involving already processed information (e.g., using open reading frames from genome assemblies to incrementally characterize protein families)–where the number of PSAs required to be performed could be small (when compared to that generated in de novo assembly) but needs to be performed multiple times due to the online/incremental nature of the application.

Some key challenges exist in the design of a scalable parallel algorithm that can meet the scale of 109 PSAPS or more. Even though the computation of individual PSAs are mutually independent, the high variance in sequence lengths and the variable rate at which those PSA tasks are identified using an exact matching filter can result in load imbalance (as will be elaborated in Section  3.3). In addition, the construction of the exact matching filter (such as the suffix tree) and the use of it to generate pairs for PSA computation on-the-fly need to be done in tandem with task processing (PSA computation), in order to reduce the memory footprint.
                           2
                        
                        
                           2
                           Note that it is not reasonable to assume that all of the generated pairs from the filter can be computed and stored prior to PSA calculations.
                        
                     

In this paper, we present the design of a scalable parallel framework that can achieve orders of magnitude higher PSAPS performance than any contemporary software. Our approach uses a combination of techniques from asynchronous load balancing (viz. work stealing and dynamic task counters), remote memory access using PGAS, data replication, and exact matching filters using the suffix tree data structure  [50] in order to achieve homology detection at scale. Several factors distinguish our method from other work: (i) We choose the all-against-all model as it finds a general applicability in most of the large-scale genome and metagenome sequencing initiatives, occupying an upstream phase in numerous sequence analysis workflows; (ii) To ensure high quality of the output, each PSA is evaluated using the optimality-guaranteeing Smith–Waterman algorithm  [44] (as opposed to the traditional use of faster sub-optimal heuristics such as BLAST); (iii) We use protein/putative open reading frame inputs from real world datasets to capture a more challenging use-case where a skewed distribution in sequence lengths can cause nonuniformity in PSA tasks; and (iv) To the best of our knowledge, this effort represents the first use of work stealing with suffix tree filters.

The key contributions are as follows: 
                           
                              1.
                              Comprehensive solution to scalable optimal homology detection at the largest reported scale of 8 K cores (previous highest was 2 K cores  [52]);

A new implementation of suffix tree construction that uses the distributed memory work stealing approach for dynamic load balancing;

Design and evaluation of different dynamic load balancing strategies–viz. work stealing, work stealing with iterators, and dynamic task counters–for scalable PSA computation;

Results demonstrating parallel efficiency of ∼75%–100% for 2.56 M sequences and core counts up to 8 K cores; our results also show that we could analyze 2.56 M sequences at 8 K cores in 33 s with a PSAPS rate of 2 M.

The paper is organized as follows: Section  2 presents the sequence homology problem in more detail and addresses the current state of computational solutions for the problem of homology detection. Section  3 presents the overall system architecture of our solution. Section  4 describes and experimentally evaluates our parallel algorithm. Key findings and future line of research are outlined in Section  5.

Let 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 s
                              
                              
                                 2
                              
                           
                         denote two sequences of lengths 
                           
                              
                                 n
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                        , respectively over a fixed input alphabet 
                           Σ
                        . For DNA, 
                           Σ
                           =
                           
                              {
                              a
                              ,
                              c
                              ,
                              g
                              ,
                              t
                              }
                           
                        . For amino acid/protein sequences, the alphabet contains one symbol for each of the 20 amino acids. Let 
                           s
                           
                              [
                              i
                              …
                              j
                              ]
                           
                         denote the substring starting at index 
                           i
                         and ending at 
                           j
                         in 
                           s
                        , and let the string indexing start at 1. The suffix 
                        
                           i
                         of string 
                           s
                         is the substring 
                           s
                           
                              [
                              i
                              …
                              
                                 |
                                 s
                                 |
                              
                              ]
                           
                        . As convenient, we will use the terms “strings” and “sequences” interchangeably.

An alignment between two sequences is an order-preserving way to map characters in one sequence to characters in the other sequence or to gap symbols. There are many models for computing alignments—the most common models are global alignment, where all characters from both sequences need to be involved, and local alignment, where the aligning portions can be restricted to a pair of substrings from the two sequences. An alignment is scored based on the number of character substitutions (matches or mismatches) and the number of characters aligned with gaps (insertions or deletions). For DNA sequences, positive scores are given to matches and negative scores to penalize gaps and mismatches. For protein/amino acid sequences, scoring is typically based on a predefined table called a “substitution matrix” which scores each possible 
                           
                              |
                              Σ
                              |
                           
                           ×
                           
                              |
                              Σ
                              |
                           
                         combination  [1]. An optimal alignment is one which maximizes the alignment score.

Computing an optimal alignment between two sequences 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 s
                              
                              
                                 2
                              
                           
                         can be achieved in 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                              
                              ×
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         time and 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                              
                              +
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         space using various dynamic programming algorithms  [31,44,20]. Faster, approximation heuristic methods such as BLAST  [2], FASTA  [39], or USEARCH  [12] are available to speedup the alignment process in near linear time, although they run the risk of producing sub-optimal alignments.

The sequence homology detection problem is as follows: Given a sequence set 
                              S
                              =
                              
                                 {
                                 
                                    
                                       s
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       s
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       s
                                    
                                    
                                       n
                                    
                                 
                                 }
                              
                           , identify all pairs of sequences that are “homologous”. There are several ways to define homology depending on the type of sequence data and the intended use-case. Since for this paper, we deal with protein/amino acid sequences, we use the following definition consistent with some of the previous works in the area  [53,51,52]: Two sequences 
                              
                                 
                                    s
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    s
                                 
                                 
                                    2
                                 
                              
                            of lengths 
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                           , respectively, are homologous if they share a local alignment whose score is at least 
                              
                                 
                                    τ
                                 
                                 
                                    1
                                 
                              
                              %
                            of the ideal score (with 
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                              
                            matches), and the alignment covers at least 
                              
                                 
                                    τ
                                 
                                 
                                    2
                                 
                              
                              %
                            of 
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                            characters. The above is assuming 
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                              
                              ≤
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                            w.l.o.g. The parameters 
                              
                                 
                                    τ
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    τ
                                 
                                 
                                    2
                                 
                              
                            are user-specified, with defaults for protein sequences set as 
                              
                                 
                                    τ
                                 
                                 
                                    1
                                 
                              
                              =
                              40
                              %
                            and 
                              
                                 
                                    τ
                                 
                                 
                                    2
                                 
                              
                              =
                              80
                              %
                              [52]. Note that for DNA sequences, these cutoffs typically tend to be higher as more similarity is expected at the nucleotide level. The lower cutoffs used in protein sequences make the homology detection process more time consuming because more pairs of sequences typically need to be evaluated. Many methods that happen to use even fast alignment heuristics such as USEARCH  [12] and CD-HIT  [26] do not even allow specifying such lower settings due to computational constraints. If one were to deploy dynamic programming methods to evaluate alignments, an optimal alignment will be computed regardless of the specified cutoff thus making the solution more generic. The key lies in scaling the number of alignments computed to the extent that evaluation of the identified pairs becomes feasible. However, to the best of our knowledge, no such parallel implementations exist. Consequently, all the genome and metagenome scale projects so far have resorted to BLAST-like heuristics to compute homology. On the other hand, several studies have shown the importance of deploying optimal alignment methods to ensure high sensitivity (e.g.,  [38,43,52]).

Let us visit here the question of what makes homology detection through optimal alignment computation challenging from a scalability point of view. An exhaustive, brute-force evaluation of all 
                              
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                              
                            pair combinations is not feasible given the large values of 
                              n
                            expected in practice (even if alignment heuristics are to be used). As a result, filters need to be used to identify only a subset of pairs for which alignment computation is likely to produce satisfactory results (as per the pre-defined cutoffs). A popular filtering data structure is that of the look-up table  [3], which is also internally used in numerous programs that are variants of BLAST and FASTA  [39,12,26,4]. While it is easy to construct and process this data structure, its use is restricted to identifying short, fixed-length exact matches between pairs of sequences. This is owing to its space complexity, which is exponential in the length of the exact match sought after—more specifically, 
                              O
                              
                                 (
                                 
                                    
                                       
                                          |
                                          Σ
                                          |
                                       
                                    
                                    
                                       k
                                    
                                 
                                 )
                              
                            where 
                              k
                            is the length of the exact match. Furthermore, a smaller value of 
                              k
                            (typically, 3 or 4 used in practice) significantly increases the number of pairwise sequence alignments (PSAs), as more pairs of sequences are likely to share a shorter exact match by random chance.

The use of suffix trees
                              3
                           
                           
                              3
                              Since we have multiple sequences as input, the appropriate data structure here is the “generalized suffix tree”, which is nothing but a unified suffix tree corresponding to all suffixes of all the input sequences; however, for convenience, we simply use the term suffix tree in this paper.
                              [50] overcomes these limitations as its space complexity is linear in the input size, and it has the ability to allow detection of arbitrarily long exact matches in constant time per matching pair  [23]. It has also demonstrated a high selectivity as a filter for identifying pairs, typically identifying less than 0.1% of the total 
                              
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                              
                            pairs for both DNA and protein sequences [52,22,24].

There are, however, some design challenges presented by the use of suffix trees. First, constructing suffix trees on massively parallel distributed memory machines is nontrivial, owing to the inherent irregularity of the underlying data access patterns [23,15,30]. Second, although the data structure has a linear space complexity, the constant of proportionality is high, typically around 40–50. Therefore, the data structure needs to be generated and stored in a distributed manner in order for scalability. Third, despite the high selectivity of pairs, the number of pairs identified could still be in several billions or more for modest sized inputs containing millions of sequences, precluding the possibility of storing them before processing them for alignment.

The algorithm presented in this paper improves on our previous efforts  [52,9] and tackles the challenges outlined above through the use of work stealing and task counters. Wu et al.  [52] use a hierarchy of master and worker processes on a compute cluster to balance the load of generating pairs from a precomputed, out-of-core sequence filter while concurrently aligning the generated pairs. They report scaling up to 2 K processors. Daily et al.  [9] were the first to apply a work stealing technique to scale sequence homology to over 100 K processors but did so by simulating an arbitrary filter which did not introduce compute overhead or load imbalance, thus their work focused primarily on the work stealing of the brute force 
                              
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                              
                            set of sequence pairs. Our work represents the first comprehensive solution to scalable optimal homology detection given an input set of sequences; nothing is computed beforehand and no portions of the pipeline are simulated. Our pipeline applies work stealing to the creation and processing of the suffix tree filter concurrently with the pair alignments. Lastly, while there are numerous solutions available for hardware acceleration of individual PSA computations on various specialized multicore platforms such as GPUs, FPGAs, etc. (reviewed in  [42]), the implementation presented in this paper does not incorporate those (future work).

In this section we explore many ways of solving the problem of optimal homology detection. We first attempt to reduce the task space using known filtering techniques. Then we propose a solution to the load balancing issue caused by using the filters in addition to the load imbalance inherent to the problem.

As noted in Section  2, exact matching filters need to be used in practice to reduce the task space from 
                           
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                           
                         PSAs. One of the most effective filters designed to date is the suffix tree filter used by  [52]; however the search for better filters is an open area of research. We describe the suffix tree filter as well as an alternative length-based filter in the following sections.

Using suffix trees to identify “promising” sequence pairs for alignment computation is detailed in  [52]. We improve upon their work by not precomputing and storing the suffix trees to disk, and instead generate the suffix tree on-the-fly and use it to identify promising pairs when different subtrees of the suffix tree become available.

To build the suffix tree in parallel, we independently construct subtrees of the suffix tree. We first partition all suffixes of the input sequences into 
                              
                                 
                                    
                                       |
                                       Σ
                                       |
                                    
                                 
                                 
                                    k
                                 
                              
                            “buckets” based on their first 
                              k
                            characters, where 
                              k
                            is a short, fixed-length parameter e.g., 5 for amino acid sequences. We represent a suffix as a 3-tuple of the sequence index, the offset from the start of the sequence, and the bucket index. The reason for the sequence index and offset are clear, however our choice of associating the bucket index with each suffix was for memory considerations as well as for ease of implementation. With respect to memory, the number of suffixes (3-tuples) depends on the size of the input sequences, whereas the number of buckets depends on 
                              
                                 
                                    
                                       |
                                       Σ
                                       |
                                    
                                 
                                 
                                    k
                                 
                              
                            which grows quickly as either 
                              k
                            or 
                              
                                 |
                                 Σ
                                 |
                              
                            becomes large. Our implementation allows for much larger 
                              k
                            than would normally be allowed given memory constraints. With respect to ease of implementation, we can store the suffixes as a contiguous array instead of using a sparse representation of the buckets. This contiguity enables easy sorting of the suffixes as well as the direct exchange of the suffixes subtrees when load balancing.

Once the buckets are constructed, by definition of the suffix tree, each such bucket contains suffixes that fall into a distinct subtree rooted at a depth of 
                              k
                            of the tree. The idea is to subsequently process all buckets in parallel so that the individual subtrees corresponding to buckets can be constructed in an independent manner. A challenge here is that the size of each bucket is not necessarily uniform as it is input dependent, and the amount of work is proportional to the number of suffixes contained in the tree. Consequently, one option is to statically partition the buckets onto each process in an attempt to balance the total number of suffixes to be handled on each process. However, this would require global knowledge as to the size of each bucket, and if 
                              
                                 
                                    
                                       |
                                       Σ
                                       |
                                    
                                 
                                 
                                    k
                                 
                              
                            is large this approach is not feasible. As an alternative, we partition the buckets based on the bucket index modulo the number of processes, then we apply work stealing to further load balance this problem. The initial static distribution of the buckets is a simple calculation. In addition, since adjacent buckets, e.g., “AAB”, “AAC” where 
                              k
                              =
                              3
                           , tend to be similar in size when they share a common prefix (here “AA”), the initial distribution keeps adjacent buckets from being stored on the same process in case their shared prefix occurs frequently. Lastly, each subtree requires a variable amount of suffixes to be present in memory, along with their corresponding sequences, before processing begins. This may increase the amount of communication in our implementation, especially when sequences are not stored locally (discussed more in detail in Section  3.2). Non-local sequences are always fetched as needed, which works well for aligning two sequences with at most two fetches, but in the case of suffix subtree processing which may require many fetches, we cache non-local sequences until the subtree processing is complete. Caches are not shared between processes and are discarded once the subtree is no longer being processed. The suffix subtrees are themselves constructed in a depth-first manner by recursively bucketing the set of suffixes at increasing node depths. We do not construct or use any auxiliary suffix tree data structures such as suffix links. A depth-first traversal of the constructed subtree generates the promising pairs similar to the algorithm of Gusfield  [18, p. 147] for generating maximal repeated pairs.

The suffix tree filter, although generally effective in terms of reducing the number of alignments to perform, takes a non-negligible time to create and process the suffix subtrees. One way to achieve further savings in the number of PSAs performed, without impacting the final output, is as follows: we can rule out pairs based upon the length of the two sequences involved in the potential alignment. As a user-supplied heuristic, if the two sequences could not possibly produce a positive optimal score because the sequences differ too greatly in length, or if one of the sequence lengths is less than the minimal length cutoff, the pair is discarded. This length-based filter calculation is in fact used by the suffix tree filter as an additional filter after it has identified a promising pair using the tree alone. We explore the merit of using the length based filter on its own in Section  4.

Using work stealing as in  [9] required the tasks to be explicitly enumerated and stored for a total of 
                              
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                              
                            tasks stored across 
                              P
                            processes. The largest dataset explored by the authors was 2.56 M sequences which resulted in approximately 3.28 trillion tasks. The tasks were stored as two 8-byte integer sequence identifiers. This could be reduced to a single 8-byte integer using a combinatorial number system of degree 2, but even so this would require nearly 24 TB of aggregate memory or at minimum nearly 800 compute nodes with 32 GB of usable memory each. This solution of computing and storing the enumerated pairs does not scale with respect to memory constraints, even if we are able to filter out pairs—eventually larger datasets will produce enough pairs to invalidate this approach.

An alternative is to dynamically generate and process the pairs using a dynamic load balancing scheme. The strategy in  [52] was to use a hierarchy of masters and workers in such a way to handle pairs being generated faster than they could be consumed. We use a similar strategy but apply it using work stealing, dynamically creating new work to be consumed as suffix trees are processed.

A significant challenge in the design of parallel homology detection is the management of the sequence data. The strategy in  [9] was to store the sequence database once per compute node rather than once per worker process. In a hybrid MPI + pthread model this is accomplished by running one MPI process per compute node to hold the sequences and then using pthreads to access the read-only sequence database. In a standard MPI model, the sequences can be stored in shared memory.

By storing the entire sequence database per compute node, the authors did not address memory constraints such that the sequences would not fit within a single compute node. This is a problem as the database sizes continue to grow faster than the amount of memory per node. Our solution to this problem relies on a PGAS model rather than a shared-nothing MPI model or a hybrid MPI + pthread model. The PGAS model provides a shared memory interface to the sequence database while transparently distributing the sequences across compute nodes.

Using the PGAS model, the aggregate memory of multiple compute nodes is available with the trade-off of having to communicate sequences that are no longer local. We reduce the chances of having non-local sequences by replicating the sequence database once per subset of nodes such that each subset of nodes has enough aggregate memory to store the complete sequence dataset. As an improvement over  [52], non-local sequences are communicated using one-sided operations rather than periodic collective communications or the alternative of using non-blocking two-sided operations which would require explicit progress. We use an efficient one-sided communication library  [48] which performs better than the one-sided primitives of the MPI-2 standard, making this a viable implementation strategy.

There is significant incidence of load imbalance throughout this problem. We look at the causes and solutions in detail next.

For the suffix tree filter, each suffix is placed in a bucket based on its first 
                              k
                            characters resulting in at most 
                              
                                 
                                    
                                       |
                                       Σ
                                       |
                                    
                                 
                                 
                                    k
                                 
                              
                            buckets. Each bucket is processed to yield a distinct subtree of the suffix tree, which is subsequently processed to generate sequence promising pairs. 
                              k
                            must be sufficiently large to create enough work to distribute. Subtree creation is linearly proportional to the sum of the length of all suffixes that constitute the subtree. Pair generation on the other hand takes time linearly proportional to the number of output pairs. Since the sizes of the buckets may not be uniform, load imbalance could occur. Further, the number of pairs generated by a tree is completely dependent on the content of the trees, which also varies (quadratic in the worst case).

The length-based filter does not directly cause load imbalance since it requires negligible computation time on its own. However, when used as part of the brute force strategy, it will reject pairs as they enqueue for computation and will ultimately alter the already imbalanced workload but in a similarly imbalanced way.


                           Fig. 1
                            shows the histogram and normalized cumulative distribution of alignment processing times for all-against-all alignment of 15,000 sequences obtained from a metagenomics sequence database  [7]. We observe from Fig. 1(a) that a significant fraction of tasks are of the order of milliseconds or lower, with a non-negligible fraction consuming well above a millisecond. The large number of tasks together with the wide disparity in the task processing times exacerbates problems associated with static load balancers due to small errors in the estimation of alignment times. The alignments include a few large tasks taking few tenths to over one second.


                           Fig. 1(b) shows the cumulative distribution of time spent in processing all tasks that can be processed under a particular time. As we anticipated, despite their counts, the smallest alignment operations consume a negligible fraction of the total processing time. On the other hand, alignment operations that can be processed in 1–100 ms consume almost 90% of the total processing time. This shows that the alignment operations critical to load balanced execution vary by up to two orders of magnitude in their processing time.

The means to load balance computations fall into three broad categories, namely static partitioning, dynamic repartitioning, and asynchronous repartitioning. In static partitioning, the work is collectively distributed among available compute resources based on available load information. Dynamic repartitioning is similar to static repartitioning; however, rather than performing once at the beginning of the computation it is performed periodically and collectively. The last strategy is to asynchronously migrate work between compute resources without exchanging information collectively. In the case of homology detection, as shown by the characteristics in Fig. 1 as well as due to the dynamic nature of suffix subtree processing and pair alignments, the best load balancing approach would also need to be dynamic and asynchronous. Examples of asynchronous load balancing include work stealing and distributed task counters.


                           Work stealing: Scalable work stealing as a general approach to asynchronous load balancing is detailed by Dinan et al.  [10] and Lifflander et al.  [28] while its application to sequence alignment is covered in  [9]. Briefly, work stealing models a shared task pool. The task can be represented by any fixed-size datatype including structures. The implementation of Dinan et al. places a portion of the task pool on each process in a double-ended queue (deque) which is split into shared and private portions. Tasks can be released from the private portion to the shared portion without locks; acquiring tasks from the shared portion to the private portion requires locking. Tasks may also create additional tasks as part of their execution; however dynamically adding tasks to the pool is done into the private portion and the process becomes lock free. When a worker runs out of tasks in both the private and shared portions of its deque, it becomes a thief. Thieves choose a random victim and attempt to steal half of their tasks, if available. A termination detection algorithm is used to end the task pool execution. The implementation of work stealing in Lifflander et al.  [28] and Daily et al.  [9] uses an MPI + pthreads execution model and an active message programming model instead of the PGAS model used by Dinan et al.; however it follows the same model of a shared task pool. The implementation requires one core per compute node be reserved as a progress thread. Even so, it was shown to scale to over 100 K cores with 75% efficiency  [9].


                           Work stealing with iterators: A special form of work stealing can be utilized when the tasks are a finite countable set and can therefore be represented as a contiguous sequence of natural numbers. Instead of implementing the task pool with one deque per worker, each worker stores a range of numbers from the task set as a 
                              
                                 [
                                 
                                    low
                                 
                                 .
                                 .
                                 
                                    high
                                 
                                 ]
                              
                            interval. Therefore, a steal operation splits the victims range in half and only transfers two integer values instead of half of a queue’s tasks. This results in both memory and communication bandwidth savings. We use a combinatorial number system of degree 2 in order to translate a non-negative index to a lexicographically ordered 2-combination which represents the two sequences to align as described by  [9,25]. We explore using work stealing iterators to improve the efficiency of work stealing for sequence alignments.


                           Distributed task counters: Work stealing iterators are a form of a distributed task counter. Many high-speed interconnects provide hardware-accelerated implementations of an atomic integer fetch-and-add instruction which can be used to implement a distributed task counter. A process requesting a new task increments the value of the counter while reading the old value. The atomicity of the instruction guarantees that each calling process reads a unique counter value. We translate the counter value into a pair of sequence IDs using the same combinatorial number system of degree 2 as with work stealing iterators. Using distributed task counters does not necessarily require one core per node to be reserved, especially on high speed interconnects. This can result in improved efficiency with respect to work stealing. Further, although less important, distributed task counters only allocate space for the counter on a single process which avoids the need to allocate portions of the task pool on each process. We explore using distributed task counters to improve the efficiency of work stealing for sequence alignments.

@&#IMPLEMENTATION@&#

Having evaluated many approaches (see Section  4), we arrived at the architecture detailed in Fig. 2
                        . The basis of our implementation relies on the work stealing model as described in 3.3.3. One thread per compute node is reserved to facilitate the transfer of tasks. Tasks are stolen only from the shared portion of a victim’s task deque and are delivered to the thief’s private portion. Computing (removing) or alternatively adding a task to the worker’s deque causes the local work to rebalance between the shared and private portions. After an all-to-all exchange of suffixes, both to statically load balance subtree work as well as to place all suffixes needed for a given subtree on a single process, the task pool is initially seeded with only all of the subtree processing (pair generation) tasks. However, as subtree tasks are processed they add pair alignment tasks to the pool, as well. The dynamic creation and stealing of tasks cause the tasks to become unordered. The input sequence database is only distributed if there is insufficient memory on a compute node. Although the system we tested had ample resources, we evaluate both the limited and unlimited memory cases.

@&#RESULTS AND DISCUSSION@&#

Here we present our performance analysis which covers our exploration of alternative load balancing strategies and sequence alignment pair filters for scalable homology detection.

Experiments were performed on the Hopper supercomputer at the National Energy Research Scientific Computing Center (NERSC)  [32]. It is a 1.28 petaflop/sec Cray XE6 consisting of 6384 compute nodes made up of 2 twelve-core AMD ‘MagnyCours’ 2.1 GHz processors and 32 GB RAM per node. Hopper’s compute nodes are connected by the Cray Gemini Network which is a custom high-bandwidth (8.3 GB/s), low-latency (
                           <
                           1
                           
                           
                              μ
                           
                           
                              s
                           
                        ) network with a topology of a 3D torus. We compiled our application using the Intel®  C++ 64 Compiler XE, version 12.1.2.273 using the flags -O3 -pthread. The MPI library is a custom version of mpich2 for Cray XE systems, version 5.4.4.

The following evaluations were performed using input datasets containing 80, 1280, 2560, and 5120 K amino acid sequences in FASTA format. The datasets were created by randomly sampling from the Sorcerer II Global Ocean Sampling dataset  [53] made available by the CAMERA  [7] data portal. The 80 K, 1280 K, 2560 K, and 5120 K datasets have total sequence character lengths of 43 M, 221 M, 390 M, and 727 M respectively and average sequence lengths of 541.7, 173.1, 152.5, and 142.2.

The benefit of the length-based filter is that it does not require global knowledge of all sequences while also taking negligible time to compute. On the other hand, being a local filter it requires examining all 
                           
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                           
                         pairs. Because we must examine all pairs we can then enumerate all pairs which allows us to use the load balancing strategies of work stealing iterators and distributed task counters in addition to the original work stealing strategy (see Section  3.3.3). Fig. 3
                         shows the strong scaling performance of work stealing all pairs, adding the length-based filter, using task counters, and adding the length-based filter (Brute, BruteLength, Counters, and CountersLength, respectively) for the 80 K dataset. The work stealing iterators approach is not shown here because it performed similarly to work stealing with tasks.

What we see in Fig. 3 is that the dynamic task counters performed better with and without the length-based filter. This is due to the work stealing approach reserving one core per compute node for communication progress. The dynamic task counters do not have that limitation. This amounts to a 6.7% increase in performance which is reasonable considering on the hopper system we are utilizing the otherwise reserved 24th core (4.2% of the available cores). There are additional modest gains in performance due to the reduced communication requirements of the dynamic task counter approach compared to the frequent stealing attempts of work stealing.

When considering the length-based filter, the wall clock savings are 20%. When we look at the number of alignments performed, the efficiency of the length-based filter is 30%. For the four approaches considered here, the scalability is nearly perfect. However, when considering the 99% filter efficiency of the suffix tree approach, the perfect scalability of the length-based filter approach is overshadowed. The length-based filter simply leaves too much work to be performed by the remaining pairs to make this an effective filter on its own.

The suffix tree filter was already known to eliminate ∼99% of the alignments  [52]. However, it may produce the same pair for alignment more than once. The theoretical maximum number of duplicates per pair 
                           
                              (
                              i
                              ,
                              j
                              )
                           
                         is bounded by the number of distinct maximal matches between those two strings  [23]. To analyze the cost of duplicate pairs, we augmented the suffix tree filter with a C++ STL set and inserted the pairs as they were generated in order to discard duplicate pairs. We processed the suffix tree for the 80 K dataset on a single compute node (without performing alignments) as well as in parallel on 4 K cores. The suffix tree constructed entirely on a single compute node (therefore eliminating all duplicates) generated 6,401,316 pairs out of a possible 3,199,960,000 (eliminating 99.8% of pairs). The distributed suffix tree filter, while able to eliminate duplicates within each subtree, produced 15,136,463 pairs which is an increase of 136.5% over the perfect duplicate elimination (eliminating 99.5% of pairs).

In order to take advantage of perfect duplicate elimination for distributed suffix subtree processing, we implemented a simple distributed hash table. The entire time spent removing duplicates via the distributed hash table never amounted to more than one second of the total application runtime for all datasets and all core counts we tested. Globally removing duplicate pairs was thus a viable approach. We use this approach for the remaining part of our evaluations.


                        Fig. 4
                         shows how the length filter compares to the suffix tree filter using the 80 K sequence dataset. For this input, the running time when using the suffix tree filter is already less than a minute at 1 K cores so it is not surprising that scalability is limited to 4 K cores. What should be noted is the drastic difference in the time to solution and resource needs; even at the smallest core count the suffix tree filter is over an order of magnitude faster than the best alternative filter strategy of the length-based filter with distributed task counters.

The tree cut depth 
                              k
                            and the minimum exact match length cutoff parameters for the suffix tree can have a direct impact on the number of promising pairwise sequence alignments suggested by the suffix tree filter. In order to measure this impact, we varied these two parameters independently for the 80 K dataset while keeping the number of processors fixed at 240.

We found that changing the cut depth 
                              k
                            only changed the number of subtrees to create and process which directly impacts the time to solution. Our fasted times had 
                              k
                              =
                              3
                            which generated 8353 subtrees. Setting 
                              k
                              =
                              5
                            generated more subtrees (2,790,772) but each of the subtrees contained fewer suffixes and were processed more quickly. However, the additional subtrees eventually caused modest slowdown compared to 
                              k
                              =
                              3
                            since after processing a subtree the duplicate pairs are eliminated which caused contention for the distributed hash table. Setting 
                              k
                              =
                              1
                            caused significant slowdown since the number of buckets generated (21) was much smaller than the number of processes such that there was not enough work available to be performed in parallel. For all inputs considered in this evaluation, setting 
                              k
                              =
                              3
                            was sufficient. Setting 
                              k
                            did not have any impact on the number of alignments to perform because alignment decisions are based on the minimum exact match length cutoff parameter, which is always greater or equal to the cut depth chosen.

Changing the minimum exact match length cutoff dramatically changed the number of alignments to perform but had less impact on the number of homologous pairs identified. Our default of 7 produced 2,707,143 pairs of which 435,152 were homologous and ran for 499 s. Setting it higher to 9 produced 1,303,842 pairs of which 404,735 were homologous and ran for 101 s. Setting it lower to 6 produced 6,401,179 pairs of which 442,828 were homologous and ran for 179 s. Setting it to 5 or lower caused excessive running times. For all experiments hereafter we set this cutoff to 7.


                           Fig. 5
                            shows how the suffix tree filter performs when the 80 K dataset has been distributed across multiple nodes. Although the hopper system has ample resources available, it is important to measure the effect of a distributed sequence dataset. We limited the resources available to each node’s processes such that the 80 K dataset was split across every two nodes in a round robin fashion. If a sequence was no longer local to a node, it would request the remote sequence from the nearest rank with that sequence. Distributing the dataset had no effect on the time taken to compute alignments since any alignment would require at most two sequence fetches. However, the number of sequence fetches needed for any particular suffix subtree could be large. The suffix subtree creation and processing are the primary reasons for the decrease in performance when using a distributed sequence database. The results in Fig. 5 are from our implementation which caches all needed sequences during tree construction and processing. In addition, fetching and caching remote sequences one at a time as they are needed by the tree construction algorithm performed better than a bulk request of all needed sequences at the start of tree creation due to communication contention.

Hereafter again considering replicated sequences, Fig. 6
                            shows the strong scaling performance of the suffix tree filter running concurrently with sequence pair alignment using the 1280, 2560, and 5120 K sequence datasets. Although using the suffix tree filter is far better than any other known filter strategy, it does not scale for larger inputs. This is because the real world dataset we tested have a few highly occurring substrings, thus resulting in some subtrees containing an inordinate number of suffixes—more than 10 standard deviations away from the average number of suffixes per subtree. The suffix tree filter is only as fast as its longest-processing subtree. In the case of the 2560 K sequence dataset, this amounts to approximately 25 s for the largest single tree which is why we see the wall clock time never go far below approximately 32 s even as we increase the number of processors. In the case of the 5120 K sequence dataset, the most time spent processing a single tree was 389 s, limiting the scalability to 1 K cores. Fig. 7
                            further illustrates the poor scaling due to the single long-running subtree task.

There are two options for mitigating the scalability challenges imposed by large suffix subtrees. First, such large subtrees could simply be ignored since a highly repetitive substring will not produce meaningful homology results, but this comes with the trade-off of missing some valid homologous pairs. Second, such large subtrees could be subdivided into additional subtrees rooted at greater depths within the larger subtree. We attempted the latter approach by dynamically cutting large trees if they were two or more standard deviations away from the global average number of suffixes per subtree. We continued to recursively subdivide large trees until either the number of suffixes in the resulting trees were small enough or if the cut depth reached the minimum exact match length criteria. However, this did not significantly or consistently improve performance because the commonly occurring substrings were as long or longer than the minimum exact match length criteria—subtrees would be further divided without significantly reducing the number of suffixes in the problematic subtrees. This result highlights the worst case scenario where the commonly occurring substring might still be longer than the minimum exact match length criteria requested by the user (this value was 7 in our tests compared to the cut depth of 3 also used in our tests). Cutting the suffix tree any deeper than the minimum exact match length criteria would likely result in missed pairs. This is a possible indication that either the minimum exact match length cutoff is too short for this subtree or the prefix exact matching sequence corresponding to this subtree is a highly repetitive sequence in the input and hence the subtree can be discarded. Removing the bottleneck of large subtrees will be addressed in future work.

Compared to our preliminary work  [9] as well as to our non-tree filters evaluated above, by using the suffix tree filter our time to solution was greatly improved while parallel efficiencies were reduced. The simulated filter in our prior work was computed in constant time and removed arbitrary pairs such that those prior performance results cannot be directly compared to the real suffix tree filter which accurately removes candidate pairs while introducing its own processing costs and load imbalance. If not using a suffix tree filter, we are then left with the choice of either using a less-effective but computationally insignificant filter, or not using a filter at all. Either choice would waste computation on poor alignments but would scale better. We believe that in light of trying to process ever-bigger datasets, a reduced time to solution is preferable over pure scalability. Future work will continue to address the scalability challenges.

Our approach here running on the same hardware and with the same datasets outperformed our preliminary work even when including the suffix tree processing time up to 8 K cores. Compared to Wu et al.  [52], our parallel efficiencies of over 99% on 2 K cores were comparable to their 95% efficiencies on 2 K cores. In addition, we were able to have good parallel efficiencies out to 8 K cores. Further, our wall clock time (albeit on more capable hardware) of 125 s at 2 K cores for the 2560 K dataset is nearly 
                              64
                              ×
                            faster than the previously reported 7975 s.

Since our goal was to be able to process sequences at the same rates as they are generated on current sequencing equipment, we report our PSAPS results in Fig. 8
                           . We see from the figure that we did not achieve the same rate of sequence production outlined in Section  1.1 however our best PSAPS rate is over 
                              2
                              ×
                              
                                 
                                    10
                                 
                                 
                                    6
                                 
                              
                           . This is also less than our preliminary work reports at 
                              2.4
                              ×
                              
                                 
                                    10
                                 
                                 
                                    7
                                 
                              
                            PSAPS. However, our preliminary work, without using a suffix tree filter, was performing imprecise and likely unnecessary work as evidenced by our faster running times when using the suffix tree filter. Our approach, therefore, has better throughput even with fewer PSAPS.

@&#CONCLUSIONS@&#

We presented a design of a scalable parallel framework which achieves orders of magnitude higher PSAPS performance and at greater scale than contemporary software using the generally applicable all-against-all sequence alignment model. This represents a comprehensive solution to scalable optimal homology detection. This achievement was facilitated using the work stealing dynamic load balancing technique, a one-sided asynchronous PGAS model for data transfer, and a distributed hash table to eliminate duplicate work. Our results demonstrate a promising step towards analyzing biological sequences as fast as they can be generated on contemporary sequencing hardware.

@&#FUTURE WORK@&#

There are a number of promising approaches to further reduce the time-to-solution of homology detection and increase the PSAPS rate. One area for optimization is in reducing the processing time of the worst-case large subtree outliers. Increasing the window size 
                        k
                      would produce many more and potentially smaller subtrees. However, due to resource constraints, the window size 
                        k
                      cannot simply continue to grow. Using a dynamically sized 
                        k
                      is one solution; however 
                        k
                      cannot be larger than the minimum match length heuristic provided by the user (in our case it was 7). It may very well be that a real dataset has a frequently occurring substring that is still larger than 
                        k
                     .

There are many ways to utilize hardware acceleration to improve PSAPS  [42]. Of particular interest is to utilize CPU SIMD vectorized Smith–Waterman. We did not address this technique in this paper because we use a semi-global variant of the SW algorithm in our approach which did not yet have a vectorized implementation compared to the popular SW algorithm which has many. Further, because our input datasets contain some long sequences, our semi-global variant uses very little memory compared to the available vectorized SW implementations which produce the entire dynamic programming table.

Our initial results looking at alternative filters and load balancing techniques showed that distributed task counters performed better than work stealing. However, this load balancing approach is only applicable to countable, monotonically increasing enumerated tasks. It is an open research question whether this approach could be applied to a highly dynamic and seemingly randomized set of tasks that our suffix tree filter and sequence pair alignment problem exhibit.

@&#ACKNOWLEDGMENTS@&#

This work was supported in parts by the DOE Office of Science, Advanced Scientific Computing Research program (award DE-SC-0006516), and by the Laboratory Directed Research and Development program through the eXtreme Scale Computing Initiative at Pacific Northwest National Laboratory (PNNL). PNNL is operated by Battelle for the United States Department of Energy under contract DE-AC05-76RL01830. This research used resources of the National Energy Research Scientific Computing Center, which is supported by the Office of Science of the US Department of Energy under Contract No. DE-AC02-05CH11231.

@&#REFERENCES@&#

