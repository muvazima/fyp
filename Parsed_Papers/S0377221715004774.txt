@&#MAIN-TITLE@&#Defining line replaceable units

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We discuss the line replaceable unit (LRU) definition decision problem.


                        
                        
                           
                           Replacement levels are selected within the indenture structure of capital assets.


                        
                        
                           
                           We frame the problem in maintenance literature and show how it is treated in practice.


                        
                        
                           
                           We propose an MILP model to optimize the LRU definition decision problem.


                        
                        
                           
                           Numerical experiments show large cost reductions compared to heuristics from practice.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Maintenance

Replacement

Integer programming

Line replaceable unit definition

@&#ABSTRACT@&#


               
               
                  Defective capital assets may be quickly restored to their operational condition by replacing the item that has failed. The item that is replaced is called the Line Replaceable Unit (LRU), and the so-called LRU definition problem is the problem of deciding on which item to replace upon each type of failure: when a replacement action is required in the field, service engineers can either replace the failed item itself or replace a parent assembly that holds the failed item. One option may be fast but expensive, while the other may take longer but against lower cost. We consider a maintenance organization that services a fleet of assets, so that unavailability due to maintenance downtime may be compensated by acquiring additional standby assets. The objective of the LRU-definition problem is to minimize the total cost of item replacement and the investment in additional assets, given a constraint on the availability of the fleet of assets. We link this problem to the literature. We also present two cases to show how the problem is treated in practice. We next model the problem as a mixed integer linear programming formulation, and we use a numerical experiment to illustrate the model, and the potential cost reductions that using such a model may lead to.
               
            

@&#INTRODUCTION@&#

To maintain capital assets, a typical maintenance organization repairs them by replacing failed items (repair-by-replacement). A physical item that is replaced is called a line replaceable unit (LRU; see, e.g., DoD, 1996). The LRU definition problem is a maintenance policy decision that should be considered as a part of strategic or tactical maintenance planning: the exchange of LRUs produces downtime, and therefore the selection of items that should be defined as LRUs is a critical decision. Downtime can be compensated for with spare assets, and this means that the LRU decision should be considered from the outset of a capital asset acquisition program.

Traditionally, non-economic criteria are used to define LRUs. For example: Is it possible to know (test) that the item requires maintenance? Can the failed item be disassembled, and a spare reassembled to the asset without destruction or damage to other parts? Are there special adjustment and calibration needs? These technical criteria help engineers fit the LRU definition to existing practices and available resources of the maintenance organization. While these non-economic criteria are of key importance, inclusion of economic criteria can lead to a more cost effective LRU definition. The aim of this paper is to take a step in that direction.

We first link the problem to the scientific literature. Three relevant literature streams are reviewed: (i) maintenance task analysis, (ii) maintenance optimization, and (iii) level of repair analysis. The setup of this review is based on the Logistics Support Analysis framework (see, e.g., Jones, 2006). We find that the LRU decision is implicit in existing models for maintenance planning, and thus has not received the attention that it requires.

We next show how the problem is treated in practice by gathering insights from two organizations: a system developer, Thales Nederland BV, and a maintenance service provider, NedTrain BV. We show how LRU decisions are made at these organizations, giving insights about when they make the decision, who makes the decision, and what criteria are used. Also here, we find that the LRU definition decision is often made implicitly.

We propose to model the LRU definition problem explicitly. Using insights from the literature and from practice we come up with a mixed integer linear programming (MILP) formulation to find the optimal LRU definition. We perform a numerical experiment using typical problem sizes and parameters as they appear at NedTrain. Our theoretical contribution is as follows:

                        
                           1.
                           We link the problem to multi-component maintenance optimization and frame it in the literature as a decision that should be made after maintenance task analysis, and before level of repair;

We improve the LRU definition decision that is traditionally technical, by explicitly modeling the trade-off between downtime and cost, including replacement lead time, spare assets and the cost of replacement;

In multi-component maintenance optimization, the interactions between components are modeled. We explicitly incorporate one type of interaction called structural dependence, in which defining what to replace depends on the assembly structure of the capital asset.

From a practical point of view, we contribute by examining the cost savings that could be achieved compared to ad-hoc decisions made by experts. We do this in an extensive numerical experiment. We thus show that it is important to make the LRU definition decision explicitly in practice, and we give a model that can be used to do this.

The remainder of this paper is structured as follows. Section 2 presents the relevant literature and frames the LRU definition problem in the literature. Section 3 then shows two example cases from practice. Section 4 presents the LRU model notation, assumptions, and the mathematical formulation. AppendixÂ B shows that the resulting LRU definition problem is NP-hard. Section 5 presents the numerical experiment. Finally, Section 6 discusses the conclusions and perspectives for future research.

We use the framework of logistics support analysis (LSA) to structure our review of the literature. The LSA framework is shown in Fig. 1. It structures the decisions needed to produce the maintenance program for an asset, including the required (amounts of) resources. This enables us to position the LRU definition problem in the literature.

We first explain the LSA framework in Section 2.1. We then focus on three topics in detail; on maintenance task analysis in Section 2.2, on maintenance optimization, which covers the LRU definition problem, in Section 2.3, and on level of repair analysis in Section 2.4.


                        Jones (2006) and Blanchard and Fabrycky (2011) provide good overviews of the LSA framework. It begins with the analysis of possible failure events. Reliability predictions are made for the failure of asset components. Next, maintenance significant items (and their failure effects and criticalities) are identified with the help of fault-tree analysis (FTA) and failure modes, effects and criticality analysis (FMECA). The analysis results are combined in the reliability centered maintenance analysis (RCMA) to establish the set of feasible maintenance policies for the capital asset, e.g., time based maintenance or run-to-failure (see, e.g., Moubray, 1997; Tinga, 2010). At this point in the LSA framework, engineers have thus determined which items may fail, how often that is expected to happen, what effect and criticality such failure may have, and what preventive measures (if any) to take.

The next three analyses, Maintenance task analysis (MTA), maintenance optimization and level of repair analysis (LORA), are discussed in detail in the next three sections. MTA helps to identify and quantify the required maintenance resources, such as manpower or support equipment. Maintenance optimization models are mainly used to determine the optimal preventive maintenance intervals and task clustering. LORA supports repair or discard decisions, and determines where in the repair network to carry out these activities.


                        Sparing analysis, which follows after LORA, helps determine the spare parts package (see, e.g., Basten & van Houtum, 2014; Muckstadt, 2005; Sherbrooke, 2004, for an overview of the literature on spare parts inventory control models). Life cycle cost (LCC) is determined next. Finally, value engineering (VE) highlights asset functions that add cost but do not add significant value and feedback is given to design.

Maintenance task analysis is the detailed, step-by-step analysis of a maintenance task to determine how it should be performed, who will be required to perform it, and what physical resources are needed to complete it. Most maintenance tasks involve manual disassembly and (re)assembly operations. To find the best task procedure for maintenance, engineers use human factors analysis, path/motion planning and assembly/disassembly sequencing.

Human factors analysis helps to assess the effort to access the maintenance point and the risks involved, given a proceduralized task (see, e.g., Dhillon & Liu, 2006). Together with human factors, path and motion planning helps to reveal the best way for a service engineer to reach and route a part into or out of an assembly. Next, optimal sequencing helps to establish the optimal order of assembly and disassembly (see, e.g., Lambert, 2003).

Once the task procedure is established, maintainability analysis is used to estimate (or measure) the required time and resources. The literature on maintainability analysis has mostly concentrated on estimating the (mean) time to repair, using either statistical methods or expert-based assessment (see, e.g., Barabadi, Barabady, & Markeset, 2011; Moreu De Leon, GonzÃ¡lez-Prida DÃ­az, BarberÃ¡ MartÃ­nez, & Crespo MÃ¡rquez, 2012). A quantification of both resource demand and task time are very useful for decision making. The data will be used as input of maintenance optimization models. We will need the results from MTA for solving LRU definition problem.

Most literature on maintenance optimization focuses on defining the best policy for when to replace a particular item. However, for multi-component assets it is important to define not only when, but also what to replace. This derives from the fact that in capital assets with many items, interaction between items influences the maintenance action that should be chosen. Nicolai and Dekker (2008) review the literature on multi-component maintenance optimization and they distinguish between economic, stochastic and structural dependence as a result of interaction between items.

Economic dependence exists when costs decrease or increase by grouping maintenance tasks. Stochastic dependence exists when items present failure interactions, i.e., states of items can affect the states of other items and their failure rate. Finally, structural dependence exists when items have to be replaced, or at least dismantled, before failed components can be replaced or repaired.

The term structural dependence was coined by Thomas (1986), who was one of the first to review the problems in multi-component maintenance optimization with structural dependence, i.e., where, â...the question is whether one should replace the whole car, the engine or just the piston rings when the piston rings need to be replacedâ. With structural dependence, the disassembly precedence relations are important, which follow from MTA. We see the LRU definition problem as a multi-item maintenance optimization problem with structural dependence.

This problem has been a recurring problem in the literature on maintenance optimization for several decades, starting with the seminal paper by Sasieni (1956) (see e.g. Nicolai & Dekker, 2008; Marais, Rivas, Tetzloff, & Crossley, 2013). Moreover, while typically the focus has been on the decision about the optimal maintenance interval, i.e., when to replace, the key decision for the LRU definition problem is at what level within the indenture structure of a physical asset to define the LRU, i.e., the decision on what to replace.

The level of repair analysis problem is a cost minimization problem that involves two decisions. Firstly, determining whether a maintenance significant item should be repaired or discarded upon failure. Secondly, determining where to allocate this repair/discard task in the repair network. The LORA problem has been addressed in the literature as an MILP model by several authors (see, e.g., Barros & Riley, 2001; Basten, vanÂ der Heijden, & Schutten, 2011). Recently, LORA models have been extended to consider availability by incorporating the amount of spare parts to stock (the sparing decision) (see, e.g., Basten, vanÂ der Heijden, & Schutten, 2012). We find that the literature on LORA takes the LRU decision as a given.

To the best of our knowledge, the importance of optimally determining line replaceable units was brought to attention only by Jensen (1975), in the context of level of repair analysis. Jensen states that the LRU definition is implicit in his LORA formulation. However, one of the inputs of his model is the explicit definition of which item is replaced directly from the asset, and which items (if any), are used to repair the failed LRU. Therefore, the LRU definition decision must be made before his LORA model can be used.

We show insights about how organizations make the LRU definition decision in practice based on two exploratory cases. Interviews were conducted following the methodology in Schotborgh, McMahon, and Houten (2012). This means that we begin by asking experts to compare performance of different LRUs, and next focus on what performances they consider, e.g. time to replace, resources needed, task difficulty. We thus determine (i) when LRU definition decisions are made, (ii) who makes them, and (iii) what criteria are considered.

In Sections 3.1 and 3.2, we present our findings at a high-tech system developer and a maintenance service provider, respectively. For each case, we give a short company overview, followed by a description of the LRU definition process. Next, we discuss the criteria used by experts, and we give individual case conclusions. Finally, in Section 3.3 we draw more general conclusions from practice.


                        Thales Nederland B.V. (Thales) is the largest defence company in the Netherlands. Thales designs and manufactures naval command and control, sensor, and communications systems. As a high tech systems developer, Thales is involved in maintenance by providing training, supplying service parts (LRUs), overhaul, upgrades, and modifications to its clients, and by performing repairs according to support contracts.

At Thales, design tasks are partitioned according to the type of technology used, and engineers are grouped into Technical Units with expertise in each type of technology, e.g., processing or microwaves. Fig. 2 shows how the LRU definition process is organized at Thales, according to the V-model of systems engineering. Through the process of system requirements analysis, engineers translate the clientâs capability requirements into system performance. Maintenance performance is allocated at system level in the form of Reliability, Availability, Maintainability, Testability (RAMT) requirements.

Next, each Technical Unit must allocate the system level RAMT requirements to individual LRUs, thereby making the LRU definition decision. They use for this the (i) LRU requirements and the (ii) Integrated Logistic Support (ILS) Guidelines that have been developed by the ILS department. The Technical Unit communicates the LRU definition decisions to individual design teams. Design Teams will then develop the LRUs (parts) complying with the requirements and the logistics guidelines. For completeness, we include a summary of the LRU requirements in AppendixÂ D.
                     

The ILS Guidelines are used to give an overview of supportability aspects to be considered by designers, as well as performance targets for design. Their goal is to improve system supportability and lower life cycle cost. Improving LRU definitions at Thales often involves redesign, and this is a considerable effort. Thales outsources manufacturing of some of its components, and this means that redesign has to involve the suppliers. Engineers can use the guidelines to trade-off manufacturability with supportability, i.e., a trade-off between manufacturing and operating costs.

The LRU requirements describe two types of criteria used by design teams when developing LRUs. Firstly, an LRU has to satisfy four mandatory criteria. If this is impossible, then the next higher assembly/equipment will be defined to be the LRU. Otherwise, the maintenance concept is changed to direct repair of the hardware item while installed in the asset, i.e., no repair by replacement and no definition of LRU.

Secondly, there are a number of preferred criteria for selection of LRUs. For example, there exist requirements for the maximum weight and dimensions. These allow the LRU to be handled by one service engineer only. If the design team has a good reason not to fulfill the requirement, then the preferred criteria may be waived. However, there is a constraint on the total number of waivers. Waivers are controlled during design review.

In summary, we have found that LRU definitions at Thales are made during the early stages of design. Engineers within technical units make the LRU definition decisions, and criteria for defining LRUs are based on compliance to standard LRU requirements. These requirements do not explicitly mention economic trade-offs.


                        NedTrain B.V. (NedTrain) is a full maintenance, repair and overhaul (MRO) service provider for trains. It is a subsidiary of NS, the main passenger railway operator in the Netherlands. NedTrain provides 24/7 service involving regular maintenance, repair, overhaul, modernization and life extension. Four types of facilities provide the required services, spanning from first line service to component repair and overhaul.

For NedTrain, the supportability of new trains depends on the level in the indenture structure at which LRUs are defined. The LRU level is initially defined during acquisitions of new trains, resulting in a preliminary list of LRUs. The preliminary list of LRUs may change throughout a trainâs life cycle when new knowledge about item performance becomes available. The actual LRU decision is made at the operational level. In practice, the LRU level is changed ad-hoc by service engineers during repair.


                        Fig. 3 shows how the LRU definition process takes place during acquisition of new trains to produce the preliminary list of LRUs. A similar process is followed to change the list later in the life cycle. The LRU level is initially defined by the supplier during acquisitions, and it is communicated to NedTrain as a recommended spare parts assortment. For each of the suggested LRUs, NedTrain must decide to accept or revise this LRU level.

If NedTrain decides to revise the suggested list of LRUs, then experts will try to find an LRU level that gives a better fit to existing resources and to the maintenance concept. The whole process involves frequent communication with the suppliers. A team of experts begins the LRU research. This is typically done by looking deeper in the indenture structure to try to find smaller LRU candidate than the one proposed by the supplier. Next, they determine whether or not there are parts in this new level that can be exchanged. This is the most important technical aspect considered for defining LRUs. If there is no feasible disassembly sequence to remove the LRU candidate item directly, then the item is non-LRU. In this case the team shifts focus to the parent (assembly) item and repeats the analysis.

For some LRU candidates, direct replacement is possible only when the proper tools or equipment are available. If resources facilitate replacement and they are available, then the item is selected as an LRU. Some of the aspects considered for this decision include task frequency, skill level and effort required, for example. It is a rule of thumb that approximately 85Â percent of the parts can be replaced in any maintenance workshop of NedTrain. However, the problem of limited availability of skills and manpower was noted by several experts.

If the required resources are not readily available in the workshop, then there is a cost trade-off. The expert team filters out those items that require expensive tools or equipment. If the cost of installing the additional resource is unacceptable, the expert team will begin negotiations with the supplier to outsource replacement. If an agreement is reached with the supplier, the item will be defined as LRU. In this case a service contract is signed and the supplier will perform direct replacement on the train. Otherwise, the item is defined as non-LRU.

The preliminary list of LRUs lends the operational LRU decision to service engineers in the workshops. Once the trains are fielded, there is a lot of freedom for service engineers at NedTrain to decide how a particular failure is repaired. LRU definitions are changed ad-hoc, i.e., the decision of what component is replaced. Often, if a service engineer decides to correct the failure by replacing an O-ring, (s)he can. If otherwise (s)he decides to replace the entire (assembled) unit, then that may also be allowed.

Service engineers find it is easier to replace a small part instead of a large assembly. This is because typically less interfaces have to be taken apart by replacing smaller items. Also, large and heavy components need more handling effort. However, some experts suggest that while replacing a small component is cheap, the train often remains waiting longer. The behavior of service engineers may come in conflict with this point of view. Our conclusion is that the LRU definitions should be a strategic/tactical decision. This is also the position of management.

Summarizing, we have found that LRU definitions decisions at NedTrain are made during acquisition and during the operating life of passenger trains. The goal during acquisitions is to analyze the preliminary list of LRUs of the supplier to create an initial spare parts assortment that better fits the maintenance concept of NedTrain. Therefore, the objective is not the specific choice amongst replacement alternatives. This LRU definitions are made by an expert team of engineers, in agreement with the suppliers, to fit the resources of NedTrain. In practice, during the operating life of the train the service engineers may make the replacement decision ad-hoc, and the LRU level within the indenture structure may change.

Our research shows that LRU definitions require considerable efforts, that costs are not always incorporated and that supplier involvement is required. At NedTrain, performing the LRU definition decision for a new train series requires one year of an expert teamâs efforts. In practice, RAMS/RAMT influence LRU definitions, and LCC calculations have a limited influence in the decision. Both for Thales and for NedTrain, increasing collaboration with suppliers has led to improved LRU definitions, e.g., higher availability and lower LCC.

To help Thales and NedTrain, we propose to use model-based decision support. We use an optimization approach in Section 4 of this paper which will probably be more useful for companies like NedTrain, though we expect it will also give insights that help designers at Thales. NedTrain can benefit from reduced downtime and increased standardization of repair. At Thales, helping designers make logistic trade-offs is required to support the system engineering efforts. This could be subject of future research.

In Section 4.1, we explain the relevant notation and assumptions, and in Section 4.2, we present a mixed integer linear programming formulation for the LRU definition problem. AppendixÂ B shows that the resulting LRU definition problem is NP-hard.

Consider a capital asset with several indenture levels. Such a multi-indenture structure is a rooted ordered tree. Fig. 4
                         shows an example three-indenture asset with the notation that we use. Let I be the set of all maintenance significant items, and 
                           
                              |
                              I
                              |
                              â
                              N
                              ,
                           
                         with |I| denoting the cardinality of I. For convenience we denote 
                           
                              I
                              =
                              {
                              1
                              ,
                              2
                              ,
                              â¦
                              ,
                              |
                              I
                              |
                              }
                           
                        . Let Îi
                         be the subset of items that are direct descendants of item i â I. Notice that 
                           
                              
                                 Î
                                 i
                              
                              =
                              â
                           
                         Â if and only if item i â I is a leaf (i.e., has no descendants). We denote by the set Ai
                         the set of all ascendants of item i â I, i.e., all assemblies that contain, at some indenture level, item i.

Consider the maintenance system in Fig. 4. For its primary process, an operator requires k assets to be operational, i.e., the target number of available assets is k. Each of the k assets will remain in operation until a corrective maintenance action or preventive maintenance is required. When a maintenance event is required, the asset is removed from service and taken to a maintenance facility. After maintenance, the asset is sent to an inventory stock point.

We make some assumptions in order to keep our model simple, allowing us to focus on the insights that we can get. We assume that there is ample repair capacity (i.e., uncapacitated resources) and that item replacement times are deterministic with lead time ri
                         > 0 for LRU i â I. The item replacement time is the total time required for failure detection, isolation, repair and checkout/calibration. We assume that the asset behaves as a series of critical items: if one fails, then the asset fails. Finally, we assume that failures happen individually.

Let mi
                         be the individual failure rate (yearly number of failures) of item i â I. This means that if mi
                         > 0, then failures occur in item i that are not due to failures in any of its descendants. Without loss of generality it holds that mi
                         > 0 for all leaf items, i.e., items i â I with 
                           
                              
                                 Î
                                 i
                              
                              =
                              â
                           
                        . We assume mi
                         over k operational assets. There may be moments when there are less than k assets operational, but given a high service level, this does not happen often and the number of operational assets will not be far below k (for a more extensive discussion of why such a constant failure rate is realistic to assume, see Sherbrooke, 2004, p.24, or Basten & van Houtum, 2014, p.40). Let Î»i
                         be the cumulative failure rate of item i â I. Î»i
                         is the sum of the cumulative failure rates of those child items j â Îi
                         that are not defined as LRU. Î»i
                         is thus an auxiliary variable and we show our recursive approach for calculating Î»i
                         in Section 4.2. By definition, Î»i
                         â¥ mi
                        , for all i â I, and 
                           
                              
                                 Î»
                                 i
                              
                              =
                              
                                 m
                                 i
                              
                           
                         if item i is a leaf item, i.e., if 
                           
                              
                                 Î
                                 i
                              
                              =
                              â
                           
                        .

We define the following decision variables:

                           
                              â¢
                              
                                 
                                    
                                       
                                          
                                             X
                                             i
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         1
                                                         ,
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         component
                                                         i
                                                         â
                                                         I
                                                         is
                                                         
                                                         defined
                                                         
                                                         as
                                                         
                                                         LRU,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         0
                                                         ,
                                                      
                                                   
                                                   
                                                      otherwise;
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 
                                    
                                       N
                                       â
                                       N
                                    
                                  is the total number of assets to acquire.

The cost function contains two cost factors. Firstly, the annual holding cost, c
                        0, of the assets (this includes interest, depreciation, etc.). Secondly, the cost of replacement of an LRU i â I, ci
                        . Replacement costs include labor and material costs.

Our objective is to determine which items out of the total set of items I to define as LRU, plus the total number of assets N to acquire, such that the total costs are minimized while the availability constraint is met. We state the LRU-definition problem as a mixed integer linear program below. The linearization of the objective function and Constraints 2â4 can be found in AppendixÂ A.

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             minimize
                                             
                                          
                                       
                                       
                                          
                                             
                                                c
                                                0
                                             
                                             N
                                             +
                                             
                                                â
                                                
                                                   i
                                                   â
                                                   I
                                                
                                             
                                             
                                                
                                                   c
                                                   i
                                                
                                                
                                                   Î»
                                                   i
                                                
                                                
                                                   X
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             subject
                                             
                                             to
                                             
                                          
                                       
                                       
                                          
                                             N
                                             â
                                             
                                                â
                                                
                                                   i
                                                   â
                                                   I
                                                
                                             
                                             
                                                
                                                   r
                                                   i
                                                
                                                
                                                   Î»
                                                   i
                                                
                                                
                                                   X
                                                   i
                                                
                                             
                                             â¥
                                             k
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Î»
                                                   i
                                                
                                                =
                                                
                                                   m
                                                   i
                                                
                                                +
                                                
                                                   â
                                                   
                                                      j
                                                      â
                                                      
                                                         Î
                                                         i
                                                      
                                                   
                                                
                                                
                                                   
                                                      Î»
                                                      j
                                                   
                                                   
                                                      (
                                                      1
                                                      â
                                                      
                                                         X
                                                         j
                                                      
                                                      )
                                                   
                                                
                                                ,
                                                â
                                                i
                                                â
                                                I
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                       
                                       
                                          
                                             
                                                Î»
                                                i
                                             
                                             â¤
                                             
                                                Î»
                                                i
                                             
                                             
                                                X
                                                i
                                             
                                             +
                                             
                                                â
                                                
                                                   j
                                                   â
                                                   
                                                      A
                                                      i
                                                   
                                                
                                             
                                             
                                                
                                                   Î»
                                                   j
                                                
                                                
                                                   X
                                                   j
                                                
                                             
                                             ,
                                             â
                                             i
                                             â
                                             I
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                       
                                       
                                          
                                             N
                                             â
                                             N
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                       
                                       
                                          
                                             
                                                X
                                                i
                                             
                                             â
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             ,
                                             â
                                             i
                                             â
                                             I
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Constraint 2 is a constraint on the number of assets that must be available for operation. Constraint 3 is the recursion stating that an item i â I is replaced both when failing individually (mi
                        ), and upon failure of one of its child items that have not been defined as LRU. Finally, Constraint 4 assures that a child non-LRU that fails must have an LRU ascendant. If 
                           
                              
                                 Î»
                                 i
                              
                              =
                              0
                           
                         or if 
                           
                              
                                 X
                                 i
                              
                              =
                              1
                              ,
                           
                         the constraint is always satisfied. If 
                           
                              
                                 X
                                 i
                              
                              =
                              0
                           
                         and Î»i
                         > 0, then some parent item must be defined as LRU, i.e., 
                           
                              
                                 â
                                 
                                    j
                                    â
                                    
                                       A
                                       i
                                    
                                 
                              
                              
                                 X
                                 j
                              
                              â¥
                              1
                              ,
                           
                         and thus 
                           
                              
                                 Î»
                                 i
                              
                              â¤
                              
                                 â
                                 
                                    j
                                    â
                                    
                                       A
                                       i
                                    
                                 
                              
                              
                                 Î»
                                 j
                              
                              
                                 X
                                 j
                              
                           
                        .

This section explains our numerical experiment. We first give the setup of our numerical experiment in Section 5.1; a detailed description of how we generate some parts of the problem instances can be found in AppendixÂ C. We show the results in Section 5.2. The LRU definition problem is implemented using the CPLEX 12.6 Class API for MATLAB R2013a on an Intel Core i5 M540@2,53Â gigahertz, with 4Â gigabytes RAM running 64-bit Windows 7. All instances are solved to optimality; we do not use a time limit.

We use a problem instances generator that is inspired by that of Basten etÂ al. (2012). We define three problem sets (PS): PS1, PS2 and PS3. Table 1
                         lists the settings used to modify the asset structures for each of the three sets, and Table 2
                         lists the settings for the other parameters. Typical values found at NedTrain are in between the low and high values used in the problem sets. We use a full factorial design per PS, and generate ten problem instances per parameter setting to avoid basing conclusions on one unique instance only.

Since maintenance is a labor intensive service, in our experiments we explicitly consider the effect of wages on the LRU definitions. We define the labor cost as the product of the yearly wage, w, and the direct labor time, ri
                        . This means that the cost of replacement of an LRU i â I is: 
                           
                              
                                 c
                                 i
                              
                              =
                              
                                 c
                                 i
                                 â²
                              
                              +
                              w
                              
                                 r
                                 i
                              
                              ,
                           
                         with 
                           
                              c
                              i
                              â²
                           
                         covering material and indirect labor cost.

We use three parameters to produce the asset structures used in each of the three problem sets: (i) the number of items in the first indenture level, denoted by |Î
                        0|, the (ii) average number of items per parent, denoted by 
                           
                              
                                 
                                    |
                                 
                                 
                                    Î
                                    i
                                 
                                 
                                    |
                                 
                              
                              Â¯
                           
                         and (iii) the number of indenture levels, denoted by |L|.

In PS1 and PS2 we explore the effect of different indenture structure combinations (see Table 1). In PS1 we fixate the number of indenture levels while varying the average number of items per parent, 
                           
                              
                                 
                                    
                                       |
                                    
                                    
                                       Î
                                       i
                                    
                                    
                                       |
                                    
                                 
                                 Â¯
                              
                              ,
                           
                         and the number of items in the first indenture, |Î
                        0|. In PS2 we vary the number of indenture levels, |L|, while keeping constant |Î
                        0| and 
                           
                              
                                 
                                    |
                                 
                                 
                                    Î
                                    i
                                 
                                 
                                    |
                                 
                              
                              Â¯
                           
                        . Besides the different indenture structure combinations, each problem instance in PS1 and PS2 takes one value or range for each of the seven parameters from Table 2. This means that we generate a total of 
                           
                              10
                              Ã
                              
                                 2
                                 7
                              
                              Ã
                              4
                              =
                              5
                              ,
                              120
                           
                         problem instances per PS.

Based on the results of PS1 and PS2, PS3 has been designed to focus on the effect of changes in the parent cost, 
                           
                              
                                 c
                                 i
                                 â²
                              
                              â£
                              
                                 Î
                                 i
                              
                              â 
                              â
                              ,
                           
                         as a function of the costs of its children. Therefore, the setup is identical to that of PS1, with the exception of two parameters that remain fixated at setting 1 (see Table 2) because they were found not to influence the results in PS1 or PS2. This means that for PS3 we generate 
                           
                              10
                              Ã
                              
                                 2
                                 5
                              
                              Ã
                              3
                              Ã
                              4
                              =
                              3
                              ,
                              840
                           
                         problem instances.

We give more details on the parent-child cost factor, fc
                        , and the parent cost, 
                           
                              
                                 c
                                 i
                                 â²
                              
                              â£
                              
                                 Î
                                 i
                              
                              â 
                              â
                              ,
                           
                         because this helps to explain the results in Section 5.2. A detailed explanation of the other parameters is given in AppendixÂ C. For PS1 and PS2 the cost of a parent assembly is proportional to the cost of its most expensive child item, i.e., 
                           
                              
                                 c
                                 i
                                 â²
                              
                              =
                              
                                 f
                                 c
                              
                              max
                              
                                 c
                                 j
                                 â²
                              
                              â£
                              j
                              â
                              
                                 Î
                                 i
                              
                              ,
                           
                         for i â Iâ£Îi
                         â  â. In addition to this setting, in PS3, we also consider 
                           
                              
                                 c
                                 i
                                 â²
                              
                              =
                              
                                 
                                    f
                                    c
                                 
                                 
                                    
                                       |
                                    
                                    
                                       Î
                                       i
                                    
                                    
                                       |
                                    
                                 
                              
                              
                                 â
                                 
                                    j
                                    â
                                    
                                       Î
                                       i
                                    
                                 
                              
                              
                                 c
                                 j
                                 â²
                              
                           
                         and 
                           
                              
                                 c
                                 i
                                 â²
                              
                              =
                              
                                 f
                                 c
                              
                              
                                 â
                                 
                                    j
                                    â
                                    
                                       Î
                                       i
                                    
                                 
                              
                              
                                 c
                                 j
                                 â²
                              
                           
                        . The former setting means that a parent assembly has the average cost of the child items, j â Îi
                        , multiplied by a cost factor. In the latter setting, the cost of a parent is the sum of the cost of the child items multiplied by the cost factor.

@&#RESULTS@&#

Computation times are mainly driven by the changes in the asset structure settings of Table 1. Therefore, Table 3
                         shows the minimum, mean and maximum computation times for each subset of problem instances that share the same asset structure settings. The computation times are typically low, so we do not further focus on them. The remainder of this section discusses the results by answering the following questions:

                           
                              1.
                              What cost increases result when we compare the optimal LRU definition with defining (i) the first indenture (largest) items as LRU and (ii) the highest indenture (smallest) items as LRUs?

Which model parameters influence the cost increases in the above cases?

To answer these questions, we solve each problem instance to find the optimal LRU definition, and we apply two heuristics that are based on what we have seen in practice. We call the first heuristic the large heuristic (make LRUs as large as possible, i.e., all first indenture items), and denote the resulting costs by Cl
                        . We call the second heuristic the small heuristic (make LRUs as small as possible, i.e., all leaf items), and the resulting costs are denoted by Cs
                        . The optimal costs are denoted by C
                        *. Notice that both heuristics represent a naive approach, because they are generally not followed for all items when defining LRUs in practice. However, we believe that it is a good reference point for contrasting extreme cost results.

We answer Question 1 by showing the cost increases that appear when comparing C
                        *, with the cost of the two heuristic solutions: Cl
                         and Cs
                        . The percentage increase that we show is calculated as 
                           
                              
                                 
                                    C
                                    
                                       l
                                       /
                                       s
                                    
                                 
                                 â
                                 
                                    C
                                    *
                                 
                              
                              
                                 C
                                 *
                              
                           
                        . Question 2 addresses the influence of model parameters on the possible cost increases. Answering this question gives managerial insights about the relevant cost drivers in the model. We use an n-way analysis of variance to test the significance of the results for different parameter settings.

To answer Question 1, Table 4
                         summarizes the cost increases over all problem instances. We see that for all PSs, using the heuristics results in huge cost increases compared to the optimal solution, with the small heuristic performing better than the large heuristic. The cost increase for all problem instances is at least 4Â percent (shown in AppendixÂ E). These results show that solving the LRU definition problem considering technical aspects only, as is currently common in practice (see Section 3), typically leads to high additional costs. Optimization incorporating economic criteria is required.

We next answer Question 2. We discuss only those parameters that have a significant effect on the achieved cost increase. Item replacement time, ri
                        , and the target number of assets, k, had no significant effect on the cost increase in any of the PSs. Fig. 5
                         shows the main effects plot of the cost increase in PS1 for those parameters that have a significant effect (p-values less than 0.05 in the n-way analysis of variance of the cost increase). We discuss each of these effects below. AppendixÂ E shows the minimum (min), average (mean) and maximum (max) cost increase for parameter settings of PS1, PS2 and PS3.

The largest cost increases result from increasing the number of items per parent (
                           
                              
                                 
                                    |
                                 
                                 
                                    Î
                                    i
                                 
                                 
                                    |
                                 
                              
                              Â¯
                           
                         from 2 to 4) and the cost factor (fc
                         from the range [0.5; 1.5] to the range [1; 3]). Both increases mean that costs of leaf items remain the same while parent items become more expensive. As a result, it becomes more costly to make a suboptimal LRU definition. Furthermore, in the optimal solution, the number of LRUs doubles and LRUs will be smaller than before. Therefore, we see that the percentage cost increase of the large heuristic compared with the optimal solution becomes much higher, while this effect is much smaller (
                           
                              
                                 
                                    |
                                 
                                 
                                    Î
                                    i
                                 
                                 
                                    |
                                 
                              
                              Â¯
                           
                        ) or even reversed (fc
                        ) for the small heuristic.

Increasing the item replacement cost, 
                           
                              
                                 c
                                 i
                                 â²
                              
                              â£
                              
                                 Î
                                 i
                              
                              =
                              â
                              ,
                           
                         or the item failure rate, mi
                        , leads to a slightly higher cost increase. While these setting changes do not significantly influence the number of LRUs in the optimal solution, the LRU replacement costs increase with increases in ci
                         or Î»i
                        . Therefore, the relative contribution of the costs of the fleet to the total optimal costs becomes much smaller: it becomes more costly to make a suboptimal LRU definition.

With increasing asset price, c
                        0, we found an average reduction in the cost increase for both heuristics. Increasing c
                        0 has the inverse effect of ci
                         or Î»i
                        . The reduction in the cost increase results because for more expensive assets the costs of the fleet are higher, and the relative weight of the LRU replacement costs becomes smaller. Finally, changes in w do not lead to large cost increases. The reason is that wages represent a relatively small contribution to the total costs.


                        Fig. 6
                         shows the main effects plot of the cost increase due to an increase in the number of indenture levels, |L|, from three to six indentures (settings 1â4) for PS2. Increasing |L| creates more opportunity for allocating cheaper repair options in the optimal solution. We find that the number of LRUs in the optimal solution has large variations within each setting, while remaining almost unchanged for both heuristics, e.g., for 
                           
                              |
                              L
                              |
                              =
                              6
                              ,
                           
                         problem instances range from 478 LRUs (closer to the large heuristic) to 1476 LRUs (closer to the small heuristic). Both heuristics result in increased costs.


                        Fig. 7
                         shows the main effects plot of the cost increase given the parent item cost settings for PS3. The differences between the average cost of the parent between settings 
                           
                              
                                 
                                    â
                                    
                                       j
                                       â
                                       
                                          Î
                                          i
                                       
                                    
                                 
                                 
                                    c
                                    j
                                 
                              
                              
                                 
                                    |
                                 
                                 
                                    Î
                                    i
                                 
                                 
                                    |
                                 
                              
                           
                         and maxâcj
                         is very small, which explains why they result in very similar cost increases. With 
                           
                              
                                 â
                                 
                                    j
                                    â
                                    
                                       Î
                                       i
                                    
                                 
                              
                              
                                 c
                                 j
                                 â²
                              
                              ,
                           
                         more small items are defined as LRU in the optimal solution. This makes a small cost increase for the small heuristic, but makes a huge cost increase for the large heuristic.

Summarizing, the cost of parent assemblies relative to child items can have a huge influence on the cost increases. Therefore, if parents become more expensive compared to their children, there is more to gain by making optimal LRU definitions, and these optimal definitions include smaller items.

@&#CONCLUSIONS@&#

In this paper we have discussed a problem within maintenance optimization: the optimal selection of replacement level within the indenture structure of capital assets. To the best of our knowledge, this problem has not received attention in the literature. We have presented the LRU definition problem as a decision on whether or not to replace a parent assembly or a child item, upon failure of that child item. The LRU definition problem explicitly accounts for the structural dependency existing between items within the indenture structure of capital assets. In practice, the LRU definition decision is usually made ad-hoc, or based only on engineering/technical criteria. Furthermore, many maintenance repair decisions, such as the Level of Repair Analysis decisions, assume the LRU definitions implicitly.

We have shown that the LRU definition problem is NP-hard, that it can be optimized using an MILP model, and that significant cost reductions can be achieved when compared to two heuristics commonly used in practice. This provokes further research about the ways to improve LRU decisions in practice. Some of the assumptions in the current model of the LRU definition problem may be relaxed, especially that of sequential maintenance.

The model can also be extended by incorporating limited labor capacity. We have seen that wage differences do not significantly influence in LRU definitions. However, we have also seen in practice a growing concern for labor scarcity in the maintenance industry. Limited manpower (working hours per skill sets) could be an additional constraint in the model. Increasing task frequency builds routine, and helps prevent costly mistakes in maintenance work. A lower bound on replacement frequency can be added as constraint.

Proceeding in the direction of combining the LRU definition problem with other problems would be useful to support the joint maintenance and logistics decisions for re-defining LRUs, for example at NedTrain. One way would be to combine it with LORA, e.g., the work by Basten etÂ al. (2011). This means combining the MILP model for the LRU definition problem with the MILP model for the LORA problem. It may also be beneficial to help maintenance assessment by combining the LRU definition problem with the joint optimization of level of repair analysis (LORA) and spare parts stocking (see Section 2.4). One way would be by extending the work by Basten etÂ al. (2012). This means combining the MILP model for the LRU definition problem with the MILP model for the LORA problem. Solving that MILP first and then a spare parts stocking model. Using a feedback loop to the MILP model leads to an iterative heuristic to solve the joint problem.

@&#ACKNOWLEDGMENTS@&#

This research is part of the âRolling Stock Life Cycle Logisticsâ applied research and development program, funded by NS/NedTrain. We thank the experts at Thales and NedTrain for their invaluable help and insights. The second author gratefully acknowledges the support of the Lloydâs Register Foundation (LRF). LRF helps to protect life and property by supporting engineering-related education, public engagement and the application of research. We gratefully acknowledge the editor and the reviewer for their valuable comments that helped improve this paper.

In this appendix, we linearize the mathematical model described in Section 4.2. The objective function, and Constraints 2â4, contain products of the cumulative failure rate Î»i
                      and the decision variable Xi
                     . This product is a nonlinear expression. We linearize these expressions by introducing an auxiliary variable Ïi
                      that is equal to Î»iXi
                     . We further define Îi
                      as the failure intensity of item i â I, including the failure intensity of all its descendants. It is a Big M variable and it is computed recursively: 
                        
                           
                              Î
                              i
                           
                           =
                           
                              m
                              i
                           
                           +
                           
                              â
                              
                                 j
                                 â
                                 
                                    Î
                                    i
                                 
                              
                           
                           
                              Î
                              j
                           
                        
                     . The linearized LRU definition problem is shown below. The objective function and constraints A.2 to A.4 are the same as the objective function and constraints 2 to 4 in the original model, with Î»iXi
                      being replaced by Ïi
                     . Constraints A.5 to A.8 are added.

                        
                           (A.1)
                           
                              
                                 
                                    
                                       
                                          minimize
                                          
                                       
                                    
                                    
                                       
                                          
                                             c
                                             0
                                          
                                          N
                                          +
                                          
                                             â
                                             
                                                i
                                                â
                                                I
                                             
                                          
                                          
                                             
                                                c
                                                i
                                             
                                             
                                                Ï
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.2)
                           
                              
                                 
                                    
                                       
                                          subject
                                          
                                          to
                                          
                                       
                                    
                                    
                                       
                                          N
                                          â
                                          
                                             â
                                             
                                                i
                                                â
                                                I
                                             
                                          
                                          
                                             r
                                             i
                                          
                                          
                                             Ï
                                             i
                                          
                                          â¥
                                          k
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.3)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Î»
                                             i
                                          
                                          =
                                          
                                             m
                                             i
                                          
                                          +
                                          
                                             â
                                             
                                                j
                                                â
                                                
                                                   Î
                                                   i
                                                
                                             
                                          
                                          
                                             (
                                             
                                                Î»
                                                j
                                             
                                             â
                                             
                                                Ï
                                                j
                                             
                                             )
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.4)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Î»
                                             i
                                          
                                          â¤
                                          
                                             Ï
                                             i
                                          
                                          +
                                          
                                             â
                                             
                                                j
                                                â
                                                
                                                   A
                                                   i
                                                
                                             
                                          
                                          
                                             Ï
                                             j
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.5)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Ï
                                             i
                                          
                                          â¤
                                          
                                             Î
                                             i
                                          
                                          
                                             X
                                             i
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.6)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Ï
                                             i
                                          
                                          â¤
                                          
                                             Î»
                                             i
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.7)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Ï
                                             i
                                          
                                          â¥
                                          
                                             Î»
                                             i
                                          
                                          â
                                          
                                             Î
                                             i
                                          
                                          
                                             (
                                             1
                                             â
                                             
                                                X
                                                i
                                             
                                             )
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.8)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Ï
                                             i
                                          
                                          â¥
                                          0
                                          ,
                                          â
                                          i
                                          â
                                          I
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.9)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          N
                                          â
                                          N
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (A.10)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             X
                                             i
                                          
                                          â
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          â
                                          i
                                          â
                                          I
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

We show that the binary knapsack problem (BKP) can be reduced to the LRU definition problem in polynomial time. Since the BKP is known to be NP-hard, see for example Martello and Toth (1990, p. 6), this proofs that also the LRU definition problem is NP-hard.

The BKP is the problem of selecting items j â J to put in a knapsack with a fixed capacity C, such that a profit is maximized. Each item j â J gives a profit pj
                      and has a weight wj
                     . An item j â J is selected to be put in the knapsack if 
                        
                           
                              x
                              j
                           
                           =
                           1
                        
                     ; 
                        
                           
                              x
                              j
                           
                           =
                           0
                        
                      otherwise. The mathematical model formulation is then

                        
                           
                              
                                 
                                    
                                       
                                          minimize
                                          
                                       
                                    
                                    
                                       
                                          
                                             â
                                             
                                                j
                                                â
                                                J
                                             
                                          
                                          
                                             p
                                             j
                                          
                                          
                                             x
                                             j
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          subject
                                          
                                          to
                                          
                                       
                                    
                                    
                                       
                                          
                                             â
                                             
                                                j
                                                â
                                                J
                                             
                                          
                                          
                                             w
                                             j
                                          
                                          
                                             x
                                             j
                                          
                                          â¤
                                          C
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             x
                                             j
                                          
                                          â
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          â
                                          j
                                          â
                                          J
                                       
                                    
                                 
                              
                           
                        
                     
                  

We next construct an instance of the LRU definition problem. We set 
                        
                           k
                           =
                           1
                        
                      and below we will show that as a result of our formulation, 
                        
                           N
                           =
                           2
                        
                     . For now, we thus assume that 
                        
                           k
                           â
                           N
                           =
                           â
                           1
                        
                     . We define a product structure with one dummy component, indicated by 
                        
                           â
                           1
                           ,
                        
                      that has |J| subcomponents; to be more precise, 
                        
                           
                              Î
                              
                                 â
                                 1
                              
                           
                           =
                           J
                        
                     . We define 
                        
                           
                              p
                              max
                           
                           =
                           
                              max
                              
                                 j
                                 â
                                 J
                              
                           
                           
                              {
                              
                                 p
                                 j
                              
                              }
                           
                        
                      and set 
                        
                           
                              c
                              
                                 â
                                 1
                              
                           
                           =
                           
                              p
                              max
                           
                        
                      and 
                        
                           
                              m
                              
                                 â
                                 1
                              
                           
                           =
                           0
                        
                     . We then set, for i â J, 
                        
                           
                              m
                              i
                           
                           =
                           1
                           ,
                        
                     
                     
                        
                           
                              c
                              i
                           
                           =
                           
                              p
                              max
                           
                           â
                           
                              p
                              i
                           
                           ,
                        
                      and 
                        
                           
                              r
                              i
                           
                           =
                           
                              w
                              i
                           
                           /
                           C
                        
                     . We come back to 
                        
                           
                              r
                              
                                 â
                                 1
                              
                           
                           ,
                        
                      but we assume for now that 
                        
                           
                              r
                              
                                 â
                                 1
                              
                           
                           =
                           0
                        
                     . The LRU definition problem for this instance is then:

                        
                           (B.1)
                           
                              
                                 
                                    
                                       
                                          minimize
                                          
                                       
                                    
                                    
                                       
                                          2
                                          
                                             c
                                             0
                                          
                                          +
                                          
                                             p
                                             max
                                          
                                          
                                             Î»
                                             
                                                â
                                                1
                                             
                                          
                                          +
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             (
                                             
                                                p
                                                max
                                             
                                             â
                                             
                                                p
                                                i
                                             
                                             )
                                          
                                          
                                             X
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (B.2)
                           
                              
                                 
                                    
                                       
                                          subject
                                          
                                          to
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             
                                                w
                                                i
                                             
                                             C
                                          
                                          
                                             X
                                             i
                                          
                                          â¤
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (B.3)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Î»
                                             
                                                â
                                                1
                                             
                                          
                                          =
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             (
                                             1
                                             â
                                             
                                                X
                                                i
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Î»
                                             i
                                          
                                          =
                                          1
                                          ,
                                          â
                                          i
                                          â
                                          J
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (B.4)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             Î»
                                             i
                                          
                                          â¤
                                          
                                             X
                                             i
                                          
                                          +
                                          
                                             Î»
                                             
                                                â
                                                1
                                             
                                          
                                          
                                             X
                                             
                                                â
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (B.5)
                           
                              
                                 
                                    
                                       
                                    
                                    
                                       
                                          
                                             X
                                             i
                                          
                                          â
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          â
                                          i
                                          â
                                          J
                                          âª
                                          
                                             {
                                             â
                                             1
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

To see that the objective function is correct, there are two things to notice. Firstly, notice that we omit the term 
                        
                           X
                           
                              â
                              1
                           
                        
                      from the objective function because 
                        
                           
                              X
                              
                                 â
                                 1
                              
                           
                           =
                           0
                           â
                           
                              Î»
                              
                                 â
                                 1
                              
                           
                           =
                           0
                           ,
                        
                      while 
                        
                           
                              X
                              
                                 â
                                 1
                              
                           
                           =
                           1
                           ,
                        
                      otherwise. Secondly, notice that we omit the term Î»i
                      from the objective function because 
                        
                           
                              Î»
                              i
                           
                           =
                           1
                        
                      for i â J as a result of Constraint (B.3). Using that 
                        
                           
                              Î»
                              
                                 â
                                 1
                              
                           
                           =
                           
                              â
                              
                                 i
                                 â
                                 J
                              
                           
                           
                              (
                              1
                              â
                              
                                 X
                                 i
                              
                              )
                           
                           ,
                        
                      following Constraint (B.3), and that Xi
                      â {0, 1}, we can rewrite the objective function to become:

                        
                           
                              
                                 minimize
                                 
                                 2
                                 
                                    c
                                    0
                                 
                                 +
                                 
                                    p
                                    max
                                 
                                 
                                    |
                                    J
                                    |
                                 
                                 â
                                 
                                    â
                                    
                                       i
                                       â
                                       J
                                    
                                 
                                 
                                    p
                                    i
                                 
                                 
                                    X
                                    i
                                 
                                 ,
                              
                           
                        
                     and since the first two terms are constant, this is equivalent to:

                        
                           
                              
                                 maximize
                                 
                                 
                                    â
                                    
                                       i
                                       â
                                       J
                                    
                                 
                                 
                                    p
                                    i
                                 
                                 
                                    X
                                    i
                                 
                                 .
                              
                           
                        
                     By further noticing that in Constraint (B.2) we can multiply both sides of the equation by C and that Constraints (B.3) and (B.4) are basically used for book keeping, we see that we have constructed an instance of the LRU definition problem that, when solved, gives the solution for our original binary knapsack problem. (Notice that to find Constraint (B.2) we have used that we can make both sides positive instead of negative, which means that the inequality is reversed.)

The only point remaining is that we need to ensure that 
                        
                           N
                           =
                           2
                        
                     . We can achieve this by, on the one hand, ensuring that there is always a strictly positive (small) workload, so that 
                        
                           N
                           >
                           k
                           =
                           1
                           ,
                        
                      and on the other hand, setting 
                        
                           
                              c
                              0
                           
                           â¥
                           
                              p
                              max
                           
                           
                              |
                              J
                              |
                           
                        
                      so that N â¤ 2. Ensuring that there is always a small workload can be achieved by setting 
                        
                           
                              r
                              
                                 â
                                 1
                              
                           
                           =
                           Ïµ
                        
                      and setting 
                        
                           
                              r
                              i
                           
                           =
                           Ïµ
                           +
                           
                              w
                              i
                           
                           
                              (
                              1
                              â
                              Ïµ
                              |
                              J
                              |
                              )
                           
                           /
                           C
                           ,
                        
                      with 
                        
                           
                              Ïµ
                              |
                              J
                              |
                              <
                              <
                           
                           
                              min
                              
                                 i
                                 â
                                 J
                              
                           
                           
                              {
                              
                                 w
                                 i
                              
                              }
                           
                           ,
                        
                      and 
                        
                           0
                           <
                           Ïµ
                           |
                           J
                           |
                           <
                           1
                        
                     . Instead of Eq. (B.2) above, Eq. 2 in the LRU definition model will then become (notice that 
                        
                           
                              Î»
                              
                                 â
                                 1
                              
                           
                           =
                           
                              â
                              
                                 i
                                 â
                                 J
                              
                           
                           
                              (
                              1
                              â
                              
                                 X
                                 i
                              
                              )
                           
                        
                     ):

                        
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          N
                                          â
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             [
                                             Ïµ
                                             +
                                             
                                                
                                                   
                                                      w
                                                      i
                                                   
                                                   
                                                      (
                                                      1
                                                      â
                                                      Ïµ
                                                      |
                                                      J
                                                      |
                                                      )
                                                   
                                                
                                                C
                                             
                                             ]
                                          
                                          
                                             X
                                             i
                                          
                                          â
                                          Ïµ
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             (
                                             1
                                             â
                                             
                                                X
                                                i
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                          â¥
                                          k
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             Ïµ
                                             |
                                             J
                                             |
                                          
                                          +
                                          
                                             â
                                             
                                                i
                                                â
                                                J
                                             
                                          
                                          
                                             
                                                
                                                   w
                                                   i
                                                
                                                
                                                   (
                                                   1
                                                   â
                                                   Ïµ
                                                   |
                                                   J
                                                   |
                                                   )
                                                
                                             
                                             C
                                          
                                          
                                             X
                                             i
                                          
                                       
                                    
                                    
                                       
                                          â¤
                                          N
                                          â
                                          k
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     which ensures that there is always a small positive workload, while the same optimal solution will still result.

In this appendix, we explain the problem instances generator. The settings that we use for the parameters are listed in Table 2 in Section 5.1. In the explanation here, we assume setting 1 for each parameter. The number of items per indenture level are given in Table 1 in Section 5.1. Each item at indenture level 
                        
                           L
                           +
                           1
                        
                      is randomly assigned to a parent (at indenture level L) using a uniform distribution on the parent indentureâs index range. The number of children per parent will thus differ per parent. The annual demand for an item, mi
                     , is drawn per item from a uniform distribution on the interval [0.01; 0.1]. The leaf itemâs replacement costs, i.e., ci
                     , for 
                        
                           i
                           â
                           I
                           â£
                           
                              Î
                              i
                           
                           =
                           â
                           ,
                        
                      are drawn from a shifted exponential distribution with shift factor 1000 and rate parameter 
                        
                           7
                           /
                           (
                           10
                           ,
                           000
                           â
                           1
                           
                           000
                           )
                        
                     . As a result, we do not have items with a price below 1000â euros and approximately 5Â percent of the itemsâ prices exceed 10, 000Â euros. Therefore, there are typically more cheap items than expensive items. The parameter fc
                      is drawn from a uniform distribution on the range [0.5; 1.5]. The item replacement lead time per hour, ri
                     , is drawn from a uniform distribution on the range [0.25; 2]. Asset prices are drawn from a uniform distribution on the range 1000âeuros Ã [200; 400].


                     Table D.5 shows a summary of the LRU requirements at Thales, including mandatory and preferred criteria.


                     Table E.6
                      shows the results for PS1, PS2 and PS3. We only show the full list of results for parameter settings in PS1, because these parameter settings had similar results in PS2 and PS3.

@&#REFERENCES@&#

