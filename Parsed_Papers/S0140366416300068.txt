@&#MAIN-TITLE@&#Statistical estimation of the names of HTTPS servers with domain name graphs

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present the domain name graph (DNG), which is a formal expression that can keep track of CNAME chains and characterize the dynamic and diverse nature of DNS mechanisms and deployments.


                        
                        
                           
                           We develop a framework called Service-Flow map (SFMap) that works on top of the DNG. SFMap estimates the hostname of an HTTPS server when given a pair of client and server IP addresses. It can statistically estimate the hostname even when associating DNS queries are unobserved due to caching mechanisms, etc.


                        
                        
                           
                           Through extensive analysis using real packet traces, we demonstrate that the SFMap framework establishes good estimation accuracies and can out- perform the state-of-the art technique called DN-Hunter. We also identify the optimized setting of the SFMap framework. The experiment results suggest that the success of the SFMap lies in the fact that it can complement incomplete DNS information by leveraging the graph structure.


                        
                        
                           
                           To cope with large-scale measurement data, we introduce techniques to make the SFMap framework scalable. We validate the effectiveness of the approach using large-scale traffic data collected at a gateway point of Internet access links.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Traffic analysis

SSL/TLS

DNS

Graph

@&#ABSTRACT@&#


               
               
                  Adoption of SSL/TLS to protect the privacy of web users has become increasingly common. In fact, as of September 2015, more than 68% of top-1M websites deploy SSL/TLS to encrypt their traffic. The transition from HTTP to HTTPS has brought a new challenge for network operators who need to understand the hostnames of encrypted web traffic for various reasons. To meet the challenge, this work develops a novel framework called SFMap, which estimates names of HTTPS servers by analyzing precedent DNS queries/responses in a statistical way. The SFMap framework introduces domain name graph, which can characterize highly dynamic and diverse nature of DNS mechanisms. Such complexity arises from the recent deployment and implementation of DNS ecosystems; i.e., canonical name tricks used by CDNs, the dynamic and diverse nature of DNS TTL settings, and incomplete and unpredictable measurements due to the existence of various DNS caching instances. First, we demonstrate that SFMap establishes good estimation accuracies and outperforms a state-of-the-art approach. We also aim to identify the optimized setting of the SFMap framework. Next, based on the preliminary analysis, we introduce techniques to make the SFMap framework scalable to large-scale traffic data. We validate the effectiveness of the approach using large-scale Internet traffic.
               
            

@&#INTRODUCTION@&#


                     Background:

Monitoring and understanding traffic mix is crucial for network operators. Port number conventions and deep packet inspection (DPI) are widely used to understand the breakdown of traffic mix. However, these techniques have become less effective for the following reasons. First, the majority of modern services, such as social networking service, video, and messaging services, are all performed over web traffic [15], and port number information is too coarse-grained to distinguish such services from each other. Second, the encryption of communication channels has disabled inspection of HTTP headers, which include useful information such as uniform resource identifiers (URIs). Modern protocols for accelerating the web such as SPDY and Websocket employ mandatory encryption of HTTP with SSL/TLS (secure socket layer/transport layer security), i.e., HTTPS. Naylor et al. [13] recently reported that fraction of HTTPS traffic volume measured at a large-scale ISP has significantly increased over these 2+ years (from April 2012 to July 2014). They also found that their measurement study suggests that cost of deploying HTTPS is decreasing. In fact, the Internet survey data collected by the [17] shows that as of September 2015, more than 68% of the Alexa Top 1M web sites [1] deploy SSL/TLS to encrypt their traffic. Hence, the increasing adoption of HTTPS brings new research challenges to traffic classification problems as discussed in the past studies such as [2,7] 
                     
                        1
                     
                     
                        1
                        We note that server name indication (SNI) extension of TLS can be used to obtain hostname of HTTPS server. However, there are many client/server implementations that do not adopt SNI. In fact, in our dataset, roughly half of HTTPS clients did not use the SNI extension.
                     
                     
                     .


                     Goal and challenges:

Based on the aforementioned information, this work aims to enable network operators to infer the hostnames of HTTPS traffic. Hostname information is useful for network operators to understand what types of services are carried over HTTPS flows. Although the IP address property of an HTTPS server may reveal that the server is used by a particular company such as Google, this information often fails to provide us with information about the services that are used over the flow, such as web searches, blogs, and videos. Such services are associated with distinct hostnames such as www.google.com, www.blogspot.com, and www.youtube.com. Bermudez et al. [2] revealed that simple reverse DNS lookup does not return accurate domain information used by HTTPS servers. Thus, to understand the traffic mix of HTTPS flows, we need to infer server hostnames.

The main idea of our approach is to correlate HTTPS flows and DNS queries/responses. The basic assumption is that prior to requesting an HTTPS flow, a web application should resolve the IP address of the HTTPS server by querying a DNS query. Therefore, by monitoring prior DNS queries/responses, we can estimate the hostname that is associated with IP address of the HTTPS server. Although this approach might look trivial, there are three practical challenges.

(Challenge 1) Canonical name (CNAME) tricks used by CDNs
                  

First, modern CDN providers leverage CNAME tricks to accelerate the efficiency of content delivery [16]. Fig. 1 shows an example of a CNAME chain used by a CDN provider. Here, assume that we know that the IP address of an observed HTTPS server is 
                        
                           s
                           1
                           =
                           23.2.132.181
                        
                     . Now, our task is to associate s1 with the original hostname, 
                        
                           n
                           1
                           =
                        
                      
                     www.ieee.org. However, as is shown in Fig. 1, n1 is not directly resolved to s1 due to the existence of the CNAME chain. Using this chain structure, a CDN provider can provide the optimal server IP address s1 to serve the content of n1 to client c1. Thus, to associate s1 and n1, we need to keep track of the CNAME chain, which exhibits dynamic and complex behavior as we shall see soon.

(Challenge 2) Incomplete measurements
                  

A DNS record can be cached by several mechanisms such as local DNS resolvers, DNS caching within operating systems, and DNS caching within applications such as web browsers. The implementations of these caching mechanisms are diverse. Some recent implementations used in web browsers store DNS records aggressively to improve response time, thereby ignoring DNS TTL settings [4]. Even though such implementations violate the rule of DNS TTL, they can work because even if a selected server IP address is no longer an optimal one, the server IP address generally continues to be valid. Thus, due to the standard and illicit caching mechanisms, a DNS query, which should have appeared prior to an HTTP request, is often invisible. The absence of DNS queries suggests that we require estimation techniques to recover incomplete measurements.

(Challenge 3) Dynamicity, diversity, and ambiguity
                  

Every hostname used in DNS is assigned a time-to-live (TTL), which defines the lifetime of the hostname within a stub DNS resolver. If the hostname is not queried again before the TTL has expired, the DNS record of the hostname will be removed from a stub DNS resolver. In general, the hostnames in a CNAME chain have different TTL values. Fig. 2 presents an example of cumulative distributive function (CDF) of TTL values for hostnames that are resolved to IP addresses (A record) and hostnames that are resolved to CNAMEs (CNAME record). Note that the data was taken from a mid-sized production network, and the characteristics of CDF were the same for other dataset. The graph clearly shows that A record hostnames have shorter TTLs than CNAME hostnames. For example, more than 50% of A record hostnames have TTL values that are less than 60 s. This indicates that the association between hostnames and IP addresses is highly dynamic. These hostnames have shorter TTLs because CDN providers tend to control traffic at a fine granularity [4].

The diversity of TTL values and DNS caching mechanisms leads to ambiguity of CNAME association behavior. We illustrate an actual sample in Fig. 3
                     , which presents DNS resolutions for a client, c1. The first observation generates the relationship between s1 and n1 for client c1. The second observation generates the relationship between s2 and n2 for client c1. Now, assume an estimation problem. If we observe the pair (c1, s1), which hostname should it be associated with? If we simply keep the relationships shown above, the answer is n1. However, due to the existence of intermediate CNAME node m1, the actual answer is n2 because m1 is now associated with s2 by a query of n2, and n1 is associated with m1 due to a caching mechanism. Note that this behavior depends on the implementation of the stub DNS resolver used by the client c1. If the implementation ignores intermediate CNAME nodes, the answer could be n1. Thus, there is an intrinsic ambiguity in CNAME associations.


                     Contributions:

In this work, we present a novel methodology that aims to infer the hostnames of HTTPS flows, given the three research challenges shown above. The key contributions of this work are summarized as follows.

                        
                           •
                           We present the domain name graph (DNG), which is a formal expression that can keep track of CNAME chains (Challenge 1) and characterize the dynamic and diverse nature of DNS mechanisms and deployments (Challenge 3).

We develop a framework called Service-Flow map (SFMap) that works on top of the DNG. SFMap estimates the hostname of an HTTPS server when given a pair of client and server IP addresses. It can statistically estimate the hostname even when associating DNS queries are unobserved due to caching mechanisms, etc. (Challenge 2).

Through extensive analysis using real packet traces, we demonstrate that the SFMap framework establishes good estimation accuracies and can outperform the state-of-the art technique called DN-Hunter, [2]. We also identify the optimized setting of the SFMap framework. The experiment results suggest that the success of the SFMap lies in the fact that it can complement incomplete DNS information by leveraging the graph structure.

To cope with large-scale measurement data, we introduce techniques to make the SFMap framework scalable. We validate the effectiveness of the approach using large-scale traffic data collected at a gateway point of Internet access links.

The remainder of this paper is organized as follows: Section 2 summarizes the related work. Section 3 describes the proposed SFMap framework in detail. In Section 4, using the small and mid-size data, we perform performance evaluation to identify the optimized setting of the SFMap framework. Section 5 proposes techniques that make the SFMap framework scalable. We also validate the effectiveness of the approach using large-scale traffic data. Section 6 discusses the limitations of SFMap and future research directions. Finally, we conclude our work in Section 7.

@&#RELATED WORK@&#

Many studies have examined the Internet traffic classification problem. 68 studies on the topic is listed in [3]. Here, we focus our attention on the studies that make use of DNS information to the traffic classification problem; [2,10,14]. Mori et al. [10] proposed a method to identify traffic originating from large-scale video-sharing services such as YouTube. The key idea was to extract the rules of IP address numbering and naming conventions of fully qualified domain names (FQDNs) used for the services. Although their approach may work for a limited scope, it cannot be used to solve more generic web traffic classification problems. Plonka and Barford [14] presented a traffic classification method that uses DNS traffic. They developed a method that stores per client DNS rendezvous state information in a tree-like data structure. Although their results demonstrated that the DNS rendezvous-based method performs well, even for encrypted traffic, their goal was different from ours because they assumed that DNS traffic implies the ground truth. In contrast, our goal is to estimate the hostnames of HTTPS traffic from the observations of DNS traffic. Bermudez et al. [2] developed a framework called DN-Hunter, which aims to classify traffic flows using DNS traffic. DN-Hunter uses a FIFO (first-in first-out) circular list to store the relationships among FQDN information and client-server pairs. Since the scope of DN-Hunter is mostly similar to ours, this work compares the performance of SFMap with DN-Hunter.

This section describes SFMap in detail. Section 3.1 presents the overview of the SFMap framework. Section 3.2 describes DNG, which is a key component of the SFMap framework. Section 3.3 details how SFMap estimates hostnames. Lastly, Section 3.4 explains how SFMap updates DNG and statistics that are used for the estimation.

@&#OVERVIEW@&#

The goal of SFMap is to infer a hostname n of an HTTPS flow by associating preceding DNS responses with a flow key, which is defined with a pair of server IP address s and client IP address c. To this end, SFMap needs to address the research challenges discussed in Section 1. To tackle the research challenges, the SFMap framework works on top of DNG, which will be detailed in the next subsection. A DNG keeps track of the structure of DNS records; thus, it can deal with CNAME chains (Challenge 1). Next, by relaxing the constraints of the DNG, the SFMap framework can handle cases wherein there are no preceding DNS responses that are associated with the client-server pair (challenge 2). The details of the hostname estimation will be described in Section 3.3. Finally, by adequately maintaining the DNG and using the observed TTL values, the SFMap framework can deal with the dynamic nature of DNS mechanisms (Challenge 3). The updating mechanism for the DNG will be discussed in Section 3.4.


                        Fig. 4 summarizes the components of the SFMap framework. SFMap has three main functions, i.e., Learner, Estimator, and Updater. Learner consists of two components: the DNG and the Frequency counter. Learner component reads DNS queries/responses and builds and keeps the DNG and Frequency counter. Estimator performs host estimation; i.e., given a pair of client-server IP addresses (c, s) for an HTTPS flow, estimator returns the most plausible hostname(s) using the information collected from DNG and Frequency counters. Updater reads DNS queries/responses and updates the status of the DNG and the Frequency counter.

Given these primitives, our problem can be formulated as maximum likelihood estimation (MLE) under the constraints of a DNG. Given c and s in an HTTPS flow, the MLE is formulated as follows.

                           
                              (1)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                n
                                                ^
                                             
                                             
                                                (
                                                c
                                                ,
                                                s
                                                )
                                             
                                             =
                                             
                                                argmax
                                                
                                                   n
                                                   ∈
                                                   N
                                                
                                             
                                             Pr
                                             
                                                (
                                                n
                                                ,
                                                c
                                                ,
                                                s
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                          
                                       
                                       
                                       
                                          
                                             N
                                             =
                                             {
                                             n
                                             ∈
                                             
                                                V
                                                c
                                             
                                             :
                                             n
                                             
                                                →
                                                
                                                   G
                                                   c
                                                
                                             
                                             s
                                             }
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 G
                                 c
                              
                              =
                              
                                 (
                                 
                                    V
                                    c
                                 
                                 ,
                                 
                                    E
                                    c
                                 
                                 )
                              
                           
                         denotes a DNG built for c, and binary operator 
                           
                              x
                              
                                 →
                                 G
                              
                              y
                           
                         represents whether vertex x can reach to vertex y on graph G. In the following, we describe how we build and update Gc
                        , how we extract N, how we compute the likelihood probability Pr(n, c, s), and how we get the final estimation 
                           
                              n
                              ^
                           
                        .

A DNG, Gc
                        , is a directed graph used to keep A and CNAME records observed in DNS responses queried by client c. DNGs can be built separately for each client c. A vertex, v ∈ Vc
                        , is a server IP address or a hostname, while an edge, e ∈ Ec
                        , represents an A or CNAME record that links a vertex to another vertex. Each edge is grafted by a corresponding A or CNAME record observed in a DNS response, and is associated with its expire time determined by observed TTL. If an edge, e ∈ Ec
                        , is expired, it will be removed from Gc
                        .

Here, we examine how the DNG expression naturally represents the behavior of DNS resolution. Assume that clients obtain a server address via DNS responses only and that we have never missed any DNS response for the clients; i.e., DNG Gc
                         represents all name resolutions requested by a client c. When a client c sends an HTTP request to a server n, the server n’s IP address s should have been resolved by DNS. This association of n and s obtained through the DNS mechanism can be expressed as a path from n to s on the DNG Gc
                        . Note that there are cases where we cannot find such a path due to the caching mechanisms. In such cases, we need to employ several techniques that will be described soon.

In the estimation phase, we must first select candidate hostnames that are likely the original hostname for a given client-server pair (c, s). We extract a set of candidate hostnames N from DNG Gc
                        , using Eq. 2. If |N| ≥ 1, we estimate the hostname with the MLE shown in Eq. 1. A method to calculate the likelihood probability Pr(n, c, s) will be shown later.

As we mentioned in Section 1, N can be an empty set due to the standard and illicit DNS caching mechanisms. In such cases, we cannot directly associate an HTTPS flow with preceding DNS responses. To deal with these cases, SFMap extends the candidate hostnames by relaxing the constraint of edge expiration. This relaxation enables us to select hostnames that are missed due to the existence of DNS clients that ignore DNS TTL for improving the user experience. Now, N is obtained as

                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             N
                                             =
                                             {
                                             n
                                             ∈
                                             
                                                V
                                                c
                                             
                                             :
                                             n
                                             
                                                →
                                                
                                                   
                                                      G
                                                      ˜
                                                   
                                                   c
                                                
                                             
                                             s
                                             }
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    G
                                    ˜
                                 
                                 c
                              
                              =
                              
                                 (
                                 
                                    V
                                    c
                                 
                                 ,
                                 
                                    
                                       E
                                       ˜
                                    
                                    c
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 E
                                 ˜
                              
                              c
                           
                         include both valid and expired edges.

Finally, if we do not have any candidate hostnames at this stage, we use the union of all clients’ DNGs. We call such DNG as union DNG. We also call the original DNS as local DNG. While local DNG considers per-client status such as TTL expiration, union DNG ignores them. However, union DNG can cover the cases when a DNS query is not observed for a client. In other words, we use the observations of other clients as a hint to estimate the most plausible hostname. Let C denote a set of all clients. The union DNG is defined as 
                           
                              G
                              =
                              (
                              V
                              =
                              
                                 ⋃
                                 
                                    c
                                    ∈
                                    C
                                 
                              
                              
                                 V
                                 c
                              
                              ,
                              E
                              =
                              
                                 ⋃
                                 
                                    c
                                    ∈
                                    C
                                 
                              
                              
                                 E
                                 c
                              
                              )
                           
                        . Using the union DNG G, the candidate hostnames can be selected as

                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             N
                                             =
                                             {
                                             n
                                             ∈
                                             V
                                             :
                                             n
                                             
                                                →
                                                G
                                             
                                             s
                                             }
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        It then estimates the hostname with the following MLE formulation:

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                n
                                                ^
                                             
                                             =
                                             
                                                argmax
                                                
                                                   n
                                                   ∈
                                                   N
                                                
                                             
                                             Pr
                                             
                                                (
                                                n
                                                ,
                                                s
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        Like Eq. 3, we can further relax the constraint of expiration for the union DNG G; i.e.,

                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             N
                                             =
                                             {
                                             n
                                             ∈
                                             V
                                             :
                                             n
                                             
                                                →
                                                
                                                   G
                                                   ˜
                                                
                                             
                                             s
                                             }
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 G
                                 ˜
                              
                              =
                              
                                 (
                                 V
                                 ,
                                 
                                    E
                                    ˜
                                 
                                 )
                              
                           
                         and 
                           
                              E
                              ˜
                           
                         include both valid and expired edges.

To recap, the Estimator runs the combinations below from top to bottom in a step-by-step manner until a plausible hostname is found. For future reference, we give names to these steps, where LE and UE refer to Local and Union Estimators, and NTE refers to “No TTL Expiration”. For instance, the estimator LE-NTE (Local Estimator with No TTL Expiration) starts with the first step and continues to the second step until at least one candidate hostname is found, but will not proceed to the third and fourth steps. We will examine the accuracies of these estimators to study the factors that contribute to improve the estimation accuracies.


                        
                           
                              
                                 
                                 
                                 
                                 
                                 
                                    
                                       Step
                                       MLE
                                       Constraint
                                       Name
                                    
                                 
                                 
                                    
                                       1st
                                       
                                          Eq. (1)
                                       
                                       
                                          Eq. (2)
                                       
                                       LE
                                    
                                    
                                       2nd
                                       
                                          Eq. (1)
                                       
                                       
                                          Eq. (3)
                                       
                                       LE-NTE
                                    
                                    
                                       3rd
                                       
                                          Eq. (5)
                                       
                                       
                                          Eq. (4)
                                       
                                       UE
                                    
                                    
                                       4th
                                       
                                          Eq. (5)
                                       
                                       
                                          Eq. (6)
                                       
                                       UE-NTE
                                    
                                 
                              
                           
                        
                     

Finally, we note the time complexity of the Union Estimators. In the Union DNG, a single-source path search from s with reverse edges requires O(|E|) on a directed acyclic graph with topological sort, and frequency lookups are executed for n ∈ N⊆V. Therefore, the time complexity of Union Estimators is 
                           
                              O
                              (
                              |
                              V
                              |
                              +
                              |
                              E
                              |
                              )
                           
                        . However, we empirically revealed that the actual mean time complexity is much smaller than this worst-case upper bound, and is close to 
                           
                              O
                              (
                              |
                              
                                 V
                                 c
                              
                              |
                              +
                              |
                              
                                 E
                                 c
                              
                              |
                              )
                           
                         because majority of hostnames can be estimated with LE and LE-NTE as we shall show in Section 4. The details are omitted due to the space limitation.

To calculate the likelihood probabilities, we make use of empirical data. Let Fc
                           (n, s) denote the frequency of DNS messages queried by client c for hostname n with resolved address s. Using Fc
                           (n, s), Eq. 1 can be calculated as

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   argmax
                                                   
                                                      n
                                                      ∈
                                                      N
                                                   
                                                
                                                Pr
                                                
                                                   (
                                                   n
                                                   ,
                                                   c
                                                   ,
                                                   s
                                                   )
                                                
                                                =
                                                
                                                   argmax
                                                   
                                                      n
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   F
                                                   c
                                                
                                                
                                                   (
                                                   n
                                                   ,
                                                   s
                                                   )
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           Similarly, Eq. 5 can be calculated as

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   argmax
                                                   
                                                      n
                                                      ∈
                                                      N
                                                   
                                                
                                                Pr
                                                
                                                   (
                                                   n
                                                   ,
                                                   s
                                                   )
                                                
                                                =
                                                
                                                   argmax
                                                   
                                                      n
                                                      ∈
                                                      N
                                                   
                                                
                                                F
                                                
                                                   (
                                                   n
                                                   ,
                                                   s
                                                   )
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 F
                                 
                                    (
                                    n
                                    ,
                                    s
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       c
                                       ∈
                                       C
                                    
                                 
                                 
                                    F
                                    c
                                 
                                 
                                    (
                                    n
                                    ,
                                    s
                                    )
                                 
                              
                           . The method to update the frequency will be shown in the next subsection.

The Updater updates DNG Gc
                         and frequency Fc
                         when it receives a DNS response. A DNS response is associated with client c and queried hostname n
                        ⋆. The response also includes a set of A records and another set of CNAME records. Let these sets be A and M, respectively. An A record associates hostname n and server address s, while a CNAME record associates two hostnames n′ and n. Let these records be (n, s) ∈ A and (n′, n) ∈ M, respectively.

Due to the existence of short TTL value set for an A record, a client often resolves an intermediate hostname (i.e., CNAME) instead of the original one. In such a case, the frequency of an original hostname is undervalued. To cope with such a case, SFMap increments the frequencies of all original hostnames that can reach to the queried hostname. Let a set of edges be 
                           
                              
                                 E
                                 c
                              
                              =
                              
                                 {
                                 
                                    (
                                    
                                       n
                                       
                                          ′
                                          ′
                                       
                                    
                                    ,
                                    n
                                    )
                                 
                                 ,
                                 
                                    (
                                    
                                       n
                                       ′
                                    
                                    ,
                                    n
                                    )
                                 
                                 ,
                                 
                                    (
                                    n
                                    ,
                                    s
                                    )
                                 
                                 }
                              
                              ,
                           
                         where n is a CNAME of n′′ or n′. If 
                           
                              
                                 n
                                 ☆
                              
                              =
                              n
                           
                         is queried, the Updater increments Fc
                        (n′′, s) and Fc
                        (n′, s), instead of Fc
                        (n, s). Note that we assume that original hostnames should be leaf vertices on a DNG (a leaf is a vertex without incoming edge). In fact, more than 99.7% of requested hostnames are leaf vertices in our observations.


                        Algorithm 1
                         presents an algorithm that updates Gc
                         and Fc
                         upon receiving a DNS response, (c, n
                        ⋆, A, M). We discount the incremental value by the number of (n′, s) pairs at Line 7, because the algorithm increments Fc
                         for all n′ ∈ V reachable to n
                        ⋆ and for all s in A. At Line 3, we update the expiration time of edge (u, v). In addition to Algorithm 1, the Updater periodically checks the TTL expiration for all edges. If the DNS TTL expires for an edge (u, v), the edge will be removed. The time complexity of maintenance is O(|Vc
                        |) for the loop at Line 5, assuming 
                           
                              O
                              (
                              |
                              A
                              |
                              )
                              =
                              O
                              (
                              |
                              M
                              |
                              )
                              =
                              O
                              (
                              1
                              )
                           
                        .

@&#PERFORMANCE EVALUATION@&#

In this section, we evaluate the performance of the SFMap framework through extensive experiments. On the basis of the experiment results, we also aim to identify the optimum setting for the SFMap framework. To these ends, we first describe the data sets used and present some basic statistics derived from the data. Next, we evaluate the estimation accuracy of SFMap in various conditions. For reference, we compare the performance of SFMap with DN-Hunter [2]. Finally, we summarize the lessons learned for optimizing the SFMap framework.

To investigate the effectiveness of SFMap, we used the two datasets, LAB and PROD, which are the packet traces collected from a gateway router of local area network used by a research group and a gateway router of middle-scale production network, respectively. The basic statistics of the datasets are summarized in Table 1
                        
                        . As is shown in Table 1, the datasets cover two different scales, small and middle. Both datasets have same time length, 12 h. Of the 12 h, the last two hours are used to examine the accuracy; i.e., the first 10 h are used for warm-up phase. We adopted the length of warm-up from the observation of TTL distribution shown in Fig. 2; i.e., majority of the DNS resource records had TTL values less than 10 h.

Here, we present the characteristics of DNGs derived from our datasets. Table 2
                         presents the statistics of the DNGs. For brevity, we omit DNGs with TTL expiration because these DNGs should be smaller than those without TTL expiration. As is shown in the table, Union DNGs have fewer nodes and edges. For instance, since the number of clients for the LAB dataset is 10 (see Table 1), the total number of nodes in the Local DNGs should be 
                           
                              10
                              ×
                              460
                              =
                              4600
                           
                        . Thus, the number of total nodes in the Union DNG (=2849) is less than the number of total nodes in the Local DNGs. This observation implies that (1) each client-server pair in the Local DNGs has duplicate nodes and edges, and (2) the Union DNGs can be maintained with less memory. Fig. 5 shows the CDF of the number of candidate hostnames/domains for each HTTP request. Here, a candidate domain is the domain of a host (public suffix). The results suggest that roughly 15% of the HTTP requests have multiple candidates; i.e., we must statistically estimate the original hostname from these candidates.

Our methodology was evaluated using the two datasets. We make use of HTTP as a means to evaluate the accuracy of our methodologies. The ground truth was obtained from HTTP request headers, which contain hostname information. We note that although the distributions of hostnames could be different between HTTP and HTTPS, the fundamental mechanism of resolving hostname before starting HTTP/HTTPS communication should be identical. From the packet traces, we read DNS packets to build and update the DNGs. For each HTTP request pair (c, s), we estimate the hostname and compare it against the ground truth. For comparison purposes, we implemented DN-Hunter [2]. DN-Hunter has a single parameter that determines the size of memory, which keeps track of tuples of (c, s, N), where N is a hostname. To obtain the highest performance of DN-Hunter, we set infinite amount of memory size. We note that this configuration did not overflow physical memory we used in our experiments.


                        Tables 3
                         and4
                         summarize the results, where we use the notations introduced in Section 3.3. Table 3 shows the estimation accuracies in the context of exact matching, and Table 4 relaxes matching using a public suffix [12]; i.e., we can see that aaa.example.com and bbb.example.com are matched in the context of the public suffix. Using the public suffix matching allows us to distinguish hostnames with different domains, e.g., youtube.com and google.com.

First, the accuracies were improved for estimators with no TTL expiration (NTE). This observation suggests that there are a non-negligible number of DNS implementations that ignore TTL settings, which agrees with a previous report [4]. Second, the Union DNG also contributed to improve the accuracy. This observation suggests that using other clients’ information is useful in improving the accuracy when no other hint is available. Third, if we allow public suffix matching, accuracies are further improved for all the estimators. The UE-NTE achieved roughly 95% of accuracy for both datasets. Finally, the UE-NTE outperformed DN-Hunter. For the exact matching experiments, while the estimation error rates of DN-Hunter were 15-32%, the estimation error rates of UE-NTE were 8–9%. Thus, UE-NTE successfully reduced the error rates by 50–70%.

DN-hunter returns a single hostname given a client-server pair; however, if there are multiple candidate hostnames, SFMap can return several hostnames with the highest likelihood probabilities. Table 5
                         shows the results where we accept the top three hostnames as estimation. Notably, accuracies exceed 96–98% for exact matching if we pick up the top three hostnames. We note that in most cases, the hostnames ranked in the top three look similar. For instance, the top three hostnames are: pagead2.googlesyndication.com, pubads.g.doubleclick.net, and googleads.g.doubleclick.net, which are all attributed to Ad Network services. Thus, by extending the candidate hostnames, we can establish better estimations that work in practice. This extension is acceptable for our original motivation; i.e., understanding the mix of HTTPS traffic.

We summarize the lessons learned for optimizing the SFMap framework as follows. First, due to the existence of many DNS implementations that likely ignore DNS TTL, we found that omitting TTL expiration on DNG nodes leads to the improvement of the estimation accuracy. Second, we found that introducing the Union DNG improves the estimation accuracy. The observation suggests that the graph structure plays a key role in extracting other client’s information, which enables us to complement the incomplete DNS information. Thus, we conclude that UE-NTE is the optimal setting for the SFMap framework.

As the Internet traffic continuously keeps growing, we may want to ask whether the SFMap framework works for large-scale networks. To answer the question, we empirically study the scalability of the SFMap framework. In this section, we first study the memory consumption and data processing time of the SFMap framework, using the three data sets, LAB, PROD, and ACCESS. The last one is a new, and large data set we describe later. We then introduce two techniques, path sampling and graph partitioning, which improve the scalability of the SFMap framework. We validate the scalability of the SFMap framework, using the ACCESS dataset. Throughout this section, we adopt the UE-NTE, which we validated as the optimum setting in the previous section.

The ACCESS data is a set of packet traces collected at a large-scale Internet access link. The vantage point was located at a gateway point where several thousands of users reside. Due to the NDA with the data provider, other details such as exact number of users, type of the network link, network topology, and the traffic statistics such as top popular domain names cannot be disclosed in this paper. Tables 6
                         and 7
                         summarize the basic statistics of the ACCESS dataset. To make the condition become consistent among the three data sets, the lengths of learning time and estimating time were configured to 12 h and 2 h, respectively. Compared with the statistics presented in Table 1, we notice that the scale of the ACCESS data is roughly 100 times larger than that of PROD data set; i.e., the data set is useful in examining the scalability of the SFMap framework.

Using the three datasets, LAB, PROD, and ACCESS, we study the memory consumption and data processing time of the SFMap framework. For this experiment, we used our implementation of the SFMap framework written in Python. We note that the implementation has much room for improvement in terms of optimizing resource management. Table 8
                         shows the amount of time/memory to process the entire data, including data for warm-up. The results demonstrate that our implementation of SFMap works within a reasonable amount of memory for LAB and PROD data sets, i.e., less than 40 MB for LAB and less than 700 MB for PROD. For the ACCESS data set, 28 GB of memory space was needed for our implementation. Although that amount of memory consumption is affordable for modern commodity servers, we need to make the memory management scheme scalable to the size of data. Also, for LAB and PROD, the processing time is much shorter than the actual measurement length, 12 h. Thus, SFMap should work in a real-time fashion. However, for the ACCESS data set, the data processing time was longer than 12 h; i.e., it will not work in a real-time fashion. Thus, our experiment suggests that we need to make the SFMap framework scalable both in memory consumption and data processing time.

Given the results shown above, we inspected the root cause that made the data processing time much longer for the ACCESS data set. It turned out that the cost of the SFMap framework is associated with the size of DNGs; i.e., as DNGs grow over time, some nodes in the graph could have a large number of edges. Since the candidate hostname search algorithm checks all the paths on the graph for a given pair of client and server, the amount of processing time increases as the number of such high degree nodes increases.

To solve the problem of the high degree nodes, we adopt a simple approach – sampling. As we explained in Section 3.3, for a given client-server pair (c, s), the SFMap algorithm enumerates a set of candidate hostnames, N by traversing a DNG. Our approach is to limit the cost of traversing a DNG with sampling. When traversing a DNG, if a number of paths for a given node exceeds a threshold, H, we stop the traversal and select candidates only on the traversed paths. We empirically determined the threshold as 
                           
                              H
                              =
                              16
                           
                        . With this threshold, 
                           
                              H
                              =
                              16
                              ,
                           
                         a probability that a path is not traversed is smaller than 0.01. We have validated that choosing other thresholds such as 
                           
                              H
                              =
                              8
                           
                         or 
                           
                              H
                              =
                              32
                           
                         did not affect the results.

The path sampling approach works as follows: On the DNG traversal, we inverse edge directions and walk on DNGs from (c, s) to leaves in the depth first manner. At each node, we randomly choose a next hop from the neighbor nodes that are kept in a hashtable. After traversing at most H paths, we stop the traversal and extract candidate hostnames from the traversed paths.

In addition to the path sampling, we introduce graph partitioning, which is an approach to reduce the cost of traversing a large Union DNG. That is, instead of keeping a single, large Union DNG, we create several small Union DNGs, each of which are associated with a subset of randomly chosen clients. The drawback of this approach is that by partitioning a Union DNG into small graphs, we may lose some information; i.e., some paths that were in the original DNG will be missed. We will study how the graph partitioning affect the estimation accuracy. The advantage of the graph partitioning is that the tasks of processing sub Union DNGs can be parallelized and/or distributed. As recent high-speed network monitoring frameworks such as [6] and [8] have revealed, use of the parallel/distributed computing approach is one of the promising ways to achieve high scalability.


                        Fig. 6 shows the results. The threshold for sampling paths was set to 
                           
                              H
                              =
                              16
                           
                        . The number of partitioned DNGs was set to 
                           
                              m
                              =
                              1
                              ,
                              2
                              ,
                              4
                              ,
                              8
                              ,
                              16
                           
                        . As the number of partitioned DNGs increases, both the mean data processing time per DNG and mean memory consumption per DNG decrease. The regression analysis shows that 
                           
                              t
                              ∼
                              
                                 m
                                 
                                    −
                                    1.7
                                 
                              
                           
                         and 
                           
                              s
                              ∼
                              
                                 m
                                 
                                    −
                                    1.0
                                 
                              
                              ,
                           
                         where t and s are time and memory size, respectively. The fact that both time and memory obey the power-law with the exponent smaller than 
                           
                              −
                              1.0
                           
                         indicates the good scalability of the graph partitioning approach. For instance, if we adopt 
                           
                              m
                              =
                              16
                              ,
                           
                         which is the affordable number of processes that can run on a modern multi-core processor, the mean time required to process 12 h of traffic data is less than 10 mins. Similarly, if we adopt 
                           
                              m
                              =
                              16
                              ,
                           
                         the mean memory consumption required to keep a partitioned DNG fits into a 2 GB of memory space. These observations clearly showed that the partitioning method enables us to make the SFMap framework scalable both in data processing time and memory consumption.

We further demonstrate that data processing time of the SFMap framework is actually short. To this end, we measured time needed for processing a packet; i.e., loading a DNS query and searching for a HTTP request. Fig. 7
                         shows the log-log complementary cumulative distribution functions (CCDFs) of the measured time for the ACCESS data set. Here, number of partition was set to 
                           
                              m
                              =
                              16
                           
                        . As shown, more than 99/99.9 % of data processing completed within 10/100 ms. In fact, the mean processing times were 0.21 ms for loading DNS information and 0.53 ms for looking up names for HTTP requests, respectively. Although there are a very few number of cases that took longer processing time (3 s), we can safely skip such cases by setting appropriate timeout (say, 1 s) without affecting the overall accuracy since such cases occurred infrequently (
                           
                              P
                              <
                              
                                 10
                                 
                                    −
                                    4
                                 
                              
                           
                        ). We also note that the SFMap framework is applied to incoming HTTP headers but not to all the TCP packet headers. Thus, we conclude that our techniques enable the SFMap framework to monitor traffic in a real-time fashion.

Finally, we study how the partitioning method affects the estimation accuracy. Table 9
                         shows the results where we accept the top three hostnames as estimation like we did in Table 5. Although the estimation accuracy degrades as m increases, the difference is small (∼1%). If we adopt 
                           
                              m
                              =
                              16
                           
                        , the accuracy exceeds 92.9% for public suffix matching if we pick up the top three hostnames. As we mentioned earlier, in most cases, the hostnames ranked in the top three look similar. We also note that the obtained results outperformed the DN-Hunter, which established the estimation accuracy of 77.7% for the same data. These results demonstrate that while the partitioning method can establish good scalability in both time and space, it can also achieve the high estimation accuracy.

@&#DISCUSSION@&#

Here, we discuss the limitations of the proposed SFMap framework. We also outline several future research directions that can help extend our framework.

By carefully examining the estimation results, we found several intrinsic sources of misclassification. There are several factors that are associated with the incomplete measurements. As we mentioned before, the first factor is the existence of aggressive DNS caching mechanisms that ignore DNS TTL setting. The second factor we found through this study was mobility of terminals; i.e., an IP address had already been resolved in other network before the terminal arrived to the vantage point. The third factor we found was the use of an IP address in the URI. We found a non-negligible number of HTTP requests had such URIs. We manually inspected the cases and found that there are several applications that likely hard-coded an IP address; thus, they never send DNS queries. Although these are not the controlling factors today, we may need to address them if such deployments become popular in future.

As shown in Section 5, the partitioning method enables us to apply the distributed computing approach to cope with more large-scale traffic data. However, if the total size of DNGs becomes large enough to press the capacity of the entire memory in a distributed monitoring system, we will need to eliminate old records. That is, instead of keeping all of the records for a certain amount of time, e.g., 12 h, we might want to quickly delete old records that are less-likely to be reused in the future. For instance, we can safely remove entries such as those with private/bogus IP addresses. Also, once we learned that a pair of hostname and server IP address is fixed and stable, we can keep that rule without using DNG. Finally, if memory space is fully utilized despite the above approaches, we will eliminate hostnames/IP addresses that were registered but have not been reused again. The actual evaluation of memory management schemes is left for future studies. We note that in the traffic flow monitoring systems such as NetFlow, similar memory management approaches have already been used. Another possible solution would be to build a new algorithm that can maintain and update DNGs in a more compact data structure. The topic is also left for future studies. Finally, adopting packet/flow sampling techniques is also a possible solution. As previous studies such as [5] and [11] have revealed, sample-based traffic monitoring is a promising approach because it can drastically reduce the amount of packets or flows to be processed while necessary traffic statistics can be reverted from the sampled packets or flows.

@&#SUMMARY@&#

The SFMap hostname estimation framework was presented. SFMap enables network operators to estimate the hostnames of HTTPS traffic by observing DNS queries/responses. To tackle the challenges that arise from the recent dynamic deployment and diverse implementations of DNS ecosystems, the proposed SFMap framework runs on top of a single key component; i.e., a DNG, which is a formal expression that characterizes the highly dynamic and diverse nature of DNS mechanisms. From extensive analyses using real packet traces collected from two distinct locations with different network scales, we have demonstrated that SFMap has good estimation accuracy and can outperform DN-Hunter, which is a state-of-the-art estimation technique. We also introduced two techniques, path sampling and graph partitioning, which make the SFMap framework scalable in both data processing time and size of memory without losing the high accuracy. We validated the effectiveness of the approach using large-scale traffic data collected at a gateway point of Internet access links.

@&#ACKNOWLEDGMENTS@&#

We thank the workshop chairs of the 7th International Workshop on Traffic Monitoring and Analysis (TMA 2015) for providing us with the opportunity to publish the extended version of our work. A part of this work was supported by JSPS KAKENHI Grant number 25880020.

@&#REFERENCES@&#

