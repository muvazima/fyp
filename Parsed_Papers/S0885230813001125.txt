@&#MAIN-TITLE@&#Incorporating local information of the acoustic environments to MAP-based feature compensation and acoustic model adaptation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Designing suitable prior distributions is important for MAP-based methods.


                        
                        
                           
                           We propose a framework to characterize local information of acoustic environments.


                        
                        
                           
                           With the local information, suitable prior distributions can be designed.


                        
                        
                           
                           Four algorithms to specify hyper-parameters for prior distributions are derived.


                        
                        
                           
                           Results confirm the advantage of using local information to MAP-based methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

MAP

Feature compensation

Acoustic model adaptation

Local information

Hyper-parameter specification

Noise robustness

@&#ABSTRACT@&#


               
               
                  The maximum a posteriori (MAP) criterion is popularly used for feature compensation (FC) and acoustic model adaptation (MA) to reduce the mismatch between training and testing data sets. MAP-based FC and MA require prior densities of mapping function parameters, and designing suitable prior densities plays an important role in obtaining satisfactory performance. In this paper, we propose to use an environment structuring framework to provide suitable prior densities for facilitating MAP-based FC and MA for robust speech recognition. The framework is constructed in a two-stage hierarchical tree structure using environment clustering and partitioning processes. The constructed framework is highly capable of characterizing local information about complex speaker and speaking acoustic conditions. The local information is utilized to specify hyper-parameters in prior densities, which are then used in MAP-based FC and MA to handle the mismatch issue. We evaluated the proposed framework on Aurora-2, a connected digit recognition task, and Aurora-4, a large vocabulary continuous speech recognition (LVCSR) task. On both tasks, experimental results showed that with the prepared environment structuring framework, we could obtain suitable prior densities for enhancing the performance of MAP-based FC and MA.
               
            

@&#INTRODUCTION@&#

Applications of automatic speech recognition (ASR) have received considerable attention in recent years. However, the applicability of ASR is seriously limited by the fact that its performance can deteriorate when training and testing conditions do not match (Acero, 1990; Gong, 1995; Junqua et al., 1996; Huo and Lee, 2000; Huang et al., 2001; Molau et al., 2003; Deng and Huang, 2004). Maintaining satisfactorily robust performance under mismatched conditions is an essential task for ASR applications. Handling the mismatch is difficult, because it generally comes from multiple sources, including inter- and intra-speaker effects, additive noise, convolutive transmission, and channel distortions. The overall effect of these distortions can be complex and hard to characterize. Many robustness approaches have been proposed to handle the mismatch issue. These approaches can be categorized into three groups, signal-space, feature-space, and model-space approaches (Sankar and Lee, 1996; Lee, 1998), based on the space in which the mismatch issue is handled.

The signal-space approach (also known as speech enhancement methods) aims to reduce noise components from noisy speech signals while avoiding large speech distortions. Classical algorithms include spectral subtraction (SS) (Boll, 1979), Wiener filtering techniques (Scalart and Filho, 1996; Hansler and Schmidt, 2006; Chen et al., 2007), minimum mean square error spectral estimator (MMSE) (Ephraim and Malah, 1984; Martin, 2005; Hansen et al., 2006), minimum mean-square error log-spectral amplitude estimator (LSA) (Ephraim and Malah, 1985), maximum a posteriori spectral amplitude estimator (MAPA) (Lotter and Vary, 2005), and maximum likelihood spectral amplitude estimator (MLSA) (Kjems and Jensen, 2012). In the meanwhile, some models that characterize human speech production systems were often incorporated for speech enhancement, such as harmonic model (Quatieri and McAulay, 1992), the linear prediction (LP) model (Makhoul, 1976), and the hidden Markov model (HMM) (Ephraim, 1992).

The feature-space approach tries to generate feature vectors that are robust to environment mismatches. These approaches can be divided into two categories, feature processing (FP) and feature compensation (FC). FP methods process both training and testing data sets to remove mismatches on features. Temporal filtering and feature normalization methods are two effective classes of FP approaches. Representative temporal filtering algorithms include relative spectral (RASTA) (Hermansky and Morgan, 1994), moving average and auto-regression moving average (Chen et al., 2002a, 2002b), which try to smooth acoustic features to suppress noise interferences. Feature normalization methods aim to reduce the mismatch by mapping training and testing acoustic features to make them close to each other in the first or higher order statistical measures. Successful algorithms include cepstral mean subtraction (CMS) (Viikki and Laurila, 1998; Kim and Rose, 2003), cepstral mean and variance normalization (CMVN) (Tibrewala and Hermansky, 1997), and histogram equalization (HEQ) (Ibm et al., 2000). On the other hand, FC methods compute a mapping function to characterize the environmental mismatch. The acoustic features are then transformed by the mapping function to match the acoustic model. A variety of mapping functions has been applied in previous studies, among which affine transform and compensation bias are two popular choices. Notable examples include maximum likelihood (ML) and maximum a posteriori (MAP) based stochastic feature matching (SFM) (Lee, 1998; Jiang et al., 2001), feature space maximum likelihood linear regression (feature space MLLR (Gales, 1997)) and maximum a posteriori linear regression (feature space MAPLR (Li et al., 2002)).

The goal of the model-space approach is to estimate an acoustic model that is more robust to environmental changes or matches the testing condition better. Two classes of model-space approaches, discriminative training (DT) and model adaptation (MA), have been confirmed to be effective and are widely used. Generally, DT approaches use an objective function that measures the separation between parameters in a set of acoustic models. The objective function is optimized based on training data to increase the separation between model parameters. Well-known DT approaches include minimum classification error (MCE) (Juang et al., 1997), maximum mutual information estimation (MMIE) (Valtchev et al., 1997), minimum phone error (MPE) (Povey and Woodland, 2002), large margin estimation (LME) (Jiang et al., 2006), and soft margin estimation (SME) (Li et al., 2007) methods. On the other hand, MA approaches estimate a mapping function to adjust parameters in the original acoustic model to match the testing condition. Successful examples include stochastic matching algorithm (Sankar and Lee, 1996; Lee, 1998), maximum a posteriori (MAP) (Gauvain and Lee, 1994; Huo et al., 1995), MLLR (Leggetter and Woodland, 1995; Gales, 1997), and MAPLR (Chesta et al., 1999; Siohan et al., 2001).

In the reviewed approaches above, MAP-based FC and MA estimate mapping functions based on the MAP criterion to compensate for acoustic mismatches. Owing to their efficiency and flexibility, they have received extensive attention in recent years (Gauvain and Lee, 1994; Chesta et al., 1999; Siohan et al., 2001; Jiang et al., 2001; Li et al., 2002). These approaches require prior densities of the mapping function parameters, and determining suitable densities is an important task in obtaining satisfactory performance. Traditionally, prior densities were designed without considering the underlying environment structures, so the prior density could not characterize the local statistical structure of the acoustic environments. In this paper, we propose an environment structuring framework for exploring local information of the ensemble speaker and speaking environment conditions. Based on local information, we derive suitable prior densities for MAP-based FC and MA. We conducted experiments using two standardized speech databases, Aurora-2 (Pearce and Hirsch, 2000; Macho et al., 2002) and Aurora-4 (Hirsch, 2001; Parihar and Picone, 2002; Parihar et al., 2004). Experimental results confirmed the effectiveness of our proposed idea for enhancing the MAP-based FC and MA capability to handle the mismatch issue.

The reminder of this paper is organized as follows. Section 2 reviews MAP-based FC and MA and introduces the environment structuring framework. Section 3 describes four algorithms for specifying hyper-parameters of the prior densities based on the environment structuring framework. Section 4 shows our experimental setup and evaluation results. Section 5 concludes the study by summarizing our findings.

This section first reviews the fundamental theories of MAP-based FC and MA. Then we introduce the proposed environment structuring framework used for prior density specification.


                        Fig. 1
                         illustrates FC and MA in a speech recognition system. FC transforms the original testing speech features, F
                        Y, to new speech features, F
                        X, that match the acoustic model for the training condition by
                           
                              (1)
                              
                                 
                                    
                                       F
                                       X
                                    
                                    =
                                    
                                       Γ
                                       υ
                                    
                                    (
                                    
                                       F
                                       Y
                                    
                                    )
                                 
                              
                           
                        where Γ
                        
                           υ
                        (.) is an FC mapping function, and υ denotes the parameters in the FC mapping function. We use the MAP criterion to calculate υ in Γ
                        
                           υ
                        (.) by
                           
                              (2)
                              
                                 
                                    
                                       υ
                                       ˆ
                                    
                                    =
                                    arg
                                    
                                       
                                          max
                                       
                                       υ
                                    
                                    P
                                    (
                                    
                                       F
                                       Y
                                    
                                    |
                                    υ
                                    ,
                                    
                                       Λ
                                       X
                                    
                                    )
                                    [
                                    
                                       
                                          (
                                          p
                                          (
                                          υ
                                          )
                                          ]
                                       
                                       α
                                    
                                    ,
                                 
                              
                           
                        where α is a forgetting factor, p(υ) is the prior density for FC (Jiang et al., 2001), and Λ
                        X denotes the acoustic model for the training condition. When setting α
                        =0 in Eq. (2), the estimation of 
                           
                              υ
                              ˆ
                           
                         is exactly the same as that based on the ML criterion (Lee, 1998).

In MA, a mapping function, Γ
                        
                           θ
                        (.), is used to adjust parameters of the acoustic model for the training condition, Λ
                        X, and generate a new acoustic model, Λ
                        Y, for the testing condition according to
                           
                              (3)
                              
                                 
                                    
                                       Λ
                                       Y
                                    
                                    =
                                    
                                       Γ
                                       θ
                                    
                                    (
                                    
                                       Λ
                                       X
                                    
                                    )
                                    ,
                                 
                              
                           
                        where Γ
                        
                           θ
                        (.) characterizes the mismatch between the training and testing conditions. Similar to MAP-based FC, the estimation of the parameters, θ, in Γ
                        
                           θ
                        (.), is formulated as
                           
                              (4)
                              
                                 
                                    
                                       θ
                                       ˆ
                                    
                                    =
                                    arg
                                    
                                       
                                          max
                                       
                                       θ
                                    
                                     
                                    P
                                    (
                                    
                                       F
                                       Y
                                    
                                    |
                                    θ
                                    ,
                                    
                                       Λ
                                       X
                                    
                                    )
                                    
                                       
                                          [
                                          p
                                          (
                                          θ
                                          )
                                          ]
                                       
                                       τ
                                    
                                    ,
                                 
                              
                           
                        where τ is a forgetting factor, and p(θ) is the prior density for MA. We can also obtain the ML-based solution of 
                           
                              θ
                              ˆ
                           
                         by setting τ
                        =0 in Eq. (4).

In Eqs. (2) and (4), the hyper-parameters for the prior densities must be properly specified to characterize the statistics of the underlying acoustic environments. In what follows, we introduce the proposed environment structuring framework for doing this.

Two steps are involved in constructing the environment structuring framework, environment clustering (EC) and environment partitioning (EP) (Tsao and Lee, 2009). After these two steps, the environment structuring framework is structured as a two-stage hierarchical tree, as shown in Fig. 2
                        . The algorithms involved in these two steps are briefly introduced in the following discussion.

The goal of EC is to cluster the entire set of training data into several subsets. Each subset includes speech data representing similar acoustic characteristics. As shown in Fig. 2, a hierarchical tree structure is adopted to perform EC. Assuming that the tree built using EC (named EC tree hereafter) has C nodes, including the root node, intermediate nodes, and leaf nodes, we accordingly cluster the entire set of training data into C subsets {Q
                           1, Q
                           2, …, Q
                           
                              C
                           }, where each subset contains local information about the entire set of training data. Next, we use the data in each subset to estimate an acoustic model and obtain C sets of acoustic models, {Λ
                           1, Λ
                           2, …, Λ
                           
                              C
                           }. We use these C sets of acoustic models to characterize local information about the entire acoustic space.

Some previous studies also proposed to structure the training data to facilitate the model adaptation process. In Zhang et al. (2003), training data is divided into several noisy clusters, which are used to prepare multiple HMM sets. Then a noisy cluster that best matches the testing utterance is located, and its corresponding HMM set is used for recognition. Additionally, an MLLR transformation is applied to further adapt the Gaussian mean parameters. In Padmanabhan et al. (1998), speaker clustering is first performed, and model adaptation is conducted based on linear transforamtions caclulated by the cluster of speakers that is acoustically close to the testing speaker. The EC algorithm shares the similar concept of the above appraoches, while we investigate to apply the constructed EC tree to not only model adapation but also feature compensation. Furthermore, since the EC tree can characterize local informtion of the entire training acoustic space, we propose to utilize the local infromation to specify suitable prior densities for MAP-based FC and MA mapping fucntion estaimtions. These two parts will be dicsussed in more details in the following discussion.

In Gales (1996), an acoustic space clustering and selection algorithm based on a regression tree was proposed. The regression tree can be constructed based on the phonetic knowledge or in a data driven manner and was adopted to facilitate MLLR acoustic model adaptation. In Shinoda and Lee (2001), a hierarchical tree structure was used for MAP based model adaptation. Both approaches used the tree-structured clustering and selection methods for acoustic model adaptation (Gales, 1996; Shinoda and Lee, 2001). The EP algorithm adopts the same idea to partition the Gaussian components in an acoustic model into several groups. Based on the EP algorithm, we build an EP tree, as shown in Fig. 3
                           , which is used for both FC and MA. Moreover, based on the EP tree structure, we further design four prior densities to be used for MAP-based FC and MA (refer Section 3). In this study, we propose a two-stage tree structure, as shown in Fig. 2. For each of the C sets of acoustic models, {Λ
                           1, Λ
                           2, …, Λ
                           
                              C
                           }, we estimate a tree using the EP algorithm (named EP tree hereafter). Accordingly, we prepare C EP trees, {Ω
                           1, Ω
                           2, …, Ω
                           
                              C
                           }, corresponding to the C acoustic models. The EP tree presented in Fig. 3 corresponds to one EP tree in Fig. 2. Assume that this EP tree includes N nodes, the entire set of Gaussian components in an acoustic model is accordingly partitioned into N groups (Z
                           1, Z
                           2, …, Z
                           
                              n
                           , …, Z
                           
                              N
                           ), where Z
                           
                              n
                            denotes the nth group of Gaussian components in the EP tree. Because each node in the EP tree is obtained from separating the Gaussian components from its parent node, the Gaussian components are mutually exclusive in the nodes of the same layer and represent different acoustic properties. For the EP tree in Fig. 3, Z
                           1 denotes the entire set of mean parameters, Φ
                           1 represents the hyper-parameter set for Z
                           1, Z
                           
                              n
                            denotes the nth subset of the entire set of mean vectors, and Φ
                           
                              n
                            represents the hyper-parameter set for Z
                           
                              n
                           .

In the constructed environment structuring framework in Fig. 2, we have multiple acoustic models for characterizing local acoustic conditions. These multiple acoustic models are used online to perform cluster selection (CS) for determining one acoustic condition that best matches the testing condition. The selected acoustic model is used to perform FC or/and MA, and the compensated features or/and adapted acoustic models are then used to test recognition. In the compensation or/and adaptation stage, the EP tree structure in Figs. 2 and 3 are used to specify prior densities, which are used in MAP-based FC and MA. In our study, MAP-based stochastic feature matching (SFM) using a compensation bias is adopted for FC, and linear regression (LR) is chosen for MA. In the following, we introduce these two approaches under the proposed environment structuring framework.

In Eq. (1), by setting 
                           
                              
                                 F
                                 X
                              
                              =
                              [
                              
                                 f
                                 1
                                 X
                              
                              
                                 f
                                 2
                                 X
                              
                              ,
                              …
                              ,
                              
                                 f
                                 T
                                 X
                              
                              ]
                           
                         and 
                           
                              
                                 F
                                 Y
                              
                              =
                              [
                              
                                 f
                                 1
                                 Y
                              
                              
                                 f
                                 2
                                 Y
                              
                              ,
                              …
                              ,
                              
                                 f
                                 T
                                 Y
                              
                              ]
                           
                        , we perform a frame-wise feature compensation by
                           
                              (5)
                              
                                 
                                    
                                       f
                                       t
                                       X
                                    
                                    =
                                    
                                       Γ
                                       υ
                                    
                                    (
                                    
                                       f
                                       t
                                       Y
                                    
                                    )
                                    ,
                                       
                                    t
                                    =
                                    1,2
                                    ,
                                    …
                                    ,
                                    T
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 f
                                 t
                                 Y
                              
                           
                         and 
                           
                              
                                 f
                                 t
                                 X
                              
                           
                         are noisy and compensated features at the tth time index, respectively. To perform Eq. (5), we first define the form of the FC mapping function, Γ
                        
                           υ
                        (.). Generally, when sufficient samples from the testing condition are available, a complex parametric function of Γ
                        
                           υ
                        (.) can be used to compensate noise components accurately. When only a small number of samples is available, a simple form of Γ
                        
                           υ
                        (.) should be used to avoid over-fitting. In this study, we focus on the condition that only few data samples are available to estimate the compensation function. Therefore, we use a simple compensation bias for Γ
                        
                           υ
                        (.). Thus, Eq. (5) becomes
                           
                              (6)
                              
                                 
                                    
                                       f
                                       t
                                       X
                                    
                                    =
                                    
                                       f
                                       t
                                       Y
                                    
                                    −
                                    
                                       δ
                                       n
                                    
                                    ,
                                       
                                    t
                                    =
                                    1,2
                                    ,
                                    …
                                    ,
                                    T
                                    ,
                                 
                              
                           
                        where δ
                        
                           n
                         is a compensation bias belonging to the nth node in the EP tree. To perform Eq. (6), we first decode F
                        Y to generate a transcription reference. Then based on the transcription reference, we can obtain the node sequence corresponding to 
                           
                              
                                 F
                                 Y
                              
                              =
                              [
                              
                                 f
                                 1
                                 Y
                              
                              
                                 f
                                 2
                                 Y
                              
                              ,
                              …
                              ,
                              
                                 f
                                 T
                                 Y
                              
                              ]
                           
                         to perform SFM. Please note that the N biases, δ
                        
                           n
                         (n
                        =1, …, N), are shared and used to compensate all of the testing feature vectors. Namely, the compensation is performed in a frame-wise manner. Each feature vector, 
                           
                              
                                 f
                                 t
                                 Y
                              
                           
                        , selects a particular bias δ
                        
                           n
                         to perform SFM, and the selection of n out of N nodes is done by a searching process through the EP tree.

When applying MAP-based SFM to calculate δ
                        
                           n
                        , we first specify a prior density:
                           
                              (7)
                              
                                 
                                    p
                                    (
                                    
                                       δ
                                       n
                                    
                                    )
                                    ∝
                                    
                                       ∏
                                       
                                          i
                                          =
                                          1
                                       
                                       D
                                    
                                    
                                       exp
                                       
                                          
                                             −
                                             
                                                1
                                                
                                                   2
                                                   
                                                      V
                                                      
                                                         n
                                                         (
                                                         i
                                                         i
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      δ
                                                      
                                                         n
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                   −
                                                   
                                                      η
                                                      
                                                         n
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           
                        where δ
                        
                           n(i), η
                        
                           n(i), and V
                        
                           n(ii) are the ith components of δ
                        
                           n
                        , η
                        
                           n
                        , and iith diagonal component of V
                        
                           n
                        , respectively, η
                        
                           n
                         and V
                        
                           n
                         are the hyper-parameters, V
                        
                           n
                         is a diagonal matrix, and D is the feature vector dimension. From Eqs. (6) and (7), the MAP estimation of δ
                        
                           n
                         can be computed as:
                           
                              (8)
                              
                                 
                                    
                                       δ
                                       
                                          n
                                          (
                                          i
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          
                                             k
                                             
                                                n
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                          
                                             G
                                             
                                                n
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        with
                           
                              (9)
                              
                                 
                                    
                                       G
                                       
                                          n
                                          (
                                          i
                                          )
                                       
                                    
                                    =
                                    
                                       α
                                       
                                          
                                             V
                                             
                                                n
                                                (
                                                i
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       T
                                    
                                    
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                Z
                                                n
                                             
                                          
                                       
                                       
                                          
                                             r
                                             s
                                          
                                          (
                                          t
                                          )
                                          
                                             
                                                
                                                   1
                                                   
                                                      
                                                         Σ
                                                         
                                                            
                                                               s
                                                               
                                                                  (
                                                                  i
                                                                  i
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       k
                                       
                                          n
                                          (
                                          i
                                          )
                                       
                                    
                                    =
                                    
                                       α
                                       
                                          
                                             V
                                             
                                                n
                                                (
                                                i
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    
                                       η
                                       
                                          n
                                          (
                                          i
                                          )
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       T
                                    
                                    
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                Z
                                                n
                                             
                                          
                                       
                                       
                                          
                                             r
                                             s
                                          
                                          (
                                          t
                                          )
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                         
                                                            t
                                                            (
                                                            i
                                                            )
                                                         
                                                         Y
                                                      
                                                      −
                                                      
                                                         μ
                                                         
                                                            s
                                                            (
                                                            i
                                                            )
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         Σ
                                                         
                                                            
                                                               s
                                                               
                                                                  (
                                                                  i
                                                                  i
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 f
                                 
                                    t
                                    (
                                    i
                                    )
                                 
                                 Y
                              
                           
                         is the ith component of the tth testing feature vector, r
                        
                           s
                        (t) is the posterior probability at the tth observation, Z
                        
                           n
                         represents the Gaussian components in the nth EP node, and 
                           
                              
                                 μ
                                 
                                    
                                       s
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 Σ
                                 
                                    
                                       s
                                       
                                          (
                                          i
                                          i
                                          )
                                       
                                    
                                 
                              
                           
                         are the ith component of the mean, μ
                        
                           s
                        , and iith diagonal component of variance, Σ
                        
                           s
                        , of the sth Gaussian component that belongs to the nth EP node, respectively.

The overall implementation steps of MAP-based SFM online can be divided into four steps:

Step 1: With F
                        Y, perform the CS process to locate one EC node (e.g., the CSth node) that best matches the testing condition by
                           
                              (11)
                              
                                 
                                    
                                       Λ
                                       
                                          C
                                          S
                                       
                                    
                                    =
                                    
                                       
                                          arg
                                          max
                                       
                                       
                                          
                                             Λ
                                             c
                                          
                                       
                                    
                                    P
                                    (
                                    
                                       F
                                       Y
                                    
                                    |
                                    
                                       Λ
                                       c
                                    
                                    )
                                    ,
                                     
                                    ∀
                                    c
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    C
                                    ,
                                 
                              
                           
                        thereby locating the acoustic model, Λ
                        
                           CS
                        , and the EP tree, Ω
                        
                           CS
                        , for that CSth node.

Step 2: Based on F
                        Y, Λ
                        
                           CS
                        , and Ω
                        
                           CS
                        , find the alignment information and calculate the FC mapping functions, 
                           
                              
                                 Γ
                                 ν
                              
                              =
                              {
                              
                                 g
                                 ν
                                 1
                              
                              ,
                              
                                 g
                                 ν
                                 2
                              
                              ,
                              …
                              ,
                              
                                 g
                                 ν
                                 N
                              
                              }
                           
                        , where the located EP tree (Ω
                        
                           CS
                        ) is assumed to have N nodes.

Step 3: Finally, obtain the compensated feature, 
                           
                              
                                 F
                                 X
                              
                              =
                              [
                              
                                 f
                                 1
                                 X
                              
                              ,
                              
                                 f
                                 2
                                 X
                              
                              ,
                              …
                              ,
                              
                                 f
                                 T
                                 X
                              
                              ]
                           
                         by compensating F
                        Y using
                           
                              (12)
                              
                                 
                                    
                                       f
                                       t
                                       X
                                    
                                    =
                                    
                                       g
                                       ν
                                       n
                                    
                                    (
                                    
                                       f
                                       t
                                       Y
                                    
                                    )
                                    =
                                    
                                       f
                                       t
                                       Y
                                    
                                    −
                                    
                                       δ
                                       n
                                    
                                    ,
                                     
                                    t
                                    =
                                    1,2
                                    ,
                                    …
                                    ,
                                    T
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 f
                                 t
                                 X
                              
                           
                         is the compensated speech feature, 
                           
                              
                                 g
                                 ν
                                 n
                              
                              (
                              .
                              )
                           
                         is the mapping function, and δ
                        
                           n
                         is the compensation bias for the nth node in the EP tree. To determine the node index for the tth feature, 
                           
                              
                                 f
                                 t
                                 X
                              
                           
                        , we first determine a Gaussian mixture component, 
                           
                              s
                              ˜
                           
                        , by 
                           
                              
                                 s
                                 ˜
                              
                              =
                              arg
                              
                                 
                                    max
                                 
                                 s
                              
                              
                                 r
                                 s
                              
                              (
                              t
                              )
                              ,
                                 
                              s
                              ∈
                              
                                 S
                                 ′
                              
                           
                        , where S′ denotes the group of Gaussian components that belongs to the state corresponding to 
                           
                              
                                 f
                                 t
                                 X
                              
                           
                         in the decoded transcription reference. With the determined 
                           
                              s
                              ˜
                           
                        , we search through the EP tree to determine the optimal node for 
                           
                              
                                 f
                                 t
                                 X
                              
                           
                        . The search process is conducted in a bottom-up manner, which is different from the top-down scheme that is used in (Gales, 1996). Before the search process, we first calculate the accumulated statistics for every node in the EP tree, 
                           
                              
                                 ϒ
                                 q
                              
                              =
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 T
                              
                              
                                 
                                    ∑
                                    
                                       s
                                       ∈
                                       
                                          Z
                                          q
                                       
                                    
                                 
                                 
                                    
                                       r
                                       s
                                    
                                    (
                                    t
                                    )
                                 
                              
                           
                        , q
                        =1, 2, …, N. If the accumulated statistics for the nth EP node, ϒ
                        
                           n
                        , is larger than a predefined threshold, we use the compensation bias of the nth node, δ
                        
                           n
                        , to perform MAP-based SFM. If ϒ
                        
                           n
                         is smaller than a pre-defined threshold, we examine the accumulated statistics at the parent node of the nth node. This process repeats until an EP node with sufficient statistics is located.

Step 4: Decode F
                        X by Λ
                        
                           CS
                         to obtain the final recognition result.

MAPLR adapts the mean parameters in the original acoustic model to form a new one for the testing condition (Chesta et al., 1999). From Eq. (3), MAPLR is formulated as
                           
                              (13)
                              
                                 
                                    
                                       μ
                                       s
                                       Y
                                    
                                    =
                                    
                                       Γ
                                       θ
                                    
                                    (
                                    
                                       μ
                                       s
                                       X
                                    
                                    )
                                    ,
                                     
                                    s
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    S
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 μ
                                 s
                                 Y
                              
                           
                         and 
                           
                              
                                 μ
                                 s
                                 X
                              
                           
                         are the sth mean vectors in Λ
                        Y and Λ
                        X, respectively, and S denotes the entire set of Gaussian components in the acoustic model. MAPLR uses linear regression for the mapping function, Γ
                        
                           θ
                        (.), so we have
                           
                              (14)
                              
                                 
                                    
                                       μ
                                       s
                                       Y
                                    
                                    =
                                    
                                       A
                                       n
                                    
                                    
                                       μ
                                       s
                                       X
                                    
                                    +
                                    
                                       b
                                       n
                                    
                                    =
                                    
                                       W
                                       n
                                    
                                    
                                       ξ
                                       s
                                    
                                    ,
                                     
                                    s
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    S
                                    ,
                                 
                              
                           
                        where A
                           n
                        , b
                           n
                        , and W
                           n
                         are the rotation matrix, bias, and affine transform, respectively, that belong to the nth node in the EP tree, and ξ
                        
                           s
                         is the augmented vector, 
                           
                              
                                 ξ
                                 s
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         μ
                                                         s
                                                         X
                                                      
                                                   
                                                
                                             
                                             ′
                                          
                                          ,
                                          1
                                       
                                    
                                 
                                 ′
                              
                           
                        . For MAPLR, we specify the prior density for p(W
                           n
                        ) as
                           
                              (15)
                              
                                 
                                    p
                                    (
                                    
                                       W
                                       n
                                    
                                    )
                                    ∝
                                    
                                       ∏
                                       
                                          i
                                          =
                                          1
                                       
                                       D
                                    
                                    
                                       exp
                                       
                                          
                                             −
                                             
                                                1
                                                2
                                             
                                             (
                                             
                                                W
                                                
                                                   
                                                      n
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                
                                             
                                             −
                                             
                                                ρ
                                                
                                                   
                                                      n
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                
                                             
                                             )
                                             
                                                H
                                                
                                                   
                                                      n
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                
                                                
                                                   −
                                                   1
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      W
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                   −
                                                   
                                                      ρ
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                
                                                ′
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where W
                           n(i) and ρ
                        
                           n(i) are the ith row of W
                           n
                         and ρ
                        
                           n
                        , respectively; ρ
                        
                           n
                         and 
                           
                              
                                 H
                                 
                                    
                                       n
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                 
                              
                              ,
                                 
                              i
                              =
                              1
                              ,
                              …
                              ,
                              D
                           
                        , are hyper-parameters. Here we assume that each of 
                           
                              
                                 H
                                 
                                    
                                       n
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                 
                              
                              ,
                                 
                              i
                              =
                              1
                              ,
                              …
                              ,
                              D
                           
                        , is a diagonal matrix (Erdoan et al., 2001). Then, MAPLR calculates 
                           
                              
                                 W
                                 
                                    
                                       n
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                 
                              
                           
                         using
                           
                              (16)
                              
                                 
                                    
                                       W
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    =
                                    
                                       k
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    
                                       G
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    ,
                                 
                              
                           
                        where
                           
                              (17)
                              
                                 
                                    
                                       G
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    =
                                    τ
                                    
                                       H
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       T
                                    
                                    
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                Z
                                                n
                                             
                                          
                                       
                                       
                                          
                                             r
                                             s
                                          
                                          (
                                          t
                                          )
                                          
                                             
                                                
                                                   
                                                      
                                                         ξ
                                                         s
                                                      
                                                      
                                                         ξ
                                                         s
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         Σ
                                                         
                                                            
                                                               s
                                                               
                                                                  (
                                                                  i
                                                                  i
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       k
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    =
                                    τ
                                    
                                       ρ
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    
                                       H
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       T
                                    
                                    
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                Z
                                                n
                                             
                                          
                                       
                                       
                                          
                                             r
                                             s
                                          
                                          (
                                          t
                                          )
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                         
                                                            
                                                               t
                                                               
                                                                  (
                                                                  i
                                                                  )
                                                               
                                                            
                                                         
                                                         Y
                                                      
                                                      
                                                         ξ
                                                         s
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         Σ
                                                         
                                                            
                                                               s
                                                               
                                                                  (
                                                                  i
                                                                  i
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        
                     

The overall implementation steps of MAPLR can also be divided into four steps:

Step 1: With F
                        Y, perform the CS process to locate one EC node (e.g., the CSth node) that best matches the testing condition by Eq. (11), thereby locating the acoustic model, Λ
                        
                           CS
                        , and the EP tree, Ω
                        
                           CS
                        , for that node.

Step 2: Based on F
                        Y, Λ
                        
                           CS
                        , and Ω
                        
                           CS
                        , find the alignment information and calculate the MA mapping functions, 
                           
                              
                                 Γ
                                 θ
                              
                              =
                              
                                 
                                    
                                       g
                                       θ
                                       1
                                    
                                    ,
                                       
                                    
                                       g
                                       θ
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       g
                                       θ
                                       N
                                    
                                 
                              
                           
                        , where the located EP tree (Ω
                        
                           CS
                        ) is assumed to have N nodes.

Step 3: Adapt mean parameters in Λ
                        
                           CS
                         using
                           
                              (19)
                              
                                 
                                    
                                       μ
                                       s
                                       Y
                                    
                                    =
                                    
                                       g
                                       θ
                                       n
                                    
                                    (
                                    
                                       μ
                                       s
                                       
                                          C
                                          S
                                       
                                    
                                    )
                                    =
                                    
                                       W
                                       n
                                    
                                    
                                       ξ
                                       s
                                    
                                    ,
                                     
                                    s
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    S
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 μ
                                 s
                                 
                                    C
                                    S
                                 
                              
                           
                         is the mean vector, 
                           
                              
                                 ξ
                                 s
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         μ
                                                         s
                                                         
                                                            C
                                                            S
                                                         
                                                      
                                                   
                                                
                                             
                                             ′
                                          
                                          ,
                                          1
                                       
                                    
                                 
                                 ′
                              
                           
                         is for the sth Gaussian, which belongs to the nth EP node, and 
                           
                              
                                 μ
                                 s
                                 Y
                              
                           
                         is the adapted mean parameters. After the entire set of mean parameters has been adapted, we obtain the acoustic model for the testing condition, Λ
                        Y. Similar to MAP-based SFM, we search through the EP tree to determine the node that has sufficient number of adaptation statistics to compute an accurate affine transform. The search process is conducted in a bottom-up manner. Before the search process, we first calculate the accumulated statistics for every node in the EP tree, 
                           
                              
                                 ϒ
                                 q
                              
                              =
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 T
                              
                              
                                 
                                    ∑
                                    
                                       s
                                       ∈
                                       
                                          Z
                                          q
                                       
                                    
                                 
                                 
                                    
                                       r
                                       s
                                    
                                    (
                                    t
                                    )
                                 
                              
                           
                        , q
                        =1, 2, …, N. If the accumulated statistics for the nth EP node, ϒ
                        
                           n
                        , is larger than a predefined threshold, we use the affine transform of the nth node, W
                           n
                        , to perform MAPLR. If ϒ
                        
                           n
                         is smaller than a pre-defined threshold, we examine the accumulated statistics at the parent node of the nth node. This process repeats until an EP node with sufficient statistics is located.

Step 4: Decode F
                        Y by Λ
                        Y to obtain the final recognition result.

Although FC and MA can be used to compensate the same mismatch factors (or sources), they may be complementary to each other, since they deal with the mismatch problem using different strategies. Therefore, the two approaches can be integrated in an iterative manner to achieve further improvements. More details about the integration of FC and MA will be presented in Section 4.

As introduced in Sections 2.3 and 2.4, both MAP-based SFM and MAPLR take account of the hierarchical tree structure to well fit the testing acoustic environments. In this section, we present to use the tree structure to specify suitable hyper-parameters of the prior densities for MAP-based SFM and MAPLR. Four types of prior densities are developed and introduced in the following discussion.

With the environment structuring framework, we can prepare clustered prior (CP), sequential prior (SP), hierarchical prior (HP), and integrated prior (IP) densities for MAP-based SFM and MAPLR.

The hyper-parameters of the clustered prior (CP) density are estimated directly from the clustered data in each EP node of the hierarchical tree. In the following, we assume that the cth EC node is selected, and the corresponding training data for this node is Q
                           
                              c
                           . Next, we further assume that the cth EC node includes training data from K different speaker and speaking environments. Accordingly, we can divide Q
                           
                              c
                            into K subsets of training data {Q
                           
                              c,1, Q
                           
                              c,2, …, Q
                           
                              c,K
                           }. With these K subsets of training data, the CP densities of the MAP-based SFM and MAPLR in the cth EC node are computed as follows.

Step 1: Apply ML-based SFM to calculate K sets of compensation biases {
                                 
                                    
                                       δ
                                       n
                                       1
                                    
                                    ,
                                    
                                       δ
                                       n
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       δ
                                       n
                                       K
                                    
                                 
                              }, using the data from K different environments, namely {Q
                              
                                 c,1, Q
                              
                                 c,2, …, Q
                              
                                 c,K
                              }.

Step 2: Estimate the hyper-parameters of the CP density (mean and covariance), {
                                 
                                    
                                       η
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                    ,
                                    
                                       V
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                 
                              } using
                                 
                                    (20)
                                    
                                       
                                          
                                             η
                                             
                                                
                                                   n
                                                   
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                             
                                             
                                                C
                                                P
                                             
                                          
                                          =
                                          
                                             1
                                             K
                                          
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             
                                                δ
                                                
                                                   
                                                      n
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                
                                                k
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                              
                                 
                                    (21)
                                    
                                       
                                          
                                             V
                                             
                                                
                                                   n
                                                   
                                                      (
                                                      i
                                                      i
                                                      )
                                                   
                                                
                                             
                                             
                                                C
                                                P
                                             
                                          
                                          =
                                          
                                             1
                                             K
                                          
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      δ
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               )
                                                            
                                                         
                                                      
                                                      k
                                                   
                                                   −
                                                   
                                                      η
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               )
                                                            
                                                         
                                                      
                                                      
                                                         C
                                                         P
                                                      
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           

Step 1: Apply MLLR to calculate K sets of transformations, {
                                 
                                    
                                       W
                                       n
                                       1
                                    
                                    ,
                                    
                                       W
                                       n
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       W
                                       n
                                       K
                                    
                                 
                              }, using the data from K different environments, namely {Q
                              
                                 c,1, Q
                              
                                 c,2, …, Q
                              
                                 c,K
                              }.

Step-2: Obtain the hyper-parameters in the CP density {
                                 
                                    
                                       ρ
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                    ,
                                    
                                       H
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                 
                              } using
                                 
                                    (22)
                                    
                                       
                                          
                                             ρ
                                             
                                                
                                                   n
                                                   
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                             
                                             
                                                C
                                                P
                                             
                                          
                                          =
                                          
                                             1
                                             K
                                          
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             
                                                W
                                                
                                                   
                                                      n
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                   
                                                
                                                k
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                              
                                 
                                    (23)
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   H
                                                   
                                                      
                                                         n
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                      
                                                   
                                                   
                                                      C
                                                      P
                                                   
                                                
                                                )
                                             
                                             
                                                j
                                                j
                                             
                                          
                                          =
                                          
                                             1
                                             K
                                          
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      W
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               j
                                                               )
                                                            
                                                         
                                                      
                                                      k
                                                   
                                                   −
                                                   
                                                      ρ
                                                      
                                                         
                                                            n
                                                            
                                                               (
                                                               i
                                                               j
                                                               )
                                                            
                                                         
                                                      
                                                      
                                                         C
                                                         P
                                                      
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                          ,
                                       
                                    
                                 
                              where 
                                 
                                    
                                       W
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                j
                                                )
                                             
                                          
                                       
                                       k
                                    
                                 
                               and 
                                 
                                    
                                       ρ
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                j
                                                )
                                             
                                          
                                       
                                       
                                          C
                                          P
                                       
                                    
                                 
                               are the (ij)th elements of 
                                 
                                    
                                       W
                                       n
                                       k
                                    
                                 
                               and 
                                 
                                    
                                       ρ
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                 
                              , respectively, and 
                                 
                                    
                                       
                                          (
                                          
                                             H
                                             
                                                
                                                   n
                                                   
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                             
                                             
                                                C
                                                P
                                             
                                          
                                          )
                                       
                                       
                                          j
                                          j
                                       
                                    
                                 
                               is the jjth diagonal element in 
                                 
                                    
                                       H
                                       
                                          
                                             n
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                          C
                                          P
                                       
                                    
                                 
                              .

With the same procedure, we can estimate the CP density for every node in all of the C EP trees. Because each CP density corresponds to a specific group of mean parameters for a particular cluster of environments, it provides local information of the ensemble environments. With the online CS process, we can directly locate the CP densities that best match the testing condition for MAP-based SFM and MAPLR.

The hyper-parameters of the sequential prior (SP) density are estimated based on sequential Bayesian learning (Hamilton, 1991). The SP densities enable MAP-based SFM and MAPLR to incorporate information seen previously for compensating the current testing utterances and for adapting the current acoustic model. The use of the SP density has been confirmed effective for MAP-based SFM (Jiang et al., 2001; Tsao et al., 2011); here we refine it further by using the local information provided by the environment structuring framework. In our system, the CS procedure is performed first to locate the acoustic model and EP tree that best match the testing utterance. With the located acoustic model and EP tree, the SP densities for MAP-based SFM and MAPLR are estimated through the following steps.

Step 1: At the beginning stage, initialize the hyper-parameters in the SP densities for every EP node. The hyper-parameter for the nth EP node is initialized as 
                                 
                                    {
                                    
                                       η
                                       n
                                       
                                          S
                                          P
                                          (
                                          0
                                          )
                                       
                                    
                                    =
                                    0
                                    }
                                 
                              . For the first utterance, 
                                 
                                    
                                       δ
                                       n
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                               is computed based on the ML criterion using Eqs. (8)–(10) while setting α
                              =0 in Eqs. (9) and (10).

Step 2: For the uth utterance, use the SP density with 
                                 
                                    
                                       η
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              , estimated from the previous (u
                              −1) utterances, to calculate 
                                 
                                    
                                       δ
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               using Eqs. (8)–(10).

Step 3: Use the calculated 
                                 
                                    
                                       δ
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               to update the hyper-parameters for the following utterances. Accordingly, the hyper-parameter for the nth EP node becomes 
                                 
                                    {
                                    
                                       η
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          )
                                       
                                    
                                    =
                                    
                                       δ
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                    }
                                 
                              .

Step 1: At the beginning stage, initialize the hyper-parameters in the SP densities for every EP node. The hyper-parameter for the nth EP node is initialized as 
                                 
                                    {
                                    
                                       ρ
                                       n
                                       
                                          S
                                          P
                                          (
                                          0
                                          )
                                       
                                    
                                    =
                                    0
                                    }
                                 
                              . For the first utterance, 
                                 
                                    
                                       W
                                       n
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                               is computed based on the ML criterion using Eqs. (16)–(18) while setting τ
                              =0 in Eqs. (17) and (18).

Step 2: For the uth utterance, use the SP density with 
                                 
                                    
                                       ρ
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          −
                                          1
                                          )
                                       
                                    
                                 
                              , estimated from the previous (u
                              −1) utterances, to calculate 
                                 
                                    
                                       W
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               using Eqs. (16)–(18).

Step-3: Use the calculated 
                                 
                                    
                                       W
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               to update the hyper-parameters for the following utterances. Accordingly, the hyper-parameter for the nth EP node becomes 
                                 
                                    {
                                    
                                       ρ
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          )
                                       
                                    
                                    =
                                    
                                       W
                                       n
                                       
                                          (
                                          u
                                          )
                                       
                                    
                                    }
                                 
                              .

To simplify the online computation, we only sequentially update 
                                 
                                    
                                       η
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               and 
                                 
                                    
                                       ρ
                                       n
                                       
                                          S
                                          P
                                          (
                                          u
                                          )
                                       
                                    
                                 
                               for MAP-based SFM and MAPLR, respectively, and use fixed 
                                 
                                    
                                       V
                                       n
                                       
                                          S
                                          P
                                       
                                    
                                 
                               and 
                                 
                                    
                                       H
                                       n
                                       
                                          S
                                          P
                                       
                                    
                                 
                               in the online process. Here, we set 
                                 
                                    
                                       V
                                       n
                                       
                                          S
                                          P
                                       
                                    
                                    =
                                    
                                       V
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                 
                               and 
                                 
                                    
                                       H
                                       n
                                       
                                          S
                                          P
                                       
                                    
                                    =
                                    
                                       H
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                 
                              .

Although the SP density can effectively utilize the information from previous testing data to perform FC and MA, when the environment condition changes abruptly (for example, from high SNR to low SNR conditions), the use of the SP density may lead to poor FC and MA mapping function estimations. Therefore in our study, the CS process is performed before using the SP density to prevent the performance degradations caused by sudden acoustic condition changes. By performing the CS process, only the most suitable EP tree is selected for each testing utterance, and the SP density of that EP tree is used for the MAP-based estimations. After decoding on that utterance, we only update the SP density of that selected EP tree for the following utterances. In this sense, only the suitable SP densities are used and updated for each particular test utterance.

As in the case of the SP densities, we perform the CS process to locate the acoustic model and EP tree that best match the testing condition to calculate the HP densities. The HP densities for MAP-based SFM and MAPLR are estimated as follows.

Step 1: For the root node of the EP tree, we calculate δ
                              1 using the entire set of means in the root node based on the ML criterion using Eqs. (8)–(10) while setting α
                              =0 in Eqs. (9) and (10), where no HP density is used in the calculation. The estimated δ
                              1 is used to prepare the prior densities for the child nodes in the next layer.

Step 2: For the nth node with its parent node r (as shown in Fig. 3), we have the hyper-parameter 
                                 
                                    
                                       η
                                       n
                                       
                                          S
                                          P
                                       
                                    
                                    =
                                    
                                       δ
                                       r
                                    
                                 
                              , and MAP-based SFM calculates δ
                              
                                 n
                               using Eqs. (8)–(10). The calculated δ
                              
                                 n
                               is used to prepare the prior densities for the child nodes of the nth node.

Step 3: Repeat Step 2 until reaching the leaf nodes of the EP tree.

Step 1: For the root node of the EP tree, we calculate W1 using the entire set of means in the root node based on the ML criterion using Eqs. (16)–(18) while setting τ
                              =0 in Eqs. (17) and (18), where no HP density is used in the calculation. The calculated W1 is used as the prior densities for the child nodes in the next layer.

Step 2: For the nth node with its parent node r (as shown in Fig. 3), we have the hyper-parameter 
                                 
                                    
                                       ρ
                                       n
                                       
                                          H
                                          P
                                       
                                    
                                    =
                                    
                                       W
                                       r
                                    
                                 
                              , and MAPLR calculates W
                                 n
                               using Eqs. (16)–(18). The calculated W
                                 n
                               is used to prepare the prior densities for the child nodes of the nth node.

Step 3: Repeat Step 2 until reaching the leaf nodes of the EP tree.

As in the case of the SP densities, we only online estimate mean hyper-parameters, 
                                 
                                    
                                       η
                                       n
                                       
                                          H
                                          P
                                       
                                    
                                 
                               and 
                                 
                                    
                                       ρ
                                       n
                                       
                                          H
                                          P
                                       
                                    
                                 
                               for MAP-based SFM and MAPLR, respectively, and use fixed 
                                 
                                    
                                       V
                                       n
                                       
                                          H
                                          P
                                       
                                    
                                    (
                                    =
                                    
                                       V
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                    )
                                 
                               and 
                                 
                                    
                                       H
                                       n
                                       
                                          H
                                          P
                                       
                                    
                                    (
                                    =
                                    
                                       H
                                       n
                                       
                                          C
                                          P
                                       
                                    
                                    )
                                 
                              . The main advantage of the HP densities is that the information of the current testing utterance can be used efficiently with the EP tree structure.

The hyper-parameters in the IP densities combine those in the three prior densities presented above. We simply use a linear combination in this study. Therefore, for MAP-based SFM, we obtain the hyper-parameter, 
                              
                                 
                                    η
                                    n
                                    
                                       I
                                       P
                                    
                                 
                              
                           , using:
                              
                                 (24)
                                 
                                    
                                       
                                          η
                                          n
                                          
                                             I
                                             P
                                          
                                       
                                       =
                                       
                                          w
                                          
                                             C
                                             P
                                          
                                       
                                       
                                          η
                                          n
                                          
                                             C
                                             P
                                          
                                       
                                       +
                                       
                                          w
                                          
                                             S
                                             P
                                          
                                       
                                       
                                          η
                                          n
                                          
                                             S
                                             P
                                          
                                       
                                       +
                                       
                                          w
                                          
                                             H
                                             P
                                          
                                       
                                       
                                          η
                                          n
                                          
                                             H
                                             P
                                          
                                       
                                       ,
                                    
                                 
                              
                           where 
                              
                                 
                                    w
                                    
                                       C
                                       P
                                    
                                 
                              
                           , 
                              
                                 
                                    w
                                    
                                       S
                                       P
                                    
                                 
                              
                           , and 
                              
                                 
                                    w
                                    
                                       H
                                       P
                                    
                                 
                              
                            are weighting coefficients.

Similarly for MAPLR, we obtain the hyper-parameter, 
                              
                                 
                                    ρ
                                    n
                                    
                                       I
                                       P
                                    
                                 
                              
                           , using:
                              
                                 (25)
                                 
                                    
                                       
                                          ρ
                                          n
                                          
                                             I
                                             P
                                          
                                       
                                       =
                                       
                                          ε
                                          
                                             C
                                             P
                                          
                                       
                                       
                                          ρ
                                          n
                                          
                                             C
                                             P
                                          
                                       
                                       +
                                       
                                          ε
                                          
                                             S
                                             P
                                          
                                       
                                       
                                          ρ
                                          n
                                          
                                             S
                                             P
                                          
                                       
                                       +
                                       
                                          ε
                                          
                                             H
                                             P
                                          
                                       
                                       
                                          ρ
                                          n
                                          
                                             H
                                             P
                                          
                                       
                                       ,
                                    
                                 
                              
                           where ɛ
                           
                              CP
                           , ɛ
                           
                              SP
                           , and ɛ
                           
                              HP
                            are weighting coefficients. In this study, we only update 
                              
                                 
                                    η
                                    n
                                    
                                       I
                                       P
                                    
                                 
                              
                            and 
                              
                                 
                                    ρ
                                    n
                                    
                                       I
                                       P
                                    
                                 
                              
                           , respectively, for MAP-based SFM and MAPLR online, and use fixed 
                              
                                 
                                    V
                                    n
                                    
                                       I
                                       P
                                    
                                 
                                 (
                                 =
                                 
                                    V
                                    n
                                    
                                       C
                                       P
                                    
                                 
                                 )
                              
                            and 
                              
                                 
                                    H
                                    n
                                    
                                       I
                                       P
                                    
                                 
                                 (
                                 =
                                 
                                    H
                                    n
                                    
                                       C
                                       P
                                    
                                 
                                 )
                              
                           . As in the case of the HP densities, we first locate one EP tree, and then iteratively estimate and propagate the IP densities. Finally, the estimation and propagation stop at the leaf nodes of the EP tree. Notably, the CP, SP, and HP densities are estimated using the information from the training data, statistics seen from the previous utterances, and the current testing data with the EP tree, respectively. Therefore, the IP densities incorporate multiple prior information sources.

@&#EXPERIMENTS@&#

In this section, we present the speech databases, experimental setup, and results of MAP-based FC and MA with the environment structuring framework.

We conducted experiments on two sets of speech tasks, Aurora-2 (Pearce and Hirsch, 2000; Macho et al., 2002) and Aurora-4 (Hirsch, 2001; Parihar and Picone, 2002; Parihar et al., 2004). Aurora-2 is a connected digit recognition task including two training sets, multi-condition and clean condition. The multi-condition training set was used to build acoustic models and to construct the environment structuring framework. There are 70 different testing conditions (ten noise types at seven SNR levels) in Aurora-2. These 70 testing conditions were divided into set A, set B, and set C. Speech signals in test sets A and B were distorted by additive noises (in set A, the noise types were subway, babble, car, and exhibition; in set B, the noise types were restaurant, street, airport, and train station). Speech signals in set C were distorted by additive noise and channel effects (subway and street noises together with an MIRS channel mismatch).

Speech data in the Aurora-4 task were obtained from the Wall Street Journal (WSJ0) database (Paul and Baker, 1992) and artificially contaminated with different types of noise at SNR levels ranging from 5 to 15dB. Two sampling rates, 8kHz and 16kHz, were available for both training and testing. In this study, the 8kHz sampling rate condition was used. The multi-condition training set was selected to build acoustic models and to construct the environment structuring framework. This training set included 7138 utterances. Fourteen test sets were provided for evaluating performances, and 166 utterances for each test set were used as suggested in (Parihar and Picone, 2002). The 14 test sets were classified into four groups: set A (clean data with the Sennheiser microphone; test set 1), set B (noisy data with the Sennheiser microphone; test sets 2–7), set C (clean data with the secondary microphone; test set 8), and set D (noisy data with the secondary microphone; test sets 9–14). In the following, we will present performances of these four sets along with an average result, Avg (test sets 1–14).

For both Aurora-2 and Aurora-4, we used the ETSI advanced front-end (AFE) for feature extraction (ETSI, 2007). Each feature vector comprised 39 dimensions including 13 static features along with their first- and second-order dynamic features. To perform speech recognition, the HVite function in HTK toolkit (Young et al., 2005) was used for Aurora-2. On the other hand, for Aurora-4, we used a weighted finite state transducer (WFST) (Mohri et al., 2008) based speech recognizer that was developed at National Institute of Information and Communications Technology (NICT) (Dixon et al., 2012). Here, we intentionally used two types of decoders to confirm the compatibility of MAP-based FC or/and MA with the environment structuring framework and different ASR systems.

For Aurora-2, we followed the complex backend HMM topology suggested by (Macho et al., 2002) to prepare 11 digit models (zero, one, two, three, four, five, six, seven, eight, nine, and oh) with silence and short pause models. Each digit model contained 16 states and 20 Gaussian mixtures per state. Silence and short pause models included three and one states, respectively, and 36 mixtures per state. For Aurora-4, we adopted a triphone-based HMM topology to train acoustic models. For this topology, we used 2137 shared states in total. Each triphone was characterized by three active states, and each state was modeled by eight Gaussians. Silence and short pause were also characterized by three active states, where each state was characterized by 16 Gaussians. In the original Aurora-4 baseline system, a bigram language model was used to test recognition (Parihar et al., 2004). In more recent studies, a trigram language model has also been used to provide more powerful language modeling capability and thus achieve better recognition performance (Hilger and Ney, 2006; Tüske et al., 2011). When using a trigram language model, it becomes more difficult to further improve the recognition performance than using a bigram language model. In this study, we used a trigram back-off language model that was prepared by the reference transcription of the training utterances.

For each of the Aurora-2 and Aurora-4 tasks, we constructed an environment structuring framework (in Fig. 2), including one two-layer EC and one two-layer EP tree. The root node of the EC tree contained the entire set of training utterances. In the first layer, the EC tree included two nodes, dividing the entire set of training data into two clusters. In the second layer, each node in the first layer was further divided into two nodes, with each node containing a subset of training data from its parent node. Finally, an EC tree with seven nodes (one root node, two intermediate nodes, and four leaf nodes) was constructed. In the proposed framework, data clustering units can be any particular types, which correspond to underlying distortion factors that cause mismatches of training and testing conditions. For Aurora-2 and Aurora-4, speaker variability, noise types, and SNR conditions are obvious distortion factors. When the labels corresponding to these distortions are available, data clustering can be performed accordingly. In the Aurora-2 database, the training set included 17 different speaking environments that were originated form the same four types of noise as in test set A, at four SNR levels: 5dB, 10dB, 15dB, and 20dB, along with clean condition. We further divided the training set into two gender-specific subsets to form 34 speaker and speaking environments. In this study, the two-layer EC tree used in Aurora-2 was constructed by: the first layer classified the 34 environments into two groups of two genders, and the second layer separated the 17 environments into two groups roughly according to high/low SNR levels (Tsao et al., 2011).

On the other hand, the training data in Aurora-4 did not provide explicit SNR labels, and thus we adopted an utterance level clustering process to build the EC tree. The following four steps were performed to construct the EC tree (as presented in Fig. 4
                        ):

Step 1: Use the entire training set to estimate a Gaussian mixture model-based universal background model (GMM-UBM).

Step 2: Estimate utterance-specific GMMs by performing MAP adaptation on the GMM-UBM. Assuming that the training set has U utterances, we estimate U utterance-specific GMMs.

Step 3: Concatenate mean parameters in each GMM into a super-vector to obtain U super-vectors.

Step-4: Apply k-means vector quantization (VQ) (Duda et al., 2001) to the U utterance-specific super-vectors. Then use the VQ result on these super-vectors to classify the training utterances and construct the EC tree. Finally the utterances belonging to each EC node are further clustered into K groups, corresponding to K specific acoustic conditions. In this study, we set K
                        =10 for each EC node.

Based on the EC tree, we first used the entire training set to train one HMM set for the root node. Then a MAP adaptation (Gauvain and Lee, 1994) was adopted to estimate an HMM set for each EC node in the first and second layers. Therefore, for both Aurora-2 and Aurora-4, all of the seven acoustic models in the EC tree have the same model topology. Next, for each of the seven HMM sets, we estimated a two-layer EP tree, each consisting of one root, three intermediate, and six leaf nodes. A top-down k-means clustering algorithm with the weighted Euclidean distance (Duda et al., 2001) was adopted to group the Gaussian components representing similar acoustic properties in the same layer. Finally with the EC and EP algorithms, we prepared the environment structure that included an EC tree with seven nodes, and each node had an EP tree with ten nodes, in the offline stage.


                        Fig. 5
                         shows the overall recognition system consisting of FC, MA, and the environment structuring framework. The overall procedure can be divided into three stages. In the first stage, the 1st pass decoder recognizes testing speech and outputs a recognized reference. In the second stage, we compute the required statistics, such as r
                        
                           s
                        (t) in Eqs. (9), (10) and (17), (18), based on the recognized reference; then the mapping functions of FC or/and MA are estimated. In the third stage, the estimated parameters for FC or/and MA feed into the 2nd pass decoder. After performing FC or/and MA, the 2nd pass decoder recognizes speech and outputs the final recognition result.

To perform MAP-based SFM, we followed Eqs. (6)–(10) and the four steps introduced in Section 2.3, in a per-utterance self-compensation manner. To perform MAPLR, we followed Eqs. (14)–(18) and the four steps introduced in Section 2.4, in a per-utterance self-adaptation manner.

@&#EXPERIMENTAL RESULTS@&#

This section reports the experimental results. In the following discussion, EI indicates that the environment independent (EI) acoustic model was used for the three stages in Fig. 5. This EI acoustic model was trained on the entire set of training data, corresponding to the root node of the EC tree. Here, the EP tree for this EI acoustic model is called the EI tree. ED indicates that an environment dependent (ED) acoustic model was used for the three stages in Fig. 5. The ED acoustic model and the ED tree were located from the EC tree using the CS process (in Eq. (11)). Finally, FC and MA denote the results of using compensation bias and linear regression, respectively, as the mapping functions.

First, we present the recognition results on the Aurora-2 task. The recognition performances were reported in terms of average word error rate (WER).

The results for sets A, B, and C, in 0- to 20-dB SNR conditions, are reported in the following discussions. The average result of the 50 testing conditions (over the ten noise types at 0- to 20-dB SNR levels) is also provided as Avg. We list the EI experimental results of the Baseline, ML-based FC, and ML-based MA, respectively, as Baseline (EI), ML-FC (EI), and ML-MA (EI) in Table 1
                              . Notably, ML-based FC and MA, respectively, use α
                              =0 in Eqs. (9) and (10) and τ
                              =0 in Eqs. (17) and (18). For Baseline (EI) in Table 1, we directly use the EI acoustic model to test recognition. The same baseline results can be found in previous studies (Wu and Huo, 2006; Tsao and Lee, 2009). The results in Table 1 verified that both ML-FC and ML-MA improved the baseline performance consistently over sets A, B, C, and Avg.

Next, we list the ED results of the Baseline, ML-based FC, and ML-based MA, respectively, as Baseline (ED), ML-FC (ED), and ML-MA (ED) in Table 2
                              . For this set of results, we used the ED acoustic model and ED tree to perform ML-FC, ML-MA, and test recognition. From Table 2, we observe clear improvements of ML-FC (ED) and ML-MA (ED) over Baseline (ED). Comparing Tables 1 and 2, we notice that we can obtain better performance for the baseline, FC, and MA using the ED acoustic model and ED tree than using the EI acoustic model and EI tree. The improvements confirm the benefits of using the ED acoustic model and ED tree that incorporate the local information of the environment space.

In MAP-based FC and MA, four types of prior densities as introduced in Section 3 were applied. The parameters, α and τ, in Eqs. (2) and (4), were optimized empirically. The results of Avg in Aurora-2 are shown in Figs. 6 and 7
                              
                              . The IP densities that performed the best were presented in the figures: for MAP-FC, {w
                              
                                 CP
                              
                              =0.2, w
                              
                                 SP
                              
                              =0.1, w
                              
                                 HP
                              
                              =0.7} in Eq. (24) was applied, and for MAP-MA, {ɛ
                              
                                 CP
                              
                              =0.3, ɛ
                              
                                 SP
                              
                              =0.2, ɛ
                              
                                 HP
                              
                              =0.5} in Eq. (25) was applied.

From these figures, we can see that IP outperforms CP, SP, and HP for both MAP-FC (ED) and MAP-MA (ED). This set of results confirms that by integrating prior information about CP, SP, and HP, the IP densities can enable MAP-based FC and MA to achieve better performance than they can achieve individually. For this reason, the IP densities were used for MAP-based FC and MA in the following experiments.


                              Table 3
                               shows the results of MAP-FC (ED) and MAP-MA (ED) using the IP densities. From Tables 2 and 3, we can see that both MAP-based FC and MA achieve better performances for all of the four sets than their ML-based counterparts.

As we mentioned in Section 2, FC and MA may provide supplementary information to each other. Thus, we also tested the combination of MAP-based FC and MA. In this case, the testing feature vectors were first compensated by FC, and then the acoustic model was adapted by MA based on the compensated features. Table 4
                               lists this set of results as MAP-FC+MA (ED), where the ML-based counterpart is also listed as ML-FC+MA (ED) for comparison. From Table 4, it is noted that MAP-FC+MA (ED) outperforms ML-FC+MA (ED) for all of the four test sets, confirming the advantage of using the prior densities. Additionally, from Tables 3 and 4, we can see that MAP-FC+MA (ED) outperforms both MAP-FC (ED) and MAP-MA (ED), verifying that FC and MA can be integrated to achieve further improvements.

Following the same experimental procedures as on the Aurora-2 task, we conducted the experiments on the Aurora-4 task. The average WER was again used to report recognition performances.


                              Table 5
                               lists the Aurora-4 baseline results of using EI and ED acoustic models as Baseline (EI) and Baseline (ED), respectively. From Table 5, we again observe that Baseline (ED) provides consistent improvements over Baseline (EI) for the five test sets, confirming the effectiveness of the CS process in determining the acoustic model that better matches the testing condition for performing recognition.

Next, Table 6
                               shows the results of ML-based FC, MA, and FC+MA, respectively, as ML-FC (ED), ML-MA (ED), and ML-FC+MA (ED). By comparing the results in Tables 5 and 6, we can see that ML-FC (ED), ML-MA (ED), and ML-FC+MA (ED) outperform Baseline (ED) in Avg. In addition, we observe that ML-FC+MA (ED) underperforms ML-FC (ED). This might be owing to the too limited data available to calculate the MA mapping function, and thus over-fittings occur.

In a preliminary experiment, we observed that the IP densities gave the best performance for MAP-based FC, MA and FC+MA for the Aurora-4 task (which was consistent with the Aurora-2 experimental results in Figs. 6 and 7). Thus in Table 7
                              , we list the results of MAP-based FC, MA and FC+MA, all using the IP densities, as MAP-FC (ED), MAP-MA (ED), and MAP-FC+MA (ED).

From Tables 6 and 7, we observe that MAP-FC (ED), MAP-MA (ED), and MAP-FC+MA (ED), respectively, outperform their ML-based versions consistently over the five test sets. The results confirm that the prior densities effectively enhance FC, MA, FC+MA to achieve better performances. Meanwhile, we notice that although ML-FC+MA (ED) underperforms ML-FC (ED) in Table 6, with the IP density, MAP-FC+MA (ED) outperforms MAP-FC (ED) in Table 7; the results indicate that the MAP criterion effectively reduces the over-fitting issues for MA. MAP-FC+MA (ED) represents our best configuration in this study: the integration of FC and MA with the IP densities provided by the ED acoustic model and ED tree. Compared with the Aurora-4 baseline results, MAP-FC+MA (ED) achieved clear and consistent WER reductions over the five test sets.

In the previous experiments, for the EI results, the EI acoustic model and the prior densities prepared using the EI tree were used to perform MAP-based FC and MA. Similarly, for the ED results, we used the ED acoustic model and prior densities prepared using the ED tree. Here, we tested performance using the ED acoustic model, whereas the prior densities were prepared using the EI tree. We show and denote this set of results as MAP-FC (ED-EIP), MAP-MA (ED-EIP), and MAP-FC+MA (ED-EIP) in Table 8
                              . Notably, the results in Tables 7 and 8 used the same ED acoustic model but different prior densities.

From Tables 7 and 8, we can see that MAP-FC (ED), MAP-MA (ED), and MAP-FC+MA (ED) outperform MAP-FC (ED-EIP), MAP-MA (ED-EIP), and MAP-FC+MA (ED-EIP), respectively. The results verify that using the prior densities prepared by the ED tree, MAP-based FC, MA, and FC+MA can yield better performance than that using prior densities prepared using the EI tree.

We intend to further verify the significance of improvements (WER reductions) of MAP-FC (ED), MAP-MA (ED), and MAP-FC+MA (ED) over MAP-FC (ED-EIP), MAP-MA (ED-EIP), and MAP-FC+MA (ED-EIP), using a t-test analysis (Hayter, 2006). Because the entire Aurora-4 test set has 14 different sets, we conducted the t-test on 14 pair-wise results. Table 9
                               lists the t-test results of MAP-based FC, MA, and FC+MA using prior densities prepared using the EI tree versus that prepared using the ED tree. From Table 9, we observe small p-values for the t-test results, suggesting that MAP-FC (ED), MAP-MA (ED), and MAP-FC+MA (ED), respectively, outperform MAP-FC (ED-EIP), MAP-MA (ED-EIP), and MAP-FC+MA (ED-EIP), over the 14 test sets consistently. Since the ED tree provides local information, the results confirm that more suitable prior densities can be designed by incorporating local information to enable MAP-based algorithms to achieve better performance.

@&#CONCLUSION@&#

In this paper, we proposed a two-stage environment structuring framework to facilitate suitable prior density specification for MAP-based FC and MA for robust speech recognition. Based on the EC and EP processes, a hierarchical tree structure was created to describe the acoustic environments. Based on the hierarchical tree structure, we can determine a local acoustic space to fit the testing condition. In addition, based on the hierarchical tree structure, we proposed three types of prior density estimation algorithms as well as their combination to facilitate the MAP-based FC and MA. On the Aurora-2 and Aurora-4 tasks, our evaluation showed that by using the environment structuring framework to determine the best acoustic model for recognition, we can already improve the baseline recognition results. Moreover, the performance can be enhanced by adopting ML-based FC and MA. A further improvement was achieved by using MAP-based FC and MA. In addition, from the results of utilizing the prior density estimation for MAP-based FC and MA, we confirmed that the IP densities gave the best performance, because they integrated the knowledge of prior information sources from the CP, HP, and SP densities. Finally, considering the contributions of the ED and EI trees for robust recognition, we observed that using the prior densities prepared by the ED tree outperformed that prepared by the EI tree. All of these results confirmed the advantage of incorporating local information into prior density preparation.

In this study, we focused our attention on using the environment structuring framework to prepare suitable prior densities for MAP-based FC and MA. Only MAP-based SFM and MAPLR were presented as two application examples. It is clear that other MAP-based approaches can also utilize the prior densities prepared by the environment structuring framework. Additionally, the proposed framework can be applied to other tasks, such as environment or event modeling and de-noising for audio event recognition tasks, and speaker modeling for speaker recognition tasks. We will explore further in these directions in the future.

@&#ACKNOWLEDGEMENT@&#

This work was supported by the National Science Council of Taiwan under contracts NSC101-2221-E-001-020-MY3.

@&#REFERENCES@&#

