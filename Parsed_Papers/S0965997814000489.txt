@&#MAIN-TITLE@&#Design of efficient packing system using genetic algorithm based on hyper heuristic approach

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New robust flexible to change system used to model different packing problem.


                        
                        
                           
                           Novel integrated approach with hyper-heuristic search technique coupled with GA.


                        
                        
                           
                           All possible cases for placement: rectangle items with and without rotation.


                        
                        
                           
                           Novel fitness function to evaluate the strength of the overall design layout.


                        
                        
                           
                           Reduce computation time significantly achieve high filling rate upto 99%.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Genetic algorithm

Heuristic

Hyper heuristic

Optimization

Strip packing

Transportation industries

@&#ABSTRACT@&#


               
               
                  In practice the maximum usage of container space arises in many applications which is one of the crucial economical requirements that have a wide impact on good transportation. A huge amount of monetary infrastructure is spent by companies on packing and transportation. This study recommends that there exists a scope for further optimization which if implemented can lead to huge saving. In this paper, we propose a new hyper heuristic approach which automates the design process for packing of two dimensional rectangular blocks. The paper contributes to the literature by introducing a new search technique where genetic algorithm is coupled with the hyper heuristic to get the optimal or sub optimal solution at an acceptable rate. The results obtained show the benefits of hyper-heuristic over traditional one when compared statistically on large benchmark dataset at the 5% level of significance. Improvements on the solution quality with high filling rate up to 99% are observed on benchmark instances.
               
            

@&#INTRODUCTION@&#

Packing and transportation are one of the major concerns for developed as well as developing nations. The changing scenario of growing need compels to make government policies and mission for the development of science and technologies to achieve safe, economical, efficient, secure, and meet applicable regulatory requirements for packing and transportation. A numerous efforts are being done to resolve packaging and transportation issues safely, economically, and promptly. First and foremost, objective for transport packaging must serve to protect goods in transit. This can be achieved by proper packing and placement of goods during transit as it can only ensure against unintended shocks, impacts or accidents of any kind. Good and efficient transportation has a vital role to play in the economy of any nation.

In this paper, we discuss the packing issues related to two dimensional objects like packing of rectangular strips into a larger container. The main objective is to maximize the space utilization by the rectangle and minimize the overall height of the packed rectangles. There are different categories for this problem such as placement with and without rotation of the items, placement subjected to guillotine cut or non guillotine cut. We address the placement of rectangle blocks both with and without rotation subjected to guillotine cut, i.e., the placement of the rectangle blocks must be parallel to the containers axis. The paper first presents the placement strategy, carry out the fitness evaluation of the obtained design, and then use a constructive greedy hyper-heuristic approach to search a better solution. Genetic algorithm is used to improve the solution and prevent the it from being trap in local minima. Computation results on benchmark instances show the efficiency and better convergence rate.

The common approaches used to solve this class of problem are classified as exact, heuristic, and meta heuristic. Based on the nature of these approaches they proceed to find optimal or suboptimal solution for the given problem instance. In exact approaches, methods that use linear programming concept like branch-and-bound, branch-price, branch-cut-price, etc. are usually employed that involve tree search procedure. These approaches are fairly acceptable on small instances but fail to perform well on larger classes. Some of the recently proposed approaches include Belov et al. [1] investigates the constraint programming approach for orthogonal packing not allowing the rotation of pieces. The approach is based on disjunctive strategy for branching and uses linear programming based relaxation bounds. Leung et al. [2] solved some instances of irregular strip packing problem by non linear programming model with tabu search used to avoid local minima. Arahori et al. [3] proposed an exact method that represented the sub problem as g-staircase and used branch and bound to solve allowing relaxation.

Several major contributions as heuristic algorithm to solve the problem are presented in the literature. Out of many is first to count is by Baker et al. [4] which is bottom left, and being used as basis by many other heuristic and meta heuristic approaches. Considering both horizontal and vertical placement Asik and Özcan [5] improved the best fit heuristic by considering the bi-directional placement (BBF). This work was improved by Özcan et al. [6] by best fit based bi-directional heuristic (BBFM) taking pair of rectangles to be placed rather than single placement. The heuristic approaches exploit the feature of the problem to get optimal solution in reasonable time. However, the approach does not guarantee to get optimal for all cases. The meta heuristic approaches like genetic algorithm (GA), stimulation annealing, etc. are used to solve the strip packing problem. The GA approach considering strip packing as the permutation problem was solved by Yeung and Tang [7] named as Lowest-Fit-Left-Aligned” (LFLA) heuristic approach. Bortfeldt [8] used GA for strip packing without performing any encoding to determine the best layout design. Another GA approach was used by Gonc-alves [9] based on random key for the initial population generation to get the placement sequence for the rectangles. GA was hybridized with the placement procedure. A greedy randomized adaptive search procedure (GRASP) by Alvarez-Valdes et al. [10] based on the intuitive learning to fix the difficult strip packing problem by setting appropriate parameters with the learned information. Wei et al. [11] presented a least wasted first (LWF) strategy that evaluated based on the position occupied by the rectangle and coupled it with local search to improve the performance.

Leung and Zhang [12] proposed fast layer-based heuristic (FH) with the strategy of stacking rectangles, where the concept of reference line is used for packing. The greedy strategy is used to improve the result by assigning of fitness value to unpacked rectangle and selecting the one with highest fitness. A hybrid simulation annealing (HSA) algorithm by Stephen et al. [13] which combine three sequential approaches: fitness strategy to find possible solution, greedy strategy to select the best one and simulation annealing to escape from local minima. Burke et al. [14] gave a genetic programming based hyper heuristic system for better evolution to solve the strip packing problem. In this paper, we have exploited the behavior of hyper heuristic with genetic algorithm.

@&#MOTIVATION@&#

Shipping of goods is a common and a day to day activity in almost all the industries. Thus, achieving highest occupancy of container capacity is an important concern. The better utilization have impact on many factors like reducing number of vehicle in shipment, reducing the cost of damage during transit, improving the transportation cost and economy saving. All these goals can be achieved if boxes are packed optimally or near optimally. Packaging decisions have a major impact on logistical productivity and efficiency. Handling efficiency in all of these situations is significantly influenced by package design, unitization, and communication characteristics. The packing problem is a type of NP-Hard problem as the number of box increases the solution cannot be obtained in polynomial time. This motivates the use of heuristic and meta-heuristic approaches. For, the packing combinatorial optimization problem with growing complexity and computational constraint the solution using exact approach in reasonable time seems to be infeasible.

Combinatorial optimization problems are core and exist everywhere in the industrial system. Various practical issues are to be considered while dealing with these problems. These issues are practical solvability as the problem size grows, i.e., the complexity with size, accuracy of the developed model, processing time, etc. are important consideration point in finding the optimum solution. All these issues should be efficiently tackled by the solution methodology. However, in case of exact approach run time often increases dramatically with the problem instance and on the other hand small and moderate instance can be efficiently solved in reasonable time. The next common approach is to apply heuristic techniques which find good solution in reasonable time. However, it does not guarantee the solution quality. This encourages the use of meta-heuristic approach for combinatorial optimization problem. Meta-heuristic uses intelligent and computational efficient search techniques for better exploitation and exploration of the search space. Its use is becoming popular to solve complex real world applications of practical interest. The proposed approach based on hyper heuristic is derived from various combinations and adaptations of principles and ideas from mathematical programming, biological and physical systems, and artificial intelligence.

The contributions made to the literature are stated in this section. The important features of the designed system are as follows:
                           
                              1.
                              A hyper-heuristic search technique is coupled with genetic algorithm for efficient packing of 2D rectangle pieces into a given huge container.

A packing technique that considers the placement of rectangle pieces with and without rotation.

A novel fitness function to evaluate the strength of the overall design layout.

Designed a new robust system flexible to changes and can be used to model different cutting and packing problem occurring in other major industries like shipbuilding, textile, wood, plastic, sheet metal, and leather manufacturing.

The performance is independent of the preprocessing of instances and the computation time is significantly reduced.

The efficiency of the proposed approach concluded from the computation result on the benchmark instances are reported in the result and discussion session.

This paper is organized as follows: ‘Problem definition and system model’ introduces the problem definition and a formalization of packing problem. The theoretical background for better understanding of the approach is discussed in ‘Theoretical Background’, wherein the subsections we briefly discuss genetic algorithm and hyper-heuristic search methodology. ‘Proposed Methodology’, presents the proposed approach which details the placement strategy, the novel fitness function and the coupling with hyper-heuristic for better evaluation of the problem. ‘Experimental result and discussion’, reports the experimental work carried out on the benchmark instances from the literature. It presents a detail comparison and report statistical observation made when the proposed approach is compared with traditional as well as recently proposed from the literature. Finally, in ‘Conclusion’ we give the concluding remarks on the obtained results and comment on efficiency and effectiveness of the proposed model.

Cutting and packing can be classified in different ways as proposed by Wäscher et al. [15] the categories are dimensions, kind of assignment, assortment of large objects, assortment of small items and on the basis of shape of the small items. Based on dimensions these are categorized as: one dimensional (1D) bin packing, two dimensional (2D) strip packing and three dimensional (3D) bin packing. In 1D Bin Packing Problem packing is considered for set of different size items into minimum required large identical objects. In case of 2D variable width and length are used whereas for 3D the variable parameters are width, length or height. The strip packing problem is represented by 2/V/O/M specifying it’s a two dimension problem where the assignment involve selection of object and all its item involving assortment of one large object with many items of different figure for the assortment of small items.

Here, we address the two dimensional aspect of the problem that occurs in many industrial application. The problem is a set of finite rectangles of varying height and width are to be packed in the larger container (large enough to accommodate all rectangles) such that the height of packing is minimized or in other word the occupancy is high. The problem can be easily mapped to cutting industry which involves cutting of large stock to meet lower stock customer demand or to warehouse industry which requires the arrangement of items on to big platform, container, or vessels. The variant of packing problem is one with the shape of items to be packed are irregular usually encountered by fabrication and textile industries. These irregular geometric shapes increase the complexity of such problem. This section introduces the packing problem and gives a mathematical formulation of the model.

Given an rectangular area or container with a fixed width W and height H, and a set of n rectangles say R
                        1, R
                        2,…,
                        Rn
                        . Each rectangle to be packed has a width (wi
                        ) and height (hi
                        ), where i
                        =1,…,
                        n. Let the container rectangular area be considered as a Cartesian plane with the bottom left most coordinate as (0,0). The smaller rectangles are placed parallel to the edge of the X and Y axis. The objective of the rectangular packing is to place all the rectangles, such that no vacant or minimum space between any two placed rectangle and the resulting layout design height is minimized. The placements of rectangles are subjected to the following constraints:
                           
                              1.
                              No rectangle placement can exceed the width of the container and all the rectangles can be packed in the container.

No two rectangles can overlap each other.

Edge of the rectangle packed is parallel to the edge of the container.

Rotation of rectangles are allowed, i.e., they can be packed either horizontally or vertically in the container.

The model is formulated based on simple observations; the developed compact model thus developed helps to find the optimal solution. The model makes use of two decision variables: P stating that each rectangular block can be placed only once in the container and the second xij
                         indicating that ith rectangle is placed at jth level. Each rectangular block is represented using a quadruple (xi
                        ,
                        yi
                        ,
                        hi
                        ,
                        wi
                        ) where (xi
                        ,
                        yi
                        ) represents the leftmost coordinate of placed rectangle, h and w stands for height and width respectively.
                           
                              
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   If block is placed in the container
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   Otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The item packing at the level is modeled by
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   If block
                                                   
                                                   i
                                                   
                                                   is placed at boundary surface for level
                                                   
                                                   j
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   Otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This model differs from other level based models, as in other models each level is determined by the highest placed rectangle, and the filling of level takes place by smaller ones and finally the levels are kept in the container. However, in this case, the focus is on width parameter rather than height. The top surface of each placed rectangle is called the level, and the associated width is termed as level width (Wi
                        ), i.e., the length of the ith level as denoted by the bold lines as in Fig. 1
                        . Each level form acts as a sub maximization problem, where the objective is to maximize these level width occupancy of the top surface by placement of rectangles. The decomposition of problem into number of sub problem of maximization helps to achieve the overall objective of container height minimization by efficient packing.

The Integer Linear Programming (ILP) model for each level is as follows:
                           
                              (1)
                              
                                 
                                    max
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 sub
                                 :
                                 
                                 
                                    max
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          j
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       ij
                                    
                                 
                                 +
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 1
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       ij
                                    
                                 
                                 ⩽
                                 
                                    
                                       W
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                w
                                             
                                             
                                                i
                                             
                                          
                                          ⩽
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          
                                          or
                                          
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          +
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                          ⩽
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          
                                          or
                                       
                                    
                                    
                                       
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                h
                                             
                                             
                                                i
                                             
                                          
                                          ⩽
                                          
                                             
                                                y
                                             
                                             
                                                j
                                             
                                          
                                          
                                          or
                                          
                                          
                                             
                                                y
                                             
                                             
                                                j
                                             
                                          
                                          +
                                          
                                             
                                                h
                                             
                                             
                                                j
                                             
                                          
                                          ⩽
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       x
                                    
                                    
                                       ij
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                           
                        
                     

The objective function (1) indicates the maximization the level surface by placing those rectangles such that summation of width is less than or equal to level width. Eq. (2) imposes that each item is packed exactly once either to form the level or placed to maximize the top surface for any other level. Eq. (3) imposes the width constraint, i.e., the sum of the placed rectangles width cannot exceed the level width to be maximized. Constraint (4) ensure that there is no overlapping between any two rectangles placed.

Genetic Algorithms (GA) are stochastic method for optimization which imitates the natural evolution process, described by Darwin’s Theory. Due to its stochastic nature it is required to set an upper limit on the number of executions or value of objective function to be maximized or minimized. It belongs to the group of Evolutionary Algorithms (EA). The GA composes of three basic major operators: Reproduction, Crossover and Mutation. The reproduction is a process by which transfer of genetic information from parent with good fitness to their offspring to survive the next generation. Crossover is a process between two parents where they exchange genetic information to generate two offspring with mix features. From the optimization problem perspective, it is referred as the exploitation of the search space region. Mutation refers to a random change in gene by altering one or more values to generate an entirely new one. It plays an important role in this search process as the changes made can help in finding better solution and prevent population stagnation by escaping from local minima problem. The GA has proved as a robust search technique in complex search space of optimization problem. This motivates the use of GA in scientific application, business application, industrial applications, and system designs because of their capability of searching for the objective improvement. Some recently reported applications of GA in literature are optimization methods for a national-level highway project planning presented by Šetinc et al. [16], Residential Temperature Control in the Presence of Time-Varying Electricity by Molina et al. [17], smoothing technique in frequency domain discussed by Eder and Gerstmayr [18] etc.

The challenges to solve computationally hard search problem have motivated the use of hyper heuristic approach for automating the heuristic search design helpful in solving numerous real world problems. Hyper heuristic refers to the search methodology or learning mechanism to solve combinatorial search by either generating or selecting the heuristic. The objective of hyper-heuristic is to design some generic approaches with a distinguish feature of operating on search space of heuristic, and generate solution of acceptable level using set of easy to implement low level heuristic. Hyper heuristic are proving to be a general problem solver approach motivating the use to obtain high quality solution across distinct problem domains. These are competent search techniques witnessing the great success to numerous real-world applications. As these applications are huge in size, exact approaches are not inadequate, thus heuristics are commonly preferred.

The concept of using hyper-heuristic technique is not recent. The approach was used in many problems since 1960s. A prior mention of the term is found in a technical report by Denzinger et al. [19] but used in the context where range of Artificial Intelligence algorithm was used for theorem proving. However, it was first reported in a peer reviewed conference paper in 2001 [20]. A state of the art survey on hyper heuristic is presented by Burke et al. [21]. Burke in his work, states the crucial work that leads to hyper heuristic method comes from contribution by Fisher and Thompson [22] and Crowston et al. [23]. In production scheduling based problem the idea was to combine scheduling rules for better performance in comparison to applying single rule. In 1990s, the similar work was discussed by Storer et al. [24,25] work on job shop scheduling problem. The scheduling was encoded as (Heuristic, Problem) space with objective of finding better combination of problem specific heuristic. Another approach to search heuristic sequence using genetic algorithm for open shop scheduling is discussed by Fang et al. [26,27]. Drechsler et al. [28] presented a solution to Ordered Binary Decision Diagram by using evolutionary algorithm by developing strategies to the problem that learn from good heuristics.

The aim of a guided hyper-GA is to make the dynamic removal and insertion of heuristics more efficient, and evolve sequences of heuristics in order to produce promising solutions more effectively. In this paper, we have used a hyper-heuristic as a high level approach that, take into consideration a number of low level heuristic and select an appropriate one at each decision point. Hyper heuristics are classified into two broad categories based on the nature of heuristic search space and the feedback source during the learning process. The nature of search heuristic depends on the approach nature whether it is heuristic selection or generation, where they are further, categorized either to be constructive or perturbation. Similarly, the feedback used during learning is categorized into online, offline and no learning. The proposed methodology falls under the sub class of constructive heuristics selection for hyper heuristic methods. The constructive heuristic starts with no solution, but as the solution proceeds, iteratively they select the best ones and finally build the entire solution. The important challenge is to select the best one amongst available for the given current problem state.

In this section, we discuss the proposed methodology for packing of rectangular blocks in detail. The section is basically divided into two subsections. ‘Solution model’ presents the solution design model for packing the problem. ‘Hyper heuristic combined with model’ demonstrate how the cost associated with the automation of design system can be reduced by the integrating hyper heuristic with the proposed model. It also shows that the use of constructive heuristic is quite promising to solve large instances in reasonable time.

The model is designed to solve a set of randomly generated sub optimization problems. The sub problem refers to the sub maximization problem of the level surface, which are generated after each iteration as shown in Fig. 1. The maximization of the level surface at each stage would finally result in a placement of all rectangles into the container achieving maximum occupancy. These generated sub problems are solved using two techniques namely genetic algorithm and hyper heuristic. GA role is to evolve the solution space to get the optimal solution, whereas the hyper heuristic technique is employed to select the constructive heuristic at each iteration. The solution to the model begin from execution at the initial level, i.e., the width of the container denoted by level 0 in Fig. 1(a). Here, we consider the rectangular region to be a Cartesian plane with each point on it having its X and Y coordinate. The left bottom most will have (0,0) as the origin position. The iteration begins with the optimization of the available level surface (level 0). The initial configuration of the level surface is (0,0,
                        W,
                        H) where H
                        =0 as no rectangle is placed. The maximum utilization of the level surface can be achieved by placing a rectangle or set of rectangles whose sum of width gives the highest occupancy for the level surface. The selection of the set which maximizes the level surface is done using GA. The placement results in optimizing the current level surface and also in formation of new dynamic levels since the top boundary surface of the placed rectangle form the basis for the new level. Fig. 1 shows the level creation from the origin.


                        Fig. 1(a) shows the very basic initial state (level 0) of the container when no rectangle is placed. Fig. 1(b) indicates the dynamic level formed when the base level is optimized and Fig. 1(c) shows the formation of new level by merging the top boundary surface for two placed rectangles. The merging of the boundary level results in the creation of larger boundary surface that can accommodate rectangle of larger width in consecutive iterations.

The problem is a permutation problem, where the width combination of one or more rectangles can maximize the level surface. Here, GA representation uses permutation of integer sequence number corresponding to the rectangles. The initial population is generated at random but it is subjected to preprocessing. The task of preprocessing involves checking whether the individual is feasible to optimize the level surface or not by a simple check on the sum of their width. If the sum width is less than or equal to the level surface width then it is feasible, otherwise individual is penalized by discarding the further evaluation for the current iteration. After preprocessing the fitness value for each individual is assigned. The fitness is a simple function which returns the width summation value of all rectangles used to represent the individual. For the combinatorial hard problem like packing, it must maintain a balance between exploitation and exploration of the selection process and thereby, choice of crossover and mutation operators. The two point crossover is applied for better exploration of the search space and for mutation operator to avoid the premature convergence to a suboptimal solution. Swap mutation operator is used that helps in restoring destroyed or unknown genetic characteristic into the population. These operators help GA to converge to the global optima. Furthermore, Heuristic techniques are employed to improve GA performance. The first heuristic involves in finding the rectangle with minimum height amongst the set of rectangles that constitute the individual. If more than one such rectangle exist they are combined to form a single level. It is further checked whether, these shortest heighted rectangle can be merged with any of the neighboring level resulting in extension of level surface. The second heuristic is to check, in case if the shortest heighted rectangle cannot be merge then whether the newly formed lowest level surface can be maximized by remaining rectangles. Both these heuristic explore the possibility of future evaluation of the design. If heuristic 1 and heuristic 2 fails then the individual is eliminated from further evaluation. As failure to meet these conditions indicates the insertion of vacant space, if the evaluation process is continued further. Simple checks help in reducing the solution space to a great extend and improves the performance in terms of GA computation time.


                        Fig. 2
                         details these heuristic scenarios where in Fig. 2(a) the case corresponding the shortest highlighted rectangle is discussed where no rectangle or combination exists to maximize its level surface. Such a combination indicates an introduction to empty space which cannot be removed by further evaluation. Thus, such combination is marked as infeasible for the current level. Fig. 2(b) shows the possibility where the level surface created by the shortest heighted rectangle can be maximized, and can be considered for further evaluation as it combine with neighboring level to form extension of level surface. In Fig. 2(c) the case is discussed say, when no rectangle exists to maximize the level surface of R1. However, as R4 and R2 combined to form the nearby level which can be maximized by the (R5,R6) combination. Here, the placement of R5 still make the design feasible for further evaluation as it can be combine with R1 to form an extended level surface.

The selection of rectangles to maximize the sub problem is one phase of the model. The second phase is to combine the model with hyper heuristic technique to select the best set amongst all possible combinations. For all the possible solutions generated by GA, the placement order is determined by these low level heuristic (LLH). The constructive hyper heuristic then decides the best amongst them for further evaluation. The low level heuristic that we have considered for the placement are:
                           
                              1.
                              
                                 Rightmost placement: Place at the rightmost position.


                                 MaxDiff placement: Place the rectangle so that the difference in the top level with its neighbor is maximal.


                                 MinDiff placement: Place the rectangle so that the difference in the top level with its neighbor is minimal.

All the three placement policies are applied to the possible solutions. LLH considers the evaluation of all the above three placement policies. These placement policies determine the appropriate position for the rectangular block on the top of the layer surface to be maximized. The first placement policy is the orientation of placement must be right most, i.e., placing the rectangle always towards the right side. The second and third policies are based on the difference in level height, and with maximum and minimum difference between the top level surfaces respectively. Based on the placement a goodness score is assigned to each design layout obtained and the resulting best solution is selected. The heuristic techniques used for the packing resembles the popular best fit approach. However, in this case we have considered all possible placement options and best amongst them is selected for processing of the layout design. The selection amongst the placement options is made by the evaluation of the goodness function for any design D which is defined as:
                           
                              (7)
                              
                                 goodness
                                 
                                 (
                                 D
                                 )
                                 =
                                 Score
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 +
                                 Score
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 +
                                 OccupancyRate
                              
                           
                        where
                           
                              (8)
                              
                                 Score
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   If shortest heighted rectangle
                                                   
                                                   i
                                                   
                                                   is merge with existing top level surface
                                                   
                                                   j
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   Otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 Score
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   If rectangular block exist to maximize the shortest heighted rectangle top level surface
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   Otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Score (H1) values 1 if the shortest rectangle can be merged with the existing level j otherwise 0. Score (H2) value 1 when there exists a rectangular block to maximize the shortest highlighted rectangle surface otherwise 0. The occupancy rate stands for the percentage occupancy of the selected set in the current design layout. It is measured as the ratio between the total occupied area to the total area (i.e. the max height of design layout multiplied by the width of the container).

The proposed model is implemented on 2.2GHz Intel core duo CPU processor with 2GB DDR3 primary memory. The programming platform to implement the approach is JAVA a multi threaded programming language. To evaluate the algorithm performance, we carried exhaustive testing of benchmark test instance for strip packing from the vast literature. The dataset instances used and algorithm performance is reported in the subsequent sections.

The most common datasets available and well documented in the literature on operation research are used to test the performance efficiency of the proposed approach. This helped us to compare the result from the previously published work. These datasets have diversity as these contain instances with small rectangles to large size one, and varying numbers of rectangles to be packed. Hooper and Turton [29] is the most commonly used instance for comparison consist of seven classes where each class contains three instances with the known optimal solution for all instances. The number of rectangles to be packed varies from 16 to 197 and the container width from 20 to 160. Hooper [30] generated another class of guillotinable instances T by vertical and horizontal cut generating four rectangles in each cut from a square of 200×200. It consists of 7 classes with 5 instances each.

Burke et al. [31] contain 13 instances with number of rectangles range from 10 to 500. These are randomly generated instances by cutting each rectangle in two with each cut. Valenzuela and Wang [32] used two classes of instance Nice and Path, where Nice contains the rectangle set with similar size and shape, while the path had rectangles with various sizes and shapes. With the known optimal height the placement was done on 100×100 rectangular regions. The sizes of the class considered in this implementation are 25, 50, 100, 200 and 500.

The computation results are reported for the different datasets, where the proposed approach is compared with recent and existing heuristic and meta heuristic approaches from the literature. Table 1
                         reports the computations carried out on Hopper and Turton dataset for the mean value of the packing heights obtained. The term m stands for the number of rectangles to be packed, W denote the width of the container and Opt stand for the optimum placement solution height. The table summarizes the performance with proposed approach having the least mean difference in the packing height. It shows that on an average the heuristic, which are evolved, are near to the optimal solution. The other meta heuristic approach like HGA also gives a reasonable mean difference. Out of the total available data instances the proposed approach is able to find 92% optimal result with 99% filling rate. Table 2
                         reports the result for Burke data instances, where the comparison is carried out between the proposed and best fit heuristic, greedy randomize adaptive search, and hyper heuristic approach based on genetic programming. The results clearly indicate that our proposed work well in terms of computation time as well as in the quality of solution, achieving almost systematical optimal solution. Moreover, the approach is able to find solution for N13 instance in comparison to genetic programming based hyper heuristic approach by Burke et al. [14]. N13 is the largest and a hard data instance from burke dataset with randomly generated 3152 rectangles to be packed in the container with the width of 640. The proposed approach is able to find sub optimal solution and the layout placement pattern obtained for the same is shown in Fig. 3
                        .


                        Fig. 4
                         shows the difference in execution time observed for the two different approaches based on hyper-heuristic. For the small data instances, the execution time is approximately the same. But, as the problem size grows the computation time also increases for both the cases. However, in comparison to the existing approach the proposed approach determines the solution in reasonable less time.


                        Table 3
                         shows a more specific comparison against the existing approaches in term of %-Gap, where it is defined as the ratio of the {(Obtained Solution-Optimal Height)/Optimal Height} multiplied by 100. The proposed constructive hyper heuristic gives optimal result for five out of 13 instances. The rate of filling is also high as compare to others. The proposed model clearly dominates three other comparison approaches from the Burke instance for 9 of 13 problems. The average improvement was observed to be 0.598 over genetic programming based hyper heuristic.

The statistical independent was t-test carried to compare the effectiveness with respect to other approaches for both Hooper and Turton and Burke data instances. The test was carried at a confidence interval of 95% and 10° of freedom. The results reveal that in all cases the value of p is smaller, and less than 0.001, thus it can be assumed that the result is statistically significant, i.e., there is a difference between at least two groups and even a difference in variance is observed.


                        Table 4
                         reports the result corresponding to Nice and Path data instances. It is observed that the use of constructive heuristic for evolving the design have resulted in finding of optimal solutions in comparison to other existing heuristic and meta heuristic approaches. The average mean difference from the optimal solution is least for the proposed approach in comparison to others. The approach is able to find optimal placement design pattern for Nice 3 and Path 5 instances.

@&#CONCLUSION@&#

Industries require an efficient packing mechanism for effective and economical shipping of goods. In this paper, we proposed a hyper-heuristic design model for packing of two dimensional rectangular pieces into a huge container to maximize occupancy and minimize the vacant spaces. In addition to many extra benefits like flexibility to change, support to parallel implementation over existing approaches from the literature excellent and promising results are achieved. Judging from the results obtained, this model proves to be useful for efficient transportation for manufacturing and other industries. The future perspectives is to generalize the evolving heuristic by determining the best set of placement heuristic which may lead to optimum solution at a more rapid rate.

@&#REFERENCES@&#

