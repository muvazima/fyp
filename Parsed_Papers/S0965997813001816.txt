@&#MAIN-TITLE@&#Haptic assisted aircraft optimal assembly path planning scheme based on swarming and artificial potential field approach

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper presents a haptic guided framework (tool) for optimal assembly process.


                        
                        
                           
                           Swarm based optimization path planning scheme has been implemented for optimal assembly process.


                        
                        
                           
                           The scheme presented is then compared with existing technologies and the benefits of swarm based optimization are outlined.


                        
                        
                           
                           Virtual digital mockup based simulator is designed to test the effectiveness of the presented scheme.


                        
                        
                           
                           In addition the studies reviled that haptics implementation in the framework can further improve the engineering automation process.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Virtual reality

Assembly automation

Particle swarm optimization

Ant colony optimization

Path planning

Path optimization

@&#ABSTRACT@&#


               
               
                  In this research, a novel near optimum automated rigid aircraft engine parts assembly path planning algorithm based on particle swarm optimization approach is proposed to solve the obstacle free assembly path planning process in a 3d haptic assisted environment. 3d path planning using valid assembly sequence information was optimized by combining particle swarm optimization algorithm enhanced by the potential field path planning concepts. Furthermore, the presented approach was compared with traditional particle swarm optimization algorithm (PSO), ant colony optimization algorithm (ACO) and genetic algorithm (CGA). Simulation results showed that the proposed algorithm has faster convergence rate towards the optimal solution and less computation time when compared with existing algorithms based on genetics and ant colony approach. To confirm the optimality of the proposed algorithm, it was further experimented in a haptic guided environment, where the users were assisted with haptic active guidance feature to perform the process opting the optimized assembly path. It was observed that the haptic guidance feature further reduced the overall task completion time.
               
            

@&#INTRODUCTION@&#

Virtual reality (VR) industrial simulation mainly deals with assembly and maintenance process focusing on the whole product or some of its subsystems [1]. Therefore, virtual reality is becoming a popular engineering design tool with its ability to provide intuitive interaction with computer-generated models and data [2]. The immersive aspects of virtual reality offer more intuitive methods to interact with 3d data than the conventional 2D mouse and keyboard [3]. Carrying out simulations for maintenance assembly/disassembly (MAD) activities within a virtual environment gives a person the ability to directly interact with 3d virtual models for assembly purposes. Raghavan et al. [4] illustrates an interactive tool for evaluating assembly sequences using augmented reality. The critical task of 3d data processing applications is to generate a virtual representation of a physical object from a dataset and its success relies on reliable algorithms and tools [5]. One of the important objectives can be cutting down the production cost or design errors. Operators can employ it to evaluate aspects of human-centric design for maintainability (accessibility, reachability, tool usability, part mount/dismount ability) [6,7]. However, in various complex and constrained environments, this may not be feasible and the user may be lost or even may not be able to find the ultimate solution easily himself, thus requiring extra help.

Computer aided manufacturing and system’s development has been widely studied for decades. Antonio et al. proposed a methodology that generates assembly plans for draw dies and trim/pierce dies from their design information [8]. Path planning plays a vital role in the manufacturing process and a good number of researches on path and assembly planning can be found in robotics [9], assembly maintainability [10] and computer-numerical control [11]. However, very few such approaches have been applied to industries. Many automatic path planners are only effective in some specific scenarios and may fail due to the difficulty in finding configurations or assembly sequence, which are critical for the resulting path [9]. Furthermore, to formulate the system efficient in terms of cost saving and beneficial; optimization is an important factor in assembly procedure. It is observed that in many assembly procedures, cost can be saved by opting the optimal paths and even a minor change in assembly sequence of the whole process can effect in terms of cost and producing beneficial results [12].

In this regard, our prior work has focused on combined genetic algorithm (CGA) for path planning simulations and assembly framework [13]. When extending from 2D to 3d, the environment geometry becomes more complex with additional degree of freedom for the movements of the mechanical parts, resulting in an increased computation time for optimal solution. Moreover, the planer may fail due to algorithm running out of time. Considering these issues, a two staged combined (hybrid) ant colony algorithm (CACO) was proposed [14] to deal with the assembly sequence optimization, followed by the second stage where algorithm performs path planning and optimization process. Results for the proposed CACO (APF+ACO) algorithm showed that the outcome of assembly sequence planner was successful for planning fast and viable assembly sequences. Furthermore, the second stage of CACO in terms of path planning convergence was much better in performance when compared with the combined genetic algorithms (CGA), but the computation time (time taken to plan obstacle free optimal path) was still not real-time or near to real-time. Therefore, an urge for improvement in optimal path planning computation time was necessary, since CACO was dealing with only few parts (simple environment). In response to the above problem, this paper proposes distinct intelligent assembly path planning algorithm based on the advantages of artificial potential field (APF) and particle swarm optimization (PSO) combined to find the optimal assembly path. The proposed method supports the PSO population directing towards the goal using the attractive forces, whereas, to avoid collision of handled parts with obstacles the repulsive forces are used. Evaluation between the proposed particle swarm optimization algorithm (APSO) and existing two staged CACO in a similar 3d environment show a higher performance in terms of total assembly time for the proposed approach.

Artificial potential field [14] is a path planning technique based on obstacles as repelling force sources, and goals as attracting force sources. An object is driven by the accumulation of the two forces; the attractive and repulsive forces. This method is also known as local path planning. Potential field approach has been successfully applied to various industrial problems to find an obstacle free path [15].

When performing assembly path planning process the primary task is to find a 3d trajectory for every handled part from its initial position to the final position. Geometrically given a 3d environment, each part is defined in a plane by geometrical shapes and an origin (O) representing the center of the part. To mark the boundaries of the part bounding box technology is used as shown in Fig. 1
                     . The positions of a part and its bounding box in a frame O
                     1 with respect to the reference frame O
                     0 can be represented as the transformed points of parts vertex using a 3d homogenous transformation matrix.

Considering laws of potential field as mentioned in our previous studies [14,15], the part from its start position to the final position moves with an attractive force, this attractive force pulls the part to its final position, similarly, parts which already reached their final position are considered as an obstacle for the upcoming parts. This rule ensures that handled part will not collide with the pre-assembled parts. In case the path is blocked by an obstacle; each obstacle has its own repulsive force that repels the part from the obstacle avoiding collision of part and obstacle. As the part reaches its final position from initial to final a 3d trail is formed. The configuration of every part is represented by q
                     =[dxi dyi dzi θi
                     ] where dxi
                     , dyi
                     , dzi
                      is translation along the x-axis, y-axis and z-axis of the workspace coordinate and q represents these coordinates.

In this study, 3d path planning process based on 3d potential field method is further assisted by the PSO (particle swarm optimization) for optimization process in finding optimal path. Within the context of path planning via APF, the avoidance of local minima has been addressed in many different ways; in particular, dynamic search characteristics are employed to avoid local minima by various researchers. One of the finest techniques having swarm behavior was proposed by Colin et al. [16]. Another method to avoid local minima is to generate a virtual objective when handled assembly part is in a minima; the basic idea is to replace the global objective with virtual local goals in order to escape the local minimum [17]. Similar approaches have been proposed, in which the idea is to add virtual obstacles for avoiding local minima when creating the potential field [18].

PSO algorithm was introduced by Kennedy and Eberhart in 1995 [19]. Since then, PSO algorithm has been successfully applied to many optimization problems, such as learning of artificial neural networks (ANN) model predictive control [20]. PSO algorithm has been broadly applied to the manufacturing industry. Liao et al. [21] resolve the complex job-shop scheduling problem using an improved PSO algorithm in which local heuristic information is introduced. Schutte et al. [22] implement PSO algorithm for the biomechanical optimization and conclude that PSO algorithm is easier to be fulfilled than GA algorithm. The applications of PSO algorithm in integrated process planning and scheduling are studied by Guo et al. [23] to achieve manufacturing planning optimization. Several new operators including mutation, crossover and shift are incorporated into the traditional PSO algorithm, where results have shown that the performance of the modified PSO algorithm is improved. Here to improve the system performance with respect to computation time (real-time) and reduce the calculation cost, the artificial potential field method and the PSO algorithm are combined to form as APSO, which is used to generate the optimal or near-optimal assembly path.

The mechanism of PSO algorithm generating the optimal or near-optimal solutions is a stochastic process but the ability to pursue the optimal solutions of the particles and the collaboration among them ensure that the PSO algorithms can figure out the optimal or near-optimal solutions quickly. The formulae of the traditional PSO algorithm are simpler than those of the genetic algorithm (GA) and the ant colony algorithm (ACO), which means that the PSO algorithm can be more conveniently implemented. The population size of the PSO algorithm is smaller than those of the GA algorithm, so the initialization of the populations is simpler using the PSO algorithm than that of the other intelligent optimization algorithms. In addition, the population size of the PSO algorithm is constant and the amount of the solutions is appropriate to be controlled in the optimization process.

The traditional PSO algorithm comes from the simulation of the social behavior of the birds seeking for food. The best strategy for one bird to reach the destination is to pursue the bird that is nearest to the food. The solutions of the optimization problems are viewed as the birds which are called particles. The optimization process of the problems is regarded as the progressive paths of the particles seeking for the food. Each particle has a fitness computed by the fitness function. The particle direction and distance of each particle are subject to its velocity. All the particles are pursuing the best particle owning the optimum fitness until the optimal or near-optimal solutions are obtained. The particles are commenced with stochastic initializations and the optimal or near-optimal solutions are generated by iterative computations. Each particle renews its own solution based upon two best solutions in each computation time step, i.e. the current individual best solution searched by it and the global best solution searched by the particle colonies, which are represented as pbest and gbest, respectively. To improve the computation efficiency, a portion of the whole particles are selected for comparison and the global best solution can be replaced by the local best solution if the population size of the particles is too large. For multivariable optimization problems, the best solutions pbest and gbest will be substituted with the vectors pbest and gbest respectively. The next velocity vector and solution vector of each particle are updated according to formulae (6) and (8) after the two current best solution vectors are calculated [19].
                        
                           (1)
                           
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              =
                              
                                 
                                    wV
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    1
                                 
                              
                              (
                              
                                 
                                    pbest
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              )
                              +
                              
                                 
                                    c
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    2
                                 
                              
                              (
                              gbest
                              -
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              )
                           
                        
                     
                     
                        
                           (2)
                           
                              w
                              =
                              
                                 
                                    W
                                 
                                 
                                    Max
                                 
                              
                              -
                              [
                              (
                              
                                 
                                    W
                                 
                                 
                                    Max
                                 
                              
                              -
                              
                                 
                                    W
                                 
                                 
                                    min
                                 
                              
                              )
                              Iter
                              ]
                              /
                              MaxIter
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              =
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 V
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      is velocity of agent i at iteration k, w is weighting function, ci
                      is coefficient of weighting factor such that c
                     1
                     ∊[0,1] and c
                     2
                     ∊[1,2], r
                     1 
                     r
                     2 are random numbers, 
                        
                           
                              
                                 S
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      is current position of agent i at iteration k, pbesti
                      is the current optimal solution of the particle ith, gbest is global optimal solution of the group, wMax is initial weight, wMin is final weight, MaxIter is maximum iteration and Iter is current iteration number (see Fig. 2
                     ).

Although the traditional PSO algorithm has many advantages to resolve the optimization problems, the performance of it, such as the premature convergence and the stochastic stagnation, is heavily impacted by the principle and the parameters of the algorithm. The research [20] indicates that the traditional PSO algorithm will smoothly slip into the local near-optimal solutions when the optimization problem is relatively complex and it cannot jump over the obstruction. Therefore, the traditional PSO algorithm will be improved and can be modified to meet the applied demands of the complex optimization problems. The adverse situations will be lowered after the APF method is combined with the traditional PSO algorithm. APF method [17] has the particular characteristics, such as the collision avoidance and attraction towards goal, which can enhance the diversity of the particles and actuate the particles to move out from the local near-optimal solutions.

In our proposed approach (APSO) a hybrid algorithm of artificial potential field and PSO, the premature convergence of the traditional PSO algorithm is undermined and the convergence of it is also accelerated. Furthermore, the performance to accomplish the global optimization is also improved subject to the optimization method. First, the principal assembly process constraints are specified and the optimization model of assembly sequences taking these constraints into account is presented. The assembly planner initially investigates and optimizes the assembly sequence. Second, the principle of the traditional PSO algorithm and the APF method are outlined.

In the proposed algorithm the traditional PSO strategy is combined with artificial potential field algorithm [15]. The artificial potential field (AFP) algorithm is implemented as primary path planning algorithm that generates a path from initial to final position. Applying APF algorithm can result in more than one path as a solution. Therefore, the APF path planning algorithm is combined with particle swarm optimization (PSO) technology to derive the optimal solution. The flowchart of the proposed algorithm is shown in Fig. 3
                     . In particle swarm optimization the mechanical parts were considered as swarm particles and their moving velocity was based on the attractive and repulsive forces generated by the parts and obstacles in the environment.

The proposed algorithm performs assembly initially by loading the 3d cad models of parts with their initial and final position. The assembly procedure starts with planning the path for the parts, where all the parts are placed on the starting point and random velocity 
                        
                           (
                           
                              
                                 V
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                           )
                        
                      is initialized for every part. Velocity update rule was followed based on Eq. (5). When the part reaches the final position its gbest is calculated and a list of path value is maintained for each part.

The process starts by placing the parts on their initial position. The movement of the parts is affected by 
                        
                           
                              
                                 
                                    
                                       V
                                    
                                    
                                       →
                                    
                                 
                              
                              
                                 apf
                              
                           
                        
                      as shown in Eq. (4), which is accumulation of two types of forces, the attractive forces Fatt
                      and the repulsive forces Frep.
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          V
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    apf
                                 
                              
                              =
                              Δ
                              q
                              
                                 
                                    
                                       
                                          F
                                       
                                       
                                          att
                                       
                                    
                                    +
                                    
                                       
                                          F
                                       
                                       
                                          rep
                                       
                                    
                                 
                                 
                                    ‖
                                    
                                       
                                          F
                                       
                                       
                                          att
                                       
                                    
                                    +
                                    
                                       
                                          F
                                       
                                       
                                          rep
                                       
                                    
                                 
                              
                              S
                           
                        
                     
                  

Hence proposed APSO algorithm is presented as:
                        
                           (5)
                           
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              =
                              
                                 
                                    wV
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              Vapf
                              +
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    1
                                 
                              
                              (
                              
                                 
                                    pbest
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              )
                              +
                              
                                 
                                    c
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    2
                                 
                              
                              (
                              gbest
                              -
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              )
                           
                        
                     
                     
                        
                           (6)
                           
                              w
                              =
                              
                                 
                                    W
                                 
                                 
                                    Max
                                 
                              
                              -
                              [
                              (
                              
                                 
                                    W
                                 
                                 
                                    Max
                                 
                              
                              -
                              
                                 
                                    W
                                 
                                 
                                    min
                                 
                              
                              )
                              Iter
                              ]
                              /
                              MaxIter
                           
                        
                     
                     
                        
                           (7)
                           
                              If
                              
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              >
                              
                                 
                                    V
                                 
                                 
                                    max
                                 
                              
                              ,
                              
                              then limit
                              (
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              )
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                              =
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                                 
                                    k
                                    +
                                    1
                                 
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              f
                              (
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                              (
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        
                     where 
                        
                           
                              
                                 S
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      represents the current position of the ith part in solution space and k indicates the iteration count, ci
                      is coefficient of weighting factor such that c
                     1
                     ∊[0,1] and c
                     2
                     ∊[1,2], r
                     1 and r
                     2 are random numbers uniformly distributed between interval (0,1) and 
                        
                           f
                           (
                           
                              
                                 S
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                           )
                        
                      is the fitness function. Vmax a constant is defined to limit the velocity of the swarm allowing it not to go out of bounds.

The attractive force pulls the parts towards its final position while the repulsive force repels the part from a collision with the obstacles. If the part reaches the final position the gbest of the path is reported as optimal solution. If the pbest of the path is greater than the previous pbest, the new pbest value is ignored. When the part enters the final position area, predefined set of rules [13] for snapping were applied:
                        
                           
                              Rule 1: If the part has reached its final position it will become an obstacle for the next part.


                              Rule 2: After selecting a possible assembly direction the part must move in that direction when assembled to avoid interference between parts.


                              Rule 3: If a given assembly direction is perpendicular to the face of the part, all the repulsive forces generated by existing parts will disappear automatically.

These rules ensure that the parts will not collide with existing assembled parts when entering their final position with the sequence and orientation information. The loop mechanism in traditional PSO for updating gbest and pbest were used. When numbers of max iterations are performed the gbest is considered as shortest and optimal path. Finally, the effectiveness of the proposed scheme is verified in comparison with traditional particle swarm optimization (PSO) [19] and existing hybrid ACO (CACO) [14] in a haptic guided 3d simulation environment.

With the advent of haptic technology, traditional visual-only collaborative virtual environments have been gradually transited to haptic based collaborative virtual environments [7]. Our Proposed system was test implemented in a 3d haptic collaborative intelligent assembly system. Once the optimal paths for all the parts are found as mentioned in above approach, a trajectory for each obtained path is visible in the simulation environment and haptic guidance feature is enabled to guide the user throughout the maintenance procedure. When a user manipulates the assembly environment by handling the moving part force feedback is computed and sent to the haptic controller to keep the part in the given optimal trajectory.

The simulator for assembly path planning (APP) is based on two aspects first the sequence of the parts and second obstacle free path planning. The virtual assembly path planner system reported in this paper as shown in Fig. 4
                      utilizes a pc based application and general-purpose hardware for interaction, making the system easy to use. The graphical interface was designed in C++ to let the user interact with the haptic guided environment. 3d CAD files for aircraft parts were developed with CATIA (Computer Aided Three-dimensional Interactive Application) software package to be utilized by this environment. The Open Inventor application programming interface provides the virtual environment facility. The presented experiment was done using the C++ platform and Open Inventor for 3d virtual environment. A single computer with a Pentium (2.14GHz) CPU and 2GB ram is used to run the A/D simulations. Comparison between APSO and CACO was later performed with the derived results since both the algorithms were simulated in a similar environment and setup. The simulation scene contains parts of unassembled helicopter engine with a total weight of 644627 faces. The computed workspace was (4.0×4.0×4.0) environment as it can be seen in Fig. 4. Six unassembled parts of aircrafts were taken initially and the task defined was to find obstacle free path for the assembly of each part. Once the optimal path for each handled part is obtained the trajectory form initial to final position of the handled part is calculated and displayed in graphical mode of haptic guided environment, this trajectory is further utilized in the haptics assisted mode. As shown in Fig. 5
                      the assembly processes of all given (6) parts, for every handled part an optimal trajectory is evaluated and then simulated in virtual 3d environment.

This section outlines the two competitive experiments (shown in Table 4) which were performed to show that the APSO performance against ACO algorithm and traditional PSO is indispensable. The experiments were performed in a 3d haptic guided environment that was kept similar for all experiments. The first comparison is between the proposed method and hybrid ACO (CACO) [14]. The second comparison is made between the proposed method and traditional PSO [19]. After 100 runs, the mean value of proposed method proposed APSO, CACO and traditional PSO were calculated which were found better than existing (PSO and CACO) algorithms as shown in Table 1
                     .

The comparisons are as follows:

The convergence of generation’s comparison was made between proposed approach (APSO) and combined ACO (CACO). Initial task was to plan optimized path for aircraft un-assembled engine parts. As discussed earlier although CACO approach was 100% successful in finding optimized obstacle free path, therefore we mainly focused on the computation time (total time consumed by the algorithm to find solution) and then the convergence rate (best optimized results).

The valid assembly sequences (Q) are initially provided to the proposed algorithm, these assembly sequences contains the sequence of parts to be assembled. Since this algorithm is dealing with six handled parts each part was identified with a number given from one to six for identification purpose. The actual path distance (ΣD
                        act) was defined as summation of single distances from one path point (Oi
                        ) starting from initial position to another path point until reach the final position. Sum of D
                        act value (ΣD
                        act) is calculated for the shortest path found for each part. Table 2
                         shows the repulsive radius value used for each handled part (from 1 to 6) and the sum of D
                        act value calculated for given valid sequences initially to the APSO, among them Q
                        ={1,2,5,3,4,6} was found as optimal solution with total D
                        act value of 110.41. Fig. 6
                         shows the convergence rate of both the algorithms and the best particle progressions in the evolutional process for 100 runs, though in Table 3
                        
                         first experiment detailed comparisons for convergence rate in every generation is given. As shown in Fig. 6, the solid line is the cost function value for every generation that is calculated using the proposed method (APSO); the dotted line is the cost function value of generations using ACO. After 100 generation run, it was observed that the APSO performance is faster in terms of computation process and furthermore, it showed higher convergence rate when compared with the CACO in similar assembly environment.

The second convergence of generation’s comparison was made between APSO and traditional PSO. The parameters of both the algorithms are defined as follows: particle number is 6 initially to verify the prototype; c
                        1
                        =1 and c
                        2
                        =1.5; generation setting was set to 100, although feasible path of single handled part can be reached in less than 90 generations. The initial position of the swarm was generated with random value for both algorithms, allowing the algorithms to spend time in searching the better path of assembly path. In optimization process both the algorithms showed a rapid convergence starting from first generation until the 100th last generation. The results for the convergence rate and performance comparison are shown in Fig. 7
                        , whereas; in Table 3 second experiment detail comparison for convergence rate in every generation is given.

The proposed APSO method as shown in Fig. 7 showed a higher convergence trend towards the efficient fitness value (closer to 1) when exploring solutions in the environment. The advantage of using artificial potential field method produced more directed path towards the final solution when compared with traditional PSO. APSO found to be faster in order to search the whole environment because of the attractive forces (pull forces directing the parts towards their final position).

In this research we utilized Phantom Omni haptic device. The device workspace is based on three degree of freedom providing three input coordinates in form of force and three output coordinates as force feedback. The characteristics of the Omni device are force feedback of 1.4N, 380×267×191mm translational workspace and 297, 260, 335° (yaw, roll, pitch) of rotational workspace. In order to improve the stability of haptic rendering we used virtual coupling in the simulation environment. Moreover, we created a multi-threaded rendering framework to ensure stable haptic feedback. To reach the necessary higher update rates for stable haptic feedback, asynchronous multi-threaded system was developed. Visual rendering and haptic rendering were isolated into two separate threads. During the experiments the haptic thread was on average running at 1kHz.

The haptic assistance was limited to the translational workspace only to keep the haptic environment simple for the users. Compared to the previous approach by Christiand and Yoon et al. [15], where the haptics simulation was enhanced only by force feedback to the user, in this approach we used haptic guides with active guidance (attractive force toward the object) and feedback force to the user in haptic assisted phase. For precise manipulation in active guidance mode the degree of freedom of the assembly object is reduce to 1DoF (i.e. allowing only one translate movement). This approach offers a more direct, intuitive control over the interaction activity, thus speeding up the optimal assembly process and its direction controls.

The vector F in Eq. (4) is directly applied to haptic guidance force in virtual maintenance system. The force generates the active guidance direction for user to avoid the collision of part with obstacles present in environment. This haptic movement of the part is limited to the path boundary; whenever the movement begins to cross the path boundary the user feels haptic reaction forces between the pointer and the trail boundaries. When handled part is perpendicular to its final assembly position all the haptic forces disappear to let it freely assemble. Each handled part when assembled in its final position becomes an obstacle and start generating repulsive force.

To compare haptic assisted feature that implements the trail concept from the path obtained and the haptic free assembly process a user study was carried out. In user study a participant was confronted in the haptic guided virtual environment with an assembly task. Five participants (one female, four male) took part in the test. Their age ranged from 24 to 34years (with an average of 10years). Except all, one subject was right-handed, while some of the users already experienced haptic simulations before, they cannot be considered as experienced users of haptic devices for assembly process. The experiment was designed to be performed in two phases; the first was designed without haptic feedback called haptic free (HF) environment, whereas the second phase was haptic assisted phase (HA). To keep fair comparison the sequence guidance along with initial and final position information was available to the users in both phases. In haptic free phase the user environment was provided without haptic support (active guidance and force feedback support) and optimized paths. The user was allowed to assemble the parts freely adopting any path starting from initial to final position within the virtual environment. The second phase HA, was haptic assisted environment where the user was provided with an optimized sequence and haptic guidance to follow the optimized path trajectories (generated from the experimental results of APSO approach) to keep the path shorter and obstacle free avoiding unnecessary path diversions.

During the user study, quantitative data were recorded for all the users in both phases. Analyzing the data in Table 4, the performance of users was largely dependent on the approach and complexity of 3d environment. When in haptic free mode the users took more time to complete the assembly scenario whereas, the overall time to complete the scenario was reduced almost 20% when performing with haptic assisted feature as shown in the table.

Overall, haptic assisted approach was found better than the haptic free approach; comparison results between both the phases are shown in Fig. 8
                     , the performance improvements were mainly because of the haptic assistance applied for the user ease to predict and follow the shortest path trajectory. Fig. 9a
                      shows the detailed analysis of subtask in phase one: haptic free. The task completion time taken by every user is shown along with the breakdown data of every part the user picked and assembled. Fig. 9b
                     , shows the optimal assembly path opted by the users in phase two (HA), where haptic guidance was provided to the users to keep the users in optimal trajectory for assembly every part picked and assembled to avoid collisions and keep shorter paths. The optimized and haptic assisted results in proposed layout of 3d environment along with assembly process in haptic assisted system satisfied the tasks given to complete scenario. The results showed that this haptic-assisted feature particularly supports the user in efficient assembly process and maintenance training in the complex environments as shown in Fig. 5, in haptic mode the part follows the trajectory guided by the haptic forces. Another benefit of this haptic assisted feature can be considered as an environment where operators usually employ tools and parts that have well-known mass and stiffness properties. The proposed haptic assisted feature is expected to transmit them the same sensation.

@&#CONCLUSION@&#

In this paper, a novel assembly path planning optimization framework is developed and tested that allows operators to determine an optimal or near optimal path planning solution for assembly process. The proposed algorithm (APSO) is based on improved particle swarm optimization using potential field concepts for path planning. For comparison of proposed APSO approach with existing CACO assembly algorithm and traditional PSO, the parameters measured were the path cost (trajectory) along with the convergence rate of the algorithm and computation time. The results obtained from the virtual simulation demonstrated that the proposed algorithm converges faster to the optimal or near optimal path having low path cost (shorter trajectory) and consumes less computation time when compared with similar approach adopted by CACO and traditional PSO. Simulation result also showed that the proposed approach was successful in finding the assembly path solutions within a complex 3d maintenance environment. Furthermore, the proposed improved strategy (APSO) generates more results closer to optimal solution than the collator (Traditional PSO and CACO). The results of the proposed algorithm when used for an active haptic guidance application appeared very useful in reducing the overall assembly time, mainly where the user was not acquainted with the maintenance simulations.

@&#ACKNOWLEDGEMENTS@&#

This work was supported by National Research Foundation Korea (NRF) (2011-00313832010-0029690 and 20120009524 and 2012R1A2A2A01047344) and supported by Regional SW Convergence Support Project of NIPA.

@&#REFERENCES@&#

