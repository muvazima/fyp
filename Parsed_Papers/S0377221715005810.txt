@&#MAIN-TITLE@&#Optimal selection of IT security safeguards from an existing knowledge base

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel approach to optimally select effective IT security safeguards.


                        
                        
                           
                           Practical applicability is ensured by using extensive real-world security knowledge.


                        
                        
                           
                           The knowledge base covers 80 system components, 518 threats, and 1244 safeguards.


                        
                        
                           
                           An abstract criticality concept is used to utilize automatically extracted knowledge.


                        
                        
                           
                           The new MILP model optimally selects safeguards for realistic instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Knowledge-based systems

Information security

Decision support model

Combinatorial optimization

@&#ABSTRACT@&#


               
               
                  In this paper, a combinatorial optimization model is proposed to efficiently select security safeguards in order to protect IT infrastructures and systems. The approach is designed to provide very concrete decision support for an organization as a whole or separately for specific systems. It can be applied in practice without requiring the decision maker himself to collect extensive input data. This is accomplished by using an existing comprehensive and highly accepted knowledge base as a basis for decision making. For our analysis, we use the publicly available IT baseline protection catalogues of the German Federal Office for Information Security (BSI). The catalogues contain more than 500 threats and over 1200 safeguard alternatives to choose from. Applying our model, it is possible to make use of this knowledge and determine optimal selections of safeguards according to given security requirements. The approach supports the decision maker in establishing an effective baseline security strategy.
               
            

@&#INTRODUCTION@&#

Information technology (IT) is constantly spreading into more and more areas of organizations and it is a critical factor to be successful in the global economy. The loss, manipulation, disclosure, or simply the unavailability of information caused by IT security incidents may lead to expenses, missed profits, or even legal consequences. Incidents originate from different actors with different motives. Professional and amateur hackers, malicious employees, industrial spies, or even terrorists try to hack into systems to gain access to information or simply to create damage. They search for vulnerabilities and will use any weak link in the security chain of an organization. In the constant struggle to make systems more secure, organizations are always trying to find new ways to adequately address security issues. If too little is done, security is weak and attackers will probably succeed at some point. On the other hand, if the wrong measures are taken, the organization may be wasting precious resources that could have been used elsewhere.

It has become evident that making systems more secure is a difficult task due to the high complexity of IT infrastructures and the large amount of data required to make informed decisions. To address this problem, a considerable amount of research has been done to find ideal IT security budgets and to determine how to invest based on risk and financial measures. The problem is that existing approaches require the decision maker of an organization to provide a lot of exact input data like exact threat and vulnerability probabilities, asset valuations and other fine-grained parameters. However, these values are very difficult to obtain in practice and, in addition, are very critical to the quality of proposed solutions. Such approaches are intended to accurately address the problem but are often impractical when it comes to real-life applications. On the other hand, approaches that require less information often remain vague in their results and require the decision maker to fill in the gaps himself.

To address these issues, an approach is needed that requires an organization to provide as less data as possible but still produces very concrete investment recommendations. To achieve this, we propose to treat the problem on a different layer of abstraction than existing models and to utilize existing IT security knowledge. In fact, both aspects are closely related: instead of developing a model first and forcing the decision maker to gather required input data, we took a reversed approach: we established an extensive knowledge base first, extracted relevant information, and built a model on top of it. The data required can be obtained from common IT security practices and standards which are available from various sources including, but not limited to, International Organization for Standardization (ISO), National Institute of Standards and Technology (NIST), and German Federal Office for Information Security (BSI). These practices help organizations by guiding them on how to establish an effective basis for security. The information is mostly available in form of catalogues, guidelines, recommendations, or standards which have to be followed more or less strictly.

When analyzing existing data, it becomes evident that exact probabilities, financial impacts, etc. are not available, not even for the past. But the data still provide a valuable basis for decision making, although on a different level. The question is: is it really necessary to know a threat’s exact probability of occurrence? Is it necessary to know the exact financial impact in case of a security incident? If the goal is, for example, to accurately estimate expected losses, the answer is “yes”. But if the objective is to protect an IT system or infrastructure, we propose an alternative to facilitate the establishment of effective security safeguards without requiring this information. By abstracting the problem further and using highly aggregated “criticality coefficients”, we eliminate the dependence on exact parameters like probabilities and financial evaluations. The aggregated parameters are generated based on an extensive knowledge base with real-world security data. The idea is that exact threat probabilities or expected financial losses are not required to decide which safeguards should be implemented. Knowing which threats are more critical relative to each other is sufficient to allocate safeguards effectively. Effective, in this context, means that safeguards are selected such that their combined impact on the reduction of security threats is maximized.

For our analysis we focused on the IT baseline protection catalogues (or IT-Grundschutz catalogues) (Federal Office for Information Security, 2013b) which are part of a standard security practice provided by the BSI. We chose the IT baseline protection catalogues because they are publicly available free of charge and offer an extensive repository of technical, organizational, personnel, and infrastructural information security knowledge to protect IT systems. The catalogues are in line with the ISO 27000 series and, in addition to custom BSI certificates, it is possible to obtain an ISO 27001 certification based on safeguards listed in the baseline protection catalogues.

Organizations applying these practices to improve the state of their IT security practices can be divided into basically two groups: one group strictly follows the guideline of a standard of their choice and tries to obtain a valid certificate. The other group is not necessarily interested in a certificate, but nonetheless wants to achieve a sufficiently high security level of its IT infrastructure and systems. Certifications fulfill their purpose for the first group of organizations but have only limited value for organizations of the second group. Organizations trying to improve security without a certification face the challenge of selecting appropriate safeguards from the given catalogues. In the following, we mainly address the second group and demonstrate how they can benefit from existing IT security knowledge.

This paper is a first approach to make the large amount of available information security knowledge contained in the IT baseline protection catalogues usable for organizations. For this purpose, we propose a combinatorial optimization model which makes use of the entire baseline protection catalogues. The model is also applicable to an arbitrary subset of components which makes it usable for any use case covered by the knowledge base of the catalogues. It is possible to integrate our approach into an existing risk management process to automate and support the selection of safeguards and thus guide the decision maker in creating an effective risk mitigation plan.

The remainder of the paper is organized as follows: Section 2 outlines literature related to decision making in IT security. Section 3 introduces the source of data which we used as basis for our evaluation and illustrates the data extraction process. Section 4 presents our mathematical model and shows how available data are utilized to support automatic decision making in IT security. In Section 5 we conceive a realistic case study to demonstrate the application of our model and discuss the results and computational performance. Section 6 concludes the paper.

@&#RELATED WORK@&#

In recent years, the interest in quantitative models for information security investment decisions has increased significantly. This trend is driven by the fact that information security is becoming more important each day and, at the same time, the complexity of IT systems continuously increases. Questions like, “How much security is necessary?”, “How much should be spent?”, and “How can security be improved?” are becoming more relevant these days. There are several research streams which basically try to solve the security investment problem from different angles. This problem can be broken down into two distinct subproblems where each subproblem is focused on one key issue: (1) what is the optimal amount to invest in security; and (2) what security safeguards should be selected to invest in?

The first question is probably the most-discussed one and there exists a considerable amount of related literature. It is often addressed by traditional risk analysis methods to determine loss expectancies and a return on investment (Berinato, 2002; Bojanc & Jerman-Blažič, 2012; Sonnenreich, Albanese, & Stout, 2006). This is a reasonable starting point, since other investment problems have been treated very successfully with these tools. The security investment problem, however, is problematic because security investments have no return in the classical sense of the word, i.e., there is no incoming cash flow after investing in security. For this reason, risk analysis approaches usually treat prevented losses as a profit: profit = loss reduction × probability of incident. A study by Gordon and Loeb (2002) uses risk analysis to suggest an optimal budget for a risk-neutral decision maker. In their approach, they compare the loss caused by security incidents to the investment required to reduce the related vulnerability. Based on two general classes of security breach functions, they state that the amount to invest is considerably lower than the expected loss caused by an incident. In fact, they find that the amount to invest in security never exceeds 37 percent of the expected loss and in most cases will be substantially less. However, these observations only hold true if the security breach functions meet the condition of decreasing marginal returns in case of security investments. Hausken (2006) examined four additional types of security breach functions with different shapes and found that the amount to invest is no longer capped at 37 percent and different investment strategies should be applied in each case. Wang, Chaudhury, and Rao (2008) proposed a more detailed analysis which makes use of security incident data and statistical methods like the concept of value-at-risk to support a decision. Another general class of approaches falls into the field of microeconomics and uses game theoretic models to treat security as a game between an organization and an attacker to determine an ideal investment level (Baykal-Gürsoy, Duan, Poor, & Garnaev, 2014; Cavusoglu, Raghunathan, & Yue, 2008; Gal-Or & Ghose, 2005; Gao, Zhong, & Mei, 2014; Roy, Ellis, Shiva, Dasgupta, Shandilya, & Wu, 2010).

These approaches address the security investment problem from a business perspective. Financial investments and achieved security have to be balanced. On this level, an organization can obtain insights on a reasonable budget. Which safeguards have to be taken and how the budget should be distributed remains up to the decision maker.

At this point, the second question has to be answered: which safeguards should be selected for implementation within a budget that was determined previously? Most approaches to address this question apply management tools and financial analysis based on measures like annual loss expectancy, return on investment, internal rate of return, net present value, etc. (Bojanc & Jerman-Blažič, 2012; Schilling & Werners, 2013; Sonnenreich et al., 2006; Tsiakis, 2010). Other approaches use real options analysis where dynamic aspects of investments are considered and the flexibility of decision making is utilized Gordon, Loeb, and Lucyshyn (2003); Tatsumi and Goto (2010); Ullrich (2013). An optimization driven approach to select security safeguards is proposed by Sawik (2013) which produces optimal safeguard portfolios. In their study, they use a bi-objective model to minimize expected and worst case losses applying the value-at-risk. Viduto, Maple, Huang, and López-Peréz (2012) also proposed a bi-objective model that considers the trade-off between financial costs and risk. Rakes, Deane, and Paul Rees (2012) argue that, in addition to expected losses, sparse events that might result in high-impact losses should be considered, too. They proposed a model that minimizes the total loss caused by security incidents. To factor in expected and worst-case losses, the model is solved twice with two sets of data. By employing a what-if analysis, the decision maker can then decide which solution should be implemented. Another option to treat uncertainty is fuzzy set theory which Rees, Deane, Rakes, and Baker (2011) used in a recent study to develop a decision support system addressing uncertain threat rates, impacts on assets, and countermeasure costs. To achieve this, all approaches require extensive input data like threat probabilities, incident costs, countermeasure costs, countermeasure success probabilities, etc. which makes them very hard to apply in practice. Viduto et al. (2012) lower input data requirements by using discrete scales for probability and impact values. It is, however, still problematic since finding a trade-off between costs and risk requires both to be measured accurately. Only if this is the case, the trade-off is meaningful. Glickman (2008) prioritizes security risks and employs a lexicographic optimization model to find optimal portfolios of risk reducing security programs. The model is addressing the problem at a higher level requiring less input by the decision maker. The downside is that some parameters like the effectiveness of a security program are assumed to be known which over-simplifies the problem. Without any guidance of how the effectiveness of a program can be measured, the quality of obtained solutions is implausible. In addition, if the internals of a program are out of scope, a recommendation to implement one offers only limited value for the decision maker. If it is not possible or not sufficient to deploy safeguards to achieve sufficient security, cyber insurance is also an option (Baer & Parkinson, 2007; Mukhopadhyay, Chatterjee, Saha, Mahanti, & Sadhukhan, 2013).

All existing approaches either use a small set of very generic data or require the decision maker to collect most of them before the optimization can be conducted. Our model builds on the foundation and ideas established in previous work but requires less information input by the decision maker which makes it more applicable to practical use cases. By extracting most of the model input from an existing knowledge base, we significantly reduce workload during a risk assessment and ensure that the data meet a certain quality threshold. A study by Fenz and Ekelhart (2009) demonstrates how information security knowledge from different sources, such as BSI and ISO, can be formalized and combined. Their approach facilitates the combination and reuse of existing knowledge and is a means to combine information from different sources. As a result, a comprehensive knowledge base may be established and continuously extended.

To the best of our knowledge, no model exists to support the establishment of an effective IT security strategy which incorporates large amount of data of an existing knowledge base and is still practically applicable in terms of information requirements and computational time.

Organizations that try to achieve high security have to consider a large amount of relevant information. To guide decision making, there are a number of security standards and best practices that can be followed. An internationally accepted and widely applied standard is the ISO 27000 series describing best practices for information security management. Another widely accepted, although internationally less known, standard are the IT baseline protection catalogues of the BSI (Federal Office for Information Security, 2013b). This standard is fully in line with the ISO 27000 series and offers custom BSI and ISO 27001 certifications.

For our evaluation, we utilize the IT baseline catalogues, mainly for two reasons: first, the catalogues are an extensive repository of technical, organizational, personnel, and infrastructural information security knowledge including concrete lists of threats and safeguards. This fact makes them a perfect source to serve as a knowledge base for a decision model. Second, the catalogues are publicly available and free to use without any charge which means they are usable for any organization.

The IT baseline protection catalogues consist of 3 integral parts: components (or modules), threats, and safeguards. They define 80 components which are grouped into 5 categories: general aspects, infrastructure, IT systems, networks, and applications. Each component identifies and describes a typical part or aspect of a system and contains a description of the subject. A threat captures a common scenario that may cause damage to the system. Each component may be endangered by a variety of threats. Finally, safeguards are countermeasures that can be taken to treat existing threats. They cover several aspects and are grouped into 6 areas: infrastructure, organization, personnel, hardware and software, communication, and preventive measures. In total, the IT baseline protection catalogues contain 518 threats and 1244 safeguards.

The catalogues specify that the security of each component is endangered by a number of threats. Depending on the nature of the threat, it is possible that it applies to more than one component. To counteract threats, the organization can deploy various safeguards which reduce the criticality of a specific subset of threats according to the safeguard’s effectiveness. Possible safeguards have a wide variety of capabilities to protect against different threats and they might complement each other. A basic outline of this structure is shown in Fig. 1
                        .

The complexity and size of the safeguard selection problem leads to a situation where only a rational methodology and quantitative modeling enable the decision maker to select the best configuration of safeguards. To prioritize between safeguards, it is necessary to measure their combined impact on security. Since this has to be done before safeguards are deployed, it is not possible to verify their effectiveness in a production environment. In order to solve this planning problem, we propose to extract the knowledge and to use a combinatorial optimization model enabling the decision maker to find an optimal selection of safeguards.

To utilize the knowledge contained in the IT baseline protection catalogues, we extracted relevant information. In this section, we cover the steps that were required to establish a usable knowledge base.

The knowledge of the IT baseline protection catalogues is available as a collection of different files with different data types. The typical access scenario for an end user is via a web browser. The information is distributed across several thousand html files and connected via hyperlinks. Here the general information on components, threats, and safeguards is available. The same information is also published as a PDF file containing 4420 pages (Federal Office for Information Security, 2013b). In addition, the BSI publishes what they call “cross-reference tables” as spreadsheets (Federal Office for Information Security, 2013a). The tables contain several matrices that specify for each component which threats are endangering its security. In the same fashion, safeguards are connected to the threats they have an impact on. These documents and files are the starting point (i) for establishing the knowledge base and, subsequently, the solver input; the entire process comprising five steps is visualized in Fig. 2
                        .

To extract this information we implemented a data extraction procedure (ii) in python. The procedure iteratively pulls information from the given spreadsheets and stores it in an SQLite database (iii). The database is a means to store the information consistently and enable faster and more convenient access compared to a spreadsheet. The database serves as a knowledge base and contains all information from the catalogues (80 components, 518 threats, 1244 safeguards, and connecting matrices). For each application scenario, a different excerpt may be relevant. Every organization has a different system and infrastructure and, thus, requires a unique data set with different components. For this purpose, we implemented a second procedure that generates the solver input (iv). This procedure fulfills two purposes: first, it creates the solver input and, second, it generates additional model parameters based on the given set of components. To prepare the solver input, the procedure gets a list of components as input and pulls the corresponding information from the database. The result is the solver input as a DAT file (v) which can be read by the solver. To generate additional model parameters, existing knowledge is utilized.

Different threats may impact security on a different level. To consider this fact we introduce the concept of a threat’s criticality. The criticality coefficients γ are expressing how severe threats are and enable us to compare different threats with each other. In Section 4, we show how these values are used to define security and to form the objective of our model. But first they are generated based on the given data. The criticality concept we introduce here is an additional information layer that is not directly present in the IT baseline protection catalogues. There is, however, the concept of “qualification levels” of safeguards that can be used to obtain the required information. We also utilize this information to derive the effectiveness of safeguards expressed by σ.

We begin by introducing sets 
                           I
                         and 
                           K
                         (indexed by i and k respectively) that define lists of threats and safeguards. Additionally, binary matrix 
                           
                              T
                              =
                              (
                              
                                 T
                                 
                                    k
                                    ,
                                    i
                                 
                              
                              )
                           
                         expresses whether safeguard k has an effect on threat i.

Each safeguard of the BSI standard is assigned a qualification level (A, B, C, Z, W) which indicates a safeguard’s significance for security (with A being the most important one). The qualification level also defines for which certification the safeguard is required: all A-level safeguards for an entry level certificate, A and B level safeguards for an intermediate certificate, and A, B, and C level safeguards for an ISO 27001 certificate (Federal Office for Information Security, 2008).

To generate γ, we use the available information and derive the severity of a threat by considering the number and qualification of safeguards associated with it. More specifically, if a threat has more and higher qualified safeguards associated with it, this is an indicator that this threat is more critical. This is a reasonable assumption because a high qualification level signifies that a safeguard is required in a low certificate which means it is more relevant for security. This may seem counter-intuitive at first, but it should be borne in mind that a low certification is the starting point for increasing security which means it addresses the most severe threats. Consequently, a threat is presumably more dangerous if it is treated by more high qualified safeguards of a low certification level. Therefore, we use the following calculation to generate γi
                           :

                              
                                 (1)
                                 
                                    
                                       
                                          γ
                                          i
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             ∈
                                             K
                                          
                                       
                                       
                                          
                                             T
                                             
                                                k
                                                ,
                                                i
                                             
                                          
                                          ·
                                          g
                                          
                                             (
                                             
                                                σ
                                                k
                                             
                                             )
                                          
                                       
                                       
                                       with
                                       
                                       g
                                       
                                          (
                                          x
                                          )
                                       
                                       =
                                       
                                          x
                                       
                                       
                                       ∀
                                       
                                       i
                                       ∈
                                       I
                                       .
                                    
                                 
                              
                           
                        

Equation (1) states that the threat criticality coefficient is the sum of associated 
                              
                                 (
                                 
                                    T
                                    
                                       k
                                       ,
                                       i
                                    
                                 
                                 =
                                 1
                                 )
                              
                            values g(σk
                           ) where the function g(.) returns a numeric value for a safeguard’s reduction coefficient σk
                            (see Section 3.3.2). For this example, we chose the concave square root function. As a result, safeguards with higher qualification levels influence the criticality index of associated threats at a diminishing rate.

To determine a safeguard’s reduction coefficient σ, we take into account that the effectiveness of a safeguard is correlated to its qualification level, i.e., a higher qualification level indicates a higher effectiveness. For that purpose, we define a five-level scale for σ and map it to the five qualification levels. Thus, σk
                            is defined as

                              
                                 (2)
                                 
                                    
                                       
                                          σ
                                          k
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      0.5
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      qualification
                                                      
                                                      level
                                                      
                                                      of
                                                      
                                                      k
                                                      =
                                                      A
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      0.6
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      qualification
                                                      
                                                      level
                                                      
                                                      of
                                                      
                                                      k
                                                      =
                                                      B
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      0.7
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      qualification
                                                      
                                                      level
                                                      
                                                      of
                                                      
                                                      k
                                                      =
                                                      C
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      0.8
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      qualification
                                                      
                                                      level
                                                      
                                                      of
                                                      
                                                      k
                                                      =
                                                      Z
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      0.9
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      qualification
                                                      
                                                      level
                                                      
                                                      of
                                                      
                                                      k
                                                      =
                                                      W
                                                   
                                                
                                             
                                          
                                       
                                       
                                       ∀
                                       
                                       k
                                       ∈
                                       K
                                    
                                 
                              
                           where, for example, 
                              
                                 
                                    σ
                                    k
                                 
                                 =
                                 0.6
                              
                            indicates that a safeguard reduces a threat’s criticality by 
                              
                                 1
                                 −
                                 0.6
                                 =
                                 40
                              
                            percent (i.e., down to 60 percent) if deployed, hence 
                              
                                 
                                    γ
                                    
                                       i
                                    
                                    ′
                                 
                                 =
                                 
                                    γ
                                    i
                                 
                                 ·
                                 
                                    σ
                                    k
                                 
                                 =
                                 
                                    γ
                                    i
                                 
                                 ·
                                 0.6
                              
                           . Due to the fact that σk
                            is causing a reduction to a certain percentage, a lower value for σk
                            indicates that a safeguard is more effective.

In this section, we formulate a single-stage combinatorial optimization model which is set up as a mixed integer linear programming (MILP) problem. The goal is to select a feasible subset from a pool of safeguards that maximizes security and meets a number of linear constraints. We first establish a nonlinear formulation in Section 4.1 and then use the natural logarithm to linearize it in Section 4.2. Table 1
                      lists parameters and decision variables which are used in the following.

Let 
                        
                           p
                           ∈
                           P
                        
                      denote a component of the system/infrastructure in question and let 
                        
                           i
                           ∈
                           I
                        
                      denote a threat. Matrix 
                        
                           C
                           =
                           (
                           
                              C
                              
                                 i
                                 ,
                                 p
                              
                           
                           )
                        
                      with C
                     
                        i, p
                      ∈ {0, 1} denotes whether threat i endangers component p
                     
                        
                           (
                           
                              C
                              
                                 i
                                 ,
                                 p
                              
                           
                           =
                           1
                           )
                        
                      or not 
                        
                           (
                           
                              C
                              
                                 i
                                 ,
                                 p
                              
                           
                           =
                           0
                           )
                        
                     . Each threat has the preset criticality coefficient γi
                      ≥ 0 and a variable criticality index ti
                      ≥ 0. The criticality coefficient γi
                      of a threat is an input to the model and expresses how severe a threat is without investing in security. The criticality index ti
                     , on the other hand, is variable and determined during optimization. It is reduced if safeguards are selected which are applicable to the threat in question.

The criticality coefficient γi
                      is intended to encapsulate all properties of a threat and condenses them to a single value. This value makes threats comparable and is a key component of the model. By automatically generating it based on data contained in the baseline protection catalogues, the decision maker is not forced to estimate numerous exact input parameters. The key idea is that exact threat probabilities or expected financial losses are not required to solve the safeguard selection problem. Knowing how severe threats are relative to each other is sufficient to allocate safeguards appropriately. The variable criticality index ti
                      is depending on the selection of safeguards. If a safeguard is selected, it reduces the criticality indexes of related threats according to its reduction coefficient σk
                     . If no safeguards are selected for a particular threat we have 
                        
                           
                              t
                              i
                           
                           =
                           
                              γ
                              i
                           
                        
                     .

To determine the criticality of a component, we introduce variable cp
                      which we refer to as the component criticality index (CCI). Due to the fact that the most serious threat is the key indicator of security, cp
                      is defined as the maximum of all criticality indexes of threats associated with the component in question, i.e.,

                        
                           (3)
                           
                              
                                 
                                    c
                                    p
                                 
                                 =
                                 
                                    max
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    {
                                    
                                       t
                                       i
                                    
                                    
                                       |
                                    
                                    
                                       C
                                       
                                          i
                                          ,
                                          p
                                       
                                    
                                    =
                                    1
                                    }
                                 
                                 
                                 ∀
                                 
                                 p
                                 ∈
                                 P
                                 .
                              
                           
                        
                     
                  

This definition is based on the assumption that the security of a component depends on the most serious of its threats which is the weakest link in the security chain. Therefore, to improve the security of a component, the criticality index of its most severe threat has to be reduced first. In order to achieve that, suitable safeguards have to be selected for deployment.


                     Fig. 3
                      illustrates how ti
                      and cp
                      are determined in a minimal example with one component, two threats, and two possible safeguard alternatives. If only one safeguard is to be selected, we choose the second one because it reduces the threat with the higher criticality index. In case the first safeguard is selected, we get 
                        
                           
                              t
                              1
                           
                           =
                           0.9
                           ×
                           100
                           =
                           90
                        
                      and 
                        
                           
                              t
                              2
                           
                           =
                           0.9
                           ×
                           120
                           =
                           108
                        
                      which leads to 
                        
                           
                              c
                              p
                           
                           =
                           max
                           
                              {
                              90
                              ,
                              108
                              }
                           
                           =
                           108
                        
                     . The second safeguard, however, reduces 
                        
                           
                              t
                              2
                           
                           =
                           0.5
                           ×
                           120
                           =
                           60
                        
                      and leaves t
                     1 unchanged. This results in a lower CCI value which is reduced by 20 to 
                        
                           
                              c
                              p
                           
                           =
                           max
                           
                              {
                              100
                              ,
                              60
                              }
                           
                           =
                           100
                        
                     .

When selecting safeguards, it is important to note that a safeguard only reduces the criticality of a threat if it is associated with this threat 
                        
                           (
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           =
                           1
                           )
                        
                      and if it is implemented 
                        
                           (
                           
                              s
                              k
                           
                           =
                           1
                           )
                        
                     . If 
                        
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           =
                           1
                           ,
                        
                      safeguard k is applicable to threat i and if 
                        
                           
                              s
                              k
                           
                           =
                           1
                           ,
                        
                      the safeguard is implemented. The binary matrix 
                        
                           T
                           =
                           (
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           )
                        
                      has to be provided as an input to the model and sk
                      is a decision variable which is determined during optimization. If and only if both take value 1, the criticality index of an associated threat is reduced from γi
                      to γi
                      · σk
                     , where σk
                      ∈ [0, 1] is the reduction coefficient of the selected safeguard. This AND-condition 
                        
                           (
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           =
                           1
                           ∧
                           
                              s
                              k
                           
                           =
                           1
                           )
                        
                      can be formulated as 
                        
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           ·
                           
                              s
                              k
                           
                           =
                           1
                        
                     . To model this, we multiply γi
                      by

                        
                           (4)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   σ
                                                   k
                                                
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                ·
                                                
                                                   T
                                                   
                                                      k
                                                      ,
                                                      i
                                                   
                                                
                                             
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         σ
                                                         k
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            s
                                                            k
                                                         
                                                         =
                                                         1
                                                         
                                                         and
                                                         
                                                         
                                                            T
                                                            
                                                               k
                                                               ,
                                                               i
                                                            
                                                         
                                                         =
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            s
                                                            k
                                                         
                                                         =
                                                         0
                                                         
                                                         or
                                                         
                                                         
                                                            T
                                                            
                                                               k
                                                               ,
                                                               i
                                                            
                                                         
                                                         =
                                                         0
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     which only takes value σk
                      if both 
                        
                           
                              s
                              k
                           
                           =
                           1
                        
                      and 
                        
                           
                              T
                              
                                 k
                                 ,
                                 i
                              
                           
                           =
                           1
                        
                      and defaults to 1 otherwise. In case the expression takes value 1, the criticality index of a threat is not reduced. If multiple implemented safeguards apply to the same threat, their effectiveness is multiplied. Thereby, threat criticality is reduced at a decreasing rate if more safeguards are selected. This interdependence of safeguards models the fact that security investments have a diminishing marginal utility (Rakes et al., 2012; Sawik, 2013; Schilling & Werners, 2014). Considering all safeguards at once we get the following equation to calculate the remaining criticality index of threat i after selecting safeguards according to sk
                     :

                        
                           (5)
                           
                              
                                 
                                    t
                                    i
                                 
                                 =
                                 
                                    γ
                                    i
                                 
                                 ·
                                 
                                    ∏
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    
                                       
                                          σ
                                          k
                                       
                                    
                                    
                                       
                                          s
                                          k
                                       
                                       ·
                                       
                                          T
                                          
                                             k
                                             ,
                                             i
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  

Due to the fact that 
                        
                           
                              s
                              k
                           
                           ,
                           ∀
                           k
                           ∈
                           K
                        
                      are the only decision variables on the right side of the equation, the value of ti
                      solely depends on the selection of safeguards.

The effect of safeguards is illustrated in Fig. 4
                      using the previous example. In the upper part of the figure, the result of Fig. 3 is displayed where the second safeguard is already selected. If the first safeguard is now added, the values of t
                     1 and t
                     2 are reduced on a percentage basis. This is accomplished by multiplying t
                     1 and t
                     2 by 
                        
                           
                              σ
                              1
                           
                           =
                           0.9
                        
                     . As a result, the TCI values are reduced to 
                        
                           
                              t
                              1
                           
                           =
                           0.9
                           ×
                           100
                           =
                           90
                        
                      and 
                        
                           
                              t
                              2
                           
                           =
                           0.9
                           ·
                           
                              (
                              0.5
                              ×
                              120
                              )
                           
                           =
                           0.9
                           ×
                           60
                           =
                           54
                        
                     . Consequently, cp
                      also decreases and is now 
                        
                           
                              c
                              p
                           
                           =
                           max
                           
                              {
                              90
                              ,
                              54
                              }
                           
                           =
                           90
                        
                     .

Based on these definitions, we establish the optimization model as follows (6-13):

                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                          
                                       
                                       
                                          
                                             [
                                             
                                                max
                                                
                                                   p
                                                   ∈
                                                   P
                                                
                                             
                                             
                                                c
                                                p
                                             
                                             ]
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             
                                                c
                                                p
                                             
                                             =
                                             
                                                max
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                {
                                                
                                                   t
                                                   i
                                                
                                                
                                                   |
                                                
                                                
                                                   C
                                                   
                                                      i
                                                      ,
                                                      p
                                                   
                                                
                                                =
                                                1
                                                }
                                             
                                             
                                             ∀
                                             
                                             p
                                             ∈
                                             P
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                t
                                                i
                                             
                                             =
                                             
                                                γ
                                                i
                                             
                                             ·
                                             
                                                ∏
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   
                                                      σ
                                                      k
                                                   
                                                
                                                
                                                   
                                                      s
                                                      k
                                                   
                                                   ·
                                                   
                                                      T
                                                      
                                                         k
                                                         ,
                                                         i
                                                      
                                                   
                                                
                                             
                                             
                                             ∀
                                             
                                             i
                                             ∈
                                             I
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                ·
                                                
                                                   T
                                                   
                                                      k
                                                      ,
                                                      i
                                                   
                                                
                                                ·
                                                
                                                   C
                                                   
                                                      i
                                                      ,
                                                      p
                                                   
                                                
                                             
                                             ≥
                                             
                                                
                                                   n
                                                   ̲
                                                
                                                p
                                                
                                                   (
                                                   c
                                                   )
                                                
                                             
                                             
                                             ∀
                                             
                                             p
                                             ∈
                                             P
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                ·
                                                
                                                   T
                                                   
                                                      k
                                                      ,
                                                      i
                                                   
                                                
                                             
                                             ≥
                                             
                                                
                                                   n
                                                   ̲
                                                
                                                i
                                                
                                                   (
                                                   t
                                                   )
                                                
                                             
                                             
                                             ∀
                                             
                                             i
                                             ∈
                                             I
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                s
                                                k
                                             
                                             ≤
                                             
                                                N
                                                ¯
                                             
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                s
                                                k
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                             ∀
                                             
                                             k
                                             ∈
                                             K
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                t
                                                i
                                             
                                             ≥
                                             0
                                             
                                             ∀
                                             
                                             i
                                             ∈
                                             I
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (6) minimizes the maximum of all CCIs. This formulation assumes that all components are equally important for the overall security of the system. If this is not the case, it would be possible to weight components differently by multiplying their criticality indexes with an additional factor. The objective value characterizes the overall security of the system in question and is called the system criticality index (SCI). Note that this value makes different solutions comparable, although it does not give an indication on how secure the system is on an absolute scale. Constraints (7) define CCI cp
                         as the maximum of associated TCIs. In constraints (9) and (10) a minimum number of safeguards per component 
                           
                              (
                              
                                 
                                    n
                                    ̲
                                 
                                 p
                                 
                                    (
                                    c
                                    )
                                 
                              
                              )
                           
                         respectively threat 
                           
                              (
                              
                                 
                                    n
                                    ̲
                                 
                                 i
                                 
                                    (
                                    t
                                    )
                                 
                              
                              )
                           
                         is guaranteed. The total number of safeguards is limited to 
                           
                              N
                              ¯
                           
                         in constraint (11). Since safeguards usually affect several threats, the lower safeguard limit 
                           
                              
                                 n
                                 ̲
                              
                              p
                              
                                 (
                                 c
                                 )
                              
                           
                         of a component may exceed 
                           
                              N
                              ¯
                           
                        . Finally, the decision regarding the selection of safeguards is binary (12) and all threat criticality indexes have to be nonnegative (13).

The established formulation of the problem has some drawbacks regarding its solvability due to its nonlinearity in constraints (8). Nonlinear problems are substantially more difficult to solve than linear problems. We show in the following how to obtain a MILP formulation of the problem. Constraints (8) are the only nonlinear equations where the product of multiple decision variables is calculated. To reformulate these constraints we take the natural logarithm of ti
                         and eliminate the multiplication (and exponentiation) of decision variables:

                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             t
                                             i
                                          
                                       
                                       
                                          
                                             =
                                             
                                                γ
                                                i
                                             
                                             ·
                                             
                                                ∏
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   
                                                      σ
                                                      k
                                                   
                                                
                                                
                                                   
                                                      s
                                                      k
                                                   
                                                   ·
                                                   
                                                      T
                                                      
                                                         k
                                                         ,
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                             ⇔
                                             
                                             ln
                                             
                                                (
                                                
                                                   t
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             ln
                                             
                                                (
                                                
                                                   γ
                                                   i
                                                
                                                ·
                                                
                                                   ∏
                                                   
                                                      k
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   
                                                      
                                                         σ
                                                         k
                                                      
                                                   
                                                   
                                                      
                                                         s
                                                         k
                                                      
                                                      ·
                                                      
                                                         T
                                                         
                                                            k
                                                            ,
                                                            i
                                                         
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             ⇔
                                             
                                             ln
                                             
                                                (
                                                
                                                   t
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             ln
                                             
                                                (
                                                
                                                   γ
                                                   i
                                                
                                                )
                                             
                                             +
                                             ln
                                             
                                                (
                                                
                                                   ∏
                                                   
                                                      k
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   
                                                      
                                                         σ
                                                         k
                                                      
                                                   
                                                   
                                                      
                                                         s
                                                         k
                                                      
                                                      ·
                                                      
                                                         T
                                                         
                                                            k
                                                            ,
                                                            i
                                                         
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             ⇔
                                             
                                             ln
                                             
                                                (
                                                
                                                   t
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             ln
                                             
                                                (
                                                
                                                   γ
                                                   i
                                                
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                ln
                                                
                                                   (
                                                   
                                                      
                                                         
                                                            σ
                                                            k
                                                         
                                                      
                                                      
                                                         
                                                            s
                                                            k
                                                         
                                                         ·
                                                         
                                                            T
                                                            
                                                               k
                                                               ,
                                                               i
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             ⇔
                                             
                                             ln
                                             
                                                (
                                                
                                                   t
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             ln
                                             
                                                (
                                                
                                                   γ
                                                   i
                                                
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                ·
                                                
                                                   T
                                                   
                                                      k
                                                      ,
                                                      i
                                                   
                                                
                                                ·
                                                ln
                                                
                                                   
                                                      (
                                                      
                                                         σ
                                                         k
                                                      
                                                      )
                                                   
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To replace constraints (8) with Eq. (18), ln (γi
                        ) and ln (σk
                        ) have to be precomputed which can be done efficiently before starting the optimization. Since ln (.) is a strictly monotonically increasing function, it is order-preserving which means it is still possible to differentiate between ti
                         values:

                           
                              (19)
                              
                                 
                                    ln
                                    
                                       (
                                       
                                          t
                                          i
                                       
                                       )
                                    
                                    ≤
                                    ln
                                    
                                       (
                                       
                                          t
                                          j
                                       
                                       )
                                    
                                    ⇔
                                    
                                       t
                                       i
                                    
                                    ≤
                                    
                                       t
                                       j
                                    
                                    .
                                 
                              
                           
                        
                     

The resulting MILP problem is a lot easier to solve with respect to computational complexity. There are several solvers available which can solve large instances within a reasonable solution time. The following version of the problem can be implemented as a linear model and is written as:

                           
                              (20)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                          
                                       
                                       
                                          
                                             [
                                             
                                                max
                                                
                                                   p
                                                   ∈
                                                   P
                                                
                                             
                                             
                                             ln
                                             
                                                (
                                                
                                                   c
                                                   p
                                                
                                                )
                                             
                                             ]
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             ln
                                             
                                                (
                                                
                                                   c
                                                   p
                                                
                                                )
                                             
                                             =
                                             
                                                max
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                {
                                                ln
                                                
                                                   (
                                                   
                                                      t
                                                      i
                                                   
                                                   )
                                                
                                                
                                                   |
                                                
                                                
                                                   C
                                                   
                                                      i
                                                      ,
                                                      p
                                                   
                                                
                                                =
                                                1
                                                }
                                             
                                             
                                             ∀
                                             
                                             p
                                             ∈
                                             P
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (22)
                              
                                 
                                    
                                       
                                       
                                          
                                             ln
                                             
                                                (
                                                
                                                   t
                                                   i
                                                
                                                )
                                             
                                             =
                                             ln
                                             
                                                (
                                                
                                                   γ
                                                   i
                                                
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                ·
                                                
                                                   T
                                                   
                                                      k
                                                      ,
                                                      i
                                                   
                                                
                                                ·
                                                ln
                                                
                                                   (
                                                   
                                                      σ
                                                      k
                                                   
                                                   )
                                                
                                             
                                             
                                             ∀
                                             
                                             i
                                             ∈
                                             I
                                          
                                       
                                    
                                    
                                       
                                          
                                       
                                       
                                          
                                             and
                                             
                                             (
                                             9
                                             −
                                             12
                                             )
                                             .
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                     

Constraints (22) now define the logarithmic TCI and ln (cp
                        ) are defined accordingly in constraints (21). The objective function (20) has also been adjusted and now minimizes the maximum logarithmic CCI. To obtain the original TCI, CCI, and SCI values, we use the inverse function of the natural logarithm, the exponential function, e.g.,

                           
                              (23)
                              
                                 
                                    
                                       c
                                       p
                                    
                                    =
                                    
                                       e
                                       
                                          ln
                                          
                                             (
                                             
                                                c
                                                p
                                             
                                             )
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Note that an adapted version of constraints (13) must not be included in order not to cut off feasible solutions. In the linear version of the model, ln (ti
                        ) takes negative values for ti
                         ∈ [0, 1].

In this section, we give an illustrative example to show details of the presented model and its application. For this purpose, we consider a system which represents a typical setup for providing a web based service. The setup, including two servers and 4 actors, is visualized in Fig. 5
                     . The web server delivers content to end users and accesses a dedicated database to handle persistent data. In addition to normal customers, we have editorial staff and administrative staff who manage the system. Finally, attackers are potentially threatening the security of the system.
                     
                  

For solving the model, we used the 64 bit version of Gurobi (Gurobi Optimization, 2014) with default settings. All calculations were performed on a ThinkPad T430s with Intel Core i7-3520M processor running at 2.9 gigahertz and with 8 gigabyte RAM. Additional data processing, including data extraction and solver input generation was implemented in Python (v2.7.8), a high-level programming language.

To optimally secure the described system, we extracted relevant components from the IT baseline protection catalogues. For our analysis, we identified 12 components which are directly applicable to the system in question. From these components, a list of relevant threats per component and potential safeguards per threat was compiled. All extracted components including the number of threats and safeguards per component are listed in Table 2.

To extract information on the connection of threats and safeguards, we used cross-reference tables which are available as an extension to the IT baseline protection catalogues (Federal Office for Information Security, 2013a). Since threats may be connected to more than one component and safeguards may be connected to more than one threat, the total number of 151 threats and the total number of 254 safeguards is less than the sum of the columns in Table 2. As a result, we have a 12 × 151 matrix for C and a 151 × 254 matrix for T.

For this application example, we did not specify a minimal safeguard allocation per threat or component and set 
                           
                              
                                 
                                    n
                                    ̲
                                 
                                 i
                                 
                                    (
                                    t
                                    )
                                 
                              
                              =
                              0
                              ,
                              ∀
                              i
                              ∈
                              I
                           
                         and 
                           
                              
                                 
                                    n
                                    ̲
                                 
                                 p
                                 
                                    (
                                    c
                                    )
                                 
                              
                              =
                              0
                              ,
                              ∀
                              p
                              ∈
                              P
                           
                         in constraints (9) and (10).

To give an example of data used in this example, Tables 3 and 4
                         list all safeguard options and threats of the first component. More detailed information on threats and safeguards of this and other components can be obtained from Federal Office for Information Security (2013b).

In Table 5, an excerpt from matrix T is given that shows the connection between threats and safeguards. For additional reference tables of the remaining components, we refer to Federal Office for Information Security (2013a).

To obtain the required information, we developed an automated data extraction process to obtain threats and safeguards and connecting matrices from Federal Office for Information Security (2013b) and Federal Office for Information Security (2013a) based on any given selection of components. The extracted data are stored in an SQLite database using an object-relational mapper and then further processed to meet the input format of the model. A detailed description of the data extraction process is given in Section 3.3.

@&#RESULTS@&#

To secure the system in question using the IT baseline protection catalogues, a selection of safeguards has to be made. To support the decision maker, the BSI provides an entry level certification where all A level safeguards have to be implemented and an intermediate certificate where all A and B level safeguards have to be implemented. If the objective is to obtain an ISO 27001 certificate, all A, B, and C level safeguards are required. In case of the entry level certificate, this would require implementing 128 safeguards, in case of the intermediate certificate 171 safeguards, and to fulfill the conditions of an ISO 27001 certification 205 safeguards have to be implemented. These numbers indicate what kind of effort is required to achieve the individual security levels.
                     

Ideally, we can find a smaller selection of safeguards than specified by the certificates but one that offers a comparable security level. To establish a baseline for our analysis, Fig. 6
                         shows the component criticality indexes (CCIs) of an unprotected system compared with the BSI entry level certificate. The solution is obtained by fixing the values of sk
                         to 1 if safeguard k is required by the entry level certificate (and to 0 otherwise). Note that, although we compute these values using the introduced model, no optimization is carried out at this point, since all decision variables are preset by fixating sk
                        .


                        Fig. 6 shows that implementing safeguards according to the entry level certificate increases security by reducing the criticality of all system components. All 12 components are displayed on the x-axis and the CCI value is measured on the y-axis. The dark-colored bars indicate the CCI values of the unprotected system and the light-colored bars represent the reduced indexes. The dotted line marks the objective value of the model, which is the maximum of all component criticality indexes (3). Since the most insecure component is the weakest link in the security chain of the system, we call this value system security index (SCI). We use it to measure and compare alternative solutions and find that by implementing all entry level safeguards, the SCI value is reduced by 85.5 percent from 26.845 to 3.887. We also computed these values for the intermediate and ISO 27001 certificates as follows: in case of the intermediate certificate, the SCI value is reduced by 96.0percent to 1.075 and the ISO 27001 certificate leads to a reduction of 96.7percent from 26.845 down to 0.894.

The question now is: can we achieve similar security levels (i.e., a similar SCI value) by implementing less safeguards? And if so, how many safeguards are necessary for the same level of security? To answer these questions, we compute several optimal solutions and relax the safeguard limitation of constraint (11) in the process. As a result, we can approximate a curve that indicates the achieved security level according to a predefined number of safeguards. Fig. 7
                         visualizes this curve and shows the SCIs of 20 optimal solutions where each solution corresponds to an optimal selection of safeguards with a fixed maximum 
                           
                              N
                              ¯
                           
                         of implemented safeguards. The dashed, dashed-dotted, and dotted lines mark the SCI of the entry level, intermediate, and ISO 27001 certificates. As can be seen, by implementing an optimal solution with a maximum of roughly 21 safeguards, it is possible to realize an SCI value similar to the one of the entry level certification. In other words, it is possible to achieve a comparable security level with approximately 83.6percent less safeguards. In case of the intermediate certificate, roughly 62 safeguards (63.7percent less) are required for the same security level and in case of the ISO 27001 certificate, the implementation of around 75 safeguards is sufficient which cuts the number of required safeguards by 63.4percent. These numbers show that an optimal decision with respect to the assumptions outlined can make a significant difference. As a result, considerably less effort in terms of implemented safeguards is required for a comparable security level.

In this section, we give some computational results for different instances of the problem (see Table 6
                        ). We define instance size as the number of components 
                           
                              |
                              P
                              |
                           
                         which influences the remaining input parameters. The problem we analyzed in the previous section has 12 components which include 151 threats and 254 safeguards. Since we have a combinatorial selection problem, the solution time not only depends on the instance size 
                           
                              |
                              P
                              |
                           
                         but also on the number of safeguards to be selected. To obtain comprehensive results, we computed 4 optimal solutions for each instance and chose the number of safeguards to be selected as 
                           
                              
                                 N
                                 ¯
                              
                              =
                              30
                              ,
                              60
                              ,
                              120
                              ,
                              240
                           
                        . Table 6 gives the main results of this analysis including instance size, objective value, and solution time.

The instances listed in Table 6 were randomly generated (except for Inst12) from the IT baseline protection catalogues to match a given instance size 
                           
                              |
                              P
                              |
                           
                        . To generate, for example, Inst40 with 40 components, we randomly drew 40 components from the list of 80 possible ones. In case of Inst40, this led to a number of 
                           
                              |
                              I
                              |
                              =
                              387
                           
                         threats and 
                           
                              |
                              K
                              |
                              =
                              710
                           
                         safeguard options for this instance. Due to this process, the provided instances do not resemble real-life use cases, with the exception of Inst12 which we used as the application example earlier. Nonetheless, the generated instances provide a good estimate for computational effort required to solve larger problems.

Taking a closer look at solution times, it can be observed that small instances up to 20 components are solved very fast in under 3 seconds regardless of 
                           
                              N
                              ¯
                           
                        . In most of the remaining instances the required computational time varies between 3 seconds and around 20 seconds and in some cases goes up to 81.46 seconds for Inst80 with 
                           
                              
                                 N
                                 ¯
                              
                              =
                              120
                           
                        . A notable observation is that solution time of every instance highly depends on 
                           
                              N
                              ¯
                           
                        . This is clearly visible, for example, in case of Inst70 where the solution time for 
                           
                              
                                 N
                                 ¯
                              
                              =
                              120
                           
                         is 75.64 seconds and for 
                           
                              
                                 N
                                 ¯
                              
                              =
                              240
                           
                         only 4.71 seconds. As a matter of fact, in most cases, the solution time is high for mid-range values of 
                           
                              N
                              ¯
                           
                         (with the exception of Inst20 and Inst40).

The results displayed in Table 6 show that computation time remains in an acceptable range (under 2 minutes) regardless of instance size and the number of safeguards to be selected. Since results are not needed in real-time, the achieved solution times are well within an acceptable range for a planning model. All results were computed with Gurobi (Gurobi Optimization, 2014), a commercially available solver, which makes the model applicable for real-life use cases.

@&#CONCLUSION@&#

The approach presented in this paper is designed to give very concrete decision support and at the same time does not require the decision maker to provide extensive input data. We established a knowledge base with data from the IT baseline protection catalogues of the BSI and developed a combinatorial optimization model to determine an optimal selection of safeguards. The decision maker only has to define the system in question by specifying relevant components. By choosing the minimum and maximum number of safeguards, the decision maker can influence the security level of the system. We applied our model to an exemplary information system and were able to demonstrate that security levels similar to the ones defined by the BSI and ISO 27001 certificates can be obtained with less safeguards.

An organization aiming at securing its systems sufficiently with reasonable effort can use the knowledge contained in the IT baseline protection catalogues and select a smaller number of safeguards than specified by the certificates. Since most organizations do not have specialized IT security knowledge, they would otherwise have to source out the decision process to a specialized service provider (e.g., a consulting company). This causes non-negligible additional costs and can be circumvented using the presented approach. The model can help to automate the decision process of selecting security safeguards or at the very least provide guidance during this process. It works both for a completely new system or infrastructure and for an existing one.

The use case for the model is not limited to an individual company and it could also be applied by a security consulting company to improve its service and reduce costs by automating decision making. In addition, by extending and customizing the knowledge base, it is possible to generate additional added value and, in doing so, increase the quality of generated solutions over time.

In our analysis, we deliberately left costs out of the picture and limited the selection of safeguards by their number instead of total costs. This has the advantage that the decision maker is not forced to determine the costs for all safeguards before carrying out the optimization. In practice, it is not easy to estimate cost values and with several hundred safeguard options, the information requirements would be enormous. Instead, the costs for implementing an optimal selection of safeguards should be determined after the optimization. If costs are too high, the safeguard limit can be reduced or the solution can be adjusted in other ways according to the individual needs of the decision maker.

Future research may include extending the scope of the model by taking additional factors into account. An interesting extension would be a multi-stage model to take into consideration that a system is operated over time. An adaptive multi-stage model could be used during the entire operation of a system to add, exchange, or remove safeguards and thereby adapt to a changing threat environment. To improve the quality of solutions, it is also possible to introduce uncertainty of some of the input parameters. In doing so, more robust solutions can be obtained that also yield good security if some input parameters were determined inaccurately.

@&#ACKNOWLEDGMENT@&#

This work was partially supported by the Horst Görtz Foundation.

@&#REFERENCES@&#

