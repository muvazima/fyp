@&#MAIN-TITLE@&#Analysis and classification of flow-carrying backbones in two-dimensional lattices

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The application of the backbone effect in the transport throughput capacity of materials is considered.


                        
                        
                           
                           A novel parallel implementation of the backbone algorithm is proposed for percolation lattices.


                        
                        
                           
                           The theoretical algorithm complexity is estimated for data-flow implementation.


                        
                        
                           
                           The results are analyzed regarding the classical graph-based approaches and the execution efficiency.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Flow

Current

Backbone

Infinite cluster

Percolation

Parallel algorithm

Data-flow

@&#ABSTRACT@&#


               
               
                  The paper proposes a new data-flow based approach for the identification of backbones in infinite clusters on 2-D percolation site lattices of dimension L × L. The infinite cluster is identified first, then a multi step algorithm is applied for the reduction of the infinite cluster to its backbone. Algorithm performances are evaluated theoretically and experimentally. The algorithm is local and can therefore be efficiently implemented on data-flow parallel platforms in Θ(L) time if applied on percolation lattices near the critical percolation probability or in Θ(L
                     2) in the worst case. The proposed methodology could resolve the problem of stack overflow at large systems that can appear with classical graph based algorithms, and has potential for a higher execution speed-up on parallel architectures.
               
            

@&#INTRODUCTION@&#

In the context of percolation theory, the concept of spreading hypothetical fluid particles through a random media  [1], e.g. porous materials  [2], was introduced in the past. The problem can be formulated as a bond percolation problem or a site percolation problem. In this paper, we deal with the site percolation problem, schematically illustrated by a 2-D lattice of square cells. Finding a spanning cluster, termed also infinite cluster (IC), is one of the fundamental tasks in this theory. Such clusters appear if the probability that a percolation site is occupied is higher than the critical probability threshold pc
                      
                     [3]. The backbone (BB) can be informally described as parallel pipelines, with no dead ends, that connect two opposite boundaries of the lattice. The BB has an important role in many transport processes through the percolation system, e.g. composite  [4] or photovoltaic materials  [5], nanoparticles  [6], etc. because it enables an accurate evaluation of the non-linear media resistance, permeability or other crucial parameters of various technological processes  [7].

Well-known algorithms for the identification of ICs and its parallelization have been presented in  [8–10]. Also, several algorithms for BB identification in ICs are known and published in  [11–13]. Most of the algorithms for BB identification are recursive, with a risk of stack overflow in large systems. Observing the local characteristics of system elements, e.g. site connectivity, we have explored the system properties and propose a local seven-step algorithm for the determination of the BB.

The algorithm is informally summarized in this paragraph. A lattice of black–white cells is generated, either by a random principle or by a rule. The existence of eventual ICs is confirmed by labeling the white components of the initial lattice, using only the information about the state and connectivity of local cells. If at least one IC exists, the algorithm removes ICs’ dead ends using the information about the site connectivity. Then the algorithm locally recognizes so called articulation cells (ACs), that can split an IC into two or more parts, if ACs are removed from the IC. A classification of ACs enables a local identification of the BB based on flooding.

A simple illustrative case is shown in Fig. 1
                     . In its left part, a percolation lattice with dimensions 21 × 21 cells (sites) is shown. The occupied cells, obtained with the percolation probability 
                        
                           p
                           =
                           0.6
                           ,
                        
                      are colored black. In the middle, the corresponding IC is shown with black cells. In the right part, the corresponding BB is shown with red cells. The remaining cells are shown in light blue, for better visibility. We see that all dead ends of the BB have been removed. Only one conductive path has been identified. It spans from the top to the bottom lattice boundary and can therefore contribute to a flow or transport of a matter between boundaries.

This paper is based upon Stamatović et al.  [14], extended with the following new contributions: (i) the improved algorithm for the identification of a BB in 2-D lattices has been upgraded with two additional steps, to manage all dangling IC parts on boundaries, (ii) the calculation and communication complexities of its data-flow implementation have been evaluated, and (iii) various lattices have been experimentally characterized regarding the number of time-steps and the sizes of ICs and BBs.

In the rest of the paper, some essential definitions are given, supported by illustrative examples. A new algorithm for the identification of backbones in an infinite cluster on 2-D percolation lattices with open boundary conditions is proposed. Similar problems, or at least parts of them, have been considered in [8,11,12] but none of the suggested algorithms is entirely local. Our algorithm relies on local properties of the percolation lattice cells and is not limited by the size of the lattice. The proposed solution can resolve the problem of stack overflow that could appear with the classic algorithms for the backbone identification, if implemented on the standard sequential computers. An extensive experimental evaluation of 2-D lattices is done regarding the percolation probability, the size of BBs and the number of algorithmic time-steps. We confirmed that the proposed algorithm has a high potential for a scalable and efficient parallel implementation on data-flow computing platforms, e.g. graphics processing units (GPUs), many-core accelerators (Intel Phi), field programmable gate arrays (FPGAs), systems on chips (SoC), or other processing arrays with high radix interconnection networks [15].

We consider a 2-D lattice network of unite squares (cells) whose centers are in an integer lattice. For simplicity, we suppose that the lattice has 
                        
                           N
                           =
                           L
                           ×
                           L
                        
                      cells c
                     
                        i, j
                      with positions determined by the indices 
                        
                           i
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           L
                        
                      in x and y directions, respectively, with L ≥ 3. Each cell can exist in a finite number of states, marked by colors. The cells can change their states at the end of individual time-steps, i.e. at that are discrete moments in time that mark the completion of a computation. The state of all lattice cells in a time-step t is denoted by Ct, t ≥ 0.

We use the Moore neighborhood with twenty-four neighbors. Each cell has four nearest neighbors (nn), four next-nearest neighbors (nnn) and sixteen not next-nearest neighbors (nnnn). Two cells c
                     
                        i, j
                      and c
                     
                        k, l
                      are nn-neighbors if 
                        
                           
                              |
                              i
                              −
                              k
                              |
                           
                           +
                           
                              |
                              j
                              −
                              l
                              |
                           
                           ≤
                           1
                           ,
                        
                      
                     nnn-neighbors if 
                        
                           
                              
                                 (
                                 i
                                 −
                                 k
                                 )
                              
                              2
                           
                           +
                           
                              
                                 (
                                 j
                                 −
                                 l
                                 )
                              
                              2
                           
                           =
                           2
                        
                      and nnnn-neighbors if 
                        
                           4
                           ≤
                           
                              
                                 (
                                 i
                                 −
                                 k
                                 )
                              
                              2
                           
                           +
                           
                              
                                 (
                                 j
                                 −
                                 l
                                 )
                              
                              2
                           
                           ≤
                           8
                        
                     . For short notation, the relative positions of cells are denoted by the compass notation, e.g. E for the right nn-cell, NE for the right-upper nnn-cell, WNN for the left-upper-upper nnnn-cell, etc. The nn-path (nnn-path) is a sequence of black cells pi
                     , 1 ≤ i ≤ n, n ≥ 2, such that each pair, pi
                      and 
                        
                           
                              p
                              
                                 i
                                 +
                                 1
                              
                           
                           ,
                        
                      is nn-connected (nnn-connected). More definitions about connectivity can be found in [16].

The initial configuration of the percolation sites C
                     0 can be represented by a 2-D lattice of square cells and each cell can exist in two different states, marked by the white or the black color. The left (W) and the right (E) boundary cells of the lattice are white, while the remaining cells of the top (N) and the bottom (S) boundaries are black. The lattice is surrounded by one additional layer of white cells, to simplify the analysis of cells near boundaries when the nnnn-neighborhood has to be examined. This layer is not shown in illustrations of our examples. All the remaining inner cells of the lattice, are colored black with the site probability p, and white with the probability 
                        
                           1
                           −
                           p
                        
                     . The probabilities are independent for each cell. A black nn-cluster is a group of black cells that are nn-connected. Note that the critical probability for such a percolation lattice of nn-connected sites is pc
                      ≈ 0.59, which is known from the site percolation theory  [1]. Site percolation probabilities p < pc
                      should not result in an IC.

The infinite cluster (IC) is a large black nn-cluster that spans from the top to the bottom boundary of the above defined lattice. The neighboring cells of nn-clusters are connected by edges termed also as bonds. In the same way, an nnn-cluster is a group of cells in the same state that are nn- or nnn-connected. In particular, a white nnn-cluster is a group of white cells that are nn- or nnn-connected.

The backbone (BB) is a set of black cells from the interior of the lattice that are nn-connected with the top and the bottom boundary by two nn-paths that have no bonds in common [18]. The BB is a subset of cells from ICs that are nn-connected and spans from the top to the bottom boundary of the percolation lattice. Some cells that are members of the IC are dangling, i.e. nn-connected with the IC through just a single cell. Consequently, they cannot be members of the BB. The shapes of such dangling parts can be single cells, branches or loops of cells, termed in our paper as dangling ends or dangling loops.

The BB has an important role in the transport processes of percolation systems. For example, if we study a fluid flow across the bonds of a lattice that connect black cells, we will find out that some of the bonds experience the flow, while the others are dangling ends or loops with no flow. Another example of the applicability of BB identification is in conductivity studies of composite materials made from resistive nano particles, where the BB could be defined as a part of the cluster that can carry electric current if the top and the bottom lattice boundaries are on different electric potentials.

The articulation cell (AC) is a black cell of a black IC if its removal (changing its state to white) splits the existing IC into two or more parts, with at least one part becoming unconnected with, or isolated from, the top and the bottom boundaries. The key for finding the BB is to find its ACs. However, local rules, limited to the nnnn-neighborhood, should be applied for the data-flow determination of ACs’ relations to the BB. Some specific cases of ACs are illustrated and informally explained in the left part of Fig. 2
                     
                      on an example of the IC from Fig. 1. In the right part of Fig. 2, the identified BB is colored red.

The lattice shown in Fig. 2, with 21 × 21 cells, incorporates the top and the bottom boundaries, a single black IC (nn-cluster), thirteen white nnn-clusters Oi
                     , 
                        
                           i
                           =
                           1
                           ,
                           2
                           ,
                           ⋯
                           ,
                           13
                           ,
                        
                      and thirteen ACs aj
                     , 
                        
                           j
                           =
                           1
                           ,
                           2
                           ,
                           ⋯
                           ,
                           13
                           ,
                        
                      of which two are dangling ends a
                     1 and a
                     2. We know that a removal of an AC can isolate a part of IC from the top and the bottom boundary. For example, a removal of a
                     12 or a
                     9 would isolate the dangling parts A and C and hence, these ACs cannot be parts of the BB.

Some ACs, however, can remain parts of the BB. For example, a
                     7, a
                     10 
                     a
                     11 and a
                     13 are parts of the BB. Any cell of the IC not in A, B, C or D, will not become isolated by removing these ACs. On the other hand, a
                     4 and a
                     8 are not in the BB, because they would become isolated through the isolation of the dangling part C or A, respectively.

Hence, to correctly remove all the dangling parts of the IC, to obtain the final BB, ACs have to be identified and classified according to whether they belong to the BB or not. Note that each AC has in its nnn-neighborhood at least two cells from the common white nnn-cluster. For example, NE and W neighbors of a
                     12 are in O
                     1, and NE and SW neighbors of a
                     13 are in O
                     13. Now, if all white nnn-clusters can be labeled by unique colors, using Corollary 1 
                     [12], ACs can be identified and classified locally, just from the state of their nn- and nnn-neighbors.

                        Corollary 1
                        
                           Let c
                           
                              i, j
                            
                           be a cell of a black IC and let Gc be a set of c
                           
                              i, j
                            
                           and their nn- and nnn-neighbors. Cell c
                           
                              i, j
                            
                           is AC if and only if there are at least two white cells in Gc that belong to the same nnn-cluster but can not be nn-connected with white cells in Gc.
                        

With the unique labeling of white nnn-clusters by unique colors, and assuming that the number of white nnn-clusters of the initial lattice C
                     0 is w < N/2, we can obtain the information whether two or more white cells of Gc
                      belong to the same or different white nnn-clusters. This information is important for the determination of AC’s relation regarding its membership in the BB. The unique colors genm
                     , 
                        
                           m
                           =
                           1
                           ,
                           2
                           ,
                           ⋯
                           ,
                           N
                           ,
                        
                      can be determined from the cells’ positions, for example as: 
                        
                           m
                           =
                           i
                           L
                           +
                           j
                           ,
                        
                      and must be different from white, black, green, blue, red and tagging colors (defined at the end of this section), that are reserved for special use.

Let gen ∈ genm
                      be a generic name for a unique color. For each gen cell, a maximal gen value from the nnn-neighborhood can be used for coloring all separate white nnn-clusters uniquely, with a subset of genw
                     ⊂genm
                      colors. After such a labeling of all white nnn-clusters, we can identify ACs using the Corollary 1 and the classification of ACs’ Gc
                      (nn- and nnn-neighbors). We distinguish two main cases in the classification of ACs.

In Case 1, cell c
                     
                        i, j
                      is an AC if it either has at least three gen cells in Gc
                      that are not nnn-connected in Gc
                      by gen cells or has two opposite (N and S, or W and E) gen nn-neighbors.

The state of c
                     
                        i, j
                      has to be changed to the state denoted by gen. All possible irreducible cases are shown in Fig. 3(a)–(c). Analogue cases are obtained by their rotation for 90°, 180°, and 270°. For example, the central cell c
                     
                        i, j
                      of Gc
                      in Fig. 3(c) has three black nn-neighbors, E, N and S, and three gen cells, EN, W and ES. By the counter clockwise rotation of the Gc
                      for 90°, we obtain N, W, E black cells and WN, S, EN gen cells. Note that the ACs a
                     1, a
                     2, a
                     3 and a
                     5 from Fig. 2 belong to Case 1 (Fig. 3(a)) and a
                     12 is also Case 1 (Fig. 3(b)).

We know that the cells of Gc
                      with the same gen belong to the same white nnn-cluster in the initial configuration C
                     0. Hence, they are nnn-connected with gen cells in a configuration obtained after the labeling of white nnn-clusters. Such a gen nnn-cluster surrounds dangling ends and loops that are, in Case 1, composed of actual ACs. So, we must remove such ACs by coloring them with genw
                      color and no further tagging is needed.

In Case 2, cell c
                     
                        i, j
                      is an AC if it either has three black nn-neighbors, one gen nn-neighbor and one same gen cell that is not nnn-connected with the gen nn-neighbor in Gc
                      by the gen cells, or has four black nn-neighbors and two gen nnn-neighbors that are diagonally opposite (EN and WS, or WN and ES). Note that the ACs a
                     4, a
                     6, a
                     7, a
                     8, a
                     9, a
                     10, a
                     11 and a
                     13 from Fig. 2, are cases from Fig. 3(e), (d), (e), (e), (e), (f), (f) and (f), respectively. Now, c
                     
                        i, j
                      perhaps belongs to the BB and we “temporarily” remove it by marking it with white.

Applying the above classification of ACs, cells a
                     1, a
                     2, a
                     3, a
                     5, a
                     12, from Fig. 2, are permanently removed and cells a
                     4, a
                     6, a
                     7, a
                     8, a
                     9, a
                     10, a
                     11, a
                     13 are marked with the white color. Now we tag contact couples that are pairs of orthogonally positioned black cells in the AC’s (now white) nn-neighborhood. For example, in Fig. 3(d), N and E cells are tagged as a contact couple, in (e), E and S are tagged as a contact couple, and in (f), N and E are tagged as a contact couple and also S and W. As another example, for cell a
                     7 from Fig. 2, N and E are tagged as a contact couple. For cell a
                     10, N and W are tagged as a contact couple and also S and E. Also, cell a
                     13 has two tagged contact couples, N and W, and S and E.

We know that two cells of a contact couple are nn-neighbors of a gen cell that is different from other genw
                      cells in Gc
                     , e.g. cells ‘O’ in Fig. 3(d)–(f). Notice that it is impossible to have two ‘*’ and two ‘O’ gen cells in Gc
                     . Namely, if in Fig. 3(f), ‘X’ is a gen cell, then it cannot be the same as ‘O’, because the nnn-clusters of ‘*’ and ‘O’ that surround the part of the IC, would be “mixed up” with each other (two different gen nnn-clusters are separated by an IC). Based on the tagged contact couple cells, we will obtain the information whether they are in the BB or not, by the following reasoning. If, after previous coloring of ACs by white, a cell from a contact couple remains nn-connected with black N or S boundary cells, what we should see in the next step of the algorithm, then the remaining cell of the contact couple will use this information to declare itself as a part of the BB.

The implementation of the proposed algorithm uses twelve tagging colors for twelve possible cases that are shown in Fig. 3(d)–(f) together with their rotations for 90°, 180°, and 270°. Different tagging colors are used for excluding all dangling loops from the IC. For example, in Fig. 3(f), if ‘X’ is not a black cell, then we have two contact couples (for ‘X’ and ‘O’) that must be tagged with different colors. After labeling c
                     
                        i, j
                      with white, the contact couples can not be both nn-connected with black N or S boundary cells, because the nn-connection was broken by just colored white c
                     
                        i, j
                     . All the mentioned details are necessary for correct algorithm implementation, but are not essential for the conceptual understanding of the proposed local approach. Note that the implementation in  [17] admits some dangling loops.

The proposed data-flow algorithm for the identification of BB has seven steps, as shown in Algorithm 1
                     . All algorithmic steps are performed in all cells in parallel. The algorithm runs until the lattice state changes, i.e. the current time-step Ct
                      is different from 
                        
                           C
                           
                              t
                              −
                              1
                           
                        
                     . In Step 1, all white cells surrounded by S, E and SE black cells are marked with their unique genm
                      colors.

Starting from these cells, in Step 2, all white nnn-clusters are colored with genw
                      colors, using flooding, until the state of the lattice becomes constant. Now, if the colors of the lowest left and right cells of the lattice are equal, these two cells are in the same nnn-cluster, which means that an nnn-path exists from the left to right boundary, which disconnects eventual IC. If an IC exists, the colors of these two cells must be different. Note that boundary cells are treated in the same way as inner cells, but taking into account that some neighbors are missing.

In Step 3, ACs are identified and the tagging of specific cells is made. If an AC cannot disconnect the IC, the algorithm deletes it by coloring it with genw
                      from its Gc
                     . If an AC could disconnect the IC, it is marked by white. Then, the contact couple cells of the white cells are found, by examining the ACs’ nnnn-neighborhood, and tagged for Step 4.
                  

In Step 4, the algorithm colors some black and tagged cells in green. First, the black cells c
                     
                        i, j
                     , for 
                        
                           i
                           =
                           L
                           −
                           1
                        
                      or 
                        
                           i
                           =
                           2
                        
                      are colored green. Then, all black and tagged cells that have green nn-neighbors are colored green with flooding. Eventually, the second cell of each contact couple that has got one green cell is also colored green, until the lattice state becomes stable.

In Step 5, the algorithm marks some of the remaining ACs, which were colored white in Step 3, by green, to include them in the BB. To preserve the locality of the algorithm, nnnn-neighborhood is used for the implementation of the following rule (see [12]): If c
                     
                        i, j
                      is a white cell, then it is a part of the BB if: (i) c
                     
                        i, j
                      has at least two green nn-neighbors or (ii) c
                     
                        i, j
                      has a green and a white nn-neighbor that are nn-connected with another green cell.

In Step 6, green cells are flooded by a reserved color blue from the second to 
                        
                           (
                           L
                           −
                           1
                           )
                        
                     th line of the lattice, while the Lth line is colored by a reserved color red. Now, the green cells that are nn-connected with top boundary cells but are not in the BB, become isolated. For example, in Fig. 2 cell a
                     6 and its E neighbor become isolated from the BB after Step 6.

In Step 7, blue cells are flooded with red from the 
                        
                           (
                           L
                           −
                           1
                           )
                        
                     th line to the first line. Now, the blue cells that are nn-connected with bottom boundary cells but are not in the BB are isolated. Hence, the final BB remains colored by red.

A natural approach for the implementation of a fast and scalable system that could implement the algorithm with maximal parallelism is an array of simple computing elements with a small memory and a simple arithmetic unit. Such technology is available today on various levels of granularity, from dedicated FPGA systems to general purpose GPUs or multicore computers. Note that more cells can be managed in parallel by a single computing element, but suppose now one element for each cell. The programming paradigm is data-flow, which is based on the same operations on many simple data items. It is known that such an approach could be extremely fast and energy efficient [19].
                        
                     

From the description of the Algorithm 1 it is evident that calculation in each time-step is simple and limited only to the nnnn-neighborhood. However, because of the arbitrary shapes of ICs, the numbers of time-steps in the algorithm can not be expressed exactly. Steps 2, 4, 6, and 7 are based on flooding, which can be implemented, in the case of lattices obtained with percolation probability near pc
                        , with Θ(L) time-steps, because just a few ICs can be present in this case with dimensions Θ(L). If an IC has a more complex shape, e.g. spiral, the number of time-steps could reach L
                        2/2.

Usually, the number of time-steps is much lower than L
                        2, because the clusters are flooded earlier and the lattice reaches its stationary state. In order to use this advantage, a global communication is needed that can determine that the calculation can stop earlier. Now, after each time-step, or after a small number of time-steps, a global communication has to be implemented. One option is to design a line-wise shifting of local results to a single column vector that can also be shifted to a master cell. Such a global gather operation can be performed in 2L steps. Note that a similar approach must be present also for the initial loading of the data-flow system. Often, such a communication is not necessary in all time-steps. It could be more efficient to perform it only after several calculation time-steps. However, in the worst-case, after each time-step a global communication is needed, which becomes extremely expensive.

Alternatively, the implementation of the stopping criteria can be done on the whole lattice by a special synchronization hardware that samples the status of each cell “running or idle” and synchronizes all computing elements by a single alert line in a single time-step. Taking into account this optimistic scenario we can conclude that the expected asymptotic complexity of the Algorithm 1 on parallel platforms is Θ(L), if applied on percolation lattices near the probability pc
                        , because all the operations can be performed on all cells in parallel, for each time-step and with a single-time-step for the communication. However, some worst-case arrangements of the 2-D lattice cells could require Θ(L
                        2) time-steps for the calculation.

@&#IMPLEMENTATION@&#

The algorithm code was implemented in NetLogo and Matlab programming environments. The implementation of the algorithm can be fully parallel. After each time-step, all lattice cells can change its state depending of the state of the cell’s neighborhood and a local rule. Most of the cells operate with the same local rule, except boundary cells or an eventual master cell, that could have special rules.

To assure an appropriate stopping criterion, a global communication is needed for a global test if 
                        
                           
                              C
                              t
                           
                           =
                           
                              C
                              
                                 t
                                 +
                                 1
                              
                           
                           ,
                        
                      followed by a global communication of the test result for the notification of all cells. Alternatively, the global communication can be avoided, if the algorithm runs for a specified number of time-steps that is high enough for the completion of the particular algorithmic step.

The goal of the first and the second algorithmic steps is in labeling white nnn-clusters of the initial lattice with unique colors different from black, white, and green. Note that we use cell positions for the generation of unique colors. In the first step, white cells with black E, ES and S neighbors are marked with those colors. In the second step, all initially white nnn-clusters are finally colored by unique colors.


                     Fig. 4 shows the lattice from Fig. 1 as obtained after algorithm Steps 1 and 2. On the left lattice, slightly different yellow colors of the lowest left and right cells indicate that a black IC and its BB exist. On the right lattice, the white clusters are uniquely colored with colors from dark red to yellow.

Step 3 is performed in two sub-steps. First, ACs are identified and those that could disconnect the IC are colored white. Then, the contact couples of ICs are identified and tagged for the next step. The state of the lattice after the whitening phase and the tagging phase of Step 3 are shown in the left and the right part of Fig. 5, respectively.

In Step 4, all black cells or tagged nn-neighbors from the interior lattice become green. Because all ACs, which are not in BB, have been removed in Step 3, only ACs, which could be in BB are still white. In Step 5, a white cell become a part of the BB if: (i) it is nn-connected with two green cells, or (ii) is nn-connected with a green and a white nn-neighbor which is nn-connected with another green neighbor. We use nnnn-neighbors of the white cell to check local properties of nn-neighbors’ nn-neighbors. The state of the lattice after Steps 4 and 5 are shown in the left and right part of Fig. 6, respectively.

In Steps 6 and 7 the algorithm removes green dangling ends and dangling loops which are nn-connected with the top or bottom boundary and are therefore not in the BB. In Step 6 such cells are colored from bottom to up in blue and in Step 7 from up to bottom in red, which is the color of the final BB (see Fig. 7
                     
                     ).

@&#EXPERIMENTAL RESULTS@&#

We measured the average number of algorithm time-steps needed for BBs identification and classification. The average values were calculated from 10 runs with different seeds of the random generator. Percolation lattices with 
                        
                           N
                           =
                           
                              10
                              2
                           
                           ×
                           
                              10
                              2
                           
                           =
                           
                              10
                              4
                           
                        
                      and 
                        
                           N
                           =
                           
                              10
                              3
                           
                           ×
                           
                              10
                              3
                           
                           =
                           
                              10
                              6
                           
                        
                      cells and with different percolation probabilities 0.62 ≤ p ≤ 0.65 in steps of 0.01 have been tested. A typical example of an infinite cluster in a lattice with 
                        
                           N
                           =
                           4
                           *
                           
                              10
                              4
                           
                        
                      black cells at 
                        
                           p
                           =
                           0.62
                        
                      overlaid by its BB (in red) is shown in Fig. 8
                     .

Additionally, we measured the average numbers of all black cells, cells in ICs, and cells that belong to BBs. The ratio between the total number of black cells or the number of IC cells and the number of BB cells is also calculated. The results are shown in Table 1.

We see from Table 1 that the number of algorithm time-steps is about six times larger than the number of cells in a single dimension L. Experimental results provide also the average numbers of time-steps in each algorithmic step. Steps 1 and 5 need a single time-step, Step 3 needs 2 time-steps, Steps 2 and 4 need L time-steps, while Steps 6 and 7 need 2L time-steps, respectively. The total experimental complexity of the algorithm, if applied on percolation lattices obtained with the percolation probability near pc
                     , can be estimated to 6L, which is in accordance with the asymptotic complexity estimation.

The number of cells that can cooperate in percolation transport (members of BBs) is reduced significantly in comparison to the total number of black cells or to the number of IC cells, particularly for lower values of p. From ratios in the last two columns of Table 1 it is evident that by lower percolation probabilities, ICs and BBs become thinner.

To explore the computational complexity as a function of lattice dimension L, the total number of time-steps that are needed for the identification of BBs has been calculated. The experiments have been performed on lattices with dimensions 
                        
                           L
                           =
                           
                              25
                              ,
                              50
                              ,
                              100
                              ,
                              200
                              ,
                              400
                              ,
                              800
                              ,
                              1200
                              ,
                              1600
                           
                           ,
                        
                      number of cells 
                        
                           N
                           =
                           L
                           ×
                           L
                        
                      and with the percolation probability 
                        
                           p
                           =
                           0.62
                           ,
                        
                      again in 10 runs with different seeds of the random generator for each L. The results shown in Fig. 9
                      indicate that the number of time-steps is proportional to the number of cells L on the lattice boundary.

@&#CONCLUSION@&#

We have proposed a new data-flow algorithm for the identification of a backbone from an infinite cluster in a 2-D percolation site lattice with dimensions L × L. The experimental results indicate that the proposed algorithm can be efficiently implemented on parallel platforms with an asymptotic complexity of Θ(L), if applied on percolation lattices near the probability pc
                     , because all the operations can be performed on all cells in parallel, for each time-step. However, some worst-case arrangements of the flow-carrying cells on the 2-D lattice could require Θ(L
                     2) time-steps. A global communication is needed for the stopping criteria in algorithmic Steps 2,4, 6 and 7, with the complexity of Θ(L). The actual implementation on a dedicated data-flow architecture remains for future work.

@&#ACKNOWLEDGMENT@&#

This work was partly supported by the Slovenian Research Agency under Grant P2-0095, Montenegrian national project “Discrete structures and their application” and COST programme Action IC1305, “Network for Sustainable Ultrascale Computing” (NESUS).

@&#REFERENCES@&#

