@&#MAIN-TITLE@&#An enhancement of return address stack for security

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Design a method to protect the return address stack from stack smashing attacks.


                        
                        
                           
                           Our approach does not need source code and hardware support.


                        
                        
                           
                           Relative performance overhead is only between 3.47% and 8.59%.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Stack smashing attack

Buffer overflow

Memory pointer corruption attack

Return address stack

Binary rewriting

@&#ABSTRACT@&#


               
               
                  Stack smashing is one of the most popular techniques for hijacking program controls. Various techniques have been proposed, but most techniques need to alter compilers or require hardware support, and only few of them are developed for Windows. In this paper, we design a Secure Return Address Stack to defeat stack smashing attacks on Windows. Our approach does not need source code and hardware support. We also extend our approach to instrument a DLL, a multi-thread application, and DLLs used by multi-thread applications. Benchmark GnuWin32 shows that the relative performance overhead of our approach is only between 3.47% and 8.59%.
               
            

@&#INTRODUCTION@&#

With the rapid growth of computer system, more and more issues have been concerned. One of the most concerned issues is security. Stack smashing attacks, which exploit buffer overflow vulnerabilities [18,12,31,7,30] to hijack the program control from attacked applications, are the most widely used type of attacks. Due to careless programmers, vulnerabilities [28,29] exist all the time. Diverse techniques have been proposed to thwart stack smashing attacks, such as static analysis and dynamic detection. However, they are not as useful as we thought because most of them must alter compilers [34,33,10,8,11,22,32,1,20] and recompile source code, or require hardware support [35,34,13,9] to execute specialized instructions. Another reason is that most of them are built only for Linux. However, Windows is still the most popular operating system today, and there are more applications that contain buffer overflow vulnerabilities. Therefore, we need to protect those applications from stack smashing attacks on Windows.

There is a class of techniques [26,34,23,8,25,2,32] which creates a safe area to backup return addresses to prevent stack smashing attacks. The safe area is called private stack, canary stack, or return address repository, etc. For consistency, we call it return address stack throughout this paper. These techniques revise the prologue and epilogue of each protected function. The revised function prologue will store copies of the return address into return address stack, and the revised function epilogue will restore the return address on stack with copies of them. Obviously, these techniques should guarantee that the return address stack is absolutely secure because attackers may attempt to modify the contents of the return address stack to hijack the program control. In general, these techniques set return address stack as read-only mode most of the time to protect it. The only situation that the return address stack becomes writable is in the revised function prologue when it is pushed into return address stack. In this paper, all we considered is outside the box by showing that only setting return address stack as read-only is not secure enough if the return address stack is dynamically allocated.

Our approach is based on Binary Rewriting, so we can protect applications from stack smashing attacks without source code and hardware support. Hence, we only focus on those techniques that use Binary Rewriting. We classify them into two groups according to the way they allocate return address stack: (1) static allocation [26,23] and (2) dynamic allocation [25,2]. The first group statically allocates a return address stack like adding a new section called return address stack into Portable Executable (PE) or Executable and Linking Format (ELF) file. Therefore, the return address stack is already created before running the protected application. The second group dynamically allocates a return address stack at the beginning of the protected application. In this way, the return address stack is certainly located in the heap. We discovered that there is a potential security risk if the return address stack is dynamically allocated. Because the second group dynamically allocates an area to be the return address stack, it must have an Entry Pointer of the return address stack in order to pass the address to the revised function prologue and epilogue of each protected function. However, the second group only keeps eyes on protecting the return address stack but fail to protect Entry Pointer of the return address stack. For this reason, we can launch a Memory Pointer Corruption Attack to hijack the program control from protected applications by modifying Entry Pointer of the return address stack even if they are under protection. The detail of Memory Pointer Corruption Attack will be explained in the next section.

In this paper, we design a Secure Return Address Stack to protect the return address stack and entry pointer of the return address attack from stack smashing attacks on Windows. Our approach does not need source code and hardware support because we combine DLL Injection with Dynamic Binary Rewriting to implement it. Moreover, we also extend our approach to instrument a DLL, a multi-thread application, and DLLs used by multi-thread applications. Benchmark GnuWin32 shows that the relative performance overhead of our approach is only between 3.47% and 8.59%.

The rest of this paper is organized as follows. In Section 3, we describe our approach and implementation. We evaluate our approach in Section 4. Section 5 describes a drawback, a limitation, and two potential security issues for instrumenting a multi-threading application. In Section 6, we survey related works of stack smashing attacks, and a conclusion will be given in Section 7.

@&#BACKGROUND@&#

In this section, we review the stack smashing attacks and the memory pointer corruption attacks.

To understand stack smashing attacks, Fig. 1
                         shows a typical example. The C programming language is a popular language due to its high execution efficiency, but it has a lot of unsafe functions. For example, strcpy() is one of them because it does not check boundary automatically. Lack of boundary checking during a buffer copy operation may cause areas adjacent to the buffer be overwritten. As shown in Fig. 1, msg points to a sequence of attack data that are inputted by attackers, and these attack data have more than eighty bytes, including shellcode. After executing strcpy(), all attack data will be copied into stack because strcpy() does not check the boundary of buf and msg. At this time, buf and return address are already overwritten by attack data. Therefore, the program control of this attacked program is transferred to the shellcode when ret instruction in the victim function is executed. This is a generic stack smashing attack that involves exploiting such an unsafe copy to overwrite the return address on stack with the address of shellcode.


                        Memory Pointer Corruption Attack 
                        [4,27], we call it MPC attack for short in this section, is a variety of stack smashing attacks. Fig. 2
                         is a pattern of vulnerable function. If there is an application which has a function like the one in Fig. 2, attackers will have a chance to launch MPC attack. In real world, there is a ftp server called wu-ftp, version 2.5, which has a function called mapped_path() like Fig. 2. Thus, MPC attack is not an imaginary problem. Hence, we will use Fig. 2 as an example to demonstrate how to manipulate a MPC attack.


                        msg is an input of vulnerable function, and it points to a sequence of data which are inputted by attackers. The sequences of data include three main parts as follows.
                           
                              1.
                              Attack data.

Attack data will be used to rewrite the content of attack target.

Attack target.

Attack target is an address which is assigned by attackers.

Shellcode and other data.

After executing the first strcpy(), the contents of buf are rewritten by attack data, and the content of msg is overwritten by attack target. Besides, shellcode and other data are also copied into stack. At this moment, titmsg is already changed to point to the attack target. Then, attack data will directly rewrite the content of attack target after executing the second strcpy(). Therefore, we are able to rewrite anything on anywhere of memory via controlling the input msg. There is a very good sentence of Phrack Magazine [4] to appropriately describe MPC attack: “When a buffer overwrites a pointer… The story of a restless mind”.

Previous approaches [25,2] always considered that return address stack is absolutely secure if it is set to be read-only. Then, attackers are hard to modify the contents of return address stack even if they use MPC attack. We also believe that return address stack is secure enough, but modifying the contents of return address stack is not the only way to hijack the program control from protected applications. Previous approaches dynamically allocate an area to be the return address stack when the protected application starts to run, so they must have an Entry Pointer of the return address stack, we call it Entry Pointer for short in this section, to be referenced by all protected functions. Entry Pointer is as important as a key of encryption, but it is not protected by previous approaches in any way because they only care of protecting the return address stack. Therefore, attackers are able to rewrite Entry Pointer to hijack the program control from protected applications that are protected by previous approaches via manipulating MPC attack.

If we want to rewrite Entry Pointer, we first have to know where Entry Pointer is. Generally, it must be placed in .data or .bss section from a practical view because Entry Pointer is a global variable. In addition, Entry Pointer is always located at the same address after every startup for those protected applications. This feature allows attackers to guess the address of Entry Pointer correctly with a high probability. If an attacker already guesses the address of Entry Pointer correctly, he can rewrite Entry Pointer to a fake return address stack by manipulating MPC attack. The fake return address stack is a set of return addresses which points to shellcode, and it is a part of other data. Besides, the fake return address stack and shellcode are already copied into stack by the first strcpy(). Consequently, all protected functions will access the fake return address stack when they finish function. After that, the program control is hijacked from these protected applications. Finally, we can see that it is really a potential security risk because the chance to rewrite Entry Pointer is relative high. Because previous approaches have such a security flaw as mentioned above, we are motivated to propose a Secure Return Address Stack to protect both return address stack and Entry Pointer to thwart stack smashing attacks, including MPC attack.

In this section, we first overview the proposed architecture. Although previous approaches [2,25] already protect the return address stack, they fully ignore to protect Entry Pointer of the return address stack. In order to pinpoint the security flaw, we demonstrate how to use Memory Pointer Corruption Attack to bypass the protection of previous approaches in Section 2.2. To overcome this problem, we design a Secure Return Address Stack to deal with Memory Pointer Corruption Attack. Next, we explain how to combine DLL Injection with Dynamic Binary Rewriting to implement our approach on Windows. Finally, we further enhance our approach to instrument a DLL, a multi-threading application, and DLLs used by multi-threading applications.

@&#OVERVIEW@&#

Our approach is based on a return address stack, it is a separated stack. The return address stack is responsible for storing copies of the return address of each protected function, so the return address stack does not store every return address per function. Because copies of the return address will restore the original return address on stack, the return address stored on return address stack is the final return address when each protected function finishes and returns. For this reason, the integrity of return address stack should be guaranteed, and we still need to ensure that all protected functions will access the correct return address stack. Fig. 3
                         is a fundamental concept of our architecture. Similar to previous approaches, our scheme dynamically allocates an area to be the return address stack and sets this area as read-only most of the time. However, setting return address stack as read-only is not secure enough because Memory Pointer Corruption Attack can still hijack the program control successfully by rewriting Entry Pointer of return address stack.

In order to implement our approach like Fig. 3, we still need to instrument functions that we want to protect. Fig. 4
                         is a clear contrast between an original function and a protected function. The function prologue and epilogue of each protected function will be rewritten by a jump to the corresponding function entry or exit. Function entry and exit execute not only their original tasks but also their different instrumentation codes. Fig. 5
                         is the pseudo-code of instrumentation code. As shown in Fig. 5, the only time that the return address stack becomes writable is in the function entry when the current return address is pushed into return address stack. Then, the return address stack will be set as read-only again at the end of function entry. Our approach also uses the similar way to protect Entry Pointer of return address stack.

To overcome the potential security risk mentioned in Section 2.2, we propose a Secure Return Address Stack to protect both return address stack and its Entry Pointer. In practical, there are three ways to achieve a Secure Return Address Stack:
                           
                              •
                              Address randomization for Entry Pointer
                              

We randomize the address of Entry Pointer to introduce a certain entropy for Entry Pointer so that it will not locate at the same address every time when protected applications start up. It can be a previously configured range. Originally, attackers are hard to guess the address of Entry Pointer correctly at first attempt. If we randomize the address of Entry Pointer, attackers are more difficult to guess the address of Entry Pointer correctly. However, attackers are able to rewrite Entry Pointer successfully by Brute-Force Attack if they already know the range of randomization. If attackers really want to launch Brute-Force Attack to rewrite Entry Pointer, they have to input a lot of attack data because we could set up a large range for randomization. Therefore, Brute-Force Attack is easily detected by Intrusion Detection System or System Administrator because attackers input a lot of abnormal data. In conclusion, this method can still be used to protect Entry Pointer.

Double check read-only flag before execution

Because the return address stack is set as read-only most of the time, we can check it constantly whether Entry Pointer points to a read-only area. If Entry Pointer points to a read-only area, we can make sure Entry Pointer is not rewritten by attackers because attackers do not have the power to set any areas as read-only before they get the program control from protected applications. However, this method generates a burden on performance because all protected functions should check Entry Pointer first before accessing the return address stack.

Read-only Entry Pointer
                              

Generally speaking, Entry Pointer does not need to be modified at run time after initializing the return address stack, so we are able to set Entry Pointer as read-only directly to protect it. This is a good method because setting it as read-only does not affect on the performance of protected applications. Moreover, the protected application will crash if attackers attempt to rewrite the read-only Entry Pointer.

To consider performance and security, we decide to adopt the third method to protect Entry Pointer. It means that Entry Pointer will be set as read-only all the time after the return address stack is initialized.

In contrast to previous approaches [26,23,25,2], we use a powerful and flexible way to implement our approach. We combine two useful mechanisms, DLL Injection and Dynamic Binary Rewriting, to implement our approach. In addition, we use two popular disassembly tools called OllyDbg 
                        [24] and IDA Pro 
                        [16]. Fig. 6
                         shows an outline of our implementation. We simply divide our implementation into two stages as follows:
                           
                              1.
                              
                                 First stage:
                                 
                                    
                                       1.
                                       Binary Disassembly.

Function Analysis.


                                 Second stage:
                                 
                                    
                                       3.
                                       DLL Injection.

Return Address Stack Initialization.

Dynamic Binary Rewriting.

A diagram of the instrumentation process is shown in Fig. 6, and we will describe each of these steps in detail later. DLL Injection and Dynamic Binary Rewriting are the cores of our implementation, so we first introduce two significant components of them as follows.
                           
                              •
                              Injector


                                 Injector is a process, and is a role as controller on the second stage of instrumentation process. The responsibility of Injector is injecting Defense.dll into a specific process we assigned.

Defense.dll


                                 Defense.dll is the core component that includes all defense mechanisms of our approach. It is responsible for initializing return address stack and executing binary rewriting. Defense.dll has a main function called DllMain, so that it will start automatically after being injected.

Before executing binary rewriting, we first disassemble the application we want to protect. Since disassembly is not in the core of our research, we rely on two popular disassembly tools called OllyDbg and IDA Pro to do this job because they are able to accurately distinguish between code and data. Next, we decide to protect those functions which include more than one unsafe functions, such as strcpy() or gets(). For this reason, we need to analyze these functions and identify their function prologues and epilogues because we are going to rewrite them by a jump to the corresponding function entry or exit. However, it will be very difficult to analyze functions if the application is highly optimized by compiler. After identifying all functions need to protect, we have to record a signature for each protected function. In general, we choose the front bytes of each protected function to be its signature. These signatures will be used as a searching pattern to find the actual address of each protected function on memory at run time.


                        DLL Injection is a mechanism to forcibly inject a DLL into a specific process. If we have a high privilege, we are able to forcibly inject Defense.dll into the process we want to protect. On the second stage of instrumentation process, Injector uses an API called CreateProcess() to start the application we want to protect and suspends it at first. After that, Injector injects Defense.dll into the process, and Defense.dll begins to run by itself because it has a main function called DllMain. At this moment, Defense.dll will initialize return address stack and execute binary rewriting. The detail of initializing return address stack and executing binary rewriting will be explained later. Finally, Injector uses another API called ResumeThread() to resume the process, and the process starts to run.

Return address stack is the most important element of our architecture because our approach is entirely based on it. Attackers can hijack the program control from protected applications if they are able to modify the contents of return address stack or Entry Pointer of return address stack, so we have to protect both of them. At the beginning of the protected application, we use an API called VirtualAlloc() to dynamically allocate an area to be the return address stack and use another API called VirtualProtect() to set this area as read-only most of the time. At the same time, we also use the same API to set the function entry and exit as read-only because attackers may attempt to rewrite this portion to hijack the program control from protected applications. In conclusion, we should also set Entry Pointer of return address stack as read-only, too.

We already recorded a signature per protected function on the first stage of instrumentation process, so we can use these signatures to search the actual address of each protected function on memory at run time by an API called ReadProcessMemory(). After finding the actual address of each protected function, we replace some instructions at the function prologue of each protected function with a jmp instruction by an API called WriteProcessMemory(). Definitely, we also use the same way to instrument the function epilogue of each protected function. Therefore, the function prologue and epilogue of each protected function will be rewritten to jump to the corresponding function entry or exit. In addition, the function entry and exit are included in Defense.dll, and they are already set as read-only before executing binary rewriting. Because the size of an unconditional jmp instruction and the address of function entry or exit are five bytes, we need at least five bytes of instruction space to accommodate them.

The use of DLLs is extremely common on Windows, and multi-threading is also applied to implement a lot of applications such as web server and ftp server. Consequently, instrumenting DLLs and multi-threading applications are very important. However, previous approaches [26,23,25,2] usually set these complex issues as future works or did not properly overcome them. We also discovered that the class of techniques which use static binary rewriting [23] to implement cannot completely instrument a DLL and DLLs which are used by multi-threading applications because most DLLs are loaded dynamically at run time. Moreover, modifying DLLs directly is also not a good method because DLLs are shared between applications that need to be protected or not. In order to solve this issue, our approach decides to select Dynamic Binary Rewriting to fully instrument a DLL and DLLs used by multi-threading. Finally, we propose a novel approach to instrument a DLL, a multi-threading application, and DLLs used by multi-threading applications at run time on Windows.

Before explaining how to instrument a DLL, we should first introduce two useful mechanisms on Windows: Copy-on-Write and API Hooking. First, Copy-on-Write is a paging mechanism of Win32 which lets physical memory be shared by many processes. For example, when a process rewrites a physical page shared with other processes, the page will be copied to a new physical location, and only the copy in the new location is rewritten. At this moment, only the rewriting process can access the rewritten copy, and other processes in memory can still access the original page. Second, API Hooking 
                           [15] is an intercepting mechanism which hooks a specific API and adds protection code into the API. For instance, when a process calls an API that is hooked by us, the process executes not only the API but also our protected code. However, the process does not know that it actually executes protection code which is inserted by us because it gets the correct result by calling the API. It means the hooked API will execute original tasks and extra protection code when every process calls it.

To utilize these two features, we are able to instrument a DLL at run time. At first, we hook an API called LoadLibrary() because all DLLs, including system DLLs or self-writing DLLs, are dynamically loaded into memory by LoadLibrary() on Windows. Therefore, we aim at DLLs that we want to protect to instrument their functions after LoadLibrary() loads them into memory. Next, the instrumented DLL will be copied to a new physical location because of Copy-on-Write paging policy, and only the instrumenting process can access the instrumented DLL. In addition, we use an API called GetProcAddress() to retrieve the address of an exported function from the instrumented DLL. This API helps us a lot to instrument a DLL. Eventually, our approach does not affect other processes which use the same DLL and is capable of instrumenting any DLLs that we want to protect because LoadLibrary() is hooked by us.

Race condition is a considerable issue if we would like to instrument a multi-threading application. In order to prevent race condition between threads in a multi-threading application, we must allocate an independent return address stack per thread. There is a mechanism of memory allocation that is capable of allocating memory for each thread on Windows, called Thread Local Storage (TLS). This mechanism makes each thread automatically access a different copy of TLS index, and the TLS index is independent per thread. In addition, this mechanism provides three APIs for programmers in the following, and we want to use these APIs to allocate an independent return address stack for each thread.
                              
                                 •
                                 TlsAlloc:

It allocates a TLS index. Any thread of the process can subsequently use this index to store and retrieve values that are local to the thread, because each thread receives its own slot for the index.

TlsSetValue:

It retrieves the value in the calling thread's TLS slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.

TlsGetValue:

It stores a value in the calling thread's TLS slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.

At first, we try to hook an API called CreateThread() because every thread is created by this API on Windows. We want to allocate an independent return address stack per thread after CreateThread() creates it. However, we discovered that threads are not created yet after executing CreateThread(). Threads are really created when the main function of thread is executed. Therefore, we need to instrument the main function of thread to allocate an independent return address stack for each thread. At the beginning of the main function of thread, we use TlsAlloc() to allocate a TLS index. At the same time, we allocate a return address stack and use TlsSetValue() to store Entry Pointer of the return address stack. Definitely, we also use the same way to protect the return address stack per thread as mentioned before. Finally, instrumented functions of the instrumented multi-threading application will use TlsGetValue() to retrieve Entry Pointer of the return address stack for each thread.

As mentioned above, we use the same way to instrument DLLs used by multi-threading applications. After LoadLibrary() loads DLLs that we want to protect into memory, we start to instrument their functions. Because each thread already had its own return address stack at the beginning of the main function of thread, instrumented functions of each instrumented DLL are able to use TlsGetValue() to retrieve Entry Pointer of the return address stack for each thread. In conclusion, instrumented functions of each instrumented DLL are able to aim at different threads to access their independent return address stacks.

This section evaluates the performance of our approach and illustrates the efficiency of our approach by defeating stack smashing attacks. We rewrite the function prologue and epilogue of each protected function to jump to the corresponding function entry or exit, so extra protection code that is included in function entry and exit incurs a performance overhead. The results showed that the relative performance overhead of our approach is only between 3.47% and 8.59%. Moreover, we also demonstrate the performance overhead of our approach only depends on the numbers of instrumented function called regardless of instrumented function size. Finally, the experiments were conducted on a 1.81GHz, AMD Athlon 64 processor 3000+, with 1GB RAM running on Windows Service Pack 2.

We measure the performance overhead of an instrumented function to observe the overhead which is raised by extra protection code included in function entry and exit. We have tested two different instrumented functions which are implemented by ourselves: Matrix Addition and Matrix Multiplication. These two instrumented functions compute the addition and multiplication of a 4∗4 random matrix respectively. Then, we take an average of computing 100 times of matrix addition and multiplication. Table 1
                         demonstrates the original average run-time and instrumented average run-time. The relative performance overhead of our experiment is defined as follows:
                           
                              
                                 PerformancePenalty
                                 =
                                 
                                    
                                       OriginalRunTime
                                       −
                                       I
                                       nstrumentedRunTime
                                    
                                    OriginalRunTime
                                 
                                 .
                              
                           
                        
                     

As shown in Table 1, the performance overhead of an instrumented function is only between 1.88% and 4.08%. In addition, we also discovered that the performance overhead of an instrumented function is nearly fixed because our approach always executes the same protection code in function entry and exit that without respects to instrumented function size. Therefore, the performance overhead of our approach only depends on the numbers of instrumented function called regardless of instrumented function size. Next, we are going to perform more experiments on a wide variety of GnuWin32 applications.

We adopt GnuWin32, which provides Win32-versions of GNU tools, to be the benchmark of our approach, since there are various applications of GnuWin32. According to the function, we select five exclusively types of applications in the end. The experiments of previous approaches [26,23,25,2] did not illustrate the number of instrumented functions and instrumented function called. However, there are two main factors to impact the performance. In contrast to the experiments of previous approaches, we gather statistics of number of instrumented functions and instrumented function called to precisely illustrate our experiments.


                        Table 2
                         illustrates the original run-time and instrumented run-time of GnuWin32 applications that we selected. We take an average of 100 times running of each instrumented application. The results showed that the relative performance overhead of our approach is only between 3.47% and 8.59%. Therefore, the average of performance overhead is 5.78%. Besides, we also test different inputs of bmp2png and bzip2 to show that the performance overhead of our approach only depends on the numbers of instrumented function called regardless of instrumented function size. If the numbers of instrumented function called are less, the performance overhead of our approach is relatively low. Table 3
                         illustrates the distinct performance overheads of bmp2png and bzip2 from different inputs.

During instrumenting GnuWin32 applications, we discovered that a few applications are very difficult to analyze their functions because they are highly optimized by compiler. It will be a big challenge to execute binary rewriting for those applications which are highly optimized by compiler. In conclusion, the results showed that the relative performance overhead of our approach is only between 3.47% and 8.59%, so our approach is efficient in defeating stack smashing attacks.

@&#DISCUSSION@&#

Although our approach achieves a high performance, there are little shortcomings including: a drawback, a limitation, and two potential security issues for instrumenting a multi-threading application. The drawback is the setjmp() and tlongjmp() problem because our approach does not solve it. There are two system calls setjmp() and longjmp() in C programming language. They allow programmers to bypass several functions in the call path to the current function to directly jump back to the function executing setjmp(). It means programmers use setjmp() to set a return location and use longjmp() in a different function to go back to the return location set by the setjmp() statement. Therefore, it will cause a serious inconsistency of return address storage problem if programmers use setjmp() and longjmp() to implement applications. Actually, we ignore this two system calls because setjmp() and textitlongjmp() are seldom being used by programmers. However, this problem is not a tough problem because there is an approach called Return Address Defender 
                     [8] which already proposed a solution to solve it. We are able to use the same way to solve the setjmp() and longjmp() problem if necessary.

The limitation of our approach is the Optimization problem in the area of studying binary rewriting. Although we successfully use binary rewriting to implement our approach, binary rewriting is still a complicated study, disassembly especially. We rely on two disassembly tools called OllyDbg and IDA Pro to finish disassembly issues. During disassembling GnuWin32 applications, we discovered that a small number of applications are very difficult to analyze their functions because they are highly optimized by compiler. Therefore, we cannot instrument those applications which are highly optimized by compiler. However, we are still able to instrument most applications because only a few applications have this problem. We think it as another sub-class issue, therefore, we may study on how to instrument those applications that are highly optimized by compiler and design a disassembly engine to automatically finish disassembly.

For instrumenting a multi-threading application, our approach and previous approaches [26,23] both have two potential security issues. However, each potential security issue occurs only with an extremely low probability in a multi-threading application. First, attackers may attempt to launch Memory Pointer Corruption Attack to modify Entry Pointer of return address stack as mentioned in Section 2.2 because we do not protect it in a multi-threading application. Every Entry Pointer of return address stack is stored in a TLS slot per thread, and TLS slots are managed and dynamically allocated by operating system. Therefore, attackers are hard to guess the address of each TLS slot correctly and modify the corresponding Entry Pointer of return address stack. Second, attackers may attempt to modify the contents of return address stacks for other threads when those return address stacks become writable. Although modifying the contents of other return address stacks successfully in a very short time is very difficult, it is still possible to happen in a multi-threading environment.

@&#RELATED WORK@&#

With the rapid growth of network or computer technology, security is still one of the concerned issues [5,14,6]. In this paper, we focus on stack smashing attack. Stack smashing is still one of the most popular techniques for hijacking program controls, so diverse techniques have been proposed to defeat stack smashing attacks. We can divide these techniques into two broad categories: (1) static analysis and (2) dynamic detection. Our approach falls into the dynamic detection category. Now, we broadly classify related researches into six classes as follows, and we give an example to briefly introduce each of them.

Larochelle et al. [19] proposed to use special annotations in program source code as a heuristic to infer and detect vulnerabilities in C programs. However, this method produces undesirable false positives and false negatives and requires source code to analyze.

Because many buffer overflow vulnerabilities are caused by unsafe C library functions such as strcpy() and gets(), this class of techniques [3,21,1,2] patches the standard C library for detection. For example, Libsafe [3] intercepts function calls to shared C library and executes boundary checking.

The kernel patch of non-executable stack [17] prevents attackers from executing malicious code on stack by making the stack to be non-executable. However, Return-into-libc attack entirely defeats this method by overwriting the return address and transfers the program control to shared libraries.

This class of techniques [34,33,10,8,11,22,32,1,20] inserts protection code for run-time detection at compile time. The instrumentation is done by altering existing compilers such as gcc compiler. There are plenty of famous compiler-based techniques such as StackGuard [11], StackShield [32], PointGuard [10], RAD [8], and so on. However, this method needs a source code to recompile.

Xu et al. [34] and Frantzen et al. [13] proposed a hardware-based technique against stack smashing attacks without requiring source code respectively. However, this class of techniques [35,34,13,9] needs to modify system architecture such as changing the semantics of call and ret instructions.

This class of techniques [26,23,25,2] uses binary rewriting to insert protection code for run-time detection. According to the method of binary rewriting, they can be classified into two classes: (1) static binary rewriting [26,23,2] and (2) dynamic binary rewriting [25]. This method does not need source code and hardware support, hence, there are many approaches that are implemented with it recently.

Our approach belongs to the class of Binary Rewriting because we use Dynamic Binary Rewriting to implement our approach. We do not pick static binary rewriting to implement our approach because it cannot completely instrument a DLL and DLLs used by multi-threading as we mentioned in Section 3.6. In addition, obtaining source code from applications and revising system architecture are not easy both on Windows, therefore, binary rewriting is suitable for us.

@&#CONCLUSION@&#

We designed a method to break previous proposed approaches based on return address stack. By using Memory Pointer Corruption Attack, it is possible to rewrite Entry Pointer of return address stack and hijack the program control from protected applications. We proposed a Secure Return Address Stack to protect both return address stack and its Entry Pointer without performance loss. Moreover, we do not need to recompile source code and require hardware support; in other words, our approach is capable of working on compiled binaries. The proposed solution generates a low overhead around 3.47% and 8.59%. Thus, our approach achieves both performance and security.

In contrast to the class of techniques which use static binary rewriting to implement, our approach completely instruments a DLL and DLLs used by multi-threading applications. During instrumenting multi-threading applications, we are aware of multi-threading applications that may cause the return address stack to become writable during context-switching. When the return address stack becomes writable, it has a chance to be rewritten by attackers. Although this shortcoming occurs only with an extremely low probability, we will try to overcome it in the future. Furthermore, we also plan to extend our approach to protect more critical elements except return address because there are still many attack targets among stack smashing attacks such as previous frame pointer.

@&#ACKNOWLEDGMENT@&#

The work of Chien-Ming Chen was supported in part by the Project HIT.NSRIF.2014098 supported by the Natural Scientific Research Innovation Foundation in Harbin Institute of Technology, in part by Shenzhen Peacock Project, China, under Contract KQC201109020055A, and in part by Shenzhen Strategic Emerging Industries Program under Grant ZDSY20120613125016389. The work of Hung-Min Sun was supported in part by the National Science Council, Taiwan, ROC, under Grant NSC 101-2221-E-007-026-MY3. The corresponding author is Prof. Hung-Min Sun.

@&#REFERENCES@&#

