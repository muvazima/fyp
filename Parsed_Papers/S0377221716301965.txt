@&#MAIN-TITLE@&#Test-driven simulation modelling: A case study using agent-based maritime search-operation simulation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel technique for the verification and validation of simulation models.


                        
                        
                           
                           The technique explicitly embeds verification and validation to simulation modelling.


                        
                        
                           
                           The technique can be implemented using standard unit testing tools.


                        
                        
                           
                           The proposed technique is applied to agent-based maritime search-operation simulation.


                        
                        
                           
                           Validation is rarely discussed in agent-based maritime search simulation literature.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Agent-Based Simulation

Model validation

Maritime search operations

Repast

@&#ABSTRACT@&#


               
               
                  Model verification and validation (V&V) is one of the most important activities in simulation modelling. Model validation is especially challenging for Agent-Based Simulation (ABS). Techniques that can help to improve V&V in simulation modelling are needed. This paper proposes a V&V technique called Test-Driven Simulation Modelling (TDSM) which applies techniques from Test-Driven Development in software engineering to simulation modelling. The main principle in TDSM is that a unit test for a simulation model has to be specified before the simulation model is implemented. Hence, TDSM explicitly embeds V&V in simulation modelling. We use a case study in maritime search operations to demonstrate how TDSM can be used in practice. Maritime search operations (and search operations in general) are one of the classic applications of Operational Research (OR). Hence, we can use analytical models from the vast search theory literature for unit tests in TDSM. The results show that TDSM is a useful technique in the verification and validation of simulation models, especially ABS models. This paper also shows that ABS can offer an alternative modelling approach in the analysis of maritime search operations.
               
            

@&#INTRODUCTION@&#

Agent-Based Simulation (ABS) has become one of the commonly used tools to model and understand complex and nonlinear systems (North & Macal, 2007). ABS provides a controlled environment for systematic experimentation using a simulation model that is formed from a set of interacting agents. There is no consensus on the definition of an agent in the ABS literature (Macal & North, 2010). Instead, we have observed a spectrum of complexity in its definition. At one extreme, an ABS model is formed by a set of agents with a set of simple attributes (such as speed and detection range) and simple behaviours (such as move and rescue). At the other extreme, an ABS model can be composed of a set of agents with complex attributes (such as memory and bounded rationality) and complex abilities (such as planning and learning). However, most researchers agree that an agent is an autonomous entity (i.e. it makes independent decisions without any central control), has a set of objectives and interacts with other agents and its environment.

One of the most important activities in ABS is model validation. There are similarities between ABS and Discrete-Event Simulation (DES). Both are able to represent stochastic dynamic systems and can track individuals’ states throughout their lifecycles in the model. Hence, a number of validation techniques proposed for DES are also suitable for ABS, such as face validity, operational validity, white-box validation and black-box validation. Balci (1995), Kleijnen (1995) and Sargent (2013) provide a list of validation techniques in the context of stochastic dynamic simulation which are applicable to DES and ABS. All good simulation textbooks have at least one chapter that discusses validation techniques. Law (2014, Chap. 5) and Banks, Carson, Nelson, and Nicol (2010, Chap. 10) discuss various techniques, such as increasing the face validity of a model (e.g. by involving domain experts and model users), checking the validity of model assumptions, validating the components of a model, comparing the behaviour of a model with a real system (or something that can represent a real system if a system does not exist). Pidd (2004, pp. 233–246) divides validation techniques into white-box and black-box validation. White-box validation techniques aim to ensure that the internal working of a simulation model can be justified. Black-box validation techniques compare the output of a simulation model with the output of a benchmark (such as a real-world system similar to the system being modelled or an analytic model).

Despite the similarities, some researchers (e.g. Duong, 2010; Klugl, 2008; Ormerod & Rosewell, 2006; Windrum, Fagiolo, & Moneta, 2007) have noted that model validation in ABS is especially challenging and identified a number of common challenges. First, we often need to represent the behaviours of agents and the interactions between agents using a set of logical rules. It is challenging to extract this information from social and intelligent agents, such as people and organisations, especially if the agents do not want to be exposed (such as pirates or human traffickers). Furthermore, real-world agents are often heterogeneous. Hence, it is challenging to validate whether the rules used in an ABS model represent the rules used by most real-world agents and whether we have represented the heterogeneity of real-world agents correctly. Second, there is a need to validate ABS models at various levels (agent/micro level, system/macro level and intermediate/meso level). It is challenging to validate behaviour at the system level based solely on knowledge of the behaviours of individual agents. For example, Duong (2010) explains that emergence does not exist before a simulation is run (it might not even exist in the modeller's mind); hence, techniques such as structured walkthrough to analyse emergence from a model without running it would be virtually impossible. Even if we can generate traces during a simulation run, it is still a great challenge to explain how behaviour at a lower level can cause emergence at a higher level. Finally, an ABS model often requires high-fidelity data. Although the collection of high-fidelity data has become very common, qualitative behavioural data from heterogeneous agents in a population are rarely available. Hence, empirical validation may not be possible. The difficulty in validating an ABS model is reflected somewhat in the survey done by Heath, Hill, and Ciarallo (2009). They surveyed 279 research articles and found that only 35 per cent of the models were validated both conceptually (white box) and operationally (black box). Windrum et al. (2007) conduct an interesting discussion about the methodological issues surrounding the empirical validation of ABS. Hence, the challenge is not simply one of data availability, it is also methodological. Given these challenges, an automated tool that can help modellers to validate ABS models is useful.

The objective of this paper is to propose a technique called Test-Driven Simulation Modelling (TDSM) for the verification and validation (V&V) of an ABS model. TDSM's basic principle is that a test case for a simulation model has to be specified before the simulation model is implemented. Hence, the main advantage of TDSM is that the V&V process is explicitly embedded in the simulation-model development process. Modellers are forced to think about how their model is going to be verified and validated, even before they begin to develop it. The second advantage is that TDSM can be implemented using various unit-testing tools, or incorporated into a framework such as the one proposed by Gurcan, Dikenelli, and Bernon (2013), Niazzi, Hussain, and Kolberg (2009) and Thiele, Kurth, and Grimm (2014). To demonstrate how the proposed validation technique can be used in practice, we will show a few examples in which parts of the Agent-Based Simulation software called MASSIM (MAritime Search SIMulation) are verified and validated using TDSM.

The analysis of search operations is a classic part of Operational Research (OR) and has a long history commencing with military operations during the Second World War. Since then, the applications and tools have continued to be mostly nautical, e.g. military assets looking for enemy submarines or maritime pirates, coastguards conducting search-and-rescue (SAR) operations, and patrol boats protecting ports or high-value assets. Since a search operation requires considerable time and effort, it needs to be planned and conducted efficiently. A tool that can help to analyse the expected performance of a search-operation strategy is very useful. Tools that use ABS in the maritime search domain and sea-patrol operations are surprisingly scarce in comparison to other OR techniques, as confirmed by Davidsson, Henesey, Ramstedt, Törnquist, and Wernstedt (2005) and Vaněk, Jakob, Hrstka, and Pěchouček (2013). One of the main reasons is the difficulty in validating the ABS model. This is unfortunate because ABS has unique characteristics (such as the explicit specification of individuals’ behaviours and their interactions) which offer an alternative modelling approach. Hence, the findings from this paper can also contribute to the application of ABS in maritime-search operations modelling.

This paper is organised as follows. In Section 2, we review related work in TDSM and the application of ABS in maritime search operations. We explain our generic tool for maritime search operations, called MASSIM, in Section 3. Section 4 discusses how TDSM is used to validate a number of scenarios in MASSIM. Finally, we present our conclusions and recommendations for future work in Section 5.

@&#RELATED WORK@&#

The idea behind Test-Driven Simulation Modelling (TDSM) comes from Test-Driven Software Development, known simply as Test-Driven Development (TDD) in software engineering. There are a number of definitions and aliases for TDD (Janzen & Saiedian, 2005). However, the main principle is that a test case for computer code must be created before the computer code is developed (Beck, 2003). The test case is implemented as a unit test. Unit testing is a method in software engineering that is used to test an individual unit of computer code. The individual unit can be a function, a procedure or a class. Because the code does not exist when the unit test is created, the first test will always fail. A programmer will then refine the code until it passes the unit test. Subsequently, a new unit test is created and the process is repeated. At some point, the programmer may need to refactor the code. Refactoring changes the internal structure of the code without changing its observable behaviour (i.e. the code still carries out the same function that it did before). The objective of refactoring is to make the code more readable and easier to maintain. These steps are commonly known as Red-Green-Refactor, which signifies the cycle of creating unit tests that fail, writing code that passes tests and refactoring the code. TDD is a practice that is commonly used with other practices in a software development process.

TDD is suitable for a software development process that is iterative, incremental and evolutionary (Janzen & Saiedian, 2005). A development process is iterative when it involves the repetition of development tasks, usually with an incremental set of requirements. Each increment in the requirements results in a new software release. An evolutionary development process uses feedback from previous iterations to improve the software and guide future iterations. Simulation modelling is also an iterative, incremental and evolutionary process. Simulation modellers often revisit stages in a simulation modelling process (e.g. conceptual modelling, computer implementation) iteratively. In each iteration, specifications may be modified and new specifications may be added based on new information or feedback from relevant stakeholders. Hence, the simulation-modelling process is likely to benefit from TDD.


                        Collier and Ozik (2013) conducted the first exploratory study to investigate how TDD and unit testing could be used to verify an ABS model written in the Repast simulation library. They argued that by focusing on writing small unit tests, complex simulation code could be decomposed into smaller and more manageable components. Asta, Özcan, and Siebers (2014) followed the same approach and applied it to a Discrete-Event Simulation (DES) model written using AnyLogic. Unlike Repast, AnyLogic is a visual interactive modelling software. Hence, the unit-test code was not written directly as simulation source code. Instead, they wrote each unit test using a user-defined function in AnyLogic to verify a component in the model. Onggo, Indriany, and Gunal (2014) proposed TDSM as an approach for simulation-model verification and validation. TDSM can be applied to both DES and ABS. TDSM makes use of two unit-test suites, a verification suite and a validation suite. The verification suite contains a set of test cases to check the correctness of a simulation model against its conceptual model. Each test case represents one scenario that checks the correctness of the model. For example, one scenario may test the correctness of the distance travelled by a ship, i.e. at a given speed v and travel time t, the distance between the original location of a ship and its new one is vt. The validation suite contains a set of unit-test cases to check the validity of a simulation model. This is closely linked to black-box validation. Each test case represents a scenario that compares the output of a simulation model against what is expected. For example, in this paper, we use an analytical model to provide estimations of or bounds on certain simulation outputs. These numbers are then used in validation-suite tests. Similar to Collier and Ozik (2013) and Gurcan et al. (2013), Onggo et al. (2014) advocate the use of an automatic testing tool for ABS model verification and validation. However, they adopted a different approach. Instead of using TDD, they proposed a generic testing framework for ABS models. The framework was implemented in Java to work with Repast and JUnit. However, the authors acknowledge that the next step in their work would be to integrate their framework with TDD. Research into the possible application of TDD in simulation is relatively new. Hence, the number of articles published on this topic is low.

Existing applications of ABS for maritime search operations mainly focus on maritime patrol simulations to deter pirate attacks (Bruzzone, Massei, Madeo, Tarone, & Gunal, 2011; Dabrowski & De Villiers, 2015; Decraene, Anderson, & Low, 2010; Jakob, Vaněk, Urban, Benda, and Pěchouček 2010; Jakob, Vaněk, & Pechoucek,2011; Jakob, Vaněk, Hrstka, & Pěchouček, 2012; Marchione, Johnson, & Wilson, 2014; Tsilis, 2011; Vaněk, Bošanský, Jakob, and Pěchoucěk, 2010; Vaněk, Jakob, Hrstka, and Pěchouček, 2012; Vaněk et al., 2013; Varol & Gunal, 2015), port-protection simulation (Harris, Dixon, Dunn, & Romich, 2013; Leathrum, Mathew, & Mastaglio, 2009; Shieh et al., 2012), the simulation of traffic in ports and coastal waters (Hasegawa et al., 2004), combat simulation (Champagne, 2004; Champagne, Carl, & Hill, 2003; Cioppa, Lucas, & Sanchez, 2004; Decraene, Chandramohan, Low, & Choo, 2010, Hill, Champagne, and Price, 2004; Hill, Carl, & Champagne, 2006; Price, 2003; Xing, Wan, Zhu, Sanchez, & Kaymal, 2013), surface surveillance simulations (Steele, 2004) and force protection simulations (Akbori, 2004; Harney, 2003; Ng, 2007; Sullivan, 2006; Walton, Paulo, McCarthy, & Vaidyanathan, 2005). It is clear that most of the applications are for maritime security and military operations.

In maritime security applications, ABS is used to analyse strategies to protect merchant vessels from pirates. For example, Decraene, Anderson et al. (2010) proposed utilising ABS to investigate the requirements for defending a large commercial vessel against hijacking by pirates. In their piracy simulation model, the authors applied data farming to generate a range of simulation model variants and an Automated Red Teaming (ART) technique to reveal a commercial vessel's critical vulnerabilities to pirates. Jakob et al. (2010) developed a test bed which combines simulated vessel operation with real-world data on maritime activity. They used this test bed to prototype and evaluate agent-based methods for fighting maritime piracy. However, the authors do not explicitly state the techniques they used to V&V the model. In his study, Tsilis (2011) used ABS to model a group of merchant ships travelling under escort by a warship. Based on simulation results, he inferred that the success of a counter-piracy escort mission basically depends on parameters including the numbers and speeds of pirates and merchant ships and the position and detection range of the warship. Vaněk et al. (2010) modelled the problem of a mobile agent trying to cross an area patrolled by a mobile adversary as a two-player zero-sum game (termed transit game). They tested their model on a real-world case of ship transit through areas affected by piracy in the Gulf of Aden and validated and evaluated the effectiveness of the game-theoretic approach by employing an ABS of maritime traffic. Vaněk et al. (2012, 2013) developed an ABS model of maritime traffic that explicitly modelled pirate activities and piracy countermeasures in the Gulf of Aden. They used the model to analyse the design of a new transit-corridor system in the Indian Ocean. In another publication, they combined the ABS model with an optimisation model to investigate the counter-measure configurations that yielded the best trade-off between security and cost in maritime transportation (Jakob et al., 2012). Marchione et al. (2014) presented an ABS of dynamic patterns of maritime piracy in the Gulf of Aden to estimate the number of pirates and their area of action. Varol and Gunal (2015) proposed a hybrid DES and ABS model to simulate hypothetical scenarios in the Gulf of Aden to better understand the cause and effect relationship between naval resource allocation and piracy prevention. The typical agents used in maritime-transportation security applications are merchant vessels, navy vessels and pirate vessels. The software used by researchers includes AgentC (Jakob et al., 2011, 2012; Vaněk et al., 2010, 2013), PANOPEA (Bruzzone et al., 2011), MANA (Decraene, Anderson et al., 2010; Decraene, Chandramohan et al., 2010; Tsilis, 2011; Walton et al., 2005; Xing et al., 2013) and SharpSim (Varol & Gunal, 2015). PANOPEA uses DES but it has intelligent agent components embedded in the model.

There has been an increase in efforts to apply simulation to port protection and port traffic management since 9/11, for both training and planning purposes. For example, Advanced Disaster Management Simulator (ADMS) is a simulation tool developed to train port security personnel in how to respond to a terrorist attack on a seaport (McCard, 2015). Shieh et al. (2012), used simulation to analyse the robustness of PROTECT, a game-theoretic system deployed by the United States Coast Guard (USCG) in the port of Boston. The main objective is to quantify the uncertainty that might arise in the real world. Harris et al. (2013) used Automated Vulnerability Evaluation on Risks of Terrorism (AVERT) software to implement ABS for the effective utilisation of defensive security resources in US ports. They provided a quantitative basis for recommending various patrol patterns and defensive measures that could decrease risk and enhance deterrence strategies.

Military applications vary. Cioppa et al. (2004) noted that there was increasing interest in the use of ABS in the US Department of Defense. They highlight three examples of ABS military applications. One of these is the study of how unmanned surface vehicles could be used in force-protection missions. A simulation of the Bay of Biscay U-boat campaign has been reported several times (e.g. Champagne, 2004; Champagne et al., 2003; Hill et al., 2004; Hill et al., 2006). Champagne et al. (2003) studied the emergent behaviours of combatants and the effectiveness of search patterns during the campaign. Price (2003) and Hill et al. (2004) incorporated game theory into the behaviours of agents in the model. Champagne (2004) also proposed a statistical validation methodology based on re-sampling historical outcomes, which allows comparison between a simulation and historic operation. Using this methodology he showed that the Bay of Biscay ABS is a good representation of the real-world operation. The US Navy also utilised ABS for a Naval Simulation System which was developed to support network-centric fleet battle exercises (Metron 
                        Incorporated, 2015). DeStefano (2004) utilised ABS to create an executable model of a weapons system built in an agent-based combat model “System Effectiveness Analysis Simulation (SEAS)”. Decraene, Chandramohan et al. (2010) extended ART to broaden the range of evolvable simulation model parameters and considered a maritime anchorage protection scenario where individual trajectories of belligerent vessels are evolved to break Blue. To illustrate the potential benefits of a simulation screening procedure, Xing et al. (2013) applied it to maritime escort operations in the Strait of Gibraltar.

At the US Naval Postgraduate School (NPS), a series of studies have been conducted to model and simulate force protection operations. For example, Harney (2003) used ABS to develop a prototypical planning tool for Anti-Terrorism and Force Protection for Navy ships. Sullivan (2006) expanded Harney's (2003) work by including a capability for testing force protection measures in multiple scenarios. Akbori (2004) developed an Anti-Submarine Warfare (ASW) screen design simulation to aid ASW commanders in configuring an ASW screen. Walton et al. (2005) studied ways of preventing successful small-boat attacks against larger high-value commercial ships through the utilisation of ABS. As a case study, they analysed the protection of merchant ships transiting the Straits of Malacca and extend the results of their analysis to other ports and their local waterways. Ng (2007) presented models of asymmetric threats in maritime security and used ABS to provide complex adaptive behaviours for threats. In his thesis, Steele (2004) used ABS to explore alternative configurations of the prototype and operational uses of unmanned surface vehicles (USVs) for three scenarios: maritime interdiction, surveillance and reconnaissance, and force protection. He provided operational and tactical insights into how to use USVs in maritime missions.

Some of the models mentioned above were calibrated using real-world data. For example, trajectory data for vessels (from satellite or self-reporting systems) were used to calibrate the paths taken by vessels (Vaněk et al., 2013). Similarly, Marchione et al. (2014) and Dabrowski and De Villiers (2015) used empirical observations concerning the volume of vessels sailing through the Gulf of Aden. In the absence of data, Marchione et al. (2014) used a Genetic Algorithm (GA) to estimate parameters to calibrate some of the model variables. In the case of the Bay of Biscay U-boat campaign simulation, the authors used historical data from the war. However, the behaviour of hostile or non-cooperative agents such as pirate vessels is difficult to find, and in many cases unavailable. Hence, the calibration of such agents using empirical data is limited. Researchers can use an analytical approach to model the behaviour of such agents so that the behaviour shown by the simulation model should match the underlying analytical model. However, consistent with the findings of Heath et al. (2009), model validation is hardly discussed in the literature. Validation has mainly been done using a qualitative approach, such as face validity and an expert's opinion (e.g. DeStefano, 2004; Vaněk et al., 2013; Varol & Gunal, 2015). Hence, it is clear that more research is needed on the validation of agent-based maritime search-operation models.

This section explains MASSIM, a generic ABS tool for maritime search operations that we have developed using Repast (North et al., 2013). First, we will explain how we abstract maritime search operations in MASSIM. This is followed by a detailed description of the model's structure and parameters.


                        Fig. 1
                         shows the classification of a maritime search-operation problem. Each box represents an alternative for its associated search problem element. Current version of MASSIM supports the features indicated with solid arrows. Dashed arrows indicate the features MASSIM does not support yet, e.g. currently MASSIM cannot handle a search operation in an expanding area conducted with probabilistic sensors.

From an ABS perspective, all search problems have two agents in common: a target (in a broad sense, something being searched for), and a searcher (Nunn, 1981). An operation can be classified as a two-sided problem when both target(s) and searcher(s) are active and behave in an intelligent way or a one-sided problem when either target(s) or searcher(s) is active and intelligent. The level of intelligence can be as simple as conducting a specific search pattern or as complex as learning from past experience. The agents can be stationary or moving. The search efforts in a discrete search operation are made at a number of discrete locations (e.g. a helicopter dips sonar at a location, pulls it and then flies to another location, and repeats the process for a number of discrete locations). In a continuous search operation, search efforts are carried out continuously along a certain path (e.g. a search conducted by a ship that carries hull-mounted sonar as it moves from one location to another). A logical extension of area-search problems involves searching an expanding area, as studied by Coggins (1971) and Washburn (1980). As opposed to searching a fixed area, in an expanding area search problem, the area where the target is likely to expand over time. One such example is the Flaming Datum Problem (FDP) defined by Washburn and Hohzaki (2001). FDP deals with relocating an enemy submarine that is fleeing after momentarily revealing its position. The detection function used during an operation is called definite range (also known as a “cookie cutter”) when a target is detected whenever it is within detection range. In a probabilistic detection function (such as polynomial, exponential and cubic attenuation models), the detection probability is a function of the distance between searcher and target. The analysis of a search operation can consider a single-searcher strategy or a multiple-searchers strategy. The main objective is to analyse the effectiveness of a search strategy in a number of scenarios. Multiple-searcher operations are especially useful in the analysis of the effectiveness of a collaborative search strategy where a large area of interest is divided into sectors or sub-responsibility areas for each searcher. Finally, we can evaluate various search algorithms that can be used in a search operation, such as exhaustive search, random search and specific patterns (e.g. parallel search, expanding square search).

MASSIM has been designed to support the analysis of a number of search operation settings, as shown in Fig. 1. At the time of writing, MASSIM can support one- or two-sided problems, stationary/moving agents, discrete/continuous search efforts, fixed-area search problems, a definite-range detection model, single/multiple searchers and a number of search patterns including random search and exhaustive search. The ABS model in MASSIM is formed by two agent types: searcher and target. A searcher's main objective is to detect a target. The key properties of a searcher are:

                           
                              •
                              Search strategy: This defines the movement algorithm for the searcher;

Current location: This defines the location of the searcher;

Search area: This defines the location and size of the searcher's search area;

Speed: This defines the speed of the searcher;

Detection: This defines the searcher's detection model and detection range;

Performance statistics: These are used to collect performance statistics of the searcher.

The flowchart that represents the behaviour of a searcher is shown in Fig. 2
                        . The simulation time is advanced using fixed increments (Δt). In each step, the flowchart is executed. First, the searcher will move to a new location depending on the search strategy, speed and Δt. Next, the searcher will see if there is any target within its detection range. This is done by checking all target objects within its detection radius, and depending on the detection model a target may be flagged as non-active (i.e. has been detected). A flag is needed to avoid the double counting of performance statistics (an alternative would be to remove the detected target from the simulation). When a target is detected, counters, such as the number of targets detected, are updated. Finally, performance statistics, such as the total number of targets detected and the total number of successful search efforts, are updated.

Based on its behaviour, a moving target can be classified into one of three groups: a cooperative target that wishes to be detected by a searcher (e.g. the victims in a SAR operation), a non-cooperative or evading target that wishes to hide or escape from the searcher (e.g. a refugee trying to reach his/her destination without being detected by the coastguard), and a non-cooperative target that wishes to be as close as possible to a searcher without being detected (e.g. a hostile submarine trying to approach surface ships within its effective torpedo range). The key properties of a target are:

                           
                              •
                              Movement strategy: This defines the movement algorithm for the target;

Current location: This defines the location of the target;

Search area: This is an artefact that is needed to count the frequency and measure the time that the target spends inside a search area;

Speed: This defines the speed of the target;

Counter-detection: This defines the target's counter-detection model and counter-detection range;

Statistics: These are used to collect statistics related to the target.

The behaviour of a target is shown in Fig. 3
                        . First, if the target has not been detected (i.e. active) and its objective has not been met (e.g. for a refugee boat whether it has reached a coastal area, for a victim in an accident whether she/he has been detected by a rescue boat), the target will move to a new location depending on the movement strategy, speed and Δt. The movement strategy depends on the behavioural category of the target, as mentioned earlier. Next, the target will check if its objective is met. In this case, a flag is set to exclude the target from the simulation. Regardless whether the objective has been met or not, related counters and statistics are updated (e.g. the duration until the objective is met, the frequency and time that the target spends inside a search area).

The interaction between a searcher and a target happens when the target is within the searcher's detection range. The frequency of interactions depends on the number of agents, the agents’ movement strategies and whether the target is cooperative or non-cooperative (either evading or approaching).


                        Fig. 4
                         is a screenshot of MASSIM for a single-searcher operation. In MASSIM each region is modelled as a 2-dimensional plane. All targets lie somewhere in the region of area A and refer to it as the total area (shown as the large grey square in Fig. 4). For each searcher, we define a search area A′ as a sub-region of A (shown as the white square inside the grey square in Fig. 4). The searcher and target are denoted by a triangle and a disk, respectively. The detection region of a searcher is denoted by a circle around it. When a definite range sensor is used, a target that lies inside the sensing zone will be detected. In Fig. 4, we show one searcher and 100 targets. Two of the targets are within the searcher's detection region.

The simulation parameters can be controlled from the panel on the left in Fig. 4. The parameters, their types and possible ranges are summarised in Table 1
                        . The first two parameters are the number of time steps and the duration per time step (in minutes), respectively. For a continuous search operation, a shorter time-step duration leads to a more accurate result. This is because the locations of the agents are updated in every time step. The third parameter defines the total area, A, in nautical miles squared. The area is assumed to be a square to make the simulation visualisation easier. The fourth parameter is used to specify the number of equal-size search areas. If we are interested in single-search-area operations, we can specify the size of the search area (parameter 5). Parameter 6 allows us to specify the number of searchers per search area. Hence, the combination of parameters 4 and 6 allows us to analyse single-searcher single-area operations, multiple-searchers single-area operations or multiple-searchers multiple-areas operations. A searcher has a number of attributes (parameters 7–11): speed in knots, detection function type (at the moment, it only supports definite range detection function, but it will be extended to include probabilistic functions such as polynomial, exponential and cubic), detection range in nautical miles, search strategy (such as random search, exhaustive search or parallel search), and whether the searcher has the ability to learn. Parameter 12 controls the number of targets in the total area. Each target has the same number of attributes as a searcher (parameters 13–17): speed in knots, detection function, detection range, movement strategy (such as stationary or random walk) and whether it has the ability to learn. Parameter 18 is the distance between each track in a parallel/creeping/square search in nm.

The main principle in TDSM is that the V&V of a simulation model must be specified before the simulation model is implemented. This practice explicitly integrates V&V into the simulation modelling process by forcing modellers to think about V&V before model development starts and to use V&V cases to guide the model development process.

A flowchart for the simulation modelling process with TDSM is shown in Fig. 5
                     . The TDSM stages are highlighted in grey. The simulation modelling process starts with the commonly adopted stages of problem structuring, conceptual modelling and input modelling. These stages are followed by the TDSM stage.

In the first part of the TDSM stage, model development is guided by verification cases. The objective of model verification in simulation modelling is to ensure that a conceptual model has been implemented correctly in a simulation model. A model is verified using a number of verification cases. In TDSM, each verification case is implemented as a unit test. Each unit test compares the behaviour of the simulation model against the conceptual model (closely related to white-box testing in software engineering). First, it is necessary to specify verification cases (ideally, in close collaboration with model users and/or domain experts). Afterwards, each verification case is translated into a unit test. The unit tests form a verification suite. Starting with the first unit test in the verification suite, the model is then incrementally developed until it passes the unit test. When the model passes the test, we move on to the second unit test in the verification suite. This process is repeated until the model passes all unit tests in the verification suite.

Once verification is complete, we then use the same principles for validation. The objective of model validation is to make sure that a simulation model is fit for its purpose. As in model verification, a model is validated using a number of validation cases and each validation case is implemented as a unit test. Each unit test checks the validity of a simulation model by comparing its output to the expected behaviour in the real world (using empirical data or an analytical model or theory if empirical data are not available). Hence, this technique can be applied to both data-driven models and theory-driven models. This comparison is closely linked to black-box testing. It should be noted that model validation often includes sensitivity analysis that explores the behaviour of the model under various combinations of parameter values (within acceptable ranges) as discussed in Thiele et al. (2014). In this case, a validation case tests the behaviour of the model under a specific combination of parameter values. Hence, the number of validation cases grows exponentially with the number of parameters. For this reason, in addition to better exploration algorithms, Thiele et al. (2014) highlight the importance of an automated tool (such as our tool) for model validation. As shown in Fig. 5, we start with the specification of validation cases in close collaboration with model users (and/or domain experts). This is followed by implementing validation cases as unit tests which will be grouped as a validation suite. The model will then be developed incrementally until it passes all unit tests in the validation suite. At this stage the model has been completely validated against the verification and validation cases. At some points during the iteration, it may be necessary to refactor the model to make it more structured, modular and easier to maintain. If there are no new requirements raised by the model users, the model is ready for output analysis and experiments. Otherwise, the process will be repeated. Subsequent activities follow the usual simulation modelling practice.

In cases where the simulation model is likely to be used and modified in the future, the unit tests should not be discarded after the model has been verified and validated. This is because the unit tests can be used to detect if any of the alterations or additions to the model break the existing unit tests as long as the unit tests remain relevant. For example, Fig. 6
                      shows that our model has passed four validation cases, as indicated by the check signs. When we extend or modify the model, we need to make sure that we do not break any of these cases. Of course, if a new requirement makes a unit test no longer relevant, the unit test should be removed from the verification and validation suites.

Each unit test is essentially carrying out a comparison. During verification, we can compare the behaviour of the model with what is expected based on the conceptual model. To take an example from MASSIM, a searcher moves at speed v to the north from its current location (sx, sy
                     ). After time period Δt, the new location of the searcher will be (
                        
                           
                              s
                              x
                           
                           ,
                           
                              s
                              y
                           
                           +
                           v
                           Δ
                           t
                        
                     ). This scenario can be implemented in a verification case. Detailed examples of how a unit test can be used to verify models in different contexts are discussed in Asta et al. (2014), Collier and Ozik (2013) and Onggo et al. (2014). Hence, we will not repeat these detailed implementations in this paper. During validation, the behaviour and output of the simulation model can be compared to the expected output. The expected output can be obtained from empirical data or analytic/theoretical models. In this paper, we validate our ABS model by comparing it with solutions based on analytic models from the search-theory literature. The use of analytic models is useful when empirical validation using complete real data sets is virtually impossible (e.g. we may know the locations and numbers of refugee boats detected annually but not the numbers of undetected refugee boats that manage to land in a protected coastal region).

In this section, we will give four examples of validation cases. The first two cases are based on two hypothetical search strategies commonly used to provide bounds for the performance of a real-world search strategy. The first validation case is used to compare the performance of an exhaustive search between the simulation model and the analytical model. In the second case, we repeat the same case but for a random search. The remaining cases demonstrate how we validate a real-world search strategy. In the third validation case, we validate a real-world search called a parallel search against the lower and upper bounds obtained from analytical models. In the cases mentioned above we assume that the target is stationary and equally likely to be anywhere in the search area. This is a one-sided search which incurs simpler interactions between a searcher and targets. In the fourth case we model the random search of a mobile target which seeks to approach the searcher. In this case, the search is two-sided. Both the searcher and targets try to approach each other (more complex interactions than the other three scenarios). We will give more details about each case in Sections 4.1–4.4.

To make the explanation easier, all cases in this paper are based on a single-searcher operation and a “definite range” detection model. In the definite-range detection model, detection occurs when the distance between target and searcher is less than the fixed detection range r. The total area and search area are squares with sides 
                        
                           A
                        
                      and 
                        
                           
                              A
                              ′
                           
                        
                     , respectively, and A′≤
                     A. The initial position of a target is assumed to be uniformly distributed over A. All simulation results are based on 20 replications.

For a given searcher speed v, detection range r and sweep width w
                        =2r, with a duration of Δt, a searcher can cover an area of wvΔt (we refer to this area as the covered area). An exhaustive search assumes that there is no overlap of one covered area with another, and that no segment of a covered area is placed outside the search area A′. The area A′ will then be completely searched and the target will be detected with probability 1 in time A′/(vw). Hence, an exhaustive search can be thought of as carefully placing a number of non-overlapping covered areas inside A′, as shown in Fig. 7
                         (left) (see the confetti analogy in Washburn (2002) p. 22). Since the requirement of path continuity in any real-world continuous search case would force gaps and overlaps among covered areas, an exhaustive search should be thought of as an upper bound on the search performance (Washburn, 2002).

The detection probability of a stationary target depends on the total area covered, which is a linear function of time. Once the search area is completely covered, the detection probability reaches 1 and remains constant. Let S be the event that the target is in search area A′ and D be the event that the target is detected. Then, the probability of detecting a stationary target by time t, given that the target is located inside A′ can be written as (Washburn, 2002):

                           
                              (1)
                              
                                 
                                    
                                       P
                                       t
                                       exhaustive
                                    
                                    
                                       (
                                       
                                          D
                                          |
                                          S
                                       
                                       )
                                    
                                    =
                                    min
                                    
                                       {
                                       
                                          
                                             
                                                w
                                                v
                                                t
                                             
                                             
                                                A
                                                ′
                                             
                                          
                                          ,
                                          1
                                       
                                       }
                                    
                                 
                              
                           
                        
                     


                        Fig. 8
                         (the top two curves) shows the performance of an exhaustive search, over time, obtained from the simulation model and the analytic model (Eq. (1)), where A′ = 2,304 nautical miles squared, v = 20 knots, 
                           
                              Δ
                              t
                              =
                              
                              6
                           
                         minutes and w = 8nautical miles. The figure shows a good match between the output of the simulation model and the analytical model. We used Eq. (1) in our unit test to validate the exhaustive search implementation in our model. For example, with the above settings, we expect that P(D|S) will reach 1 after searching for 864minutes (i.e. 144 time steps). Our model passes this test, as shown in Fig. 6 (validateExhausticMaxPerformance case) and Fig. 8 (the probability at 864minutes is close to 1).

The unit test to represent this validation case is shown in Fig. 9
                        . The flowchart is given on the left and the detailed unit test code is given on the right. First, the simulation is initialised (lines 3–5). Next, the simulation is run for 144 steps. This is done by obtaining the schedule from the simulation model which allows us to execute the model in step mode (lines 06–07). This is followed by obtaining P(D|S) from the simulation. To implement this, we introduce agent observer that calculates all system-level statistics. Lines 08-11 find the agent observer from the list of agents in the model. When the agent is found, we can retrieve P(D|S) (lines 12–14). Finally, we test if P(D|S) is close to 1 (line 17). This scenario shows an example of one of the most commonly used validation techniques, in which an analytic result provides an output that is expected from the simulation.

Unlike an exhaustive search, a random search places the covered areas randomly inside the search area. The size of a covered area is the same as in an exhaustive search, i.e. wvΔt. Random placement results in wasted effort because some coverage areas may overlap and some may also cover an area outside the search area (see Fig. 7 (right)). Hence, it performs worse than an exhaustive search and provides a lower bound on the performance of any sensible search strategy (Washburn, 2002). The probability of detecting a stationary target by time t, given that the target is present inside the search area, is shown in Eq. (2). The proof can be found in Koopman (1946).

                           
                              (2)
                              
                                 
                                    
                                       P
                                       t
                                       random
                                    
                                    
                                       (
                                       
                                          D
                                          |
                                          S
                                       
                                       )
                                    
                                    =
                                    1
                                    −
                                    
                                       e
                                       
                                          −
                                          
                                             
                                                w
                                                v
                                                t
                                             
                                             
                                                A
                                                ′
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The performance (P(D|S)) of a discrete random search over time is shown in Fig. 8 (using the same parameters as in the exhaustive search). The output of the simulation model matches the output of the analytical model. Eq. (2) was used in our unit test to validate the implementation of a discrete random search in our model. For example, we can check whether at time 2298minutes (i.e. 383 time steps), the analytical result (i.e. 0.93) is within the 95 per cent confidence interval of the simulation result. The simulation model passes the test as shown in the validateRandomAtTime2298 case in Fig. 6.
                     


                        Fig. 10
                         shows the flowchart and the detailed code that implement this validation case. First, the counters used to calculate the confidence interval are initialised (lines 3–5). Next, we run the simulation a number of times (lines 6–23) so that we can collect the statistics needed for the confidence interval. In each iteration, the simulation is initialised (lines 7–9). Line 8 shows how we can control the random number stream in each simulation run. Next, the simulation is run for 383 steps (lines 10–11). This is followed by obtaining P(D|S) from the simulation (lines 12–17) and collecting statistics that will be needed later (lines 18 and 19). After we have run all simulation replications, we can form a confidence interval around the mean P(D|S) (lines 24 and 25). Finally, we test if the analytical result is within the 95 per cent confidence interval (line 26). This scenario shows an example of one of the most commonly used validation techniques, in which a confidence interval is built around a simulation result and we test if the analytic result is within the confidence interval.

A parallel search is a real-world continuous search strategy that is frequently employed. The search is conducted by moving along parallel tracks with a separation distance of G
                        =
                        w, as shown in Fig. 11
                         (left). For AS
                        
                        =2,304nautical miles squared, vS
                        
                        =20knots, 
                           
                              Δ
                              t
                              =
                              
                              6
                           
                         minutes and w
                        =8nautical miles, the performance of a parallel search with G
                        =
                        w
                        =8 is shown in Fig. 11 (right). If we stop the simulation at time 864minutes (i.e. the time when an exhaustive search reaches its maximum performance), we can see that the performance of the parallel search is bounded by the performance of the exhaustive search (upper bound) and the random search (lower bound). Since the performance of any sensible real-world search is bounded by the exhaustive search and the random search, we can use this in our unit test to validate the performance of any sensible real-world search, as shown in the unit test below (0.632 and 1.0 are the performance of a discrete random search and a parallel search at time 864minutes or 144 time steps, obtained using analytical models, respectively). Note that the unit test below assumes that the targets are stationary so that we can use the performance bounds given by Eqs. (2) and (3).

The unit test to represent this validation case is shown in Fig. 12
                        . It follows a similar algorithm to the one in Fig. 9, except for the test condition at the end (line 17). This scenario shows an example of one of the most commonly used validation techniques, in which analytic results provide an upper bound and a lower bound on the simulation result. The model passes this test as shown in the validateParallelPerformanceBounds case in Fig. 6.
                     

This scenario represents a more realistic target behaviour. In this scenario, the searcher with detection range r and speed v is searching for a target with counter-detection range k and speed u. We assume that r is less than k since otherwise the target will be detected before he has a chance to react to the searcher. We also assume that u is less than v so that the searcher has a speed advantage. We further assume that the target desires to approach the searcher, i.e. when the searcher falls inside the target's counter-detection range the target moves towards the searcher. This may be because the target might be a victim who hopes to be rescued by the searcher (a search and rescue boat) or an enemy submarine that wishes to attack the searcher (an anti-submarine warfare frigate).


                        Washburn (2002) provides an equivalent sweep width (we
                        ), for the searcher in the above scenario, except that the searcher's direction of travel (its course) is fixed throughout the engagement and known to the target. Assuming dimensionless ratios α
                        =
                        u/v and β
                        =
                        r/k, we
                         is derived as follows:

                           
                              (3)
                              
                                 
                                    
                                       w
                                       e
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   2
                                                   k
                                                   
                                                   s
                                                   i
                                                   n
                                                   
                                                      (
                                                      ψ
                                                      )
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            α
                                                            2
                                                         
                                                         +
                                                         
                                                            β
                                                            2
                                                         
                                                      
                                                   
                                                   ≤
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   2
                                                   k
                                                   ,
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            α
                                                            2
                                                         
                                                         +
                                                         
                                                            β
                                                            2
                                                         
                                                      
                                                   
                                                   >
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ψ
                        =arcsin(α)+arcsin(β). Since in our case the target is also moving at speed u, we can extend the result in Eq. (2) by substituting searcher speed v with the average value of searcher-target relative speed 
                           
                              
                                 v
                                 ¯
                              
                              =
                              
                                 
                                    
                                       v
                                       2
                                    
                                    +
                                    
                                       u
                                       2
                                    
                                    −
                                    2
                                    u
                                    v
                                    cos
                                    θ
                                 
                              
                           
                        , where θ is the angle between the velocity vectors (Washburn, 2002). Then the equivalent average speed for the searcher is:

                           
                              (4)
                              
                                 
                                    
                                       v
                                       ¯
                                    
                                    ≡
                                    
                                       1
                                       
                                          2
                                          π
                                       
                                    
                                    
                                       ∫
                                       0
                                       
                                          2
                                          π
                                       
                                    
                                    
                                       
                                          
                                             v
                                             2
                                          
                                          +
                                          
                                             u
                                             2
                                          
                                          −
                                          2
                                          u
                                          v
                                          cos
                                          θ
                                       
                                    
                                    d
                                    θ
                                 
                              
                           
                        
                     

The integral in (4) cannot be evaluated explicitly, therefore it must be computed numerically. The detection probability of a randomly moving target that desires to approach a randomly moving searcher can be computed by substituting w with we
                        , and v with the relative speed 
                           
                              v
                              ¯
                           
                         in Eq. (2).

                           
                              (5)
                              
                                 
                                    
                                       P
                                       t
                                       approach
                                    
                                    
                                       (
                                       
                                          D
                                          |
                                          S
                                       
                                       )
                                    
                                    =
                                    1
                                    −
                                    
                                       e
                                       
                                          −
                                          
                                             
                                                
                                                   w
                                                   e
                                                
                                                
                                                   v
                                                   ¯
                                                
                                                t
                                             
                                             
                                                A
                                                ′
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Note that analytical model in Eq. (5) is optimistic compared to our simulation scenario. The analytical model assumes that the target can predict the searcher's motion well enough to adopt an intercept, rather than a pursuit, course. Thus the analytical model provides an upper bound for our simulation results. For this validation case, we set A
                        =
                        A′=10,000nautical miles squared, v
                        =10knots, u
                        =4knots, r
                        =3nautical miles and k
                        =9nautical miles. The result is shown in Fig. 13
                         (left). This confirms that the analytical result provides an upper bound to the simulation result. It also shows that the analytical model is significantly more optimistic. Hence, we have also added a validation to the root mean square distance travelled by the searcher in which, analytically, the value is close to 
                           
                              N
                           
                         where N is the number of time steps. Fig. 13 (right) shows that the results from the simulation model match the analytical solution.

The flowchart and unit test code that implement this validation case is shown in Fig. 14
                        . This scenario shows a different validation technique than in the previous three scenarios in which the simulation result is validated in each time step during a simulation run. This is a tedious process if done manually. Hence, this example underlines one of the advantages of using an automatic validation tool. As in the previous examples, the first steps are the initialisation of the counters and model (lines 3–14). Next, we find object observer to collect P(D|S) from the simulation (lines 15–22). The simulation is run for 400 time steps (lines 23 and 24). Lines 25–32 test whether the simulation result is less than the upper bound set by the analytical solution. The model passes this test as shown in the validateRandomMovingTargets case in Fig. 6.
                     

@&#CONCLUSION@&#

We have presented a new technique called Test-Driven Simulation Modelling (TDSM). TDSM has a number of benefits. First, it promotes the explicit integration of model verification and validation into the simulation modelling process. Secondly, the cost of finding a mistake early is considerably lower than the cost of detecting, identifying and correcting the mistake later. Finally, for validation, TDSM fits nicely with the black-box validation method in which the output of a simulation model is compared to the output of a benchmark (either from empirical data or an analytical/theoretical model). The output of an analytical model has been shown to be useful when it is virtually impossible to validate a simulation model against empirical data. We can use analytic models to calculate the performance of simple search strategies. Hence, strictly speaking a simulation model is not needed for the analysis of simple search strategies. However, for a more complex search strategy where an analytic model becomes intractable, we need a simulation model. An analytic model is still useful in the analysis of a more complex simulation model because it can provide us with bounds on performance and helps us with the validation process by making sure that any additional details that increase the complexity of the model do not break existing validation cases. This is shown in the case study using MASSIM in which simpler and more complex search operation cases share the same software components. When a more complex search operation case is added and does not break existing validation cases, our confidence in the correctness of the more complex case increases. There is no guarantee that there will be no mistakes in the more complex case, but at least if there is a mistake, it will be contained within the method/module that implements the more complex case. Kleijnen (1995) has argued that when a modeller develops a complex simulation model, s/he should validate the model by running a simplified version of the model that has a known analytical solution. In other words, the modeller should be guided by the knowledge of relevant analytic models that are simpler and have known solutions when they are building a complex model. This paper has shown how this principle is integrated with TDSM.

We have also discussed how ABS can be useful in the analysis of maritime search operations. The application of ABS in maritime search operations is lacking, partly due to the difficulty in validation of an ABS model. Hence, the technique proposed in this paper could help the adoption of ABS as one of the analytical tools in this domain.

There are many challenges in the implementation of TDSM which require further research. First, we need to find out if TDSM could lead to a better model. This is similar to software engineering research that discusses whether TDD could lead to better software, which is inconclusive (Janzen & Saiedian, 2005). However, anecdotal evidence based on the incorporation of unit testing in major software development tools (such as JUnit in Eclipse/Java, Visual Studio and NUnit) suggests that TDD may be used by many software developers. Secondly, model verification and validation is a combinatorial problem in which every model requirement often needs a number of verification and validation cases. Hence, it is very expensive to cover all possible mistakes during the model development process. More research is needed to find an optimum strategy for TDSM that balances test coverage and cost. Techniques such as Latin Hypercube described in Thiele et al. (2014) can be used to address this problem. Thirdly, a unit test can contain mistakes too. Hence, tools that can help minimise mistakes in unit test are also needed. Finally, the proposed TDSM is appropriate when we can compare the simulation result against the expected behaviour. The expected behaviour can be obtained from empirical data or analytic/theoretical models. ABS models often deal with heterogeneous agents in which collecting empirical data collection and finding an analytical result that can be used for TDSM are challenging. More research are needed to investigate how TDSM can be useful in this situation. One possible approach is to simplify the models until TDSM can be used. This is consistent with the argument made by Kleijnen (1995) as discussed earlier.

@&#REFERENCES@&#

