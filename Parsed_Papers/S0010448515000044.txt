@&#MAIN-TITLE@&#Multiple views system to support awareness for cooperative design

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We devise a cooperative awareness model to describe cooperative awareness information in product design.


                        
                        
                           
                           We propose concept of awareness intensity and an object-oriented method to identify and filter overloaded cooperative awareness model.


                        
                        
                           
                           A mechanism which responds to changes of lean cooperative awareness information is proposed to plan and execute task in product design.


                        
                        
                           
                           A navigation net managed by a multiple views system is proposed to browser lean cooperative awareness information set.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multiple view

Cooperation awareness

Cooperative design

Information overload

@&#ABSTRACT@&#


               
               
                  It is acknowledged that multiple views technology improves designer’s work efficiency by filtering redundant information. However, the increased need of cooperative activities in product design process requires views incorporating Cooperative awareness information (CAI), content of which should be lean for understanding and sortable according to importance. To achieve this target, this paper proposes an Object-based cooperative awareness model (OBCWM) and corresponding multiple views system. Requirements of CAI in product design are firstly analyzed. Then OBCWM is proposed, which consists of a CPM (Core product model) based concept framework. By use of CPM, an algorithm to calculate awareness intensity is developed based on object-oriented method. To support the mechanism of OBCWM, a multiple views system is then designed with “flexible view”, content of which is adjustable according to awareness intensity between CAI objects. After introduction to the system, application on a case is presented, followed by the evaluation of this system.
               
            

@&#INTRODUCTION@&#

To perform a cooperative design task, designers need to know situation information of cooperative environment and other designers involved as basis of decision making  [1]. In the domain of Computer Supported Cooperative Work (CSCW), the situation information is called Cooperative awareness information (CAI). CAI plays a significant role in concurrent engineering  [2,3] and favors efficient cooperation of professionals from different disciplines. An efficient cooperative design system has two basic requirements:

(1) Define CAI. Namely, the system shall first define CAI according to designers’ requirements.

(2) Filter overloaded CAI. It shall provide accurate CAI to designers by filtering overload CAI. With sharp increase of product complexity, designers need to interact with lots of CAI sourced from mass cooperative activities in the same cooperative environment. This explains the generation of information overload. Information overload makes it hard to provide accurate information for designers and their attention will be badly distracted. To avoid negative influence of CAI overload, an improved CAI support system is needed to provide designers with a lean CAI set.

To meet the two requirements of cooperative design system, this paper propose an object-oriented Cooperative awareness Model and a multiple views system based on this model.

Innovations of this paper are as follows:

(1) This paper proposes an object-oriented Cooperative awareness model (CWM) and algorithms to describe design task and awareness information, and hereby calculate the lean CAI set for a specific task.

(2) This paper proposes a concept of “flexible view” to acquire CAI according to awareness intensity between the CAI and design task.

This paper is organized as follows: Some related works with regard to overload CAI filtering and CAI definition are briefly introduced in Section  2. In Section  3, we address detail information of Object-based CWM (OBCWM), include awareness requirements of CWM, foundation, framework and mechanism of OBCWM. Section  4 introduces multiple views system based on OBCWM, followed by a case study in Section  5 to exemplify the application of this model and system. Evaluation of the system is presented in Section  6 before we reach the final conclusion.

@&#RELATED WORKS@&#

Generally, there are three resolutions to filter overload information  [4]:

(1) Improving designer’s information-processing skills by training;

(2) Assure high quality of CAI by visualization, compressed and aggregated method, such as Information Architecture  [5,6];

(3) Pre-processing and filtering CAI through information tools.

Since this paper focuses on developing an information system, which should be classified into the third resolution, we will only introduce related works of information tools which include Information Recommender System, Information Logistics System and Multiple Views System.


                        Information Recommender (IR) System. This system defines relationship between information and user by data analysis method. It uses information clustering (clustering analysis) method to quantify relationship between target data. It infers information demands of users by analyzing the user’s profiles and history information interactions. Then the system matches user’s information needs with information topics to help user acquire the lean CAI set  [7,8].

In cooperative design environments, designer’s information demands will be affected by his/her role and task attributes. Thus Zhen et al.  [9,10] proposed an information recommender system based on workflow which introduced factor of task relationships derived from workflow into its algorithm. Referral information is changed according to busy degree of designer. Kim and Lee  [11] proposed a method analyzing user profile in workflow and information flow of cooperative work to provide more accurate CAI. In addition, context information is analyzed to improve accuracy of referral CAI.


                        Information Logistics (IL) System. The goal of information logistics is to enable the effective and efficient delivery of needed information in the right format, granularity and quality, at the right place, at the right point in time to the right actors  [12]. This system uses method of“user-demand Information-supply”  [13] and Semantic technology to map information to information demands. Michelberger proposed Process-Oriented Information Logistic (POIL) and an information push system which combines information-, context-, and process-awareness. With this system, process participants do not have to actively search for relevant process information anymore, but are automatically supplied with needed process information—even if their work context is dynamically changing  [14].


                        Multiple Views (MV) System. This system uses two or more distinct views to support the investigation of a single object from different perspectives or levels of detail  [15]. In information system of manufacturing enterprises, multiple views system creates mapping relationship between user’s information needs and permission  [16–19] according to a specific access control model, and hereby determines contents of views for different users. This system not only satisfies information safety  [20] and sharing needs of enterprises, but also plays a significant role in human recognition. It relieves distraction  [17] and information anxiety  [21] caused by overload CAI and provides design workspaces for digital product designers.

Two types of solution taken by above studies can be concluded: In IL and MV, main idea is to make accurate definition of relationships between target information and users. In IR, main idea is to calculate relevance of information set in specific dimension, which is approximate to user’s requirements.

CWM provides efficient mechanism to collect, describe, publish and display CAI  [22]. As the core of CSCW  [23], CWM determines the content and supportive method of awareness.

Typical existing CWMs include spatial model  [24], workspace awareness model  [25] and role-based model  [26]. The spatial awareness model proposed by Benford abstracts relationships between objects, and defines awareness as interaction of objects through specific media. Workspace awareness model proposed by Gutwin combs the awareness needs of users during the process of cooperative design. Role-based awareness model  [26] defines task, role, object and their relationship, and then defines awareness intensity between the roles. Actually, as application of ubiquitous devices gradually matures, more awareness model theories have emerged  [27].

The spatial model  [24] is proposed for virtual environment. It depicts awareness between different “objects” in a common spatial environment. But the range of “object” is too large to apply to detailed product information.

Based on workspace model, Gutwin proposed his groupware [25]. It is more suitable for communication and execution than cooperation planning.

The space model and workspace model mainly focus on human’s activities perceived by collaborators.

The role-based model  [26] consists of relationship between task, role, object, activity and the user, and explains cooperation design from the view of organization. It is suitable to depict the assignment in cooperative design. However, the concept of “object” is still too simple to explain complex information corresponding to product information model.

To catch CAI in collaborative design, Farouk et al.  [28] proposed a situation model, which covered CAI of technical and organizational activities at three organizational levels. As shown in Table 1
                        , Farouk synthesized three types of awareness requirements in design tasks and the key questions that could help in the specification of a good awareness supportive system. However, the situation model “cannot be used directly by the collaborators”.

In conclusion, existing awareness models mainly depict relationship between different subjects qualitatively, while information overload is rarely discussed. Besides, objects of awareness are hardly mentioned in models except the situation model. Therefore it is hard for designers to acquire the lean CAI set through existing models, and an Object-Based CWM is needed.

Before introduce OBCWM proposed in this paper, we should first analyze product design and awareness requirements of CWM in product design as background.

Many typical models are proposed to explain characteristics of product design process  [29–32]. As most of these models are defined with complex factors and information, it is hard to identify the content and mechanism of CAI with these models. Shooter proposed Design information flow model  [33] to analyze design process from perspective of information transition. Since CAI is design supportive information, this paper refers to Shooter’s model to analyze CAI in design process. In this model, product design is a layered and iterated process. Shooter assumed that ‘design activities operate in two modes, iterative and layered, that are deeply intertwined’. This model concludes three types of information transition: (1) From customer demand to engineering demand; (2) From engineering demand to solutions; (3) From solutions to design result. These transitions are iterated according to evaluation of result. Shooter’s model indicates that the main task of designers is to execute and evaluate these information transitions. In this paper, each transition is related to many designers and tasks, and tasks can be classified into the following types (Fig. 1
                        ):


                        Type A. Task which needs the transition;


                        Type B. Task which decides content of source and goal information in transition;


                        Type C. Task which provides information to be transited;


                        Type D. Task which decides how the information is transited;


                        Type E. Task which transits the information;


                        Type F. Task which decides the way of evaluation;


                        Type G. Task which evaluates the transition.


                        Type N. Task irrelative to the transition.

Through the reason of collaboration between tasks is explained by information transitions, the collaborative mechanism between tasks needs to be analyzed.

From the perspective of “information behavior”  [34], this paper divides process of design task into four phases (Fig. 2
                        ): reception, planning, execution and report.

In most studies of concurrent engineering, the planning and execution phases are treated together as a “black box”  [35], in which all contents except input/output are unknown. To find CAI involved in the process, information flows in the “black box” are analyzed in this paper. All thirteen information flows of a design task are illustrated in Fig. 2 and marked with its serial number. The content of each phase and related flows are analyzed as follows: Reception. In this phase, task is assigned to designer, who confirms flow 1 consisting of target, constraint, deliveries and input information required in the task. Flow 2 transmits information comprehended and neaten by designer to next phase.


                        Planning. After reception of task, a rough plan (flow 3) consisting of activities for achieving the target is needed. To get rationales supporting decision of planning, related knowledge (flow 12) and CAI (flow 8) is consulted. As other coupled tasks are planning or executing in parallel, the CAI maybe frequently changed and affecting the result of planning. The plan in concrete is also CAI supporting other designer (flow 10). With negotiation between related tasks, the rough plan is ready and transmitted to the execution phase (flow 3).


                        Execution. After planning, task is initialized according to the plan. The proceeding of the plan is usually iterative (flow 6) and generates feedback for revising the plan (flow 4) is generated. The proceeding is supported by related knowledge (flow 12) and affected by CAI (flow 9), while new knowledge (flow 13) and CAI (flow 11) is formed and broadcasted into the collaborative environment.


                        Report. When the task is finished (flow 5), deliveries of the task should be submitted, managed and shared in the collaborative environment (flow 7).

In conclusion, CAI plays an important role in the planning and execution phases. It not only triggers and supports decisions of designer, but also maintains cooperation between different tasks. The tasks are running in parallel and integrated together to realize required transitions in product design. Supported by CAI, cooperation between different tasks is built.

Based on the analysis of cooperative design, this paper concludes that awareness requirements of CWMs include following aspects:


                        Planning aspect: When designers are planning process of tasks, they should be aware of related tasks belonging to Type A, B, D and F. As tasks are executed in parallel, plans of other tasks of different types may affect designers to modify plans during the execution of their tasks.


                        Execution aspect: When designers are executing process according to their plan, they should be aware of related tasks belonging to Type C, E and G.

All information of these aspects should be organized in a uniform framework, which composes a CWM providing lean CAI set for each designer. The CWM shall be able to answer the two questions as follows: 
                           Question 1
                           How to classify tasks into types? Before the classification, a method shall be proposed to estimate correlation of tasks and filter the irrelevant task which is invaluable for awareness.


                        
                           Question 2
                           What elements of a task are valuable to awareness? It is necessary to depict tasks through a uniform awareness framework so that system can digitize and user can understand awareness information.

Corresponding to Question 1, CWM shall help designer distinguish CAI from different type of tasks. First, correlation between tasks should be quantifiable in the CWM, so that a threshold of awareness intensity can be set to filter redundancy from the lean CAI set (tasks of Type N). Next, it is important to help designer identify CAI of different aspects.

Corresponding to Question 2, the CWM shall provide a uniform awareness framework to express CAI elements for cooperative design. Since product information is determined in the design process gradually, the framework has to depict not only information known during the planning, but also unknown information and information generated during the execution. As CAI is used for reference in activity decision in product design, the elements of CAI should be depicted by related product information model. To fit for various products, the uniform awareness framework shall be at a higher level of abstraction and can be externalized according to specific product.

To answer the questions in last section, Object-based cooperative awareness model (OBCWM) is proposed.

To answer Question 1, object-oriented method is used to define concepts of various CAI in OBCWM. The object-oriented method depicts CAI concepts and their relationships at a high abstract level, and forms a graph structure which makes it easy to define awareness intensity between different objects. With the graph, OBCWM is able to identify and filter irrelevant tasks.

To answer Question 2, OBCWM is developed based on the Core Product Model (CPM) proposed by NIST  [36] and STEP (Standard for the Exchange of Product Model Data)  [37]. OBCWM is an extensible framework which is able to integrate other CPM-based model. The target of OBCWM is to depict all CAI involved in cooperative product design. The characteristic of expandability makes OBCWM suitable for both planning and execution of various product designing.

Moreover, OBCWM provides foundation for CAI interaction mechanism which will be presented in Section  5.

In this section, an introduction to basic thought of object-oriented is presented, followed by the instruction of CPM and other references. The framework and mechanism of OBCWM will be introduced in the end.

To simplify the expression of complex relationships between objects, the OBCWM uses object-oriented method to depict all objects involved. The elements at the highest level of abstract are “object” and relationship of “object”.

Suppose OBJ is a set of meta information OBA (Object attribute): 
                           
                              
                                 
                                    OBJ
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             oba
                                          
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             oba
                                          
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          
                                             oba
                                          
                                       
                                       
                                          n
                                       
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     

As there are many types of relationship between OBJs, OBJs can be divided into many sets according to different relationships. This paper refers to the concept of hypergraph  [38] to define relationships of these sets:

Suppose a limited object set consisted of OBJ: 
                           
                              
                                 V
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             obj
                                          
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             obj
                                          
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          
                                             obj
                                          
                                       
                                       
                                          n
                                       
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     

There are several sets consisting of obj from 
                           V
                        : 
                           
                              
                                 
                                    
                                       
                                          e
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   j
                                                
                                             
                                          
                                       
                                       }
                                    
                                    ,
                                 
                              
                              
                                 
                                    
                                       (
                                       i
                                       =
                                       1
                                       ,
                                       2
                                       ,
                                       …
                                       ,
                                       m
                                       )
                                    
                                    ,
                                    
                                    
                                       
                                          ⋃
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                    
                                       
                                          e
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    V
                                    .
                                 
                              
                           
                        
                     

Hypergraph which consists of OBJ is: 
                           
                              
                                 H
                                 =
                                 
                                    {
                                    V
                                    ,
                                    E
                                    }
                                 
                                 ,
                                 
                                 E
                                 =
                                 
                                    {
                                    
                                       
                                          e
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          e
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          e
                                       
                                       
                                          m
                                       
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     

Suppose 
                           R
                         is relationship set of OBJs, 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 u
                              
                           
                         and 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 v
                              
                           
                         are endpoints of 
                           R
                        . 
                           R
                         and 
                           V
                         will form an unconnected graph 
                           
                              
                                 G
                              
                              
                                 
                                    OBJ
                                 
                              
                           
                        : 
                           
                              
                                 
                                    
                                       G
                                    
                                    
                                       
                                          OBJ
                                       
                                    
                                 
                                 =
                                 
                                    {
                                    V
                                    ,
                                    R
                                    }
                                 
                                 ,
                                 R
                                 =
                                 
                                    〈
                                    
                                       
                                          
                                             obj
                                          
                                       
                                       
                                          u
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             obj
                                          
                                       
                                       
                                          v
                                       
                                    
                                    〉
                                 
                                 ,
                                 
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       u
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       v
                                    
                                 
                                 ∈
                                 V
                                 .
                              
                           
                        
                     

Define 
                           
                              
                                 K
                              
                              
                                 R
                              
                           
                         as weight of 
                           R
                           ,
                           
                              
                                 K
                              
                              
                                 O
                              
                           
                         is weight of OBJ, and if 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 a
                              
                           
                         is adjacent to 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 b
                              
                           
                        , the path weight of them should be: 
                           
                              
                                 
                                    L
                                    r
                                    
                                       (
                                       R
                                       
                                          (
                                          
                                             〈
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   a
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   b
                                                
                                             
                                             〉
                                          
                                          )
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             b
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          min
                                       
                                       
                                          k
                                          =
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                       
                                          K
                                       
                                       
                                          
                                             
                                                R
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    
                                       (
                                       
                                          
                                             r
                                          
                                          
                                             k
                                          
                                       
                                       
                                          (
                                          
                                             〈
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   a
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   b
                                                
                                             
                                             〉
                                          
                                          )
                                       
                                       
                                          
                                             K
                                          
                                          
                                             O
                                          
                                       
                                       
                                          (
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                a
                                             
                                          
                                          )
                                       
                                       
                                          
                                             K
                                          
                                          
                                             O
                                          
                                       
                                       
                                          (
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                b
                                             
                                          
                                          )
                                       
                                       )
                                    
                                    ,
                                 
                              
                              
                                 
                                    
                                       
                                          K
                                       
                                       
                                          
                                             
                                                R
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          K
                                       
                                       
                                          O
                                       
                                    
                                    ≥
                                    0
                                    ,
                                    
                                    
                                       
                                          r
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       
                                          〈
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                a
                                             
                                          
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                b
                                             
                                          
                                          〉
                                       
                                       )
                                    
                                    ∈
                                    R
                                    
                                       (
                                       
                                          〈
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          
                                             
                                                
                                                   obj
                                                
                                             
                                             
                                                b
                                             
                                          
                                          〉
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

For any 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 j
                              
                           
                         of 
                           V
                        , suppose 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 i
                              
                           
                         is connected to 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 j
                              
                           
                           
                              (
                              
                                 
                                    
                                       obj
                                    
                                 
                                 
                                    i
                                 
                              
                              ∼
                              
                                 
                                    
                                       obj
                                    
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        , the minimum path weight shall be defined as: 
                           
                              
                                 L
                                 o
                                 
                                    (
                                    
                                       〈
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             j
                                          
                                       
                                       〉
                                    
                                    )
                                 
                                 =
                                 min
                                 
                                    (
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          j
                                          −
                                          1
                                       
                                    
                                    L
                                    r
                                    
                                       (
                                       R
                                       
                                          (
                                          
                                             〈
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      obj
                                                   
                                                
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             〉
                                          
                                          )
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                    )
                                 
                              
                           
                        
                     


                        
                           L
                           o
                           
                              (
                              
                                 〈
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       j
                                    
                                 
                                 〉
                              
                              )
                           
                         is awareness intensity of 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 j
                              
                           
                        . When 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 i
                              
                           
                         is not connected to 
                           
                              
                                 
                                    obj
                                 
                              
                              
                                 j
                              
                           
                           ,
                           L
                           o
                           
                              (
                              
                                 〈
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          obj
                                       
                                    
                                    
                                       j
                                    
                                 
                                 〉
                              
                              )
                           
                           =
                           ∞
                        . Awareness intensity of obj itself is 0.

Thanks to this object-oriented method, awareness intensity can be evaluated by the value of 
                           
                              
                                 K
                              
                              
                                 
                                    R
                                 
                              
                           
                         and 
                           
                              
                                 K
                              
                              
                                 
                                    O
                                 
                              
                           
                        . Awareness intensity of any concept derived from OBJ can be calculated by OBCWM. Furthermore, the algorithm calculating awareness intensity between tasks 
                           
                              (
                              L
                              t
                              
                                 (
                                 
                                    〈
                                    
                                       
                                          
                                             task
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             task
                                          
                                       
                                       
                                          j
                                       
                                    
                                    〉
                                 
                                 )
                              
                              )
                           
                         and between designers 
                           
                              (
                              L
                              u
                              
                                 (
                                 
                                    〈
                                    
                                       
                                          
                                             user
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             user
                                          
                                       
                                       
                                          j
                                       
                                    
                                    〉
                                 
                                 )
                              
                              )
                           
                         can be designed too. To make this method practical for product design, concepts derived from OBJ shall map to and based on existing product information models such as CPM and other models.

The core foundation of OBCWM is CPM. CPM includes a framework which depicts design information of product. The model focuses on “an artifact representation that encompasses a range of engineering design concepts beyond the artifact’s geometry, including function, form, behavior and material; as well as physical and functional decompositions, mappings between function and form, and various kinds of relationships among these concepts”  [36]. The target of CPM is to form foundation concept supporting PLM (Product Lifecycle Management). The framework of CPM is “not tied to any vendor software; open; nonproprietary; simple; generic; expandable; independent of any one product development process; and capable of capturing the engineering context that is most commonly shared in product development activities”  [39].

Much work has been done to extend CPM  [40]. The OBCWM is one of the extensions. The universality of object-oriented method is the main reason for choosing CPM as the foundation of OBCWM.

The objects in CPM and its extension can be processed with object-oriented method. Based on the derivative structure of the CPM, objects of product design are easy to create and to inherit base relationships in the CPM which are accepted by most designers. As shown in Fig. 3
                           , the main abstract classes are “CommonCoreObject” and “CommonCoreRelationship”, from which concrete classes of object and relationship are derived. In OBCWM, the OBJs defined in Section  4.1 are all instances of classes derived from CommonCoreObject, while the relationships of OBJ are all instances of classes derived from CommonCoreRelationship. Thus the value of awareness intensity can be calculated easily according to the method presented in Section  4.1.

Since existing classes depicted in the CPM are too abstract to support requirements of real product design, this paper borrows concepts from the STEP and other studies to externalize and specify classes of CPM.

The STEP is widely used in industry and becomes an important infrastructure for modeling product and related design activities, management and business.

The OBCWM refers the AP233 (Application protocol: Systems engineering) of STEP to enrich definition of requirements  [41]. Furthermore, the concepts expanding beyond the CPM in OBCWM are aligned to the concepts defined in STEP, making it easy for the OBCWM to merge with existing product information models.

Besides STEP, some other concepts are referred from related studies, such as various concepts of rationale  [42] organization of design process.

Framework of the OBCWM consists of four parts: CPM part, Object part, Process part and Transition part. The relationships of these parts in this framework are illustrated in Fig. 4
                        . All the four parts aim to meet the two requirements: to depict CAI and filter overload information.

To depict CAI, the OBCWM on one hand has functions of existing CWMs as it includes basic concepts related to product information, design process, user organization, and information transition in product design. On the other hand, the framework of OBCWM is open to integrate other CPM-based models to enhance the ability of depicting abundant concepts in various domains of product design. This characteristic of extension makes OBCWM universal to depict CAI in product design.

To filter overload CAI, the algorithm of awareness intensity is also suitable for the integrated CPM-based models, whose objects (OBJs) are also derived from “CommonCoreObject”. Thus awareness intensity of OBJs in the integrated models can also be calculated. Furthermore, designers can use the OBCWM to define algorithms of awareness intensity for tasks and users according to the Process part, in which relationships of user, task and OBJs are certainly defined. At last, Transition part is used to provide designers with transition information as a requisite part of lean CAI.

Details of each part are introduced as follows.

The CPM part (Fig. 3) is the core fundamental part from which other parts of OBCWM are extended. It contains the CPM proposed by NIST, which provides basic concepts and their relationships for product design. It mainly defines the information structure consisting of artifact, feature, behavior, requirement, specification, form, geometry, material, function and flow. In existing studies of modeling for different domains, many child OBJs are derived from these OBJs in various CPM-based models, which include OAM  [39,43], PFEM  [44], DAIM  [45,46], ESM  [47], and so on. Although child OBJs are different in models, they all inherit the original relationships between CPM OBJs. Thanks to these original relationships, different extended models can be easily integrated and used together. This well explains why and how OBCWM can be easily integrated with other CPM-based models. In this paper, each CPM-based model integrated into OBCWM is treated as a plug-in which can depict OBJs from perspectives of different domains. One OBJ can be depicted by several plug-ins at the same time, which means it can inherit all relationships defined by each plug-in. Thus the algorithm of awareness intensity can be used in all relationships of OBJs without identifying ownership between relationship and plug-ins.

Since the depiction of requirement, rationale, behavior and specification in CPM is too simple to explain corresponding awareness information, the Object part will extend these OBJs according to related studies.

To enrich “requirement” of CPM, the concepts of requirement defined in STEP AP233 is referred. The AP233 classifies requirement into seven sub-types: functional requirement, performance requirement, physical property requirement, interface requirement, imposed design requirement, reference requirement, and effectiveness measure. To refer these sub-types of requirement into Object part, we shall first compare CPM concepts with AP233 concepts. This work generates requirement-related definition of OBJs in the Object part. As shown in Fig. 5
                           , seven types of requirement are all derived from the original requirement, and relationships with other OBJs are defined according to essences of AP233.

To enhance “behavior” of CPM, OBJs of “behavior model”, “observed behavior” and “evaluated behavior” are defined according to Shooter’s information flow model.

To enhance “rationale” of CPM, this paper defined subtypes of rationale and their relationships. These rationales guide designers to find motivation of activities of all designers in cooperative environment.

To enhance “specification” of CPM, detailed forms of specification and their structure are defined. They provide more granularities to link “requirement” or “artifact”.

Benefiting from the Object part, types of OBJs are greatly enriched. Thus CAI can be more accurately depicted.

The Process part aims to depict CAI of human activity related concepts in product design. It mainly defines activity and task (Fig. 6
                           ).

“Activity” is the primary unit and basic component of task. As task process branch maybe iterative, the activity could be executed repeatedly until the task is finished. Each activity has only one “operation”, which is linked to some “TaskOBJs” been operated by the activity. All the TaskOBJs included in the same task are named as “operated OBJs” of the task in this paper.

“Task” is the primary unit and basic component of project or workflow. Each task is assigned to only one designer with a “target” indicating task’s deliveries. The deliveries are operated OBJs and named as “core OBJs” of the task in this paper. Besides core OBJs, other operated OBJs of the task are named “auxiliary OBJs”.

Based on the relationships between tasks and OBJs, algorithms of awareness intensity for tasks can be conceived. For example, one of the algorithms can be conceived as: 
                              
                                 
                                    
                                       L
                                       t
                                       
                                          (
                                          
                                             〈
                                             
                                                
                                                   
                                                      task
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      task
                                                   
                                                
                                                
                                                   j
                                                
                                             
                                             〉
                                          
                                          )
                                       
                                       =
                                       min
                                       
                                          (
                                          
                                             (
                                             L
                                             o
                                             
                                                (
                                                
                                                   
                                                      
                                                         obj
                                                      
                                                   
                                                   
                                                      k
                                                   
                                                
                                                ,
                                                
                                                   
                                                      
                                                         obj
                                                      
                                                   
                                                   
                                                      l
                                                   
                                                
                                                )
                                             
                                             )
                                          
                                          )
                                       
                                       ,
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             k
                                          
                                       
                                       ∈
                                       
                                          
                                             
                                                OBJ
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                          (
                                          
                                             
                                                
                                                   task
                                                
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       ,
                                       
                                       
                                          
                                             
                                                obj
                                             
                                          
                                          
                                             l
                                          
                                       
                                       ∈
                                       
                                          
                                             
                                                OBJ
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                          (
                                          
                                             
                                                
                                                   task
                                                
                                             
                                             
                                                j
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       OBJ
                                    
                                 
                                 
                                    
                                       C
                                    
                                 
                              
                            is the core OBJ.

Similarly, algorithms of awareness intensity for users can also be conceived based on the relationship between user and task.

To classify tasks into different types as listed in Section  3.1, the Transition part provides a framework to depict transition information (Fig. 7
                           ). The part defines identification method for each type are as follows:


                           Type A (Task which needs transition): If an auxiliary OBJ of task is goal information of the transition, the task belongs to type A.


                           Type B (Task which decides content of transited): If a core OBJ of task is rationale deciding contents of source or goal information in the transition, the task belongs to type B.


                           Type C (Task which provides the information to be transited): If a core OBJ of task is source information of the transition, the task belongs to Type C.


                           Type D (Task which decides how to transit information): If a core OBJ of task is rationale deciding method of the transition, the task belongs to type D.


                           Type E (Task which transit the information): If a core OBJ of task is goal information of the transition, the task belongs to type E.


                           Type F (Task which decides the way of evaluation): If a core OBJ of task is rationales of assigned evaluation method of the transition, the task belongs to type F.


                           Type G (Task which evaluates the transition): If a core OBJ of task is evaluation result of the transition, the task belongs to type G.

The mechanism of OBCWM is shown in Fig. 8
                        , which is explained in the format of IDEF0.

Before designer begins a task, preliminary work to initialize the framework should be done. The structure and instances of OBJ in Transition Part and Object Part should be predefined (A1, A2 and A3). In this phase, parameters (
                           
                              
                                 K
                              
                              
                                 R
                              
                           
                           ,
                           
                              
                                 K
                              
                              
                                 O
                              
                           
                        ) and threshold of awareness intensity shall be predefined.

When a task is assigned to a designer, he should first define the target including core OBJs (A5). Then the OBCWM will provide designer with OBJs whose distance to the core OBJs are shorter than the awareness intensity threshold, together with all tasks including these OBJs (A4). According to the framework of Transition Part, related transitions are found and provided to designer to support his/her task planning (A4). As the distance between OBJs is calculable, OBJs which have longer distances from the core OBJs can be identified as overload CAI and then be filtered (A4). Thus the system provides designer with only lean CAI. Then process of the task can be roughly defined by the designer with the lean CAI provided in the planning phase. The cooperation modes between pairs of cooperative tasks can be negotiated and confirmed too (A5).

When the task is initiated (A6), the OBCWM provides server to monitor related OBJs and their belonging tasks. When related OBJs in tasks of planning aspect (Type A, B, D and F) are changed, the system will notify designer to review his plan (A4). When related OBJs in tasks of execution aspect (Type C, E and G) are changed, the system will notify designer to process the task according to his plan.

@&#SUMMARY@&#

Based on object-oriented method, the OBCWM presents a framework to depict the lean CAI set which is controlled by the threshold of awareness intensity. The framework is extendable so that additional information framework in consistent with CPM can be merged into OBCWM as plug-in.

A lean CAI set can be treated as a view and shall be managed by a multiple views system. This paper proposed such a system to implement the mechanism of OBCWM depicted in Section  4.4. In this section, the definition of “flexible view” will be proposed, followed by introduction of functions of the system.

Based on the framework of OBCWM, view is defined as a CAI set corresponding to one designer. The view should include following contents:

(1) Contents of task process. It includes instance of concepts declared in the Process Part of OBCWM, with which designers record plan logic and status of the task.

(2) OBJs of task. It includes related OBJs of task and their neighbor OBJs based on the Object Part of OBCWM.

(3) Transitions related to task. It includes tasks belonging to all types except N, and the source information and goal information of the transition.

(4) Collaborators related to task.

Above elements of awareness is organized in a navigation net as shown in Fig. 9
                        . Taking use of this navigation net, designer can detect related information of awareness concentrating the core OBJs of his task.

As the threshold of awareness intensity is adjustable, the number of navigate nodes (task, designer, transition and OBJ) can be adjusted by either increasing or decreasing the threshold. The feature of adjustability makes the view flexible.

The range of view content is decided by the threshold and OBJs of task, which are operated in the task according to the definition of Process Part. OBJs included in the view can be calculated as: 
                           
                              
                                 
                                    OBJ
                                 
                                 
                                    (
                                    t
                                    ,
                                    δ
                                    )
                                 
                                 =
                                 ⋃
                                 
                                    {
                                    
                                       obj
                                    
                                    |
                                    L
                                    o
                                    
                                       (
                                       
                                          〈
                                          
                                             obj
                                          
                                          
                                             (
                                             t
                                             )
                                          
                                          ,
                                          
                                             obj
                                          
                                          〉
                                       
                                       )
                                    
                                    ≤
                                    δ
                                    }
                                 
                              
                           
                        
                     


                        obj(
                           t
                        ) is the OBJs of task 
                           t
                        . Based on 
                           
                              OBJ
                           
                           
                              (
                              t
                              ,
                              δ
                              )
                           
                        , related tasks, transitions and designers can be calculated and added into the view.

Based on the navigation net and flexibility, the view could provide lean CAI set closely related to designer’s task.

Integrated with the mechanism of OBCWM introduced in Section 3.4, designer can find related information for planning and be aware of collaborators during execution of the task. To take advantages of flexible view, following functions are provided by the multiple views system.

The system can provide following operation for designers during the process of browsing:


                           Perspective adjustment (Fig. 10
                           (a)): Label of OBA is a type of annotation, which can be used to categorize OBJ. The set of labels is also called parameter of perspective. The adjustment of Perspective includes aggregation and resolution of perspective to be shown.


                           Viewshed adjustment (Fig. 10(b)): Contents of view can be adjusted by increasing or decreasing the threshold of awareness intensity.


                           Sight distance adjustment (Fig. 10(c)): Besides viewshed and perspective control, other filtration conditions (such as time, position and collaborator) are supported to generate view.

In addition to browsing information and managing views of multiple views, the system proposed in this paper can even monitor information related to designer’s task according to its awareness intensity.

Monitoring OBJs include all OBJs within awareness range set by 
                              δ
                           . Change of OBJ including change of its content, status and R(OBJ), will automatically trigger notification services by the monitor mechanism.

When OBJ changes, the system will automatically notify related personnel who participates the task including the OBJ. The system will list and display the notification according to the time of change or receiver’s awareness intensity towards the OBJ. Thus user can locate the OBJ quickly and visit the task view through the list.

Through this monitoring function, user can learn the change of OBJ in his/her own task without delay and then learn operations of other person. Furthermore, the system will generate the cooperative hotspot report by analyzing the modification and relationships of the modified OBJs, providing significant reference to organization of cooperative activity and distribution of related resource.

Multiple views system is composed of client, communication server and multiple views server (as shown in Fig. 11
                        ). Cooperative server will respond to client request and provide cooperative communication service such as video, and voice and remote desktop. Multiple views server supports simultaneous operation of several clients.

Multiple views server is consisted of task management module, object management module, view management module and permission management module:


                           OBJ Management Module manages 
                              
                                 
                                    G
                                 
                                 
                                    
                                       OBJ
                                    
                                 
                              
                            (global OBJ graph) of system and supports edit and search of OBJ or relationship of OBJ.


                           Task Management Module manages project, personnel and content according to TA, and calculate related OBJs of task for Multiple Views Management Module.


                           Authority Management Module manages authority to facilitate view generation function of multiple Views Management Module.


                           Cooperative awareness Monitor Module monitors global obj graph in OBJ Management Module and pushes notification to user.


                           Multiple Views Management Module provides view generation, snapshot and management service to client according to navigation mechanism.

Client comprises visualization and interaction module, Object and Relationship editor, and communication tool client:


                           Visualization and Interaction module realizes navigation net as Fig. 9.


                           Object and Relationship Editor allows user to edit OBJ.


                           Communication Tool Client is bound to personnel information and provides cooperative communication service.

As a sample, a case is used to introduce the application of OBCWM and the multiple views system.

This case is to design an aircraft landing gear system for an aircraft company.

The nose landing gear consists of three main subsystems: shock absorption subsystem, retraction subsystem and steering subsystem. They are connected with mechanical structure, hydraulic line and electric circuit. Thus the designers are assigned to different professional teams, and each team consists of three groups of different subsystems (Listed in Table 2
                        ). Partners in one group work together and are able to communicate with each other at any time. However, communication between different groups and teams are limited by knowledge and work place.

To simplify the case, this paper only includes 8 designers (Designer A–H, listed in Table 2) from 4 groups in 2 teams (mechanical and hydraulic). Fig. 12
                         illustrates the product structure, the work breakdown structure (WBS) and rough relationships between tasks and products. Three layers of tasks are illustrated in the WBS. In the bottom layer, tasks can be executed in parallel. In Fig. 12, designers’ assignment is indicated with brackets in the end of each bottom task’s label.

To analyze elements affecting product design, this paper focuses on the execution of “4.2.3.2.2 Steering Actuator Design” task (colored yellow in Fig. 12), whose target is to confirm parameters of the Steering Actuator. The two actuators are used mainly to drive the steering mechanism to control direction of plane when slide at low speed. The second function is to be a damper, which damps shimmy of nose wheel during the high speed sliding. The dual functions coupled in the same artifact increase the complexity of the design task.

To perform this task, Designer B shall understand main requirements of the steering actuator including the following two aspects:


                        Function requirement: The two steering actuators should take concerted actions and convert hydraulic signal to mechanical energy, with which the steering mechanism is driven. The output energy shall be strong enough to overcome friction generated from steering the nose wheel. As dampers, the two steering actuators shall resist the displacement generated from vibration of the nose wheel. The output damping should be enough to meet the engineering demand.


                        Geometric requirement: The stroke of piston shall meet the design solution of steering mechanism, and the volume of cylinder shall as small as possible to save space in nose gear well. Finally, geometric interference with other mechanisms should be avoided.

According to the mechanism of OBCWM, the initial OBJs shall be predefined before designer B is assigned to the case task (“4.2.3.2.2”). To depict information related to the transition, the OAM and an extension package defined for hydraulic (HYD, as shown in Fig. 13
                        ) are inserted into Object part as plug-ins.

The transitions related to this task shall be defined too. Source information of this transition includes: (1) behavior model and its design rationale, (2) definition of artifacts consisting of the mechanism and various requirements for each of them, (3) definition of physical and logic connection (hydraulic links in this case) between parts, and (4) evaluative rationale of observed behavior model. Goal information of this transition includes: (1) forms of each artifact of the mechanism, (2) the observed and evaluative behavior models, and (3) forms of connection or feature between related artifacts. In Fig. 13, the source and goal information of concepts are noted with UML, from which the OBJ are instanced.

In additions, value of awareness intensity parameter shall also be defined. Tables 3–5
                        
                        
                         list some values of awareness intensity parameter of OBJs and relationships.

Since the detailed design has not started, OBJs cannot be defined completely. For example, “connections” between parts are goal information and undefined at the beginning.

Main relationships defined in this case include three aspects: (1) relationships defined by OAM; (2) relationships defined by HYD; (3) relationships generated from the same requirements and specifications which link several artifacts at the same time.

When Designer B receives the case task, he needs to confirm the task’s target, in which the core OBJs are designated, and set the awareness threshold for CAI view.

To support designer’s decision of planning, the system will provide a view including related OBJs whose awareness intensity to core OBJs is smaller than the awareness threshold. Meanwhile, the related transitions will be provided according to definition of the Transition part. All of these CAI is presented with the navigation net as shown in Fig. 9.


                        Table 6
                         lists related OBJ presented by the system (“A.I.” means Awareness Intensity).

With the navigation net, Designer B can make a rough plan for realizing the target of the task. As result of his decisions, some OBJs are chosen and become related OBJs, which are operated by activities in the plan. After the logic of process is roughly planned, cooperation mode between related tasks should be confirmed with negotiation.

As an instance, Fig. 14
                         illustrates the plan of main activities defined by Designer B, most of which are related to other tasks through cooperative interfaces. In activity 1, Designer B defines four branches for the target of steering actuator design: (1) design the artifact for actuator (activity 2, 3, 4, 5, and 6); (2) design the artifact for damper (activity 6, 8, 9, and 10); (3) collision detection (activity 6, 7 and 11); (4) design interfaces to other artifacts (activity 12, 13 and 14). Finally, in activity 15, the target of task was achieved, and the design result was submitted as a delivery. Three modes of cooperation between Designer B and others are also defined.

At the beginning, the types of connection between actuators and other artifacts were unknown, which would be negotiated by Designer B and collaborator. An awareness path of “Artifact (CPM)–(ArtifactAssociation (OAM))–Artifact”, whose instances were aware in range of less then 1, made the system provide Designer B with clues for planning activity about these connections. With the related path of “ActuatorGeometryRequirement”, Designer B discovered iterative need for interference, which formed an activity of delegation with Designer E. As the “StrokeGeometryRequirement” of the piston stroke is delivery of Task “4.2.3.2.1”, Designer B set the notification from “4.2.3.2.1” in his process.

When the case task was initialized, Designer B executed the task according to his plan as shown in Fig. 14. During the process of other tasks, new detail information of actuator was created and recorded into the framework of OBCWM. Either creation or modification of OBJs would be notified to Designer B’s view, whose awareness range covered these OBJs. The status of related tasks and designers were also collected by the multiple views system and provided to Designer B for decision in the process.

It is usually an iterative process consisted of planning and execution in real design. When new problem comes out, the multiple view system will provide lean CAI to related designers and support them to make decisions.


                        Fig. 15
                         illustrates the information panels of Designer B’s view.

@&#EVALUATION@&#

To satisfy cooperative needs of designer in co-create environment and deal with mass data in complex management system, the system proposed in this paper uses multiple views to dispatch information. Compared with traditional cooperation awareness and information overload-related theories, this method has the following advantages:

It proposes a framework to depict CAI in collaborative design, which is easy to integrate existing CPM-based product information model. This characteristic makes the framework valuable in practice.

Flexible views provide users with more methods of information filtration and interaction, including adjustment of viewshed, perspective and sight distance.

It supports CAI monitoring which enables users to timely discover awareness information change in cooperative design environment.

However, there are still some shortages of the system:

Although user can get information related to core OBJ through calculation of awareness threshold value, user does not need all OBJs of which he/she is aware. With the increase of viewshed parameter, information redundant will also increase which will hinder user’s awareness and design efficiency.

Information relationship will become complex with the increase of OBJ, which will definitely reduce usability of system.

In this paper, awareness intensity is used to evaluate redundancy of information. Thus to what extent the awareness intensity is reasonable can be seen as criteria of information filtration. As described in this paper, awareness intensity can be adjusted according to values of 
                        
                           
                              K
                           
                           
                              O
                           
                        
                      and 
                        
                           
                              K
                           
                           
                              R
                           
                        
                     . Collaborative recommendation can be applied to define values of 
                        
                           
                              K
                           
                           
                              O
                           
                        
                      and 
                        
                           
                              K
                           
                           
                              R
                           
                        
                     , which will be the next step of our study.

In addition, to improve usability of the system, information visualization will also be the next big step.

@&#CONCLUSION@&#

This paper proposes a multiple views system aiming to provide designer with lean cooperative awareness information for product design. Based on analysis of awareness requirements and existing models, OBCWM is proposed to meet two requirements of design system: to define the CAI and filter overload information. The OBCWM defines view content by information object of task, and enables users to adjust the range of view content by quantifying information awareness intensity. Based on the OBCWM, this paper proposes a multiple views system with functions of information navigation, operation and management of views, and event notification. This system aims to improve efficiency of designers in cooperative product design.

@&#ACKNOWLEDGMENTS@&#

This paper is sponsored by Chinese 863–program — “Supporting and Verification Platform for Large Aircraft’s Development”. The project number is 2009AA043306.

@&#REFERENCES@&#

