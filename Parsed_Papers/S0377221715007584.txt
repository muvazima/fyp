@&#MAIN-TITLE@&#The component commonality problem in a real multidimensional space: An algorithmic approach

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Addresses the optimal commonality problem in a multidimensional real space.


                        
                        
                           
                           The formulation is equivalent to the k-median problem.


                        
                        
                           
                           Considers interactions between different dimensions using different metrics.


                        
                        
                           
                           Provides family of greedy-like algorithms to solve large instances of the problem.


                        
                        
                           
                           Numerical experiments testify for the strong performance of the proposed heuristic.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Component commonality

Production complexity

Flexible manufacturing systems

Economics of production

Facilities planning and design

@&#ABSTRACT@&#


               
               
                  Component commonality is an efficient mechanism to mitigate the negative impact of a highly diversified product line. In this paper, we address the optimal commonality problem in a real multidimensional space, developing a novel algorithmic approach aimed at transforming a continuous multidimensional decision problem into a discrete decision problem. Moreover, we show that our formulation is equivalent to the k-median facility location problem. It is well known that when several dimensions are included and components’ features are defined in the real line, the number of potential locations grows exponentially, hindering the application of standard integer programming techniques for solving the problem. However, as formulated, the multidimensional component commonality problem is a supermodular minimization problem, a family of problems for which greedy-type heuristics show very good performance. Based on this observation, we provide a collection of descent-greedy algorithms which benefits from certain structural properties of the problem and can handle substantially large instances. Additionally, a MathHeuristic is developed to improve the performance of the algorithms. Finally, results of a number of computational experiments, which testify for the good performance of our heuristics, are presented.
               
            

@&#INTRODUCTION@&#

In a highly competitive globalized world, firms increasingly face the need of providing an enlarged product variety in order to satisfy a hugely diversified market. This increased variety of products demands a large number of different components and configurations that usually exceed by far the capabilities of the assembly line. Moreover, as Bernstein, Kök, and Xie (2011) point out, a larger number of variants of the same product increases the manufacturing complexity and leads to a more fragmented product line. This, in turn, reduces the capability of the firm for taking advantage of economies of scale.

Component commonality is one of the most efficient mechanisms to mitigate the negative impact of a large number of product variants. Thonemann and Brandeau (2000) provide the example of one major automobile manufacturer that offers a particular model in more than one billion combinations of colors, interior designs, drive train configurations, and option choices. Clearly, this level of diversification can only be attained by the use of common components in some models. According to these authors, most automotive companies have recognized the benefits of component commonality and have developed car models that share components ranging from standardised commodity parts to complicated sub-assemblies. More recently, Greimel (2013) describes the redesign of the Nissan Rogue crossover, the first product of a new modular development strategy that aims to cast down costs. He emphasizes that Nissan’s engineers redesigned 84 component systems to make them common with systems used by Renault, Nissan’s alliance partner. The goal was to standardise parts for 1.5 million units over 14 models.

Many benefits have been argued on the use of component commonality in the production line. Among them, Subramanian, Ferguson, and Toktay (2013) mention the reduction in unit production costs due to the existence of economies of scale, savings in inventory costs and mitigation of shortage costs due to risk pooling. On the other hand, the use of common components imposes additional costs, as there is a loss derived from using a higher performance component in a bottom-line product. Moreover, the manufacturing cost of a product may be increased if it has to be adapted for using a component with higher specifications than necessary (Subramanian et al., 2013). Given this trade-off, the firm faces the need of determining the number and specification of the common components to be shared by its products.

Over the last few years, the problem of component commonality has received increasing attention from both practitioners and academics. On the industrial side, it is easy to find examples of the recent debate on the issue of standardisation and component commonality. For example, in a recent webinar organized by SCM World, Fuganti
                        1
                     
                     
                        1
                        Head, EMEA Components Standardization Process & Compact Architecture Development, FIAT
                      discussed product complexity and component commonality. The following text is extracted from the webinar and appeared in print on the May 7, 2014, edition of SCM World (Fuganti, 2014):

                        
                           Increased product complexity, greater customer personalisation and the need to get new models to market faster are among the top challenges facing auto makers today. One of the main ways the auto industry is addressing these challenges, while trying to preserve the economies of scale on which it has long depended, is through modularity in product design. This leads to standard platforms, or architectures, and the reuse of common systems and components across different models.
                        
                     
                  

Through the same media, Lemoine
                        2
                     
                     
                        2
                        Director, World-Class Manufacturing, Magna
                      discusses how the methodology of value analysis and value engineering can “be used to ask key questions of the manufacturing process to enable cost reduction with minimal resources” (Lemoine, 2013). Among these questions, he mentions the possibility of parts standardisation and the introduction of new product specifications to reduce costs.

On the academic side, there is a vast amount of literature addressing different aspects of the component commonality problem. For example, Briant and Naddef (2004) discussed the case of European auto assembly plants requiring 7000 different wiring designs. In their example, the number designs indeed produced is two orders of magnitude smaller than that value. Bernstein, DeCroix, and Wang (2007) presented the case of Dell Computers where a wide variety of ending products is obtained from a more limited number of components. Finally, Subramanian et al. (2013) mention the case of Caterpillar, where important benefits have been obtained since 2008 through the use of component commonality in their products.

This paper provides a methodology for determining the attributes of a limited number of components, aimed at satisfying the requirements of a larger set of products at a minimal cost. It considers a multi-dimensional attribute space for a single component, where each attribute can take either continuous or discrete values. Our work extends the available literature on the component commonality problem as, to our knowledge, no one has yet worked on continuous multi-dimensional problems. Indeed, most of the available research is limited to the analysis of commonality problems with binary or discrete attributes. Moreover, although the problem has been extensively studied in literature, most of the available applications are aimed at deciding, out of a collection of pre-defined modules, which one should be brought to the market. Based on the observation that, after a suitable modification of the specification space, the multidimensional component commonality problem is mathematically equivalent to the k-median problem, the algorithmic approach developed here provides researchers and practitioners with a simple procedure that can easily be used in real life applications. Additionally, the proposed technique grants the decision makers more freedom on the designing phase, eliminating the need for pre-defined modules.

Finally, the tools developed in this paper can be used to solve commonality problems in areas as diverse as agro-industrial and heavy industrial machinery production, aerospace and automotive industries, photography and image processing, and computers and networking equipment manufacturing, among others. To illustrate this applicability and to further stress the relevance of the techniques developed in this paper, in the following lines we present a hypothetical example based on a real life problem faced by car manufacturers.

Let us start by illustrating the use of a common platform in a variety of cars with a wide range of weights. Toyota’s Camry has a Gross Vehicle Weight Rating (GVWR) of 2100 kilogram on its heavier version. Camry’s platform is also used, among others, by Sienna – a minivan by Toyota, which has a GVWR of 2715 kilogram on its heavier version; and by Highlander, which has maximum GVWR of 2720 kilogram and of 2840 kilogram on its non-hybrid and hybrid versions, respectively. An additional element that increases the total weight of a vehicle is the towing. While the smaller Sienna has a towing capacity between 454 kilogram and 1548 kilogram, the hybrid Highlander can tow up to 1587 kilogram, and the non-hybrid up to 2268 kilogram -it was not possible to find Camry’s official towing capacity. These numbers illustrate that the total weight of cars using the same platform may vary within a range of about 800 kilogram without towing, and up to 2500 kilogram when towing is considered (it is important to notice that even though GVWR and towing capacity values come in a range, in practice they are summarized by the heaviest of the vehicles, which broadens the weight ranges given before)
                        3
                     
                     
                        3
                        For these and further details on Toyota’s cars GVWRs and towing capacities visit, for example, http://www.car.com, http://www.edmunds.com or http://www.toyota.ca.
                     .

In the USA market alone, 2014 sales were approximately 428,000 units for Camry, 146,000 for the two Highlanders, and 124,000 for the Sienna; making a total of near 700,000 cars sold in 2014
                        4
                     
                     
                        4
                        For complete details on 2014 sales, please see http://toyotanews.pressroom.toyota.com/sales-financial/releases/.
                     .

With these figures in mind, consider the case of a large car manufacturer who has to make choices about certain structural element whose capacity for withstanding forces is crucial. Take, for example, the brake pad, a piece whose characteristics are related to the final weight of the car, including towing. This piece is used across different platforms, with several different models using the same platform, which altogether may sell several million cars worldwide every year. Brake pads, according to Toyota, are made from five main groups of materials: binding materials (binders); abrasive materials (for example, mineral fillers used to boost friction); performance related materials (included in precise amounts to enhance certain braking characteristics, e.g. temperature specific lubricants); filling materials (e.g. rubber or rubber scrap that can increase wear resistance); and structural materials (which help the pad to maintain proper shape during use). According to Toyota’s website, “these five types of materials encompass more than 2000 substances”
                        5
                     
                     
                        5
                        For further information, please visit https://parts.olathetoyota.com/what-are-brake-pads-made-of.html
                        
                     .

The above discussion highlights a potential application of the formulation and methodology developed in this paper, where all the elements of a typical component commonality problem are present: a collection of different car models and platforms uses a common part, whose attributes vary depending on the specific requirements of each model (related to their weight and towing capacity). Those requirements are quantified in continuous metrics. On the other hand, the parts materials are also quantified in continuous metrics with, at least, five different dimensions. The car maker should decide on the number of different brake pads’ versions to produce, their physical characteristics, and the allocation of the various versions to the different platforms and car models that will use them.

The rest of the paper is structured as follows. In Section 2 we review the existing literature in component commonality. Section 3 introduces our model and presents some structural properties. In Section 4 we develop an algorithmic approach for addressing large instances of the problem. A numerical assessment of approach is provided in Section 5. Finally, Section 6 concludes the article with some final remarks.

@&#LITERATURE REVIEW@&#

Over the last few years, component commonality has become an active research topic. Important research articles have been published that address the many aspects of the commonality problem. Wazed, Shamsuddin, and Nukman (2010) offer an annotated bibliography with over 100 references on the topic.


                     Fixson (2007) offers a good review on the available literature on modularity and component commonality, citing more than 160 references. It provides a categorization of the different aspects (product, process, organization and innovation), effects (product performance, variety, costs, among others) and research methods (theory and concepts, process modeling, mathematical modeling, simulation and so on) of the commonality problem.

Among the industrial products where component commonality has been studied, Fixson (2007) mentions aircrafts, wood working machines, space station water tanks, and telecommunication switches. It is widely used in the automobile industry (Boysen, Fliedner, & Scholl, 2009; Briant & Naddef, 2004; Ericsson, Karlsson, Mercer, & Robertson, 1996), and it has also found application in the production of industrial powers tools (Jans, Degraeve, & Schepens, 2008) and in the computer hardware industry (Bernstein et al., 2007).

The introduction of the concept of downward compatibility by Rutenberg (1971), opened the door for the analysis of the use of one type of component in multiple products. Since then, the problem of component commonality has been discussed analytically, among others, by Collier (1982), Hillier (2000), McClain, Maxwell, Muckstadt, Thomas, and Weiss (1984), Perera, Nagarur, and Tabucanon (1999), Preyas, Kekre, Radhakrishnan, and Srinivasan (2001) and Mirchandani and Mishra (2002).

The work of the operational research community has focused on the product aspects of the component commonality problem, concentrating their efforts on the development of mathematical models for the detection of optimal degrees of commonality and for the solution of specific commonality problems. Dogramaci (1979) and Thomas (1991) used clustering techniques for its solution. Li and Azarm (2002) and other authors (Huang, Li, & Schulze, 2008; Kamrani & Gonzalez, 2003; Simpson & D’Souza, 2004) have developed optimization methods for product design with commonalities using genetic algorithms . Other techniques that have been used are, agent-based Pareto optimization (Rai & Allada, 2003); commonality or versatility indices (Kang & Hong, 2009; Thevenot & Simpson, 2006); decomposition approaches (Avella, Boccia, Di Martino, Oliviero, Sforza, & Vasil’ev, 2005); Manufacture Resource Planning (MRPII) (Wazed, Shamsuddin, Nukman, & Nader, 2012); priority rules (Gupta & Krishnan, 1999); queueing models (Wee & Dada, 2010); scenario aggregation approaches in stochastic formulations (Jonsson, Jornsten, & Silver, 1993); or simulation (Izui, Nishiwaki, Yoshimura, Kariya, Ogihara, & Hayashi, 2010; Su, Lun, & Lee, 2012).

Regarding the approach taken in this paper, we find that only few references address the component commonality problem as a mathematical programming problem. Thonemann and Brandeau (2000) analyse a commonality problem inspired by a wire-harness problem in the automobile industry. They present a mixed-integer linear formulation of the problem that takes into account production, inventory, set-up and complexity costs. To solve the problem, they use a branch and bound algorithm and an alternative simulated annealing algorithm for large instances. Briant and Naddef (2004) propose a p-median formulation of what they refer to as the Optimal Diversity Management Problem (OMDP). Their aim is to optimally choose k out of a large number of models, minimizing certain measure of over cost (extra cost incurred when the appropriate model is substituted in a product by a compatible one with additional features). A Lagrangian relaxation and a variable fixing algorithm are provided for the integer programming formulation of this problem. Jans et al. (2008) analyse the problem of a firm which seeks to reduce costs by means of a product redesign. The aim is to group the product in families which use the same version of certain component. They propose a mixed integer non linear optimization model to find the optimal component commonality decision. The model returns the total development costs, selling prices and net present value of yearly profit over a finite horizon. A real life application with one component is solved using a standard solver and no algorithm is provided. Finally, Boysen and Scholl (2009) present a “multi-purpose” framework for general component-commonality problems, based on a two-stage graph theoretical approach. They offer a solution framework based on a two stage decomposition procedure. In the second stage, a number of product sequences defined in the first stage (heuristic method), is passed to a directed “grouping graph”, where products that can be served by the same component are grouped. Finally, it is shown that the component commonality problem reduces to a shortest path problem in the grouping graph.

As for areas of application, it is possible to find references to component commonality problems in fields ranging from computing systems (Apple), consumables (Hewlett Packard, Polaroid), photography (Fuji, Kodak), and photocopying machines (Xerox); to aerospace (Boeing), automobile manufacturers (Chrysler, Ford, General Motors, Mazda) or heavy industrial machinery (Caterpillar). See, among others, Alumur, Nickel, Saldanha-da Gama, and Verter (2012), Erzurumlu (2013), Khire, Wang, Bailey, Lin, and Simpson (2008), Örsdemir, Kemahlıoğlu-Ziya, and Parlaktürk (2014), Subramanian et al. (2013), Souza (2008), and Ye and Gershenson (2009).

It is important to highlight that all the references discussed above assume that the components in the model have 0–1 or, at most, discrete attributes. Moreover, even in those cases where an algorithm is offered, the number of different attributes included in the analysis remains relatively small (e.g. Thonemann and Brandeau (2000) use 100 products with combinations of up to eight 0–1 features, whereas Boysen and Scholl (2009) use up to 200 products and up to seven 0–1 features).

Additionally, even though it has been mentioned that the component commonality problem can be modelled as a facility location problem,

                        The CCCP ... is related to the uncapacitated facility location problem..., where opening a facility represents introducing a component ... and delivery costs are equivalent to total variable cost of component production. (Boysen & Scholl, 2009)
                        [the optimal diversity management problem] can be seen as a k-median or k-centre problem on the graph of a partial order... (Briant & Naddef, 2004)
                     
                  

no attempt has been done for a full modelization of the component commonality problem, in a real multi-dimensional attribute space, as a facility location problem.

To put the terminology that will be used throughout this paper into focus, we first introduce some concepts by means of a simple motivating example.

Consider any product, say a computer. This computer has several (generic) parts: hard drive, monitor, mother board, processor, USB flash drive, and so on. Let us concentrate on the first one. The (generic) hard drive is a part, a part that can be characterised by its defining features: rotating speed, storage capacity, form factor, interface, weight, and so on. To achieve the desired performance, the computer has certain requirements regarding the features of its hard drive, for example, it may need 2TB of storage capacity, ten thousand RPM rotating speed, 3.5 inch form factor, SATA interface, and so on. Consider now that the manufacturer proposes a collection of alternative specifications or potential configurations for the hard drive, each of them with certain attributes or values regarding the features mentioned above. Once one of those specifications has been chosen for production, it will be referred to as a component.

In a broad sense, the terms part and component are equivalent, only aimed at being used in different levels of reasoning. The part is the concept, the generic idea; the component is the physical realization of that concept.

In Fig. 1
                     , we present a simplified version of the case described above. Here, the part (a hard drive) must fulfil the product’s requirements regarding three specific features (capacity, speed and weight). The lab offers three specifications with different attributes. Given that it is the only one that fulfils the product’s requirements, Specification 3 is chosen for production. This specification is henceforth referred to as a version of the component or, shortly, a component: a hard drive.

In order to express all the features in comparable units, the different dimensions of the specification space are monetized. Thus, in our motivating example, the memory of a hard drive that has a value of 100 monetary units is (partially) suitable for any product with memory requirements below this value. Likewise, a component with specification (150, 100, 25) satisfies a product with requirements (100, 75, 50), and so on.

Once the terminology has been introduced, we present the notation and the mathematical formulation of our component commonality problem, followed by the discussion of some structural properties that will be useful for the design of the algorithmic approach.

Consider a generic product using a component, with r features, that performs certain function. The product requires a minimum level of each of the features, summarized by the vector 
                        
                           X
                           =
                           
                              (
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                              
                                 x
                                 r
                              
                              )
                           
                           ,
                        
                      where xi
                      represents the minimum admissible value of feature i and 
                        
                           X
                           ∈
                           
                              R
                              r
                           
                        
                     . The product has also associated a scalar ω > 0 representing the market demand. We assume that the product is uniquely defined by its requirements and, therefore, is fully characterized by the pair (X, ω).

On the manufacturing side, a specification, represented by a vector 
                        
                           
                              X
                              ′
                           
                           ∈
                           
                              R
                              r
                           
                           ,
                        
                      is characterized by the maximum requirements of each of the r features that it can satisfy. Once a specification is selected for production, it is referred to as a component. A product (X, ω) can use component X′ if and only if 
                        
                           
                              x
                              i
                              ′
                           
                           ≥
                           
                              x
                              i
                           
                        
                      for all 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           
                           r
                        
                     .

The use of the same component by different products implies that some of them will have a provision of a particular feature larger than necessary. This excess, or giveaway cost, constitutes an extra expense in those products that require a smaller value of the attribute. The giveaway cost incurred when using component X′ in a product with requirements X, is given by the Lk
                     -Norm between points X′ and X, when 
                        
                           
                              x
                              i
                              ′
                           
                           ≥
                           
                              x
                              i
                           
                        
                      for all 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           r
                        
                     ; otherwise, the distance is fixed to infinity in order to characterize the inadmissible cost of not being able to satisfy some requirements of product X.

Regarding the computation of the giveaway cost we notice that using the L
                     1-Norm implies that there is no interaction between the different dimensions. At the other end, an L
                     ∞-Norm would represent the case when the largest value among all features in the specification space dictates the component cost. Other Lk
                     -Norms may be good approximations for potential interactions between features.

In order to define the objective function, let 
                        
                           N
                           =
                           {
                           
                              X
                              
                                 (
                                 i
                                 )
                              
                           
                           |
                           i
                           =
                           1
                           ,
                           …
                           ,
                           
                           n
                           }
                        
                      be a set of n products (each of them with different requirements regarding the features of certain part) and 
                        
                           v
                           =
                           {
                           
                              ω
                              
                                 (
                                 i
                                 )
                              
                           
                           |
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                           }
                        
                      the associated demand vector. Moreover, let 
                        
                           S
                           =
                           {
                           
                              X
                              
                                 ′
                                 (
                                 j
                                 )
                              
                           
                           |
                           j
                           =
                           1
                           …
                           ,
                           m
                           }
                        
                      be a set of m specifications that cover the requirements of a product in N. The cost of satisfying the requirements of product i ∈ N by the element of S that minimizes such cost is then given by

                        
                           
                              
                                 g
                                 
                                    (
                                    i
                                    ,
                                    S
                                    )
                                 
                                 =
                                 
                                    min
                                    
                                       j
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       
                                       |
                                       S
                                       |
                                    
                                 
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                         
                                                            t
                                                            =
                                                            1
                                                         
                                                         r
                                                      
                                                      
                                                         
                                                            (
                                                            
                                                               x
                                                               t
                                                               
                                                                  ′
                                                                  (
                                                                  j
                                                                  )
                                                               
                                                            
                                                            −
                                                            
                                                               x
                                                               t
                                                               
                                                                  (
                                                                  i
                                                                  )
                                                               
                                                            
                                                            )
                                                         
                                                         k
                                                      
                                                   
                                                   k
                                                
                                                ;
                                             
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   x
                                                   t
                                                   
                                                      ′
                                                      (
                                                      j
                                                      )
                                                   
                                                
                                                ≥
                                                
                                                   x
                                                   t
                                                   
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                ∀
                                                
                                                t
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                
                                                r
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∞
                                                ,
                                             
                                          
                                          
                                             otherwise.
                                          
                                       
                                    
                                 
                              
                           
                        
                     The difference 
                        
                           
                              x
                              t
                              
                                 ′
                                 (
                                 j
                                 )
                              
                           
                           −
                           
                              x
                              t
                              
                                 (
                                 i
                                 )
                              
                           
                        
                      represents the giveaway cost of feature 
                        
                           t
                           =
                           1
                           ,
                           …
                           ,
                           r
                           ,
                        
                      incurred when requirement i is provided by specification j. Notice that any specification that yields an infinitely large cost is equivalent to an unfeasible solution 
                        6
                     
                     
                        6
                        To our knowledge, the use of norms to capture the interaction between different features is a novelty in the analysis of component commonality problems. Additionally, other forms of function g can be used to model more complex relations between attributes, limiting the use of norms to the computation of the giveaway costs. The only condition to be fulfilled by g is to be monotonically non-decreasing on the elements of S.
                     .

Once the main concepts have been introduced, the problem under discussion in this paper can be formulated as the problem of finding a set S
                     * of K components that satisfies the requirements of all products in N at a minimal cost, where 
                        
                           
                              S
                              *
                           
                           =
                           
                              {
                              
                                 X
                                 
                                    ′
                                    
                                       (
                                       j
                                       )
                                    
                                 
                              
                              ∈
                              
                                 R
                                 r
                              
                              
                                 |
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 K
                              
                              }
                           
                        
                     . As Briant and Naddef (2004), we focus on the manufacturing/assembly related over costs, abstracting out costs related to inventory, setup, bench tests, and validation tests; as well as other costs that are usually related to complexity. Mathematically, the Multidimensional Component Commonality problem (MDCC) can be stated as

                        
                           (1)
                           
                              
                                 
                                    min
                                    
                                       S
                                       ⊆
                                       
                                          R
                                          r
                                       
                                       ,
                                       
                                          |
                                          S
                                          |
                                       
                                       ≤
                                       K
                                    
                                 
                                 Z
                                 
                                    (
                                    S
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    ω
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 g
                                 
                                    (
                                    i
                                    ,
                                    S
                                    )
                                 
                                 .
                              
                           
                        
                     
                  

In the following section we discuss some structural results that will be of use for the algorithmic solution to the MDCC.

We start by showing that there exists a finite set M of specifications, such that N ⊆ M and any optimal solution S
                        * ⊆ M. This result is important as it allows the utilization of a finite set of potential points in the specification space and, consequently, the use of efficient approaches to solve the MDCC problem. To show this, we first introduce the algorithm Construct –a procedure for constructing set M and, following, we show that restricting the search for specifications to points in M is optimal. The pseudo-code for the algorithm is shown in Fig. 2
                        .


                        Fig. 3
                         helps to visualize the algorithm at work. The two points in the specification space, 
                           
                              
                                 p
                                 ^
                              
                              x
                           
                         and 
                           
                              
                                 
                                    p
                                    ^
                                 
                                 y
                              
                              ,
                           
                         represent the requirements of two products (without loss of generality we can refer to them simply as products). A point 
                           
                              p
                              ^
                           
                         is created using the mechanism described in algorithm Construct, i.e., point 
                           
                              p
                              ^
                           
                         inherits the maximum of the values of the jth coordinate of the two points. This guarantees that 
                           
                              
                                 p
                                 ^
                              
                              ,
                           
                         if turned into a component, it will be capable of satisfying the requirements of both products (points), without inducing a giveaway cost infinitely large.

                           Theorem 1
                           
                              If |S
                              *| < |N| then there exists a finite set of candidate points for an optimal solution. That is, for any optimal solution S
                              *, S
                              *⊆M and |M| < ∞.
                           

We prove this by contradiction. Assume there is at least one point X
                              (0) such that X
                              (0) ∉ M and X
                              (0) ∈ S
                              *. Define F(X
                              (0)) to be the set of all models using part X
                              (0). We ignore the trivial case 
                                 
                                    F
                                    
                                       (
                                       
                                          X
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                       }
                                    
                                 
                               as in such case S
                              * is, obviously, not optimal.

Let 
                                 
                                    X
                                    j
                                    M
                                 
                               be the largest value of the jth – coordinate among all nodes in F(X
                              (0)), i.e., 
                                 
                                    
                                       X
                                       j
                                       M
                                    
                                    ←
                                    max
                                    
                                       {
                                       
                                          X
                                          j
                                       
                                       
                                       ;
                                       
                                       ∀
                                       
                                       X
                                       ∈
                                       F
                                       
                                          (
                                          
                                             X
                                             
                                                (
                                                0
                                                )
                                             
                                          
                                          )
                                       
                                       }
                                    
                                    ,
                                 
                               for all 
                                 
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    r
                                 
                              . Hence, 
                                 
                                    
                                       X
                                       
                                          (
                                          M
                                          )
                                       
                                    
                                    =
                                    
                                       (
                                       
                                          X
                                          1
                                          M
                                       
                                       ,
                                       …
                                       ,
                                       
                                          X
                                          r
                                          M
                                       
                                       )
                                    
                                 
                               defines a point in 
                                 
                                    R
                                    r
                                 
                              . Finally, construct the solution 
                                 
                                    
                                       S
                                       M
                                    
                                    =
                                    
                                       S
                                       *
                                    
                                    −
                                    
                                       X
                                       
                                          (
                                          0
                                          )
                                       
                                    
                                    +
                                    
                                       X
                                       
                                          (
                                          M
                                          )
                                       
                                    
                                 
                              .

Notice that,

                                 
                                    (2)
                                    
                                       
                                          Z
                                          
                                             (
                                             
                                                S
                                                *
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                ∉
                                                F
                                                (
                                                
                                                   X
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             ω
                                             i
                                          
                                          g
                                          
                                             (
                                             i
                                             ,
                                             
                                                S
                                                *
                                             
                                             )
                                          
                                          +
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                F
                                                (
                                                
                                                   X
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             ω
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                          g
                                          
                                             (
                                             i
                                             ,
                                             
                                                X
                                                
                                                   (
                                                   0
                                                   )
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           

If we let 
                                 
                                    C
                                    =
                                    
                                       ∑
                                       
                                          i
                                          ∉
                                          F
                                          (
                                          
                                             X
                                             
                                                (
                                                0
                                                )
                                             
                                          
                                          )
                                       
                                    
                                    
                                       ω
                                       i
                                    
                                    g
                                    
                                       (
                                       i
                                       ,
                                       
                                          S
                                          *
                                       
                                       )
                                    
                                 
                               then, using an 
                                 
                                    
                                       L
                                       k
                                    
                                    −
                                 
                              Norm, the expression above becomes

                                 
                                    (3)
                                    
                                       
                                          Z
                                          
                                             (
                                             
                                                S
                                                *
                                             
                                             )
                                          
                                          =
                                          C
                                          +
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                F
                                                (
                                                
                                                   X
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             ω
                                             i
                                          
                                          g
                                          
                                             (
                                             i
                                             ,
                                             
                                                X
                                                
                                                   (
                                                   0
                                                   )
                                                
                                             
                                             )
                                          
                                          =
                                          C
                                          +
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                F
                                                (
                                                
                                                   P
                                                   0
                                                
                                                )
                                             
                                          
                                          
                                             ω
                                             i
                                          
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   r
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         j
                                                         
                                                            (
                                                            0
                                                            )
                                                         
                                                      
                                                      −
                                                      
                                                         X
                                                         j
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                      
                                                      )
                                                   
                                                   k
                                                
                                             
                                             k
                                          
                                       
                                    
                                 
                              and, equivalently,

                                 
                                    (4)
                                    
                                       
                                          Z
                                          
                                             (
                                             
                                                S
                                                M
                                             
                                             )
                                          
                                          =
                                          C
                                          +
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                F
                                                (
                                                
                                                   X
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             ω
                                             i
                                          
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   r
                                                
                                                
                                                   
                                                      (
                                                      
                                                         X
                                                         j
                                                         
                                                            (
                                                            M
                                                            )
                                                         
                                                      
                                                      −
                                                      
                                                         X
                                                         j
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                      
                                                      )
                                                   
                                                   k
                                                
                                             
                                             k
                                          
                                       
                                    
                                 
                              
                           

Therefore, the difference in costs is given by

                                 
                                    (5)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   Z
                                                   
                                                      (
                                                      
                                                         S
                                                         M
                                                      
                                                      )
                                                   
                                                   −
                                                   Z
                                                   
                                                      (
                                                      
                                                         S
                                                         *
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   
                                                   =
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         F
                                                         (
                                                         
                                                            X
                                                            
                                                               (
                                                               0
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                   
                                                      ω
                                                      i
                                                   
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               ∑
                                                               
                                                                  j
                                                                  =
                                                                  1
                                                               
                                                               r
                                                            
                                                            
                                                               
                                                                  (
                                                                  
                                                                     X
                                                                     j
                                                                     
                                                                        (
                                                                        M
                                                                        )
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     X
                                                                     j
                                                                     
                                                                        (
                                                                        i
                                                                        )
                                                                     
                                                                  
                                                                  )
                                                               
                                                               k
                                                            
                                                         
                                                         k
                                                      
                                                      −
                                                      
                                                         
                                                            
                                                               ∑
                                                               
                                                                  j
                                                                  =
                                                                  1
                                                               
                                                               r
                                                            
                                                            
                                                               
                                                                  (
                                                                  
                                                                     X
                                                                     j
                                                                     
                                                                        (
                                                                        0
                                                                        )
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     X
                                                                     j
                                                                     
                                                                        (
                                                                        i
                                                                        )
                                                                     
                                                                  
                                                                  )
                                                               
                                                               k
                                                            
                                                         
                                                         k
                                                      
                                                      
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              which, by construction of X
                              (M), implies that 
                                 
                                    Z
                                    
                                       (
                                       
                                          S
                                          M
                                       
                                       )
                                    
                                    −
                                    Z
                                    
                                       (
                                       
                                          S
                                          *
                                       
                                       )
                                    
                                    <
                                    0
                                    ,
                                 
                               which is a contradiction as we defined S
                              * to be an optimal solution. This is true as the summation terms inside the square roots in (5) are, for each j, non-larger in the first term than in the second and, at least in one dimension, they are strictly smaller.

Therefore X
                              (0) ∉ S
                              * as ∃X
                              (M) which yields a smaller value of the objective function than X
                              (0). That X
                              (M) ∈ M follows directly from algorithm Construct. This concludes the proof.□


                              A component commonality problem defined in a general space can be written as a problem where the set of potential specifications is finite. Hence, we can define the problem MDCC as
                              
                                 
                                    (6)
                                    
                                       
                                          
                                             min
                                             
                                                S
                                                ⊆
                                                M
                                                ,
                                                
                                                   |
                                                   S
                                                   |
                                                
                                                ≤
                                                K
                                             
                                          
                                          Z
                                          
                                             (
                                             S
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                N
                                             
                                          
                                          
                                             ω
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                          g
                                          
                                             (
                                             i
                                             ,
                                             S
                                             )
                                          
                                       
                                    
                                 
                              
                           


                              Problem MDCC 
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                S
                                                ⊆
                                                M
                                                ,
                                                
                                                   |
                                                   S
                                                   |
                                                
                                                ≤
                                                K
                                             
                                          
                                          Z
                                          
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                 
                              
                              is mathematically equivalent to the k-median problem, thus, all the tools available to solve this problem are available to solve the MDCC. That is, if we refer to each of the K components to be manufactured as a facility, then the MDCC problem consists of locating K facilities such that the weighted distance from each node (product) to the closest facility is minimised. The relevant distances are given by matrix g(i, j) for i ∈ N and j ∈ M, where N is the set of nodes and M the set of potential facility locations.
                           

A natural consequence of Corollary 2 is that the maximization version of the MDCC, whose formulation is straightforward and therefore omitted here, shares the submodularity property of the k-median problem as well as its monotonicity. This notion is put formally in Property 1. For the minimization version, although no fixed bound is known, numerical results have shown that a greedy algorithm performs very well (see for example Berman, Krass, and Menezes (2007) and Nemhauser, Wolsey, and Fisher (1978)).

                           Property 1
                           
                              The greedy algorithm applied to the maximization version of the MDCC induces an objective function value which is not further away from 37% of the optimal value (See proof in 
                              Nemhauser et al. (1978)).

Unfortunately, the high dimensionality of the MDCC may hinder the application of the standard Greedy Algorithm. In its worst case, set M’s cardinality is 
                        
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              
                                 max
                                 {
                                 |
                                 N
                                 |
                                 ,
                                 r
                                 }
                              
                           
                           
                              (
                              
                                 
                                    |
                                    N
                                    |
                                 
                                 i
                              
                              )
                           
                           ,
                        
                      i.e. |M| ∈ O(2|N|), suggesting that a problem that grows exponentially in the number of nodes, which in turn grows exponentially on its basic input, is indeed very hard. For example, in problems with 100 nodes (specifications), whose attributes are taken from the set of natural numbers, we find the cardinality of M to be, on average, around 1500. If, instead, the number of nodes is 150, then the average cardinality of M grows to 2400. Moreover, if the specifications are taken from the set of real numbers then the cardinality of M can get close to 10, 000.


                     Fig. 4
                      illustrates how, even apparently simple instances may hide a very large set M. In that figure, the larger solid circles are products, (set N); whereas the smaller (1517) solid circles are the relevant specifications that constitute set M. Dashed vertical and horizontal lines in the specification space mark all specification values that crosses a point in M.

In order to address the complexity problem of the MDCC, in Section 4 we present an algorithmic approach based on the standard greedy algorithm that, whilst preserving the greedy nature, avoids the necessary evaluation of all the points in M that the standard greedy approach requires.

In this section, we present a collection of algorithms designed to find an efficient solution to the MDCC overcoming its dimensionality limitations. In order to do so, we first present a couple of observations that will help us to formalize our greedy approach. Our approach takes advantage of the submodularity property of the set function, and delivers algorithms that are both efficient and effective.

                        Observation 1
                        
                           There exists a point
                           
                              
                                 
                                    P
                                    ^
                                 
                                 ∈
                                 M
                              
                            
                           such that, a specification
                           
                              
                                 P
                                 ^
                              
                            
                           will satisfy the requirements of all the products in N and, consequently,
                           
                              
                                 Z
                                 
                                    (
                                    
                                       {
                                       
                                          P
                                          ^
                                       
                                       }
                                    
                                    )
                                 
                                 <
                                 ∞
                              
                           . Moreover,
                           
                              
                                 P
                                 ^
                              
                            
                           is possibly in N.

This is true by construction of set M. See algorithm Construct and Fig. 3.□


                           If
                           
                              
                                 
                                    P
                                    ^
                                 
                                 ∈
                                 N
                              
                            
                           then either
                           
                              
                                 
                                    P
                                    ^
                                 
                                 ∈
                                 
                                    S
                                    *
                                 
                              
                            
                           or
                           
                              
                                 Z
                                 (
                                 
                                    S
                                    *
                                 
                                 )
                                 =
                                 ∞
                              
                           .


                           Observation 2 is straight forward. If the upper right corner of the feature space has a product then, unless there is a specification satisfying its requirements, the product will have to use a specification that is either (or both) at its left or below it, which implies an infinitely large cost, see Fig. 3.□

Following the two observations above, in the subsections below we introduce two Greedy-type algorithms. From Observation 1, we see that any myopic procedure will start by placing the first member of the solution set on point 
                        
                           P
                           ^
                        
                     . Since in a greedy approach there is no backtracking, a traditional greedy algorithm (to be formalized below) starts with the handicap of being forced to place a new component in that position. From Observation 2, we have that such move is only necessary if 
                        
                           
                              P
                              ^
                           
                           ∈
                           N
                        
                      or, again from Observation 1, if 
                        
                           |
                           S
                           |
                           =
                           1
                        
                     . Clearly, only specifications in set M need to be considered.

Thus, in addition to the analysis of a traditional greedy algorithm, we develop an alternative greedy approach –called the Steepest Descent Greedy algorithm- that, without backtracking, avoids the shortcomings of the traditional procedure. The reason for our focus on greedy type algorithmic constructions lies on the fact that years of work with the median problem (see Corollary 2 to Theorem 1), have witnessed the outstanding performance of the greedy approaches, which is probably due to the submodularity property of the median problem (see Property 1).

We start by discussing a suitable version of the standard greedy algorithm. In what follows we will refer to this as the traditional greedy algorithm (TG). The TG algorithm is presented in Fig. 5
                        . In each iteration, a new additional specification is added to the current solution set STG
                        . That is, we add a specification s ∈ M such that Z(STG
                         ∪ {s}) is minimized.

Algorithm TG works very well for small problems. However, the need for calculating set M brings computational burden that may hinder the application of the TG algorithm on some practical situations (please see the discussion around Property 1). For example, instances of about 100 models defined in a 3-dimensional specifications space are already too large to be solved in most computers.

In order to address the complexity problem due the size of the input to algorithm TG, in the following section we propose a family of algorithms with greedy structure which avoid the need of a complete inspection of set M.

In this section we focus on improving performance of the greedy algorithm whilst maintaining a greedy-type structure.

Before proceeding with the description of our algorithmic approach, it is convenient to introduce some notation that will be used in the algorithm. We start defining, the solution set 
                           
                              S
                              =
                              {
                              
                                 S
                                 1
                              
                              ,
                              …
                              ,
                              
                                 S
                                 K
                              
                              }
                              ,
                           
                         where 
                           
                              
                                 S
                                 i
                              
                              =
                              
                                 (
                                 
                                    S
                                    
                                       i
                                       ,
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    S
                                    
                                       i
                                       ,
                                       r
                                    
                                 
                                 )
                              
                              ,
                              
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                        . Solution set S is defined as a multiset; i.e., multiple copies of a same member are allowed. We now introduce, for each 
                           
                              j
                              =
                              1
                              ,
                              …
                              ,
                              r
                              ,
                           
                         a vector 
                           
                              
                                 u
                                 j
                              
                              =
                              
                                 (
                                 
                                    x
                                    j
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 )
                              
                              ,
                              
                              ∀
                              i
                              ∈
                              N
                           
                        ; namely, uj
                         is a vector composed by the jth coordinate of all nodes in N; Without any loss of generality, we sort the elements of uj
                         such that 
                           
                              
                                 u
                                 1
                                 j
                              
                              ≥
                              
                                 u
                                 2
                                 j
                              
                              ≥
                              …
                              
                              ≥
                              
                                 u
                                 r
                                 j
                              
                           
                        ; and remove any multiplicity in order to obtain 
                           
                              
                                 u
                                 1
                                 j
                              
                              >
                              
                                 u
                                 2
                                 j
                              
                              >
                              …
                              
                              >
                              
                                 u
                                 
                                    k
                                    j
                                 
                                 j
                              
                              ,
                           
                         where kj
                         ≤ |N|. In other words, each vector uj
                         has kj
                         elements.

With these elements we can now define 
                           
                              
                                 I
                                 
                                    i
                                    j
                                 
                              
                              
                                 (
                                 S
                                 )
                              
                              =
                              k
                           
                         when 
                           
                              
                                 S
                                 
                                    i
                                    j
                                 
                              
                              =
                              
                                 u
                                 k
                                 j
                              
                           
                        . That is, I is an inverse function with domain in S that returns the position of value Sij
                         in vector uj
                        . We finally introduce function F(S, i, j), which changes the jth-element of the ith-member of the solution set, S, in the following manner:

                           
                              
                                 
                                    F
                                    
                                       (
                                       S
                                       ,
                                       i
                                       ,
                                       j
                                       )
                                    
                                    =
                                    
                                       S
                                       ^
                                    
                                    
                                    where
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         S
                                                         ^
                                                      
                                                      t
                                                   
                                                   =
                                                   
                                                      S
                                                      t
                                                   
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   t
                                                   =
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   K
                                                   ;
                                                   t
                                                   ≠
                                                   i
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         S
                                                         ^
                                                      
                                                      
                                                         i
                                                         k
                                                      
                                                   
                                                   =
                                                   
                                                      S
                                                      
                                                         i
                                                         k
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   k
                                                   =
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   
                                                   r
                                                   ;
                                                   k
                                                   ≠
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         S
                                                         ^
                                                      
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   =
                                                   
                                                      u
                                                      
                                                         
                                                            I
                                                            
                                                               i
                                                               j
                                                            
                                                         
                                                         +
                                                         1
                                                      
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      I
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      (
                                                      S
                                                      )
                                                   
                                                   <
                                                   
                                                      k
                                                      j
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         S
                                                         ^
                                                      
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   =
                                                   
                                                      S
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   ,
                                                
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                    
                                    ,
                                 
                              
                           
                        The first term in F indicates that, every time a new specification i is tested, only the element in S corresponding to that particular specification changes. The second term indicates that only coordinate j of Si
                         must change, while all the other coordinates remain the same. If there are specifications in M, in the direction indicated by j, left to be evaluated, the third term in F indicates that the corresponding coordinate Sij
                         must be updated with the next largest value in uj
                        . Finally, if there are no specifications available, then the coordinates of Si
                         remain the same.

Once the main notation has been described, we can now introduce our algorithmic approach, henceforth referred to as the Steepest Descent Greedy Algorithm (SDG). This approach is built upon three different actions, namely, (a) place nodes in a selected point in the network; (b) move nodes according to certain rule in the direction of largest improvement; and (c) repeat the last action, either place or move. Based on these three actions, four variants of the SDG algorithm are proposed. Each of them is characterized by the string SDGαβ, where α ∈ {a, s} indicates if the evaluations are based either on absolute values (a) or on the slope of the improvements (s). On the other hand, β ∈ {1, 2} identifies two alternative variations for each value of α.

The first variant of the SDG algorithm is labelled as SDGa1 and is illustrated in Fig. 6
                        
                        . In this variant, action place locates K copies of a specification in a point where a single component can serve all models at minimum cost, generating the solution 
                           
                              S
                              =
                              {
                              
                                 p
                                 ^
                              
                              ,
                              …
                              ,
                              
                              
                                 p
                                 ^
                              
                              }
                           
                         where 
                           
                              
                                 p
                                 ^
                              
                              =
                              
                                 (
                                 
                                    u
                                    1
                                    j
                                 
                                 |
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 
                                 r
                                 )
                              
                           
                        . Immediately after, the algorithm selects the first element of S, S
                        1, and action move is performed, moving the selected element in the direction j that induces the largest reduction in the objective function. Formally, the algorithm performs a move from S to F(S, i, j′) if 
                           
                              
                                 j
                                 ′
                              
                              =
                              
                                 arg
                                 
                                    j
                                    ∈
                                    {
                                    1
                                    ,
                                    …
                                    ,
                                    r
                                    }
                                 
                              
                              
                              minimizes
                              
                              Z
                              
                                 (
                                 F
                                 (
                                 S
                                 ,
                                 i
                                 ,
                                 j
                                 )
                                 )
                              
                           
                        . Once element Si
                         is moved (or not if no improvement is obtained) action repeat is performed. Repeat starts by selecting the next element of S and the process is repeated performing action move. This sequence is repeated until no additional node can be moved with improvement in the value of the objective function. The resulting specifications are the components that solve the commonality problem.

Algorithm SDGa1 moves each node in the specification space at a time. A maximum of K elements will be moved at most 
                           
                              
                                 ∏
                                 
                                    j
                                    =
                                    1
                                 
                                 r
                              
                              
                                 r
                                 j
                              
                              ≤
                              
                                 n
                                 r
                              
                           
                         times each for 
                           
                              n
                              =
                              |
                              N
                              |
                           
                        . Each move requires, at most, r 
                        K tests. Thus, the algorithm complexity is 
                           
                              O
                              (
                              K
                              
                              r
                              
                              
                                 n
                                 r
                              
                              )
                           
                        .

The second variant of the algorithm is labelled SDGa2. It is very similar to SDGa1 with the exception that after moving specification Si
                        , action repeat goes back to move until Si
                         cannot be moved without a negative impact on the value of the objective function. At this point, repeat changes focus from Si
                         to 
                           
                              S
                              
                                 i
                                 +
                                 1
                              
                           
                         and requests action move to be repeated until no further improvement in the objective function value is possible. The algorithm keeps following this same logic until no specification can be moved without reducing the objective function’s value. The pseudo-code of this algorithm, as well as the one of each of the other variants, follows the same lines of algorithm SDFa1 and is therefore omitted.

In short, SDGa1 moves a specification once, and only once, at a time, before trying the next component. Alternatively, SDGa2 keeps moving the same specification until no further improvement in the objective function can be attained, or the specification cannot be moved any further.

As it can be seen, the step improvements in variants SDGa1 and SDGa2 are based on the absolute value of the objective function, when it is evaluated during action move. Alternatively, algorithms of the family SDGsβ, described below, seek to maximize the relative improvement attained by each subsequent movement.

Algorithm SDGs1 starts locating two copies of a specification at point 
                           
                              p
                              ^
                           
                        . It performs action move westwards and downwards towards the origin, searching for the attributes that maximise

                           
                              
                                 
                                    −
                                    
                                       
                                          Z
                                          (
                                          S
                                          )
                                          −
                                          Z
                                          (
                                          F
                                          (
                                          S
                                          ,
                                          i
                                          ,
                                          j
                                          )
                                          )
                                       
                                       
                                          
                                             S
                                             
                                                i
                                                j
                                             
                                          
                                          −
                                          F
                                          
                                             
                                                (
                                                S
                                                ,
                                                i
                                                ,
                                                j
                                                )
                                             
                                             
                                                i
                                                j
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        At any point where no improvement is possible, one more specification is co-located together with one of the existing components and repeat requests the procedure to perform action move as described above. The routine is repeated until no negative slope can be obtained.

Finally, algorithm SDGs2 is similar to SDGs1 except that function F(S, i, j) is modified in order to allow all 2 × r directions (i.e. toward and away from origin) to be tested. It can be seen, that SDGs1 performs better -in terms of CPU time- than SDGs2; however, there is no dominance in the solutions’ quality between these two algorithms.

In the following section, we compare quality of the solutions and computational times of the two greedy heuristics and their variants.

In this section we evaluate the performance of the four variants of the SDG algorithm and compare them against the traditional greedy algorithm.

All tests were carried out in a MacBookPro with a 2.6 GegaHertz Intel Core i7 processor, 8GegaByte memory (1600 MegaHertz) DDR3. The algorithms were coded in Wolfram’s Mathematica V.9. Mathematica uses an interpreted language which is slower than compiled languages. Thus, computation times can be further improved if a compiled language is used. However, the relative performance of the algorithms is not expected to present great variations.

For our analysis we use a two-dimensional specification space for the definition of the products. Each instance consists of a collection of products, each of them represented by two coordinates in the specification space. Coordinates are obtained as random extractions from certain probability distribution.

We first compare the performance of the algorithms discussed in Section 4 using a uniform integer distribution with support in 
                        
                           {
                           0
                           ,
                           
                           1
                           ,
                           …
                           ,
                           100
                           }
                        
                     . The results are illustrated in Figs. 7 and 8
                     .

In Fig. 7, we present the results of a single instance consisting of 100 products with positive demand. The result is representative of what would be obtained from a larger set of instances and it makes it easier to discuss some important issues. The plot on the left hand side depicts the value objective function different cases with the number of components (K) ranking from 1 to 10; the plot on the right hand side shows the CPU time required for solving each case.

The first point to attract attention to is the time taken by the TG algorithm to solve an instance. TG is an order of magnitude more expensive in terms of computational time than the other four algorithms. Moreover, the computer time increases at faster rate on the number of components than with the other four algorithms.

It is also important to remark the fact that the TG algorithm solution dominates all other four, as it can be seen in the right hand side panel of Fig. 7. This dominance becomes more evident as the number of components increases. Unfortunately, it is precisely for larger number of components when TG’s computational time increases dramatically. In our experiments, it prove difficult to obtain results for instances with a number of products larger than 100, using the TG algorithm. Moreover, in those cases when the product’s requirements were taken from the real numbers instead than from the integers, the TG algorithm presented problems and lost stability.

For example, in Fig. 8, where specifications were drawn from the set of real numbers, it was not possible to use algorithm TG. Fig. 8 does not reveal a clear dominance of any of the algorithms. In fact, we have seen that all four algorithms were the best for some particular instance in our tests. However, when the number of complements increases, we can see that algorithms of the family SGsβ, perform better in terms if the solution’s quality. On the other hand, algorithms of the family SDGa2 show better performance in terms of computational time.

The second part of the numerical assessment consisted on testing the proposed SDG algorithms on larger instances (in terms of number of products). Table 1
                      presents the statistics for 20 randomly generated instances for each combination of number of products and components from the sets {200, 300, 400} and {3, 6, 9, 12}, respectively. Rows are organised by number of products and columns are grouped by the algorithm used and further subdivided by number of components. The results, for the case of variant SDGs1, are measured in distance units for the case of the objective function value (upper-half of the table); and in seconds for the case of CPU time (lower-half of the table). For all the other variants, the numbers presented in the body of the table are percentages of those obtained from variant SDGs1, which was used as baseline.

All instances were generated in a 100 × 100 square where each product’s coordinates are real numbers in the interval [0, 100]. Demands were randomly extracted and then normalized to 1. Consequently, the larger is the number of models, the denser becomes the square and more diluted becomes the demand. The results shown in Table 1 provide an understanding of the effect of these factors when the number of components remains constant.


                     Table 1 shows an interesting result, related to the idea of economies of scale in economic theory: as the number of products increases, for a fixed number of components, the expected cost increases at a decreasing rate. This is so because, as the number of products increase, there is less concentration of demand –in expectation- for any particular component. Thus, doubling the number of products does not double costs. Also, as the number of components increase (please see SDGs1 columns) the total costs decrease at a decreasing rate, a fact that is related to the economic notion of decreasing returns to scale. An important consequence of this is that, if the fixed cost of introducing one extra component is high enough, it is easy to determine the optimal number of components, K, to be introduced.

Regarding algorithmic performance, we have that the larger the number of components, the better SDGs1 performs with respect to SDGa1 and SDGa2. But it is not possible to extract a clear pattern of relative performance between SDGs1 and SDGs2. Notwithstanding, for large number of components, SDGs1 always outperforms SDGs2. On the other hand, we can see that the relative performance of each algorithm, with respect to SDGs1, does not seem to follow any trend as the number of models increase.

In terms of CPU time, it is clear that the SDGs variants are outperformed by the SDGa algorithms. On the other hand, SDGa2 seems to perform better than SDGs1 as the number of components increases. Overall, even though the computational times grow at increasing rate with both, the number of components and the number of products, this rate does not seem to be very rapid.

Finally to complete the numerical assessment of our algorithmic approach, we present the solution of a 3-dimensional instance. The example consists of 50 products (represented by blue nodes) extracted from the real interval (0, 100). This set unfolds into 913 relevant points (red nodes), making a total of 963 candidate specifications. This instance is illustrated in the left hand side of Fig. 9. The weight (demand) of each product was randomly extracted from a uniform distribution defined between 0.2 and 0.6. Once all weights were generated, their values were normalised.


                     Fig. 10
                      shows the objective function value for a number of parts ranking between 2 and 12. The legends are the same as in Figs. 7 and 8 and have been omitted for the sake of clarity. The solution for the case of 12 components, is illustrated in the right hand side graph of Fig. 9. The solid cubes represent the selected specifications.

These results illustrate the strength of our approach: whereas the traditional greedy algorithm can hardly handle two dimensional problems with no more than 100 or 150 different products, the SDG algorithm can easily address multidimensional problems with a reasonably large (realistic) number of inputs. Notwithstanding that the computing time will still grow considerably, it is remarkable that our approach can still handle very large problems.

MathHeuristics are heuristics that include the optimization of a sub-problem in the process of finding a good solution for a particular problem. In this section we present a MathHeuristic that improves substantially the performance of the algorithms discussed in Section 4.2, in particular the one of algorithm SDGs2. It consists of starting the heuristic by solving (near) to optimality a smaller problem, instead of considering all the points in set M as suggested before (please see Section 3.1 and the discussion around algorithm Construct in Fig. 2).

The process works as follows. We consider only those points that represent the requirements of the incumbent products as potential specifications for the components, i.e. set N. Moreover, in order to guarantee the existence of a feasible solution, we increase set N with the point 
                           
                              p
                              ^
                           
                         in the northeast corner of the specification space, i.e. 
                           
                              
                                 N
                                 ¯
                              
                              =
                              N
                              ∪
                              
                                 p
                                 ^
                              
                           
                         (notice that point 
                           
                              p
                              ^
                           
                         is obtained during the first iteration of algorithm Construct, please see the discussion around Fig. 3). Using set 
                           
                              N
                              ¯
                           
                         as input, the smaller start-up problem (
                           
                              
                                 |
                                 
                                    N
                                    ¯
                                 
                                 |
                              
                              =
                              
                                 |
                                 N
                                 |
                              
                              +
                              1
                           
                        ) aims at finding an optimal initial placement of the K components.

The initial optimization can be conducted using Lagrangian relaxation with sub-gradient search method, which usually converges to a solution that fosters an objective value within a fraction ϵ of the optimal. The heuristic then continues executing the WHILE loop -see the pseudo-code presented on Fig. 6.


                        Fig. 11
                         illustrates the performance of SDGs2 with warm-start with an extra solid line that nearly-dominates all others. In tests with smaller instances it clearly dominates the traditional greedy algorithm, TG. A minor inconvenience of the warm-start lies on the extra time required to solving the Lagrangian relaxation, however, for relatively large instances this should not be an issue. For large problems - about thousand nodes - the Lagrangian problem converges in few minutes. Unfortunately, convergence is not always guaranteed and for problems beyond 1000 nodes there is, although not very frequently, a stability problem that may eventually halt the computation.

@&#CONCLUSION@&#

In this paper, we addressed the component commonality problem with multiple attributes in a real valued attribute space. In order to do so, we introduced the Multidimensional Component Commonality (MDCC) problem, which solves the problem of finding a set of components that satisfy the requirements of a collection of products at a minimal cost. Our manuscript extends the available literature by introducing a multidimensional approach where the different attributes of the common component can take either discrete or continuous values in certain interval of the real line.

The problem, as formulated, possesses certain structural properties which allow the utilization of a finite set of potential points in the specification space. Moreover, we show that the MDCC is equivalent to the k-median problem and, consequently, all the tools available for the k-median can be used to solve the MDCC. In particular, we show that greedy type algorithms can provide good quality solutions to our problem in reasonable time.

As the high dimensionality of the MDCC problem hinders the application of the standard greedy algorithm, we present an algorithmic approach that, whilst preserving the greedy structure, reduces the number of points that need to be visited in order to find a solution to the problem. We offer four variants of the so called steepest descent greedy algorithm, two of them focus on the absolute improvement of the objective function value at each step, while the other two concentrate on the relative improvement attained by each subsequent movement. We additionally provide a warm-start MathHeuristic that, in most cases, may help to improve the performance of the above mentioned heuristics.

Numerical evaluation confirms that, even though for small instances the traditional greedy algorithm performs better than the proposed alternatives, when the size of the problem grows to more realistic dimensions the traditional greedy becomes prohibitively expensive in terms of computing time. This fact underlines the relevance of our approach, as the proposed algorithms present important savings in computing time without important losses in the solution’s quality. Moreover, our approach is capable of solving multidimensional instances with a realistic number of inputs within reasonable time.

There are some important practical implications of the contributions presented in this paper. The most evident one is that it allows addressing problems of high dimensionality with continuous-valued features. A less evident, but no less relevant, is that it brings the possibility of moving from product-design decisions (component-commonality) to a combination of product-design/diversity-management decisions, shifting the problem from a cost minimization perspective to a profit maximization point of view. This issue will be further discussed below, with the future research directions.

To conclude, the MDCC addresses aspects of the component commonality problem that so far remained unattended in the literature, providing an efficient framework to solve the problem in a multidimensional feature space with real valued attributes. However, there are questions that remain open for future research in the multidimensional component commonality problem. In particular, we would like to call attention to the following aspects that should be further investigated:

                        
                           •
                           The interaction between different attributes in a single component has not been completely addressed. Although the use of different Lk
                              -norms may be a proxy for some cases, there are certainly situations where interactions between features appear in very complex ways. For example, weight and width of a part may have a convoluted relationship, not allowing Lk
                              -norms to approximate the problem with sufficient accuracy.

The formulation can also be extended to frameworks where one product may have different components subject to commonality. That is, a horizontal–vertical analysis of commonalities among products, or across and within parts of the same product. In the computer industry, for example, different final products use common components (e.g. motherboards or hard drives in different computer models). At the same time, in the motherboard of a particular computer model, there may be different parts that use similar circuits which could also benefit from component commonality analysis.

The contribution presented herein may allow for new formulations that combine a product diversity problem with a component commonality problem. The result should be the complete design and specification of the product portfolio that the firm will offer to the market. In such framework, the proposed mathematical model should incorporate, at one level, information about the demand of each version as a function of both its price and the attributes conferred by its components. At a different level, the cost function must take into consideration the solution of a component commonality problem in the product mix. In overall, the formulation is conceived as a profit maximization problem. This is a challenging research direction, positioned in the interface between marketing, product development and operations research, a mix that adds yet another layer of complexity to the problem.

@&#REFERENCES@&#

