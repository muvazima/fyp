@&#MAIN-TITLE@&#A robust and efficient method for estimating enzyme complex abundance and metabolic flux from expression data

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A new algorithm can estimate enzyme abundance using gene–protein-reaction rules.


                        
                        
                           
                           A new algorithm uses enzyme abundance to quickly estimate fluxes.


                        
                        
                           
                           The flux estimates enjoy comparably superior predictivity and good robustness.


                        
                        
                           
                           Software packages with modular implementations are available for the algorithms.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

@&#ABSTRACT@&#


               
               
                  A major theme in constraint-based modeling is unifying experimental data, such as biochemical information about the reactions that can occur in a system or the composition and localization of enzyme complexes, with high-throughput data including expression data, metabolomics, or DNA sequencing. The desired result is to increase predictive capability and improve our understanding of metabolism. The approach typically employed when only gene (or protein) intensities are available is the creation of tissue-specific models, which reduces the available reactions in an organism model, and does not provide an objective function for the estimation of fluxes. We develop a method, flux assignment with LAD (least absolute deviation) convex objectives and normalization (FALCON), that employs metabolic network reconstructions along with expression data to estimate fluxes. In order to use such a method, accurate measures of enzyme complex abundance are needed, so we first present an algorithm that addresses quantification of complex abundance. Our extensions to prior techniques include the capability to work with large models and significantly improved run-time performance even for smaller models, an improved analysis of enzyme complex formation, the ability to handle large enzyme complex rules that may incorporate multiple isoforms, and either maintained or significantly improved correlation with experimentally measured fluxes. FALCON has been implemented in MATLAB and ATS, and can be downloaded from: https://github.com/bbarker/FALCON. ATS is not required to compile the software, as intermediate C source code is available. FALCON requires use of the COBRA Toolbox, also implemented in MATLAB.
               
            

@&#INTRODUCTION@&#

FBA (flux balance analysis) is the oldest, simplest, and perhaps most widely used linear constraint-based metabolic modeling approach (Shestov et al., 2013; Lewis et al., 2012). FBA has become extremely popular, in part, due to its simplicity in calculating reasonably accurate microbial fluxes or growth rates (e.g. Schuetz et al., 2012; Fong and Palsson, 2004); for many microbes, a simple synthetic environment where all chemical species are known suffices to allow proliferation, giving fairly complete constraints on model inputs. Additionally, it has been found that their biological objectives can be largely expressed as linear objectives of fluxes, such as maximization of biomass (Schuetz et al., 2012). Neither of these assumptions necessarily hold for mammalian cells growing in vitro or in vivo, and in particular the environment is far more complex for mammalian cell cultures, which have to undergo gradual metabolic adaptation via titration to grow on synthetic media (Pirkmajer and Chibalin, 2011). Recently, there have been many efforts to incorporate both absolute and differential expression data into metabolic models (Blazier and Papin, 2012). The minimization of metabolic adjustment (MoMA; Segrè et al., 2002) algorithm is the simplest metabolic flux fitting algorithm, and it can be extended in order to allow the use of absolute expression data for the estimation of flux (Lee et al., 2012), which is the approach taken in this study. A different approach for using expression in COBRA, also very simple, is E-flux, which simply uses some function of expression (chosen at the researcher's discretion; typically a constant multiplier of expression) as flux constraints (Colijn et al., 2009). Despite this surprising simplicity, the method has found many successful applications, but the user-chosen parameter and use of expression as hard constraints is, in our opinion, a detraction, and others have had better results taking an approach similar to Lee et al. (2012) (Bogart and Myers, in press).

The MoMA method, framed as a constrained least-squares optimization problem, is typically employed to calculate the flux vector of an in silico organism after a mutation by minimizing the distance between the wild-type flux and the mutant flux. The biological intuition is that the organism has not had time to adapt to the restricted metabolic capacity and will maintain a similar flux to the wild-type (WT) except where the perturbations due to the mutation dictate necessary alterations in fluxes (Shlomi et al., 2005). Suppose a is the WT flux vector obtained by an optimization procedure such as FBA, empirical measurements, or a combination of these. For an undetermined flux vector v in a model with N reactions the MoMA objective can be expressed as


                     
                        
                           (1)
                           
                              minimize
                              
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 N
                              
                              
                                 
                                    (
                                    
                                       v
                                       i
                                    
                                    −
                                    
                                       a
                                       i
                                    
                                    )
                                 
                                 2
                              
                           
                        
                     subject to the stoichiometric constraints Sv
                     =
                     0 where 
                        
                           
                              v
                           
                        
                        =
                        
                           
                              (
                              
                                 v
                                 1
                              
                              ,
                              …
                              ,
                              
                                 v
                                 N
                              
                              )
                           
                           T
                        
                      and S is the stoichiometric matrix (rows correspond to metabolites, columns to reactions, and entries to stoichiometric coefficients). Constant bounds on fluxes are often present, such as substrate uptake limits, or experimental V
                     max estimates, so we write these as the constraints v
                     
                        lb
                     
                     ⪯
                     v
                     ⪯
                     v
                     
                        ub
                     . The objective may be equivalently expressed in the canonical quadratic programming (QP) vector form as min. (1/2)v
                     
                        T
                     
                     v
                     −
                     a
                     
                        T
                     
                     v. This assumes that each a
                     
                        i
                      is measured, but it is also possible and sometimes even more useful to employ this objective when only a subset of the a
                     
                        i
                      are measured (if a
                     
                        i
                      is not measured for some i, then we omit 
                        
                           
                              (
                              
                                 v
                                 i
                              
                              −
                              
                                 a
                                 i
                              
                              )
                           
                           2
                        
                      from the objective). In metabolomics, for instance, it is always the case in experiments with labeled isotope tracers that only a relatively small subset of all fluxes are able to be estimated with metabolic flux analysis (MFA; Shestov et al., 2013). Combining MoMA with MFA provides a technique to potentially estimate other fluxes in the network.

A variant of MoMA exists that minimizes the absolute value of the difference between a
                     
                        i
                      and 
                        
                           v
                           i
                        
                      for all known a
                     
                        i
                     . To the best of our knowledge, the following linear program is the simplest version of linear MoMA, which assumes the existence of a constant flux vector a:


                     
                        
                           (2)
                           
                              
                                 
                                    
                                       minimize
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          N
                                       
                                       
                                          d
                                          i
                                       
                                    
                                 
                                 
                                    
                                       subject to
                                    
                                    
                                       
                                          
                                             
                                                S
                                                v
                                             
                                          
                                       
                                       =
                                       
                                          
                                             0
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                v
                                             
                                          
                                          lb
                                       
                                       ⪯
                                       
                                          
                                             v
                                          
                                       
                                       ⪯
                                       
                                          
                                             
                                                v
                                             
                                          
                                          ub
                                       
                                    
                                 
                                 
                                    
                                       ∀
                                       i
                                       :
                                    
                                    
                                       −
                                       
                                          d
                                          i
                                       
                                       ≤
                                       
                                          v
                                          i
                                       
                                       −
                                       
                                          a
                                          i
                                       
                                       ≤
                                       
                                          d
                                          i
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          d
                                          i
                                       
                                       ≥
                                       0
                                    
                                 
                              
                           
                        
                     
                  

The d
                     
                        i
                      are just the distances from a priori fluxes to their corresponding fitted fluxes. Linear MoMA has the advantage that it is not biased towards penalizing large magnitude fluxes or under-penalizing fluxes that are less than one (Boyd and Vandenberghe, 2004; Shlomi et al., 2005). Additionally, linear programs are often amenable to more alterations that maintain convexity than a quadratic program and tend to have fewer variables take on small values, and it is much easier to interpret the importance of a zero than a small value (Boyd and Vandenberghe, 2004).

We wish to apply MoMA to expression data rather than flux data, but there are two primary problems that must be tackled. First, we must quantify enzyme complex abundance as accurately as possible given the gene expression data. Although there is not a one-to-one correspondence between reactions and enzyme complexes, the correspondence is much closer than that between individual genes and metabolic reactions. In the first part of this work, we employ an algorithm that can account for enzyme complex formation and thus quantify enzyme complex abundance. Second, we must fit real-valued variables (fluxes) to non-negative data (expression), which is challenging to do efficiently. To accomplish this, we build on the original MoMA objective, which must be altered in several ways (also discussed in Lee et al. (2012), which lays the groundwork for the current method). We develop automatic scaling of expression values so that they are comparable to flux units obtained in the optimization routine. This can be an advantage over the prior method as it no longer requires the manual choice of a flux and complex abundance pair with a ratio that is assumed to be representative of every such pair in the system. Related to this, we also implement the sharing of enzyme complex abundance between the reactions that the complex catalyzes, rather than assuming there is no competition between reactions catalyzed by the same complex. Reaction direction assignment enables comparison of fluxes and expression by changing fluxes to non-negative values. We show that batch assignment, rather than serial assignment (Lee et al., 2012) of reaction direction can greatly improve time efficiency while maintaining or slightly improving correlations with experimental fluxes. In addition to several of the methods described so far, we also included in our comparison two methods for tissue-specific modeling. In GIMME, the authors remove reactions whose associated gene expression is below some threshold, then add reactions that preclude some user-defined required metabolic functionalities in an FBA objective back into the model, and finally use FBA again to obtain fluxes (Becker and Palsson, 2008). The other tissue-specific method we compared with is iMAT, which employs a mixed integer linear programming (MILP) problem to maximize the number of reactions whose activity corresponds to their expression state (again using thresholds, but this time, there are low, medium, and highly expressed genes, and only the lowly and highly expressed genes are included in the objective) all while subject to typical constraints found in FBA (Shlomi et al., 2008).

Finally, we employ several sensitivity analyses and performance benchmarks so that users of the FALCON method and related methods may have a better understanding of what to expect in practice.

@&#METHODS@&#

Most genome-scale models have attached Boolean (sans negation) gene rules to aid in determining whether or not a gene deletion will completely disable a reaction. These are typically called GPR (gene–protein-reaction) rules and are a requirement for FALCON; their validity, like the stoichiometric matrix, is important for generating accurate predictions. Also important are the assumptions and limitations for the process of mapping expression data to complexes so that a scaled enzyme complex abundance (hereafter referred to as complex abundance) can be estimated. We address these in the next section and have attached a flow chart to illustrate the overall process of mapping expression of individual genes to enzyme complexes within the greater context of flux estimation (Fig. 1
                     ). We employ an algorithm for this step—finding the minimum disjunction—for estimating complex abundance as efficiently and as accurately as possible given the assumptions (Section A.2).

Consideration of constraint availability, such as assumed reaction directions and nutrient availability, is crucial in this type of analysis. In order to work with two sets of constraints with significantly different sizes in yeast, we wrote the MATLAB function removeEnzymeIrrevs to find all enzymatic reactions in a model that are annotated as reversible but are constrained to operate in one direction only. This is not something a researcher would normally want to do since constraints should generally act to improve modeling predictions, but we are interested to see how their removal influences model predictions and solution robustness.

The function useYN5irrevs copies the irreversible annotations found in Yeast 5.21 (Lee et al., 2012) to a newer yeast model, but could in principle be used for any two models; by default, this script is coded to first call removeEnzymeIrrevs on both models before copying irreversible annotations. Application of these scripts removes 853 constraints in Yeast 5.21 and 1723 constraints in Yeast 7. Despite the significant relaxation in constraints, since nutrient uptake constraints are unaffected, FBA only predicts a 1.28% increase in growth rate in the minimally constrained Yeast 7 model. However, in FALCON, we are no longer optimizing a sink reaction like biomass, and this relaxation in internal constraints proves to be more important. Constraint sets for Human Recon 2 are described in Fig. 8.

Given the diversity and availability of genome-scale expression datasets, either as microarray or more recently RNA-Seq, it could be useful to gauge the number of enzyme complexes present in a cell. A recent study found that only 11% of annotated Drosophila protein complexes have subunits that are co-expressed (Jüschke et al., 2013), so it cannot be assumed that any given protein subunit level represents the actual complex abundance. We formalize a model for enzyme complex formation based on GPR rules that are frequently available in genome-scale annotations.

The original expression to complex abundance mapping procedure (Lee et al., 2012) performed a direct evaluation of GPR rule expression values—replacing gene names with their expression values, ANDs with minimums, and ORs with sums, without altering the Boolean expression of the GPR rule in any way. Below we illustrate a problem that can occur with this mapping where some genes’ expression levels may be counted more than once.

The r
                        
                           i
                         are different reaction rules and the e
                        
                           i
                         are the corresponding estimated complex abundance levels. Lower case letters are shorthand for the expression level of the corresponding gene ID in uppercase; for example, a
                        =E(A), where E(A) is the expression of gene A.


                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             r
                                             1
                                          
                                          :
                                          =
                                          [
                                          A and B
                                          ]
                                          
                                          or
                                          
                                          [
                                          A
                                          
                                          [
                                          A and C
                                          ]
                                          →
                                          
                                             e
                                             1
                                          
                                          =
                                          min
                                          (
                                          a
                                          ,
                                          b
                                          )
                                          +
                                          min
                                          (
                                          a
                                          ,
                                          c
                                          )
                                       
                                    
                                    
                                       
                                          
                                             r
                                             2
                                          
                                          :
                                          =
                                          
                                          [
                                          A and (B or C)
                                          ]
                                          →
                                          
                                             e
                                             2
                                          
                                          =
                                          
                                          min
                                          (
                                          a
                                          ,
                                          b
                                          +
                                          c
                                          )
                                       
                                    
                                 
                              
                           
                        
                     

Supposing A is the minimum, then if we just evaluate r
                        1 directly (a rule in disjunctive normal form, or DNF), A will be counted twice. Rules with sub-expressions in DNF are frequently encountered in practice, but directly evaluating them can lead to erroneous quantification.

Another possibility is partitioning expression among multiple occurrences of a gene in a rule. For instance, in r
                        1 above, we could evaluate it as 
                           
                              e
                              1
                           
                           =
                           min
                           (
                           
                              a
                              2
                           
                           ,
                           b
                           )
                           +
                           min
                           (
                           
                              a
                              2
                           
                           ,
                           c
                           )
                         to account for the repeated use of a. However, other potential issues aside, we can see that this can cause problems rather quickly. For instance, suppose b
                        =
                        a and c
                        =0; then min(a, b
                        +
                        c)=
                        b
                        =
                        a appears to be correct, not 
                           min
                           (
                           
                              a
                              2
                           
                           ,
                           b
                           )
                           +
                           min
                           (
                           
                              a
                              2
                           
                           ,
                           c
                           )
                           =
                           
                              a
                              2
                           
                           +
                           0
                        . From this example, we can see that conversion to conjunctive normal form (CNF; Russell and Norvig, 2009), as in r
                        2 appears to be a promising prerequisite for evaluation.

In Section A.2, we show that converting a rule to CNF is a sound method to aid in the estimation of enzyme complex abundance. The minimum disjunction algorithm is essentially just the standard CNF conversion algorithm (Russell and Norvig, 2009), with the implementation caveat that a gene that is in disjunction with itself should be reduced to a literal. We have found that this makes the CNF conversion algorithm tractable for all rules and prevents double counting of gene expression. Conversion to CNF and selection of the minimum disjunction also removes redundant genes from the complex (e.g. holoenzymes; see Assumption 8). Biologically, selecting the minimum disjunction effectively finds the rate-limiting component of enzyme-complex formation. After conversion to CNF, the minimum disjunction algorithm substitutes gene-expression values as described in Lee et al. (2012) and evaluates the resulting arithmetic expression. Another new feature of our approach is the handling of missing gene data. If expression is not measured for a gene in a GPR rule, the rule is modified so that the missing gene is no longer part of the Boolean expression. For instance, if data is not measured for gene B in [A and (B or C)] then the rule would become [A and C]. This prevents penalization of the rule's expression value in the case that the missing gene was part of a conjunction, and it also assumes there was no additional expression from the missing gene if it is in a disjunction.

Although conversion to CNF may be intractable for some expressions (Russell and Norvig, 2009), we tested our implementation of the algorithm on three of the most well-curated models which contain some of the most complex GPR rules available. These models are for E. coli (Orth et al., 2011), yeast (Aung et al., 2013), and human (Thiele et al., 2013). In all cases, the rules were converted to CNF in less than half a second, which is far less than the typical flux fitting running time from Algorithm 3.1.

Using the minimum disjunction method results in several differences from direct substitution and evaluation in yeast GPR rules. When data completely covers the genes in the model (e.g. Lee et al., 2012), complex abundance tends to have few differences in yeast regardless of the evaluation method (25 rules; 1.08% of all rules for Yeast 7). This number goes up significantly in Human Recon 2 (Thiele et al., 2013) due to more complex GPR rules (935 rules; 22% of all rules). For the human model, we could not find any data set that covered every gene, so instead random expression data roughly matching a power law was used to generate this statistic. If we use proteomics data for yeast and human models, the algorithmic variation in how missing gene data is handled causes some additional increase in differences (Picotti et al., 2013; Gholami et al., 2013). For proteomics, in the Yeast 7 model 205 rules (8.87% of all rules) differed, and in Human Recon 2, 1002 rules (23.57% of all rules) differed. We can see that for yeast, the changes in flux attributed to enzyme abundance evaluation can be relatively small for data with 100% gene coverage, but can be significant in human (Fig. 5).

Prior work that served as an inspiration for this method used Flux Variability Analysis (FVA) to determine reaction direction (Lee et al., 2012). Briefly, this involves two FBA simulations per reaction catalyzed by an enzyme, and as the algorithm is iterative, this global procedure may be run several times before converging to a flux vector. We removed FVA to mitigate some of the cost, and instead assign flux direction in batch; while it is possible that the objective value may decrease in subsequent iterations of the algorithm, this is not an issue since the objective function is changed at each iteration to include more irreversible fluxes. The objective value of a function with more fluxes should supersede the importance of one with fewer fluxes, as the functions are not the same and thus not directly comparable, and we wish to include as many data points in the fitting as possible.

One major advance in our method is the consideration of enzyme complexes sharing multiple reactions, which we call reaction groups. This is done by partitioning an enzyme complex's abundance across its reactions by including all reactions associated to the complex in the same constraint. Both minimally and highly constrained models (Section 4.2) show some fluxes with significant differences depending on the use of group information, particularly in the minimally constrained model (Fig. 2
                     ). We now discuss the algorithm in detail, including several other important features, including automatic scaling of expression.

To make working with irreversible fluxes simpler, we convert the model to an irreversible model, where each reversible flux 
                        
                           v
                           j
                        
                      in the original model is split into a forward and a backward reaction that take strictly positive values: 
                        
                           v
                           
                              j
                              ,
                              f
                           
                        
                      and 
                        
                           v
                           
                              j
                              ,
                              b
                           
                        
                     . We also account for enzyme complexes catalyzing multiple reactions by including all reactions with identical GPR rules in the same residual constraint; indexed sets of reactions are denoted r
                     
                        i
                      and their corresponding estimated enzyme abundance is e
                     
                        i
                     . Fig. 2 shows the difference in Algorithm 3.1 when we do not use reaction group information. The standard deviation of enzyme abundance, σ
                     
                        i
                     , is an optional weighting of uncertainty in biological or technical replicates.

We employ a normalization variable N in the problem's objective and flux-fitting constraints to find the most agreeable scaling of expression data. The linear fractional program shown below can be converted to a linear program by the Charnes–Cooper transformation (Boyd and Vandenberghe, 2004). To avoid the need for fixing any specific flux, which may introduce bias, we introduce the bound 
                        
                           ∑
                           
                              j
                              ∣
                              ∃
                              i
                              s.t.
                              j
                              ∈
                              
                                 R
                                 i
                              
                           
                        
                        |
                        
                           v
                           j
                        
                        |
                        ≥
                        
                           V
                           lb
                           Σ
                        
                     . This guarantees that the optimization problem will yield a non-zero flux vector. As an example of how this can be beneficial, this means we do not need to measure any fluxes or assume a flux is fixed to achieve good results; though this does not downplay the value of obtaining experimentally based constraints on flux when available (Fig. 6).

The actual value of 
                        
                           V
                           lb
                           Σ
                        
                      is not very important due to the scaling introduced by N, and we include a conservatively small value that should work with any reasonable model. However, for numeric reasons, it may be best if a user chooses to specify a value appropriate for the model. Similarly, if any fluxes are known or assumed to be non-zero, this constraint becomes unnecessary. To keep track of how many reactions are irreversible in the current and prior iteration, we use the variables rxns
                     
                        irrev
                      and rxns
                     
                        irrev,prior
                     . The algorithm terminates when no reactions are constrained to be exclusively forward or backward after an iteration.


                     
                        Algorithm 3.1
                        FALCON 
                              
                                 
                                    
                                    
                                       
                                          
                                             INPUT: {R
                                             
                                                i
                                             
                                             :
                                             i an index for a unique enzyme complex where r
                                             
                                                i
                                              = {j: complex i catalyzes reaction j}}
                                       
                                       
                                          
                                             INPUT: enzyme abundances (mean: e
                                             
                                                i
                                             , standard deviation: σ
                                             
                                                i
                                             )
                                       
                                       
                                          
                                             INPUT: model (S matrix, v
                                             
                                                lb
                                             , v
                                             
                                                ub
                                             )
                                       
                                       
                                          
                                             
                                             
                                                
                                                   u
                                                   min
                                                
                                                ←
                                                
                                                   min
                                                   j
                                                
                                                
                                                {
                                                
                                                   V
                                                   
                                                      j
                                                      ,
                                                      max
                                                   
                                                
                                                :
                                                
                                                   V
                                                   
                                                      j
                                                      ,
                                                      max
                                                   
                                                
                                                >
                                                0
                                                }
                                              where 
                                                
                                                   V
                                                   
                                                      j
                                                      ,
                                                      max
                                                   
                                                
                                                =
                                                max
                                                (
                                                |
                                                
                                                   v
                                                   
                                                      lb
                                                      ,
                                                      j
                                                   
                                                
                                                |
                                                ,
                                                |
                                                
                                                   v
                                                   
                                                      ub
                                                      ,
                                                      j
                                                   
                                                
                                                |
                                                )
                                             .
                                       
                                       
                                          
                                             
                                             
                                                
                                                   V
                                                   lb
                                                   Σ
                                                
                                                ←
                                                
                                                   u
                                                   min
                                                
                                                |
                                                {
                                                j
                                                :
                                                ∃
                                                i
                                                
                                                   s
                                                   .
                                                   t
                                                   .
                                                
                                                j
                                                ∈
                                                
                                                   R
                                                   i
                                                
                                                }
                                                |
                                             
                                          
                                       
                                       
                                          
                                             
                                             rxns
                                             
                                                irrev
                                             ← number of reactions (j) such that either 
                                                
                                                   v
                                                   
                                                      ub
                                                      ,
                                                      j
                                                   
                                                
                                                >
                                                0
                                              or 
                                                
                                                   v
                                                   
                                                      lb
                                                      ,
                                                      j
                                                   
                                                
                                                <
                                                0
                                             , but not both.
                                       
                                       
                                          
                                             
                                             for all i do
                                          
                                       
                                       
                                          
                                               Scale data to be of similar size for numeric stability:
                                       
                                       
                                          
                                               
                                             
                                                
                                                   e
                                                   i
                                                
                                                ←
                                                
                                                   
                                                      
                                                         e
                                                         i
                                                      
                                                      
                                                         V
                                                         lb
                                                         Σ
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                         j
                                                      
                                                      
                                                         e
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                               
                                             
                                                
                                                   σ
                                                   i
                                                
                                                ←
                                                
                                                   
                                                      
                                                         σ
                                                         i
                                                      
                                                      
                                                         V
                                                         lb
                                                         Σ
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                         j
                                                      
                                                      
                                                         e
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          
                                             
                                             while
                                             
                                             rxns
                                             
                                                irrev
                                             
                                             >
                                             rxns
                                             
                                                irrev,prior
                                             
                                             
                                             do
                                          
                                       
                                       
                                          
                                               
                                             rxns
                                             
                                                irrev,prior
                                             
                                             ←
                                             rxns
                                             
                                                irrev
                                             
                                          
                                       
                                       
                                          
                                               Call LP Solver (updates v):
                                       
                                       
                                          
                                                 
                                             
                                                minimize
                                                
                                                
                                                   ∑
                                                   i
                                                
                                                
                                                   
                                                      
                                                         d
                                                         i
                                                      
                                                   
                                                   
                                                      n
                                                      
                                                         σ
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                                 s.t.
                                       
                                       
                                          
                                                 
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      
                                                      ∣
                                                      
                                                      ∃
                                                      i
                                                      
                                                         s
                                                         .
                                                         t
                                                         .
                                                      
                                                      j
                                                      ∈
                                                      
                                                         R
                                                         i
                                                      
                                                   
                                                
                                                |
                                                
                                                   v
                                                   j
                                                
                                                |
                                                ≥
                                                
                                                   V
                                                   lb
                                                   Σ
                                                
                                             
                                          
                                       
                                       
                                          
                                                 
                                             
                                                ∀
                                                i
                                                :
                                                −
                                                
                                                   d
                                                   i
                                                
                                                ≤
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      
                                                         R
                                                         i
                                                      
                                                   
                                                
                                                (
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                                +
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                                )
                                                −
                                                n
                                                
                                                   e
                                                   i
                                                
                                                ≤
                                                
                                                   d
                                                   i
                                                
                                              where 
                                                
                                                   v
                                                   j
                                                
                                                =
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                                −
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                                 
                                             
                                                
                                                   d
                                                   i
                                                
                                                ,
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                                ,
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                                ≥
                                                0
                                             
                                          
                                       
                                       
                                          
                                                 
                                             n
                                             >0
                                       
                                       
                                          
                                               
                                             for all 
                                             
                                                {
                                                j
                                                ∣
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                                +
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                                >
                                                0
                                                ,
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                                ≠
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                                }
                                              
                                             do
                                          
                                       
                                       
                                          
                                                 Constrain the smaller of 
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      f
                                                   
                                                
                                              and 
                                                
                                                   v
                                                   
                                                      j
                                                      ,
                                                      b
                                                   
                                                
                                              to be 0.
                                       
                                       
                                          
                                                 
                                             rxns
                                             
                                                irrev
                                             
                                             ←
                                             rxns
                                             
                                                irrev
                                             
                                             +1
                                       
                                       
                                          
                                               
                                             end for
                                          
                                       
                                       
                                          
                                             
                                             end while
                                          
                                       
                                       
                                          
                                             OUTPUT: v
                                          
                                       
                                    
                                 
                              
                           
                        


                     Algorithm 3.1 and the method in Lee et al. (2012) are both non-deterministic. In the first case, Algorithm 3.1 solves an LP during each iteration, and subsequent iterations depend on the LP solution, so that alternative optima may affect the outcome. In the latter case, alternative optima of individual LPs is not an issue, but the order in which reactions assigned to be irreversible can lead to alternative solutions. However, we found that the variation due to this stochasticity is typically relatively minor, particularly in cases where the model is more heavily constrained (Figs. 5 and 6).

@&#RESULTS AND DISCUSSION@&#

Using the same yeast exometabolic and expression data employed for benchmarking in the antecedent study (Lee et al., 2012) that included an updated version of the Yeast 5 model (Heavner et al., 2012) and the latest yeast model (Aung et al., 2013), we find that our algorithm has significant improvements in time efficiency while maintaining correlation with experimental fluxes, and is much faster than any similarly performing method (Table 1
                         and Fig. 6). Timing for the human model also improved in FALCON; in a model with medium constraints and exometabolic directionality constraints, FALCON completed on average in 3.6m and the method from Lee et al., 2012 in 1.04h. Furthermore, when we remove many bounds constraining the direction of enzymatic reactions that are not explicitly annotated as being irreversible in prior work (Lee et al., 2012), we find that our formulation of the approach seems to be more robust than other methods.

We see that the predictive ability of the algorithm does not appear to be an artifact; when FALCON is run on permuted expression data, it does not do as well as the actual expression vector (Fig. 3
                        ). The full-sized flux vectors estimated from permuted expression as a whole also does not correlate well with the flux vector estimated from the actual expression data, but we notice that the difference is visibly larger in the minimally constrained model compared to the highly constrained model (Fig. 7). Rigidity in the highly constrained model appears to keep most permutations from achieving an extremely low Pearson correlation, likely due to forcing fluxes through the same major pathways, but a rank-based correlation still shows strong differences.

To understand the sensitivity of flux to expression, we multiply noise from multivariate log-normal distributions with the expression vector and see the effect on the estimated fluxes. For instance, correlation between two types of proteomics data yields a Pearson's r
                        =0.7 (Gholami et al., 2013), corresponding to an expected σ
                        ≈1.4 and expected r
                        ≈0.4 for flux in our most highly constrained human model (Fig. 8). We find that enzymatic reaction directionality constraints influence the sensitivity of the model to expression perturbation (Fig. 4
                        ). It is important to note that mere presence of the constraints does not help us determine the correct experimental fluxes when other classes of methods (e.g. FBA; Table 1) are used. Additionally, it is possible to obtain good predictions even without a heavily constrained model (Table 1).

With Human Recon 2, additional constraint sets supply some benefit, but even the most extreme constraint set does not compare to what is available in Yeast 7, which is also inherently constrained by the fact that yeast models will be smaller than comparable human models (Fig. 8). For mammalian models, more sophisticated means of constraint, such as enzyme crowding constraints (Shlomi et al., 2011), or using FALCON in conjunction with tissue specific modeling tools, may prove highly beneficial.

It is not an unreasonable hypothesis that fluxes would correlate well with their associated complex abundances. Indeed, the general principle needed for fitting fluxes to enzyme complex abundances is to assume the values would be correlated in the absence of other constraints (e.g. branch points that arise from the stoichiometry). More specifically, it should be the case that flux is proportional to enzyme complex abundance given ample availability of substrate, and that this proportionality constant does not vary too much between reactions. There are undoubtedly many exceptions to this rule, but it seems as though there may be some underlying evolutionary principles for it to work in this parsimonious fashion, as has been partly verified (Bennett et al., 2009).

Aside from the obvious benefits of constraint-based methods also estimating fluxes for non-enzymatic reactions, and assigning a direction for reversible enzymatic reactions, we see that in general, our method does not predict a strong correlation between complex abundance and flux (Fig. 9). Recently it has been shown that many fluxes are not under direct control of their associated enzyme expression level (Chubukov et al., 2013), which gives experimental support to the idea that a network-based approach, such as that presented in this paper, may be useful in understanding how fluxes may be constrained by expression data. Chubukov et al., 2013 also note that enzymes may be overexpressed in some cases, either for robustness or because of noise in transcriptional regulation. This will not usually be a problem in FALCON, unless entire pathways are overexpressed, which would be unusual as it would represent a seemingly large energetic inefficiency.

The present work does not attempt to use empirically obtained kinetic parameters to estimate V
                        max, but this approach does not seem as promising in light of experimental evidence that many reactions in central carbon metabolism tend to operate well below V
                        max (Bennett et al., 2009). Still, a better understanding of these phenomena may make it possible to improve flux estimation methods such as the one presented here, or more traditional forms of MFA (Shestov et al., 2013) by incorporating enzyme complexation and kinetic information.

Still, complex abundance may have uses aside from being a first step in FALCON. The method presented here for complex abundance estimation can be used as a stand-alone method, as long as GPR rules from a metabolic reconstruction are present. For instance, it may not always be desirable to directly compute a flux. As an example, the relative abundance of enzyme complexes present in secretions from various biological tissues, such as milk or pancreatic secretions, may still be of interest even without any intracellular flux data. Perhaps more importantly, this approach to estimating relative complex levels can be employed with regulatory models such as PROM (Chandrasekaran and Price, 2010) or other regulatory network models that can estimate individual gene expression levels at time t
                        +1 given the state of the model at a time t.

GPR rules and stoichiometry may be inaccurate or incomplete in any given model. In fact, for the foreseeable future, this is a given. By using the GPR and not just the stoichiometry to estimate flux, it is possible that future work could make use of this framework to debug not just stoichiometry as some methods currently do (e.g. Reed et al., 2006), but also GPR rules. Hope for improved GPR rule annotation may come from many different avenues of current research. For instance, algorithms exist for reconstructing biological process information from large-scale datasets, and could be tuned to aid in the annotation of GPR rules (Mitra et al., 2013). Flexible metabolic reconstruction pipelines such as GLOBUS may also be extended to incorporate GPR rules into their output, and in so doing, extend this type of modeling to many non-model organisms (Plata et al., 2012). Another limitation that relates to lack of biological information is that we always assume a one-to-one copy number for each gene in a complex. Once more information on enzyme complex structure and reaction mechanism becomes available, an extension to the current method could make use of this information. Even at the current level of structure, we think it is evident that GPR rules should undergo some form of standardization; Boolean rules without negation may not always capture the author's intent for more complex purposes like flux fitting.

@&#CONCLUSION@&#

We have formalized and improved an existing method for estimating flux from expression data, as well as listing detailed assumptions in Table 2 that may prove useful in future work. Although we show that expression does not correlate well with flux, we are still essentially trying to fit fluxes to expression levels. The number of constraints present in metabolic models (even the minimally constrained models) prevents a good correlation between the two. However, as with all constraint-based models, constraints are only part of the problem in any largely underdetermined system. We show that gene expression can prove to be a valuable basis for forming an objective, as opposed to methods that only use expression to further constrain the model by creating tissue-specific or condition-specific models (Colijn et al., 2009; Shlomi et al., 2008; Becker and Palsson, 2008; Gowen and Fong, 2010).

For better curated models, the approach described immediately finds use for understanding metabolism, as well as being a scaffold to find problems for existing GPR rules, and more broadly the GPR formalism itself. The present results and avenues for future improvement show that there is much promise for using expression to estimate fluxes, and that it can already be a useful tool for performing flux estimation and analysis.

@&#ACKNOWLEDGMENTS@&#

We thank Neil Swainston for his previous work on these research issues and many helpful discussions about considerations in various genome scale models of metabolism. We also thank Michael Stillman for general discussions about modeling and for reading the paper. Finally we thank Alex Shestov, Lei Huang, and Eli Bogart for many helpful discussions about metabolism.

BEB and YW are supported by the Tri-Institutional Training Program in Computational Biology and Medicine. BEB and ZG are thankful for support from NSF grant MCB-1243588. KS is grateful for the financial support of the EU FP7 project BioPreDyn (grant 289434). CRM acknowledges support from NSF Grant IOS-1127017. JWL thanks the NIH for support through grants R00 CA168997 and R01 AI110613.


                        
                        
                        
                        
                        
                     

In order to quantify enzyme complex formation (sometimes called enzyme complexation), the notion of an enzyme complex should be formalized. A protein complex typically refers to two or more physically associated polypeptide chains, which is sometimes called a quaternary structure. Since we are not exclusively dealing with multiprotein complexes, we refer to an enzyme complex as being one or more polypeptide chains that act together to carry out metabolic catalysis.


                        Assumption 1. A fundamental assumption that we need in order to guarantee an accurate estimate of (unitless) enzyme complex abundance are the availability of accurate measurements of their component subunits. Unfortunately, this is currently not possible, and we almost always must make do with mRNA measurements, which may even have some degree of inaccuracy in measuring the mRNA abundance. What has been seen is that Spearman's ρ
                        =0.6 for correlation between RNA-Seq and protein intensity in datasets from HeLa cells (Nagaraj et al., 2011). We also found that there is moderate correlation (Pearson's r
                        =0.5) between proteomic and microarray data and fairly strong correlation between proteomic data obtained from different instruments (Pearson's r
                        =0.7; Fig. 10
                        ). This implies that much can likely still be gleaned from analyzing various types of expression data, but, an appropriate degree of caution must be used in interpreting results. By incorporating more information, such as metabolic constraints, we hope to obviate some of the error in estimating protein intensity from mRNA data.


                        Assumption 2. We also include the notion of isozymes—different proteins that catalyze the same reaction—in our notion of enzyme complex. Isozymes may arise by having one or more differing protein isoforms, and even though these isoforms may not be present in the same complex at the same moment, we consider them to be part of the enzyme complex since one could be substituted for the other.

As an example for assumptions described so far, take the F
                        1 subcomplex of ATP Synthase (Fig. 11
                        ), which is composed of seven protein subunits (distinguished by color, left). On the right-hand side we see different isoforms depicted as different colors. Error in expression data aside, instead of considering the abundances with multiplicity and dividing their expression values by their multiplicity, it may be easier to simply note that the axle peptide (shown in red in the center of the complex) only has one copy in the complex, so its expression should be an overall good estimation of the F
                        1 subcomplex abundance. This reasoning will be useful later in considering why GPR rules may be largely adequate for estimating the abundance of most enzyme complexes.


                        Assumption 3. The modeling of enzyme complex abundance can be tackled by using nested sets of subcomplexes; each enzyme complex consists of multiple subcomplexes, unless it is only a single protein or family of protein isozymes. These subcomplexes are required for the enzyme complex to function (AND relationships), and can be thought of as the division of the complex in to distinct units that each have some necessary function for the complex, with the exception that we do not keep track of the multiplicity of subcomplexes within a complex since this information is, in the current state of affairs, not always known. However, there may be alternative versions of each functional set (given by OR relationships). Eventually, this nested embedding terminates with a single protein or set of peptide isoforms (e.g. isozymes). In the case of ATP Synthase, one of its functional sets is represented by the F
                        1 subcomplex. The F
                        1 subcomplex itself can be viewed as having two immediate subcomplexes: the single γ (axle) subunit and three identical subcomplexes each made of an α and β subunit. Each αβ pair works together to bind ADP and catalyze the reaction (Oster and Wang, 2003). The αβ subcomplex itself then has two subcomplexes composed of just an α subunit on the one hand and the β subunit on the other. It is obvious that one of these base-level functional subcomplexes (in this example, either γ or αβ) will be in most limited supply, and that it will best represent the overall enzyme complex abundance (discounting the issues of multiplicity for αβ, see Assumption 4).

The hierarchical structure just described, when written out in Boolean, will give a rule in CNF (conjunctive normal form), or more specifically (owing to the lack of negations), clausal normal form, where a clause is a disjunction of literals (genes). This is because all relations are ANDs (conjunctions), except possibly at the inner-most subcomplexes that have alternative isoforms, which are expressed as ORs (disjunctions). Since GPR rules alone only specify the requirements for enzyme complex formation, we will see that not all forms of Boolean rules are equally useful in evaluating the enzyme complex abundance, but we have established the assumptions in Table 2
                         and an alternative and logically equivalent rule (Russell and Norvig, 2009) under which we can estimate enzyme complex copy number.

There is no guarantee that a GPR rule has been written down with this hierarchical structure in mind, though it is likely the case much of the time as it is a natural way to model complexes. However, any GPR rule can be interpreted in the context of this hierarchical view due to the existence of a logically equivalent CNF rule for any non-CNF rule, and it is obvious that logical equivalence is all that is required to check for enzyme complex formation when exact isoform stoichiometry is unknown. As an example, we consider another common formulation for GPR rules, and a way to think about enzyme structure—disjunctive normal form (DNF). A DNF rule is a disjunctive list of conjunctions of peptide isoforms, where each conjunction is some variation of the enzyme complex due to substituting in different isoforms for some of the required subunits. A rule with a more complicated structure and compatible isoforms across subcomplexes may be written more succinctly in CNF, whereas a rule with only very few alternatives derived from isoform variants may be represented clearly with DNF. In rare cases, it is possible that a GPR rule is written in neither DNF or CNF, perhaps because neither of these two alternatives above are strictly the case, and some other rule is more succinct.


                        Assumptions 4, 5 and 6. One active site per enzyme complex implies a single complex can only catalyze one reaction at a time. Multimeric complexes with one active site per identical subunit would be considered as one enzyme complex per subunit in this model. Note that it is possible for an enzyme complex to catalyze different reactions. In fact, some transporter complexes can transfer many different metabolites across a lipid bilayer—up to 294 distinct reactions in the reversible model for solute carrier family 7 (Gene ID 9057). Another example is the ligation or hydrolysis of nucleotide, fatty acid, or peptide chains, where chains of different length may all be substrates or products of the same enzyme complex. While we do not explicitly consider these in in the minimum disjunction algorithm, these redundancies are taken into account subsequently in Algorithm 3.1.

In order to explore the effect that stoichiometry of protein complexes can have on metabolism, we compared time series aggregates of fluxes and metabolite counts from a whole cell model of Mycoplasma genitalium (Karr et al., 2012) in two different conditions (Fig. 12
                        ). While there are outliers and deviations from perfect correlation, the results indicate that, at least in a whole cell model of M. genitalium, our assumption for protein complex stoichiometry may be acceptable. Nonetheless, we hope to address this assumption at a future date.

What is currently not considered in our process is that some peptide isoforms may find use in completely different complexes, and in some cases, individual peptides may have multiple active sites; in the first case, we assume an unrealistic case of superposition where the isoform can simultaneously function in more than one complex. The primary reason we have not tackled this problem is because exact subunit stoichiometry of most enzyme complexes is not accurately known, but an increasing abundance of data on BRENDA (Schomburg et al., 2013) gives some hope to this problem. A recent E. coli metabolic model incorporating the metabolism of all known gene products (O’Brien et al., 2013) also includes putative enzyme complex stoichiometry in GPR rules. For the second point, there are a few enzymes where a single polypeptide may have multiple active sites (e.g. fatty acid synthase), and this is not currently taken into account in our model. One way that we may take this into account has been illustrated online by one of the authors (Smallbone, 2014).


                        Assumption 8. We do not make any special assumptions requiring symmetry of an isoform within a complex. For instance, the example in assumption 8 shows how you might have one subcomponent composed of a single isoform, and another subcomponent composed of that gene in addition to another isoform. In this case, it is simply reduced to being the first gene only that is required, since clearly the second is strictly optional. That is not to say that the second gene may not have some metabolic effect, such as (potentially) aiding in structural ability or altering the catalytic rate, but it should have no bearing on the formation of a functional catalytic complex. Holoenzymes—enzymes with metabolic cofactors or protein subunits that have a regulatory function for the complex—would likely be the only situation where this type of rule might need to be considered in more detail. But in the absence of detailed kinetic information, this consideration (much like allosteric regulation) is not useful.

No additional algorithmic considerations are needed, as this is a by-product of the conversion to CNF. For instance, take the following example where the second conjunction has the redundant gene g
                        3:


                        
                           
                              
                                 (
                                 
                                    g
                                    1
                                 
                                 ∧
                                 
                                    g
                                    2
                                 
                                 )
                                 ∨
                                 (
                                 
                                    g
                                    1
                                 
                                 ∧
                                 
                                    g
                                    2
                                 
                                 ∧
                                 
                                    g
                                    3
                                 
                                 )
                              
                           
                        
                     

Distributing during the process of conversion to CNF results in:


                        
                           
                              
                                 
                                    g
                                    1
                                 
                                 ∧
                                 (
                                 
                                    g
                                    1
                                 
                                 ∨
                                 
                                    g
                                    2
                                 
                                 )
                                 ∧
                                 (
                                 
                                    g
                                    1
                                 
                                 ∨
                                 
                                    g
                                    3
                                 
                                 )
                                 ∧
                                 (
                                 
                                    g
                                    2
                                 
                                 ∨
                                 
                                    g
                                    1
                                 
                                 )
                                 ∧
                                 
                                    g
                                    2
                                 
                                 ∧
                                 (
                                 
                                    g
                                    2
                                 
                                 ∨
                                 
                                    g
                                    3
                                 
                                 )
                              
                           
                        
                     

Because every disjunction with more than one literal is in conjunction with another disjunction with only one of its literals, the disjunction with fewer literals will be the minimum of the two once evaluated. This applies to both of the singleton disjunctions g
                        1 and g
                        2, so all other disjunctions will effectively be ignored (it is up to the implementer whether the redundant sub-expressions are removed before evaluation):


                        
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     


                        Assumption 7. Another important biochemical assumption is that reactions should operate in a regime where they are sensitive to changes in the overall enzyme level in the pathways that they belong in (Bennett et al., 2009; Chubukov et al., 2013). This is perhaps the most important issue to be explored further for methods like this, since if it is not true, some other adjustment factor would be needed to make the method realistic. For instance, if all reactions in a pathway are operating far below V
                        
                           max
                        , but it is not the case in another pathway, the current method does not have information on this, and will try to put more flux through the first pathway than should be the case.


                        Assumptions 9, 10 and 11. Due to the quickness, stability, and energetic favorability of enzyme complex formation, the absence of chaperones or coupled metabolic reactions required for complex formation may be reasonable assumptions, but further research is warranted (Karr et al., 2012). Additionally, as in metabolism, we assume a steady state for complex formation, so that rate laws regarding complex formation are not needed. However, further research may be warranted to investigate the use of a penalty for complex levels based on mass action and protein-docking information. Requisite to this would be addressing Assumption 4. It would be surprising (but not impossible) if such a penalty were very large due to the cost this would imply for many of the large and important enzyme complexes present in all organisms (Nelson and Cox, 2008). A more serious consideration may be that information on post-translational modification is not currently considered. Post-translational modification is highly context-specific and the relevant data is not as cheap to get as expression data, so it may be some time before it can be integrated into the modeling framework.

We have exclusively used the Gurobi solver (Gurobi Optimization Inc, 2013) for this work, which is a highly competitive solver that employs by default a parallel strategy to solving problems: a different algorithm is run simultaneously, and as soon as one algorithm finished the others terminate. Of course, if there is a clear choice of algorithm for a particular problem class, this should be used in production settings to avoid wasted CPU time and memory. In order to address this, we benchmarked the three non-parallel solver methods in Gurobi (since parallel solvers simply use multiple methods simultaneously). The exception to this rule is the Barrier method, which can use multiple threads, but in practice for our models appears to use no more than about 6 full CPU cores simultaneously for our models. Our results for Yeast 5 and Yeast 7 with minimal directionality constraints (Heavner et al., 2012; Lee et al., 2012; Aung et al., 2013) and Human Recon 2 (Thiele et al., 2013) are shown in Table 3
                        ).

We found that in Yeast 7 with the primal-simplex solver, there is a chance the solver will fail to find a feasible solution. We verified that this is a numeric issue in Gurobi and can be fixed by setting the Gurobi parameter MarkowitzTol to a larger value (which decreases time-efficiency but limits the numerical error in the simplex algorithm). In practice, failure for the algorithm to converge at an advanced iteration is rare and is not always a major problem (since the previous flux estimate by the advanced iteration should already be quite good), but it is certainly undesirable; a warning message will be printed by falcon if this occurs, at which point parameter settings can be investigated. In the future, we plan to improve falcon so that parameters will be adjusted as needed during progression of the algorithm after finding a good test suite of models and data. For now, we use the dual-simplex solver, for which we have always had good results.

Because the number of iterations depends non-trivially on the model and the expression data, it may be more helpful to look at the average time per iteration in the above examples (Table 4
                        ).

Given the above rare trouble with primal simplex solver the universal best performance enjoyed by the dual-simplex method (Tables 3 and 4), we would advise the dual-simplex algorithms, all else being equal. The dual-simplex method is also recommended for memory-efficiency by Gurobi documentation, but we did not observe any differences in memory for different solver methods.

All timing analyses were performed on a system with four 8-core AMD Opteron™ 6136 processors operating at 2.4GHz. Fig. 6, Tables 1, 3 and 4, used a single unperturbed expression file per species (S. cerevisiae and H. sapiens; see timingAnalysis.m for details). Values were averaged across 32 replicates. Note that the iMAT method is formulated as a mixed integer program (Shlomi et al., 2008), and was able to use additional parallelization of the solver (Gurobi Optimization Inc, 2013) whereas other methods only used a single core (our system had 32 cores and iMAT with Gurobi would use all of them). Tables 3 and 4 used multivariate log-normal noise multiplied by the original expression vector to introduce more variance in the calculations; the human models were tested with 100 replicates and the yeast models with 500 replicates.

All non-trivial figures can be generated using MATLAB scripts found in the analysis/figures subdirectory of the FALCON installation. In particular, figures should be generated through the master script makeMethodFigures.m by calling makeMethodFigures(figName) where figName has a name corresponding to the desired figure. In some cases, some MATLAB .mat files will need to be generated by other scripts first; see the plotting scripts or the subsections below for details. An example is to make the scatter plots showing the difference between running falcon with enzyme abundances determined by direct evaluation or the minimum disjunction algorithm; all three scatter plots are generated with the command makeMethodFigures(‘fluxCmpScatter’). Note that, as written, this requires a graphical MATLAB session.

Several figures can be generated that are related to comparing human proteomic and transcriptomic data by executing the script proteomic_file_make.py in the analysis/nci60 subdirectory; this includes Fig. 10.

Comparison of the effects of the employed enzyme complexation methods were evaluated using compareEnzymeExpression.m and compareFluxByRGroup.m. Comparison of reaction groups was performed in compareFluxByRGroup.m.

All timing analyses were performed on a system with four 8-core AMD Opteron™ 6136 processors operating at 2.4GHz. Fig. 6 and Table 1 used unperturbed expression data; see yeastResults.m for details). Values for the FALCON method were averaged across 32 replicates, while values for the Lee et al., 2012 method were averaged across 8 replicates. Human timing analyses were performed using methodTimer.m with 8 replicates.

Enzyme complexation comparisons were performed on proteomics data from Gholami et al., 2013 (Human; 786-O cell line) and Picotti et al., 2013 (yeast; BY strain), and on RNA-Seq data from Lee et al., 2012 (yeast; 75% max μ condition). Human proteomic and trascriptomic data used for comparison in Fig. 10 were taken from Gholami et al., 2013.

@&#REFERENCES@&#

