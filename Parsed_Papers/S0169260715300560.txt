@&#MAIN-TITLE@&#BIOMedical Search Engine Framework: Lightweight and customized implementation of domain-specific biomedical search engines

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The wealth of knowledge laying in biomedical publications is invaluable to make new scientific discoveries.


                        
                        
                           
                           Domain-specific search engines aim to improve retrieval performance and to enhance user search experience.


                        
                        
                           
                           The BIOMedical Search Engine Framework aims to speed up the construction of biomedical domain-specific search engines.


                        
                        
                           
                           The BIOMedical Search Engine Framework enables the retrieval and annotation of biomedical documents and the customised visualisation of indexed concepts and documents.


                        
                        
                           
                           The BIOMedical Search Engine Framework supported the construction of the Smart Drug Search (SDS) in assistance of antimicrobial research.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Search engine framework

Biomedical literature

Vertical engine

Text mining

Web application

@&#ABSTRACT@&#


               
               
                  Background and objectives
                  Text mining and semantic analysis approaches can be applied to the construction of biomedical domain-specific search engines and provide an attractive alternative to create personalized and enhanced search experiences. Therefore, this work introduces the new open-source BIOMedical Search Engine Framework for the fast and lightweight development of domain-specific search engines. The rationale behind this framework is to incorporate core features typically available in search engine frameworks with flexible and extensible technologies to retrieve biomedical documents, annotate meaningful domain concepts, and develop highly customized Web search interfaces.
               
               
                  Methods
                  The BIOMedical Search Engine Framework integrates taggers for major biomedical concepts, such as diseases, drugs, genes, proteins, compounds and organisms, and enables the use of domain-specific controlled vocabulary. Technologies from the Typesafe Reactive Platform, the AngularJS JavaScript framework and the Bootstrap HTML/CSS framework support the customization of the domain-oriented search application. Moreover, the RESTful API of the BIOMedical Search Engine Framework allows the integration of the search engine into existing systems or a complete web interface personalization.
               
               
                  Results
                  The construction of the Smart Drug Search is described as proof-of-concept of the BIOMedical Search Engine Framework. This public search engine catalogs scientific literature about antimicrobial resistance, microbial virulence and topics alike. The keyword-based queries of the users are transformed into concepts and search results are presented and ranked accordingly. The semantic graph view portraits all the concepts found in the results, and the researcher may look into the relevance of different concepts, the strength of direct relations, and non-trivial, indirect relations. The number of occurrences of the concept shows its importance to the query, and the frequency of concept co-occurrence is indicative of biological relations meaningful to that particular scope of research. Conversely, indirect concept associations, i.e. concepts related by other intermediary concepts, can be useful to integrate information from different studies and look into non-trivial relations.
               
               
                  Conclusions
                  The BIOMedical Search Engine Framework supports the development of domain-specific search engines. The key strengths of the framework are modularity and extensibilityin terms of software design, the use of open-source consolidated Web technologies, and the ability to integrate any number of biomedical text mining tools and information resources. Currently, the Smart Drug Search keeps over 1,186,000 documents, containing more than 11,854,000 annotations for 77,200 different concepts. The Smart Drug Search is publicly accessible at http://sing.ei.uvigo.es/sds/. The BIOMedical Search Engine Framework is freely available for non-commercial use at https://github.com/agjacome/biomsef.
               
            

@&#INTRODUCTION@&#

In Life Sciences, the wealth of knowledge in journal publications is of significant importance for researchers in making scientific discoveries. However, the acquisition of such information is becoming increasingly difficult due to the large volume and heterogeneity of articles, and the intense rate of publication in these fields.

The PubMed search engine is quite powerful in that its keyword-based Boolean query interface is practical and easy to use, and it lays on the millions of abstracts available in the Medline database [1]. However, it can be difficult for researchers to explore and search such huge volume of data in an efficient manner. Queries about general topics are likely to return a large number of potentially relevant documents (hundreds or thousands of documents) that require further manual revision. Conversely, queries about very specific topics demand that the researcher knows in advance the most relevant keywords of the topic (which often vary over time).

It is much more intuitive for users to query about concepts relevant to the domain and with which they are familiar with. Within this context, domain-specific literature search is currently of high demand by biomedical researchers [2]. Efforts are being invested in the development of alternative ways to query documents from the Medline database and offer topic-driven search facilities. Alternatives are quite varied in purpose and nature, but most of them take advantage of text mining technologies and domain-specific semantics to offer a more focused and contextualized search experience [3,4].

Today, major biological databases, such as UniProt protein resources, BioCyc pathway knowledge bases and BRENDA enzyme information system enable concept-driven searches of the curated documents (abstracts or full-texts) [5–7]. Furthermore, the annual report of the Nucleic Acids Research journal about biomedical databases and Web services presents a wide variety of specialized literature search engines, created to meet the information needs of particular research communities [8].


                     Table 1
                      presents a summary of recent projects that developed domain-specific literature search systems. The purpose is not to provide a complete list of available domain-specific systems but rather to describe the technical standpoint of these applications, most notably the support provided by domain-specific semantics, the use of text mining technologies, and the visual artifacts used to enable concept-driven knowledge discovery. Text mining methods and tools are used to incorporate semantic functionality such as the automatic suggestion of synonyms for user-submitted query terms, the assessment of document relevance, the description of document contents, or the inspection of documents in which concepts are related in specific ways. Controlled vocabularies and ontologies, such as DrugBank [18], UMLS [19], MESH [1], and SNOMEDCT [20], help define the knowledge domain to be captured by the search engine and offer the means to convert keyword-based queries in domain concepts, and navigate within domain semantics [21].

For example, the Protein Interaction information Extraction (PIE) system implements a machine learning approach to provide a PubMed-like search interface that prioritizes documents mentioning protein–protein interactions [9] while Alkemio Web tool uses a naïve Bayesian classifier to predict the relatedness of chemicals to query topics [11]. In turn, the PolySearch2 supports the discovery of associations between human diseases, genes, drugs, metabolites and toxins in MEDLINE abstracts, PubMed Central full-text articles, and text-rich biological databases [13].

Typically, all search engines present results as a ranked list. Semantic annotations are visually highlighted and some semantic facets (based on concept types) may exist to narrow down the list. Graph- or tree-based visualizations are provided as advanced means of navigation, namely, to find indirect associations between concepts of interest.

From a technical standpoint, one obvious observation is that most projects undertake the construction of the domain-specific search engine from scratch, and that all these new implementations include modules for document retrieval, text mining, document indexing and scoring, and query execution. Typically, document retrieval relies on MEDLINE web services and text mining relies on open solutions for linguistic processing and biomedical entity recognition. Moreover, document/concept scoring is often based on well-known algorithms, such as the term frequency inverse document frequency (TF-IDF) algorithm [22].

Understandably, domain requirements and goals of analysis determine the practical choice of methods and tools used, but many technologies and tools have the potential of being applied across domains. In particular, the core infrastructural components linking main operations and resources in most biomedical semantic search engines could be generalized with the help of a web development framework.

There are general purpose and open-source search engine development frameworks, but they are hardly used in bioinformatics applications. These frameworks are typically equipped to deal with distribution and scalability concerns, i.e. enabling the construction of large-scale engines, rather than delivering generalized semantic functionality, i.e. enabling the construction of domain-specific engines (Table 2
                     ). So, the learning curve associated with using these frameworks together with the need to program additional biomedical semantic processing and analysis modules discourages bioinformatics application.

These observations led us to consider building the new and open-source BIOMedical Search Engine Framework. This framework aims to provide a solution to bioinformatics applications in demand of a small to medium size semantic search engine. To meet this goal, the BIOMedical Search Engine Framework integrates core features typically available in search engine frameworks with a set of features useful to perform biomedical semantic analysis. Its architecture is modular and component agnostic, and enables the interchange of different components to build biomedical domain-specific search engines at a reduced programming cost. Basic implementation covers well-established algorithms and state-of-the-art open-source tools, namely, it incorporates modules for document retrieval, text mining, document indexing and scoring, query execution, and knowledge reasoning. Controlled vocabulary is at the core of knowledge representation and reasoning, and the graph data structure helps to scale query and visualization abilities for large literature collections.

The rest of this paper aims to disclose the architecture and application of the framework and is organized as follows. Section 2 outlines the architecture of the BIOMedical Search Engine Framework, and describes how each component contributes to building a customized domain-specific literature search engine. Section 3 discusses the development of the Smart Drug Search (SDS) engine as proof-of-concept of the BIOMedical Search Engine Framework. At the end, we provide some conclusions and identify areas of future work.

@&#METHODS@&#

The BIOMedical Search Engine Framework has been designed to support the construction of domain-specific and highly customized search engines. To meet this purpose, the framework is built on top of state-of-the-art open technologies and standards, and the architecture is completely modularized, to facilitate the extension of features and methods to meet new needs or integrate other technology.

The architecture of the server application has three layers (see Fig. 1
                        ). The top layer provides a RESTful API to access data, the middle layer provides all the application logic, and the bottom layer is responsible for database management. These modules are programmed in Scala [23] and integrate technologies from the Typesafe Reactive Platform (http://www.typesafe.com/products/typesafe-reactive-platform). Most notably, the Play Framework (https://www.playframework.com/) is used as a container framework [24], the Slick database query and access library facilitates the functional-relational mapping (http://slick.typesafe.com/), and the Akka toolkit (http://akka.io/) supports the distribution and parallelization of different parts of the system [25,26]. On the other hand, the client-side web interface is developed using the AngularJS JavaScript framework (https://angularjs.org/) and the Bootstrap HTML/CSS framework (http://getbootstrap.com/).

The modules Provider, Indexer and Searcher encapsulate the most common components of search engines, i.e. the components responsible for document retrieval, document indexing and user query execution. In turn, domain-specific semantic analysis is enabled by the Annotator module. This module includes various text mining methods and tools to be used in the semantic annotation of the documents, the conversion of keyword-based queries in domain concepts, and domain-specific knowledge reasoning over query results. The semantic concept is regarded as the basic knowledge representation unit of the BIOMedical Search Engine Framework, and the user interface is designed to take advantage of concepts as best as possible. Functionality such as query resolution, document relevance assessment, document filtering and traverse, and the discovery of indirect associations are based on the information provided by domain concepts.

The document provider module is responsible for incorporating new documents into the database. Currently, the framework implements the PubMed document provider, which is based on the eUtils tools [1], and automatically transforms the XML responses into domain entities that can be easily manipulated within the framework. The way to incorporate more document providers into the system is to implement a new document retrieval class and its respective controller. In future versions, such document provider customization will be facilitated with a Scala trait, which may be refined to any given provider. Similarly to the annotator and searcher modules, the administrator will be able to toggle providers through the system configuration file.

This module operates asynchronously with respect to the rest of the system, i.e. the search engine can still operate fluently while documents are being inserted in the database.

This module integrates text mining technologies, specifically machine learning tools and dictionary-based recognizers based on controlled vocabulary. On implementing a given domain search engine, the system administrator can enable and disable the implemented annotators in the server configuration file, and this module will be responsible for articulating the annotation of the documents accordingly.

Technically speaking, the Annotator module incorporates text mining methods and tools through an adapter interface (a Scala trait). Each annotator is an Akka actor which is able to recognize named entities in the documents and store this semantic information in the database.

The operation of the various annotators is completely asynchronous. All the annotators start to work at the same time, and will respond to the supervisor once they finish. Once all the annotators have finished, and stored all annotations and concepts in the database, the document is marked as already annotated. If any annotator returns an error state to its supervisor, all the document annotations and concepts are deleted, and its status remains as “not annotated” until the system administrator issues a new annotation request.


                        Fig. 2
                         illustrates the implementation of an annotator, the ExampleDrugAnnotator, which recognizes and normalizes mentions to drug-related entities in a text. For any given annotator, the developer should implement the method “annotate”, i.e. define which concepts are to be annotated and the extent of information to be stored in the database. This annotator may call any available tagger. Here, it calls the ExternalDrugsAnnotator, which has its own method to recognize and normalize mentions to drug-related concepts, and obtains the annotations using the ExternalDrugsAnnotator.getAnnotationsIn method.

The indexer module is the core component of the search engine, as it enables the construction of the search index. Documents have associated domain-specific semantic annotations, i.e. domain concepts that have been detected in the text. These annotations are used to index the documents in a meaningful way to the domain. The relevance of individual documents with respect to each concept is calculated using the TF-IDF algorithm [22].

The indexer module is executed in a scheduled fashion, auto spawning its process after a given time interval has passed since last execution. The reason for generating the index in a scheduled fashion, instead of after each annotation is finished, is efficiency-related. Creating the search index is very resource-consuming and launching the indexer process after producing each individual annotation would deteriorate significantly the performance of the search engine. This scheduling may be configured in the engine configuration file.

The searcher module uses NER tools to normalize queries to a common concept-oriented representation (disambiguate terms or find the stored synonyms in the database). A SearcherAdapter trait is provided to perform any text processing operations necessary to map the terms specified by the user to domain concepts and look for synonyms. Although these searchers are not essential to the correct operation of the search engine, their use is recommended as an additional means of enhancing user search experience. Like with annotators, searchers can be enabled or disabled in the server configuration file. An example of a searcher implementation with a NER tool is shown in Fig. 3
                        .

Search queries are received by the system and further processed to find which keywords and concepts relate to them. Documents are scored based on those keywords and concepts, and the top scores are returned to the user. If no matching concepts are found, the system may be configured to run a simple text search with partial matching of keywords over annotations.

Finally, the retrieved documents are ranked by additively aggregating the precomputed TF-IDF scores for the annotated concepts.

As illustrated in Fig. 4
                        , the AngularJS JavaScript Model-View-View-Model (MVVM) framework, together with Bootstrap and its complete suite of CSS components, supports the rapid development of highly customizable web applications. Most notably, this framework enables the communication with the server-side RESTful API and the creation of a visually appealing interface.

The BIOMedical Search Engine Framework supports two search interfaces—basic and advanced—that provide access to the underlying TF-IDF index. The basic interface is similar to most search engines where users enter a simple keyword-based query and the relevant documents are returned. The advanced search provides search fields for each searchable field in the index. Along with the query interface, the framework provides an administrative interface from which the administrator can launch new jobs and track the progress of previously started jobs.

Overall, the interface is implemented with full responsiveness. Users may access the search engine using any Internet-capable device, and the interface will resize and accommodate its visual representation to the available screen size. Moreover, since the interface is not coupled with the server application, it can be replaced by a completely new one as long as it uses the existing RESTful API. In fact, the interface may not be even web-based, as HTTP requests can be sent from within a desktop application to any existing server. This allows system administrators to create, refine or re-structure user interface without affecting the search indices or the document collection.

The RESTful service of the BIOMedical Search Engine Framework is designed for programmatic access over the network. For example, search queries can be performed from another program and results displayed within it. Using common programming languages, any programmer can connect to the service using the different resource-oriented HTTP methods and URLs defined in the route configuration, which follow the common REST architecture practices. Queries and responses will be just plain JSON content, and can be parsed by the program to display whatever information is most relevant in each case.

The BIOMedical Search Engine Framework was verified with automated tests covering a great percentage of the main codebase. Unit tests, mostly programmed as property-based tests, verify that the units of code work as intended for any given input and integration tests guarantee that the different components and modules of the framework can function together correctly, and the main workflow is correct. The tools of choice for programming these tests have been the ScalaTest suite, as the main unit- and integration-testing framework, and the ScalaCheck as the property-based testing provider and test case generator.

All these tests are accessible through the main code repository of the software, and any skilled developer can execute them locally with the Simple Build Tool (SBT) runner and its “test” command. Refer to the Mode of availability section to know how to access the code repository of the BIOMedical Search Engine Framework.

@&#RESULTS@&#

The BIOMedical Search Engine Framework supported the implementation of the Smart Drug Search (SDS), a publicly accessible drug-related literature search application supporting research on microbial virulence, antimicrobial resistance and novel antimicrobial products (Fig. 5
                     ).

Currently, SDS indexes more than 1,186,000 article abstracts and 772,000 concepts, containing an average of 9 annotations per document (see Table 3
                     ).

In the private area of the SDS, the administrator manages, and monitors, the processes of document retrieval and annotation (Fig. 6
                        ). PubMed is the primary source of literature of SDS and MEDLINE eUtils services are used to retrieve documents [27]. Documents may be retrieved using keyword-based Boolean expressions or by indicating a list of PubMed identifiers.

The administrator can also execute document annotation, triggering as many annotator tools as specified in the configuration file. The documents pending (or failing) annotation are easily identified and can be re-issued.

Once the documents are stored in the database, the annotation module is started. Currently, SDS addresses the annotation of drugs and related substances, organisms, diseases, genes and proteins. To perform that annotation, SDS uses the following NER tool: ABNER, that provides information on gene and protein mentions [28]; OSCAR4, that identifies chemical entities and is able to normalize textual mentions to the IUPAC International Chemical Identifier (InChI) notation [29]; and Linnaeus, which is responsible for finding species mentions and normalize them to the scientific or formal name, as specified in NCBI Taxonomy [30]. It also includes a dictionary-based disease annotator based on the Disease Ontology [31] and a dictionary-based drug annotator based on DrugBank controlled vocabulary [18].

The population of the search index is a scheduled operation that will run in configurable intervals. At that point, the indexer will retrieve all the annotated concepts and create a TF-IDF ranked index. Index update does not condition the operation of the search engine. That is, any queries issued while the index is being updated are resolved on the old index. Once the update finishes, queries will be automatically directed to the updated index.

SDS query interface presents a simple and an advanced mode. Keyword-based Boolean expressions are the most common way of describing the query (Fig. 7-1
                        ). Users may also use concept-based facets to narrow down the query. For example, the user may be interested in documents that contain compound, gene and drug annotations (Fig. 7-3). Likewise, documents may be filtered by conventional searchable fields, such as publication date (Fig. 7-4).

The retrieved documents are presented as a list (Fig. 7-2). Each document is described in terms of the annotated concepts and the resulting semantic score. Results list may be further filtered by concept classes. For example, we may wish to see only documents that mention DNA entities (Fig. 7-5). Finally, the user may click on the document and read the semantically annotated abstract or access the PubMed record for additional information (Fig. 7-6).

Behind the scene, once the SDS receives a query, the engine requests all the configured searchers in the searcher module to extract the relevant concepts and retrieve their database representation. SDS implements searchers for OSCAR4, Linnaeus and our dictionary-based disease and drug annotators. The ABNER tagger is not included as a searcher because it does not support term normalization. As alternative, the engine uses a common searcher that looks for the keywords directly in the index. This operation is done concurrently, i.e. all configured searchers work at the same time, and once all operations are completed the results are aggregated (removing duplicate terms).

The retrieved documents are ranked based on the aggregated TF-IDF score of the included concepts. This operation is done asynchronously with respect to the rest of the system, allowing multiple queries to be processed at the same time and without affecting the performance of any other operation on the system.

The most immediate result of a user search will be a list of documents, sorted by semantic relevance. However, given the potentially large number of results that a query may return, SDS relies on a semantic graph structure to provide improved means of navigation and analysis (Fig. 8
                        ).

At first, the graph view renders the concepts in the retrieved documents, linked by direct co-reference in text. Color denotes concept class type, and the size of nodes and the width of edges indicate the frequency of occurrence (Fig. 8-1). By toggling the concept class facets, the user may look into sub-graphs (Fig. 8-2). Likewise, by clicking in the edge connecting two nodes, the user gets the documents supporting the reference or association (Fig. 8-3). Finally, the user may investigate the direct associations of a given node (Fig. 8-4), i.e. its neighbors, and the indirect associations between any given concepts (shortest path), i.e. look for concepts that do not have a direct link but are related by intermediary nodes (Fig. 8-5). Notably, the tool calculates the shortest path between the selected nodes, assuming that an association with fewer intermediary nodes is stronger.

The different modules that compose the BIOMedical Search Engine Framework were tested for their respective execution times within the scope of the SDS application. These tests were performed with SDS running on a personal computer with a four-core Intel Core i7 processor, 8 GB of RAM, a Linux distribution executing the kernel's version 4.3.3 and the OpenJDK distribution of the Java Runtime Environment on version 8.u60.

The execution of the PubMed provider module was tested by keeping track of the download times of the documents currently stored in the database. The average execution time is 24 ms per document considering a variation in time between 6 ms per document (the minimum execution time observed) and 40 ms per document (the maximum execution time observed). As illustrated in Fig. 9
                        , the execution time throughout the database population process, i.e. the download and storage of the 1,182,670 documents in the current SDS database, was mostly constant, with little deviations from the average time.

The population of the SDS database was performed by requesting page sizes of 200 abstracts from PubMed. While the average time to download a single document does not vary greatly with respect to page size, the aggregated time can be significantly affected. Although choosing the right page size depends mostly on network capacity, a very small page size (e.g. 1 document or a couple of documents) or a very large page size (e.g. 1000 documents) becomes ultimately slower than page sizes on the order of a few hundreds (e.g. 200 or 300 documents per page).

Next, we verified the annotation process in SDS. The annotation of the more than one million documents in the database led to an average annotation time of 374 ms per document. As illustrated in Fig. 10
                        , the annotation time was quite variable, and while most of the documents took less than 50 ms to be annotated, a non-neglected fraction of the documents took from 100 ms to 350 ms to be annotated. This variability in the annotation time was expected, because this process depends mostly on the contents of the document being annotated and very little on the state of the actual system.

It is also noteworthy that the annotation execution time discussed here does not include the insertion of the annotations in the database, only the automatic recognition of the biomedical entities. The insertion of records in the database can impose some additional delays depending on how the database is configured to handle the insertion and retrieval of annotations in bulk.

Arguably, the indexer module is the most time-consuming of all the modules in the BIOMedical Search Engine Framework. Considering the current volume of documents and annotations managed by SDS, the indexation process took a total time of 8 hours. Under this scenario, it is highly recommended that medium to large-scale applications, such as SDS, will be executed on a machine with high computing power. Conversely, if the data volume to be handled is relatively small, the application could be easily executed on a personal computer. For example, in an earlier version of SDS, the indexation of 30,000 documents and 360,000 annotations took only 40 minutes.

Finally, we tested the searcher module in order to determine the average response time to a search query. For this purpose, we executed 20 search queries with varying complexity (with respect to the total of articles retrieved, ranging from very few results to almost half the database) over various search indexes: 250,000 indexed documents, 500,000 indexed documents, 750,000 indexed documents and the complete SDS database of more than 1 million documents (Table 4
                        ). The documents included in each search index were selected randomly from the current SDS database.

As illustrated in Fig. 11
                        , those queries that return a greater number of results (i.e. are more generic) tend to take longer to execute than those with less matching documents (i.e. are more specific). At the same time, one can observe that the volume of the search index is a key factor in the execution time, i.e. most of the execution time is spent on the retrieval of records from the database, and the translation of search terms into domain concepts is negligible.

In our worst scenario, i.e. a query that returns almost 500,000 records from the complete SDS index (Q9), the execution time is of 13 seconds approximately. We consider this time acceptable, in particular considering that a query that returns so many results is necessarily very generic, and it is unlikely that SDS users will issue such broad scope queries. Moreover, it is important to note that the query execution tests have been performed without memorization of query results, which will improve the execution time for subsequent equivalent queries in a real-world scenario. For example, if the user issues the query “human” and then searches for “homo sapiens”, the second query will complete almost instantaneously, because the results for the former query will be already cached in memory.

The performance of the searcher module is the most noticeable to the end users of SDS. Therefore, the next releases of the BIOMedical Search Engine Framework and the SDS application will address the optimization of this module and, in particular, the mitigation of the time spent on the retrieval of records from the database.

@&#CONCLUSIONS@&#

This paper introduces the BIOMedical Search Engine Framework, which supports the construction of domain-specific literature search engines for biomedical applications. This framework integrates consolidated search engine technologies and state-of-the-art text mining methods and tools. Its primary aim is to take advantage of semantic analysis to enhance domain-specific search experience while minimizing the programming costs of elementary document retrieval and processing. Its modular architecture enables the customization and interchange of components to meet the requirements of a particular domain of application. It also provides a RESTful API that enables the integration of the engine in existing systems and the complete personalization of the web interface.

The Smart Drug Search system was built on top of this framework and aims to assist researchers in the study of alternative and novel antimicrobial products. This engine uses NER tools to automatically recognize textual mentions to drugs/compounds, diseases, species, proteins and genes in the articles, and construct an efficient search index with those domain-specific concepts.

Administrator and user experience with SDS provided valuable insight on how to keep developing the framework. Future versions of the framework will provide an easier mechanism to include different document sources (e.g. patents or full-text collections) in the same way that different annotators and searchers can be already included. At the same time, the web-based interface is being enhanced to deliver a richer and more visually appealing experience to the end users. The graph view of search results is being explored in that direction, but more web-interface capabilities are already being planned.

The code of the BIOMedical Search Engine Framework and its documentation are accessible at https://github.com/agjacome/biomsef and freely available under MIT License. The Smart Drug Search engine can be accessed at http://sing.ei.uvigo.es/sds/.

@&#ACKNOWLEDGEMENTS@&#

This work was partially funded by the [14VI05] Contract-Programme from the University of Vigo and the Agrupamento INBIOMED from DXPCTSUG-FEDER unha maneira de facer Europa (2012/273). The research leading to these results has also received funding from the European Union Seventh Framework Programme FP7/REGPOT-2012-2013.1 under grant agreement n° 316265, BIOCAPS. This document reflects only the author's views, and the European Union is not liable for any use that may be made of the information contained herein.

@&#REFERENCES@&#

