@&#MAIN-TITLE@&#A multi-label approach using binary relevance and decision trees applied to functional genomics

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose an adaptation for the Binary Relevance (BR) algorithm.


                        
                        
                           
                           It may decrease the number of classifiers to be analyzed by human experts.


                        
                        
                           
                           When all the labels are related, our approach finds a single classifier.


                        
                        
                           
                           When all the labels are uncorrelated our approach will be equal to BR.


                        
                        
                           
                           Performance comparable to other algorithms, with good F-measure results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi-label classification

Decision tree

Functional genomics

@&#ABSTRACT@&#


               
               
                  Many classification problems, especially in the field of bioinformatics, are associated with more than one class, known as multi-label classification problems. In this study, we propose a new adaptation for the Binary Relevance algorithm taking into account possible relations among labels, focusing on the interpretability of the model, not only on its performance. Experiments were conducted to compare the performance of our approach against others commonly found in the literature and applied to functional genomic datasets. The experimental results show that our proposal has a performance comparable to that of other methods and that, at the same time, it provides an interpretable model from the multi-label problem.
               
            

@&#INTRODUCTION@&#

Since the advance of hardware and software, the automated sequencing of DNA fragments has become possible. The amount of biological data available has been increasing, which also increases the need for computational tools for knowledge extraction. Machine learning techniques are widely used to predict gene functions so that the best predictions can then be tested in the lab to validate the results [1]. However, predicting gene functions is a complex process because a single gene may have multiple functions. Consequently, multi-label classification seems to be appropriated.

There are several reasons to investigate and propose new multi-label classification techniques, especially in the bioinformatics or bio-related research fields. Gene Ontology
                     
                        2
                        
                           http://www.geneontology.org/.
                     
                     
                        2
                      is an example of a multi-label problem, where genes and proteins may have more than one function or feature. Another example is the MIPS Functional Catalogue [2], in which genes and proteins may belong to more than one functional class. Therefore, it is very important to carry out research on computational techniques to classify multi-label problems using proteins, genes and other biological and medical data: with such knowledge it is possible to develop new drugs, treat diseases, and help in diagnostics.

Traditional algorithms are unable to handle a set of multi-label instances, since such algorithms were designed to predict a single label. A simple solution to this is to transform the original dataset into several sets of instances where each set contains all the attributes, but only one label to be predicted. This algorithm is known as Binary Relevance (BR). However, studies have shown that this approach is not a good solution [3,4], since each label is treated individually, generating one classifier for each label, and ignoring possible correlations among them. An algorithm that finds a classifier for more than one label can intuitively capture some correlations between them, and a simpler classifier may be found (one which uses a smaller number of rules, for example). Under these circumstances, it is important to research and develop techniques that use the Binary Relevance algorithm, extending it to capture possible relations among labels.

This study presents a new adaptation of the Binary Relevance algorithm using decision trees to treat multi-label problems. Decision trees are symbolic learning models that can be analyzed as set of rules in order to improve the understanding, by human experts, about the knowledge extracted. For this reason, the algorithm proposed here was designed to capture relations between labels, a feature the original Binary Relevance algorithm does not take into account, and consequently upgrade its generalization ability. Furthermore, since the present study takes model interpretability into account (and not only performance), our approach reduces the number of induced trees for expert interpretation: in the best scenario, it builds only one model (tree) that classifies all labels.

This paper is organized as follows: Section 2 describes related studies in the literature; Section 3 presents the basic concepts of multi-label classification; Section 4 presents our multi-label learning algorithm. Section 5 describes the experimental methodology to evaluate our approach; Results and discussion are presented in Section 6. Finally, Section 7 presents the final remarks and future work.

@&#RELATED WORK@&#

Different techniques have been proposed in the literature for treating multi-label classification problems. In some of them, single-label classifiers are combined to treat multi-label classification problems. Other techniques modify single-label classifiers, changing their algorithms to allow their use in multi-label problems.

BR+algorithm [5], an extension of the BR algorithm, considers the relationship between labels, and constructs binary classification problems, similarly to BR. Its main differences are its descriptor attributes, which merge all original attributes as well as all labels, except for the label to be predicted itself.

Another study using decision trees for hierarchical multi-label classification was used to analyze information about
                     Saccharomyces cerevisiae, and tries to predict new gene functions [3]. Resampling strategies were developed, and a modified version of the algorithm C4.5 [6] was used.

The Mulam [7] tool was developed based on the Weka machine learning library [8], and contains several algorithms, such as BR (Binary Relevance) [9], LP (Label Powerset) [9], RaKel (RAndom k-labELsets) [10], and ML-kNN (Multi-Label k-Nearest Neighbours) [11]. In the Binary Relevance algorithm, the original dataset is divided into sets of instances, where each instance contains all the attributes but only the label to be predicted. Then, c classifiers are induced (where c represents the total number of labels), and each induced classifier is trained to distinguish one label against all the others involved. The Label Powerset algorithm is based on a combination of more than one label to create a new one, but this may result in a considerable increase in the number of labels, and some may end up with few instances. The RAkEL algorithm constructs an ensemble of LP classifiers, and each classifier is trained with a small subset of k random labels. Algorithm ML-KNN is based on algorithm kNN: for each test instance, its k nearest neighbors in the training set are identified. Then, according to statistical information from the label set of neighboring instances, the maximum a posteriori principle is applied to determine the label set for a particular test instance.

A tool called Clus [12] uses concepts from Predictive Clustering Trees (PCT). Decision trees are constructed where each node corresponds to a group of instances from the dataset. PCT is a clustering approach that adapts the basic top-down induction of decision trees for clustering. The procedure used for constructing the PCT is similar to other induction algorithms of decision trees such as C4.5 [6] and CART [13]. Clus-HMC [14] refers to the use of Clus as a multi-label hierarchical classification system that learns a tree to classify all labels, and Clus-SC generates a decision tree for each label.

MHCAIS (Multi-label Hierarchical Classification with an Artificial Immune System) [15] is an adapted algorithm for multi-label and hierarchical classification. The first version of this algorithm builds a global classifier to predict all labels, while the second version builds a classifier for each label. In both versions, the classifier is expressed as a set of IF–THEN rules, which has the advantage of being knowledge understandable to specialists.

Other researchers developed a Network Hierarchical Multi-label Classification algorithm that exploits individual properties of proteins as well as protein–protein interactions (PPI) to predict gene/protein functions [16]. These researchers advocate that (i) the PPI network is exploited in the training phase and can thus make predictions for genes/proteins whose interactions are yet to be investigated; (ii) their method yields better performance than the others by using network and properties separately; and (iii) the use of network information improves the accuracy of gene function prediction not only for highly connected genes, but also for genes with only a few connections. Like Clus-HMC, NHMC also exploits the hierarchical organization of class labels (gene functions), which may have the form of a tree or of a direct acyclic graph (DAG).

The R3P-Loc is a multi-label ridge regression classifier that uses two databases for feature extraction, applying random projection to reduce its feature dimensions [17]. In terms of locating proteins within cellular contexts, R3P-Loc indicates a reduction in the number of dimensions of feature vectors as much as seven-folds, while it also improves the classification performance. Considering the multi-level classification of phylogenetic profiles, authors have proposed an algorithm to capture, at each level, the different aspects of affinity of a protein with another, in the same or in different species [18]. As a result, inter and intra-genome gene clusters are predicted. Aiming at facilitating biological interpretation, the same authors extract close gene associations from metabolic pathways through unsupervised clustering at a sequence level [19]. This level of association can be enhanced if the phylogenetic relationship of the corresponding genomes is taken under consideration.

Basically, the classification task aims to discover knowledge that can be used to predict the unknown class of an instance, based on the values of the attributes that describe such an instance. As a result, we can divide the classification tasks according to the number of labels to be predicted for each instance into two groups: (a) Single-label Classification and (b) multi-label classification. Single-label classification refers to the classification task where there is only one label (the target concept) to be predicted [20]. The basic principles of multi-label classification are similar to single-label classification, however the multi-label classification has two or more concept labels to be predicted. Considering symbolic models expressed as rules, a multi-label classification rule contains two or more conclusions, each one involving a different label.

Next, we formalize the notation used in the remaining text. Let X be the domain of instances to be classified, Y be the set of labels, and H be the set of classifiers for 
                        
                           f
                           :
                           X
                           →
                           Y
                        
                     , where f is unknown. The goal is to find the classifier 
                        
                           h
                           ∈
                           H
                        
                     , maximizing the probability of 
                        
                           h
                           (
                           x
                           )
                           =
                           y
                        
                     , where 
                        
                           y
                           ∈
                           Y
                        
                      is the ground truth label of x 
                     [21].


                     Table 1
                      shows the modified representation of attribute–value to deal with multi-label problems. A dataset is characterized by N instances 
                        
                           
                              
                                 z
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 z
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 z
                              
                              
                                 N
                              
                           
                        
                     , each containing m attributes 
                        
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 X
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 X
                              
                              
                                 m
                              
                           
                        
                      and c labels 
                        
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 Y
                              
                              
                                 c
                              
                           
                        
                      . On this table, row i refers to the i-th instance (
                        
                           i
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           N
                        
                     ); entry 
                        
                           
                              
                                 x
                              
                              
                                 ij
                              
                           
                        
                      refers the value of j-th attribute (
                        
                           j
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           m
                        
                     ) of instance i, and output 
                        
                           
                              
                                 y
                              
                              
                                 ik
                              
                           
                        
                      refers to the value of k-th label (
                        
                           k
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           c
                        
                     ) of instance i. The instances are tuples 
                        
                           
                              
                                 
                                    
                                       z
                                    
                                    
                                       →
                                    
                                 
                              
                              
                                 i
                              
                           
                           =
                           (
                           
                              
                                 x
                              
                              
                                 i
                                 1
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 i
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 x
                              
                              
                                 im
                              
                           
                           ,
                           
                              
                                 y
                              
                              
                                 i
                                 1
                              
                           
                           ,
                           
                              
                                 y
                              
                              
                                 i
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 y
                              
                              
                                 ic
                              
                           
                           )
                           =
                           (
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       →
                                    
                                 
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 
                                    
                                       y
                                    
                                    
                                       →
                                    
                                 
                              
                              
                                 i
                              
                           
                           )
                        
                      also denoted by 
                        
                           
                              
                                 z
                              
                              
                                 i
                              
                           
                           =
                           (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                           )
                        
                     , where the fact that 
                        
                           
                              
                                 z
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                        
                      and 
                        
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                        
                      are vectors is implicit. Note each 
                        
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                        
                      is a member of the set 
                        
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           ×
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           ×
                           …
                           ×
                           
                              
                                 Y
                              
                              
                                 c
                              
                           
                        
                     ; without loosing generality we will assume 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                           ∈
                           {
                           0
                           ,
                           1
                           }
                        
                     , i.e., each label will only assume binary values.

Next, before introducing our algorithm, we introduce some additional notations:
                        
                           •
                           
                              D: the full dataset with all attributes and labels {
                                 
                                    
                                       
                                          X
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          X
                                       
                                       
                                          m
                                       
                                    
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          c
                                       
                                    
                                 
                              };


                              
                                 
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    ≡
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          i
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          im
                                       
                                    
                                    )
                                 
                              : learning attributes for instance i;


                              
                                 
                                    
                                       
                                          y
                                       
                                       
                                          i
                                       
                                    
                                    ≡
                                    
                                       
                                          
                                             
                                                y
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          y
                                       
                                       
                                          i
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          i
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          ic
                                       
                                    
                                    )
                                 
                              : learning labels for instance i;


                              
                                 
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    ≡
                                    
                                       
                                          
                                             
                                                z
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                y
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              : learning instance i;


                              
                                 
                                    h
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              : the multi-label classifier model which outputs the predicted labels for instance i;


                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          l
                                       
                                    
                                 
                              : the labels dataset 
                                 
                                    
                                       
                                          D
                                       
                                       
                                          l
                                       
                                    
                                    ≡
                                    D
                                    ⧹
                                    {
                                    
                                       
                                          X
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          X
                                       
                                       
                                          m
                                       
                                    
                                    }
                                 
                              ;


                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          a
                                       
                                    
                                 
                              : the attributes dataset 
                                 
                                    
                                       
                                          D
                                       
                                       
                                          a
                                       
                                    
                                    ≡
                                    D
                                    ⧹
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          c
                                       
                                    
                                    }
                                 
                              ;


                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    :
                                    
                                       
                                          D
                                       
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    ≡
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                          -
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          c
                                       
                                    
                                    }
                                    ∪
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                               is a label dataset where 
                                 
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                          -
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          c
                                       
                                    
                                    }
                                 
                               are learning attributes and 
                                 
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                               is the target class;


                              
                                 
                                    
                                       
                                          D
                                       
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                 
                              : a dataset containing all attributes and the label 
                                 
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                       
                                    
                                 
                               that represents a target class, defined as 
                                 
                                    
                                       
                                          D
                                       
                                       
                                          i
                                       
                                    
                                    ≡
                                    
                                       
                                          D
                                       
                                       
                                          a
                                       
                                    
                                    ∪
                                    {
                                    
                                       
                                          Y
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                              ;


                              
                                 
                                    
                                       
                                          R
                                       
                                       
                                          j
                                       
                                       
                                          t
                                       
                                    
                                    :
                                    j
                                 
                              -th rule from tree t, where 
                                 
                                    
                                       
                                          R
                                       
                                       
                                          j
                                       
                                       
                                          t
                                       
                                    
                                    ≡
                                    
                                       
                                          B
                                       
                                       
                                          t
                                       
                                    
                                    →
                                    
                                       
                                          E
                                       
                                       
                                          t
                                       
                                    
                                 
                               represents the logic implication (if 
                                 
                                    
                                       
                                          B
                                       
                                       
                                          t
                                       
                                    
                                 
                               then 
                                 
                                    
                                       
                                          E
                                       
                                       
                                          t
                                       
                                    
                                 
                              ).

The strategy to deal with multi-label problems proposed in this study is presented in Algorithm 1. It can be divided into three main steps.
                        Algorithm 1
                        Binary Relevance with Decision Trees – BR-DT 
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             Require: multi-label dataset D containig m attributes 
                                                
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                
                                              and c labels 
                                                
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             Ensure: ExtendedTrees
                                       
                                       
                                          
                                             1:
                                          
                                             
                                                
                                                   G
                                                   ←
                                                   ∅
                                                
                                             
                                          
                                       
                                       
                                          
                                             2:
                                          
                                             
                                                
                                                   Extended
                                                   ←
                                                   ∅
                                                
                                             
                                          
                                       
                                       
                                          
                                             3:
                                          
                                             for 
                                             
                                                
                                                   i
                                                   ←
                                                   1
                                                
                                              
                                             to 
                                             c 
                                             do
                                          
                                       
                                       
                                          
                                             4:
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ←
                                                
                                              BuildDecisionTree(
                                                
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         l
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             )
                                       
                                       
                                          
                                             5:
                                          
                                             
                                             for 
                                             
                                                
                                                   w
                                                   ←
                                                   1
                                                
                                              
                                             to 
                                             c 
                                             do
                                          
                                       
                                       
                                          
                                             6:
                                          
                                             
                                             if 
                                             
                                                
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         w
                                                      
                                                   
                                                   ⊂
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                              
                                             then
                                          
                                       
                                       
                                          
                                             7:
                                          
                                             
                                             
                                             
                                                
                                                   G
                                                   ←
                                                   G
                                                   ∪
                                                   {
                                                   (
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         w
                                                      
                                                   
                                                   )
                                                   }
                                                
                                             
                                          
                                       
                                       
                                          
                                             8:
                                          
                                             
                                             end if
                                          
                                       
                                       
                                          
                                             9:
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          10:
                                          
                                             end for
                                          
                                       
                                       
                                          11:
                                          
                                             for 
                                             
                                                
                                                   i
                                                   ←
                                                   1
                                                
                                              
                                             to 
                                             c 
                                             do
                                          
                                       
                                       
                                          12:
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ←
                                                
                                              BuildDecisionTree(
                                                
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         a
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             )
                                       
                                       
                                          13:
                                          
                                             
                                             
                                                
                                                   S
                                                   ←
                                                
                                              
                                             
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          14:
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ←
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          15:
                                          
                                             
                                             loop
                                          
                                       
                                       
                                          16:
                                          
                                             
                                             
                                                
                                                   SR
                                                   ←
                                                
                                              SelectAllRules(S), where 
                                                
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         j
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         k
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          17:
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         Rule
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   ←
                                                
                                              BuildRules(SR), in form 
                                                
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         j
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   →
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         j
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   ∧
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         k
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          18:
                                          
                                             
                                             
                                                
                                                   L
                                                   (
                                                   
                                                      
                                                         Rule
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                   ←
                                                
                                             calculate laplace of 
                                                
                                                   
                                                      
                                                         Rule
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          19:
                                          
                                             
                                             
                                                
                                                   Ω
                                                   ←
                                                
                                             select the rule with the largest 
                                                
                                                   L
                                                   (
                                                   
                                                      
                                                         Rule
                                                      
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                
                                              precision
                                       
                                       
                                          20:
                                          
                                             Extended 
                                                
                                                   ←
                                                
                                              Extended 
                                                
                                                   ∪
                                                   {
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         i
                                                         -
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         i
                                                         +
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                   }
                                                   ∩
                                                   Ω
                                                
                                             
                                          
                                       
                                       
                                          21:
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ←
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ∪
                                                
                                              Extended
                                       
                                       
                                          22:
                                          
                                             
                                             if There are labels to be considered from 
                                                
                                                   {
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         i
                                                         -
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         i
                                                         +
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                   }
                                                
                                              
                                             then
                                          
                                       
                                       
                                          23:
                                          
                                             
                                             
                                             
                                                
                                                   SL
                                                   ←
                                                
                                              select one label y considering the best accuracy of 
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         y
                                                      
                                                   
                                                
                                              from Extended
                                       
                                       
                                          24:
                                          
                                             
                                             
                                             
                                                
                                                   S
                                                   ←
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         SL
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          25:
                                          
                                             
                                             else
                                          
                                       
                                       
                                          26:
                                          
                                             
                                             exit loop
                                       
                                       
                                          27:
                                          
                                             
                                             end if
                                          
                                       
                                       
                                          28:
                                          
                                             
                                             end loop
                                          
                                       
                                       
                                          29:
                                          
                                             end for
                                          
                                       
                                       
                                          30:
                                          ExtendedTrees 
                                                
                                                   ←
                                                   ∅
                                                
                                             
                                          
                                       
                                       
                                          31:
                                          
                                             for 
                                             
                                                
                                                   j
                                                   ←
                                                   1
                                                
                                              
                                             to 
                                             
                                                
                                                   C
                                                   (
                                                   G
                                                   )
                                                
                                              
                                             do
                                          
                                       
                                       
                                          32:
                                          
                                             ExtendedTrees 
                                                
                                                   ←
                                                
                                              ExtendedTrees 
                                                
                                                   ∪
                                                
                                              {select 
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                              with the best HammingLoss}
                                       
                                       
                                          33:
                                          
                                             end for
                                          
                                       
                                       
                                          34:
                                          
                                             return ExtendedTrees
                                       
                                    
                                 
                              
                           
                        

The first step (Lines 3–10), in Fig. 1
                     , performs the induction of c decision trees, only taking labels into account (Line 4). In this situation, for each label 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      (
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           c
                        
                     ), a decision tree 
                        
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                      is induced, using the 
                        
                           c
                           -
                           1
                        
                      remaining labels (
                        
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 Y
                              
                              
                                 i
                                 -
                                 1
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 Y
                              
                              
                                 c
                              
                           
                        
                     ) as attributes and label 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      as the target label. After that, the c trees induced earlier are converted into an initially empty graph structure G. Let 
                        
                           C
                           (
                           G
                           )
                        
                      be the number of connected components of graph G. For each 
                        
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                     , an edge connecting labels 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                     , and 
                        
                           
                              
                                 Y
                              
                              
                                 j
                              
                           
                        
                      is added to G iff labels 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      and 
                        
                           
                              
                                 Y
                              
                              
                                 j
                              
                           
                        
                      are connected in 
                        
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                      (Line 7). Fig. 1 shows an example of how the graph is built from a set of trees 
                        
                           
                              
                                 A
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 A
                              
                              
                                 c
                              
                           
                        
                     .

This first step tries to find groups of related labels and is represented by a connected component in G. It does not consider the directionality of edges, i.e., an undirected graph is built. At the end of this step, there are three possible situations:
                        
                           1.
                           
                              
                                 
                                    C
                                    (
                                    G
                                    )
                                    =
                                    1
                                 
                              , all labels are related to each other, and therefore there is only one connected component in G that contains all the labels;


                              
                                 
                                    C
                                    (
                                    G
                                    )
                                    =
                                    c
                                 
                              , no label is related to one another, then G contains c connected components; and


                              
                                 
                                    1
                                    <
                                    C
                                    (
                                    G
                                    )
                                    <
                                    c
                                 
                              , there are relationships among some labels.

In the second step (Lines 11–29), in Fig. 2
                     , the induction of tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      is carried out, now taking into account all attributes 
                        
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 X
                              
                              
                                 m
                              
                           
                        
                      and just one label 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      at a time (Line 12). After that, each decision tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      is extended (Line 15), i.e., a process is performed so that each tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      can predict more than one label. The connected component of G containing node 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      is considered, since tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      is related to label 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                     , whereas it is the label to be predicted by 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                     . This results in new trees 
                        
                           T
                           
                              
                                 ′
                              
                              
                                 i
                              
                           
                        
                      that have a list of labels at each leaf node. If all labels are correlated (first situation above), then the tree will be extended to include all labels on its leaves. If there are two or more connected components (third situation), the tree is extended only for labels that are part of its component in G. If the second situation occurs, there are exactly c unextended trees, one for each label.

Still in the second step, tree 
                        
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                      is initially selected to start the extension S for tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                     , where 
                        
                           S
                           ←
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                      (Line 13). For each rule j from 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                     , a rule is created up to the root level of the tree. For each rule j from 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      all k rules S are then selected, where 
                        
                           
                              
                                 E
                              
                              
                                 j
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           =
                           
                              
                                 E
                              
                              
                                 k
                              
                              
                                 S
                              
                           
                        
                      (Line 16). After that, all k rules 
                        
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                      are built in logical form 
                        
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           ≡
                           
                              
                                 B
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           →
                           
                              
                                 E
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           ∧
                           
                              
                                 B
                              
                              
                                 S
                              
                           
                        
                      (Line 17), i.e., the premise and conclusion of k-th rule of 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      are concatenated with the premise of rule S.

Then, the Laplace precision metric is computed (Line 18) for all rules 
                        
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                      to find the most accurate.
                        3
                        To choose the best metric, other metrics were investigated apart from Laplace. Specificity, negative precision and precision consider the set of instances with false premises and conclusions. Consequently, it is not interesting to use them to select the best rule, which must consider the set of instances with positive premise and conclusion. Metrics composed by divisor as the set of instances are not also interesting because conclusion identifies rules to defined edges. As a result, the idea of dividing the total number of instances eliminates the use of conclusion. Positive precision and sensitivity have unwanted properties because they further rules composed by less instances (false negative and false positive) without considering true positive. A solution to this problem is Laplace.
                     
                     
                        3
                      The best rule is selected with the largest Laplace value; this rule will be used to extend rule j from tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      (Line 19). The Laplace [22] is defined in (1), where 
                        
                           N
                           (
                           B
                           →
                           E
                           )
                        
                      is the number of instances satisfying both the premise and the conclusion, 
                        
                           N
                           (
                           B
                           )
                        
                      is the number of instances which satisfies only the premise, and 
                        
                           
                              
                                 k
                              
                              
                                 ^
                              
                           
                        
                      is the number of classes in the domain of 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                     . In our experiments, since 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                           ∈
                           {
                           0
                           ,
                           1
                           }
                        
                     , then 
                        
                           
                              
                                 k
                              
                              
                                 ^
                              
                           
                           =
                           2
                        
                     : 
                        
                           (1)
                           
                              L
                              (
                              
                                 
                                    R
                                 
                                 
                                    k
                                 
                                 
                                    
                                       
                                          T
                                       
                                       
                                          i
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    N
                                    (
                                    B
                                    →
                                    E
                                    )
                                    +
                                    1
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    N
                                    (
                                    B
                                    )
                                    +
                                    
                                       
                                          k
                                       
                                       
                                          ^
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     Fig. 3
                     a shows the extension of trees, where the computation of Laplace values is carried out for each 
                        
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     , choosing the largest value, as mentioned earlier; Fig. 3b shows how to extend the first rule on tree 
                        
                           
                              
                                 T
                              
                              
                                 1
                              
                           
                        
                     .

In case not all labels are extended from 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      components (Line 22), the process continues the extension on another tree. This tree is selected considering only trees in Extended, a subset from 
                        
                           {
                           
                              
                                 A
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 A
                              
                              
                                 i
                                 -
                                 1
                              
                           
                           ,
                           
                              
                                 A
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 A
                              
                              
                                 c
                              
                           
                           }
                        
                     . Only in case 
                        
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                        
                      appears in the rule selected is 
                        
                           
                              
                                 A
                              
                              
                                 i
                              
                           
                        
                      considered as a part of Extended (Line 24). Otherwise, if the extension of the tree 
                        
                           
                              
                                 T
                              
                              
                                 i
                              
                           
                        
                      is finished (Line 26), the loop terminates.

Finally, the third step, (Lines 30–33), in Fig. 4
                     , is when the selection of the tree with the lowest HammingLoss rate (see Section 5.4) per component occurs (Line 32). This step allows the selection of the best tree for each component, thus decreasing the number of trees to be analyzed. The algorithm outputs 
                        
                           C
                           (
                           G
                           )
                        
                      trees, each one of which is the best tree by component.

In order to evaluate the BR-DT Algorithm, we performed the following experiments:

The datasets used in the experiments reported here are from the functional genomic field, made available by the Catholic University of Leuven,
                           4
                           
                              http://dtai.cs.kuleuven.be/clus/hmc-ens/.
                        
                        
                           4
                         and are related to S. cerevisiae, in which the labels are hierarchically structured according to the Funcat catalog [23] developed by MIPS.
                           5
                           
                              http://www.aber.ac.uk/∼dcswww/Research/bio/dss/yeastpreds/yeast/classes.txt.
                        
                        
                           5
                         This catalog provides descriptions of functional proteins, and is structured as a four-level-deep tree.

In the experiments, we used the following ten sets of instances:
                           
                              •
                              
                                 Seq: contains sequence statistics, and is collected from various sources including ProtParam [24] and MIPS;


                                 Pheno: contains phenotype data, and is collected from various sources including TRIPLES [25], EUROFAN [26] and MIPS;


                                 CellCycle, Church, Derisi, Expr, Eisen, Gasch1, Gasch2, SPO: microarray data from [27–33], respectively;

A pre-processing of datasets was necessary to transform them into non-hierarchical data. Instead of a hierarchical attribute-class, a binary vector was created in which each position corresponded to a main category contained in the class of hierarchical dataset. Then, each instance was transformed from hierarchical class to non-hierarchical:
                           
                              •
                              Hierarchy Level 1: only considers the first hierarchy level (16 labels);

Hierarchy Level 2: only considers the second level (102 labels);

Hierarchy Level 3: only considers the third level (89 labels);

Hierarchy Level 4: only considers the fourth level (42 labels);

Normally, real world information is sampled in an irregular or unbalanced way. Unbalanced classes are a potential obstacle for classification algorithms because they may hinder the construction of models that are able to correctly discriminate the majority set from the minority one [34]. However, in general, the minority class is the most interesting and valuable in terms of representing possible new knowledge.

Several studies have reported that many base classifiers perform better if they are applied to balanced datasets [35,34,36,37]. Therefore a solution for learning models from unbalaced datasets is to make an adjustment to the dataset to equalize the distribution of instances. An example using sampling would be removing instances of the majority class (undersampling), or by adding instances of the minority class (oversampling) [38].

There are many methods in the literature for balancing classes applied to single-label problems. However, they do not apply to multi-label problems directly. To measure the balancing factor from a multi-label dataset D, we propose (2), where 
                           
                              
                                 
                                    n
                                 
                                 
                                    0
                                 
                                 
                                    k
                                 
                              
                              =
                              n
                              (
                              
                                 
                                    Y
                                 
                                 
                                    k
                                 
                              
                              =
                              0
                              )
                           
                         is the number of instances labeled 
                           
                              
                                 
                                    Y
                                 
                                 
                                    k
                                 
                              
                              =
                              0
                           
                        , and 
                           
                              
                                 
                                    n
                                 
                                 
                                    1
                                 
                                 
                                    k
                                 
                              
                              =
                              n
                              (
                              
                                 
                                    Y
                                 
                                 
                                    k
                                 
                              
                              =
                              1
                              )
                           
                         is the number of instances labeled 
                           
                              
                                 
                                    Y
                                 
                                 
                                    k
                                 
                              
                              =
                              1
                           
                        . This metric assumes values in the range 
                           
                              [
                              0
                              ,
                              1
                              ]
                           
                        , where higher values indicate more balanced class labels.
                           
                              (2)
                              
                                 Balancing
                                 (
                                 D
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       (
                                       
                                          
                                             n
                                          
                                          
                                             0
                                          
                                          
                                             k
                                          
                                       
                                       ×
                                       
                                          
                                             n
                                          
                                          
                                             1
                                          
                                          
                                             k
                                          
                                       
                                       )
                                    
                                    
                                       N
                                       ×
                                       c
                                    
                                 
                              
                           
                        
                     

Next, we describe some balancing strategies to solve multi-label problems. One way to solve the problem of unbalanced classes uses the algorithm-independent approach. In this case, a multi-label problem is transformed into a set of single-label problems, and thus it is possible to balance one label at a time.

In this study, we propose a balancing approach based on the Binary Relevance algorithm that uses both over- and undersampling as follows: first, the multi-label dataset D is transformed into a set of c single-label datasets 
                           
                              
                                 
                                    D
                                 
                                 
                                    k
                                 
                              
                           
                        . Each 
                           
                              
                                 
                                    D
                                 
                                 
                                    k
                                 
                              
                           
                         contains all attributes X, and only label 
                           
                              
                                 
                                    Y
                                 
                                 
                                    k
                                 
                              
                           
                         (
                           
                              k
                              =
                              1
                              ,
                              …
                              ,
                              c
                           
                        ). For binary classes, each dataset 
                           
                              
                                 
                                    D
                                 
                                 
                                    k
                                 
                              
                           
                         has a majority class, and a minority class. In these cases, for each dataset 
                           
                              
                                 
                                    D
                                 
                                 
                                    k
                                 
                              
                           
                        , undersampling is applied to instances belonging to the majority class, and oversampling is applied to instances belonging to the minority class. This strategy results in nearly balanced datasets.

After building a decision tree, it is possible that the induced classifier is very specific for the training data. In this case, the classifier overfits the training data too well. As the training data is only a sample of all possible instances, it is possible to add branches to the tree that improve the performance on the training data while decreasing performance on other instances outside it. In this situation, the accuracy (or other measure) on an independent (unseen) dataset yields to a poor performance classifier [39]. In order to avoid overfitting the data, some inducers prune the tree after inducing it. This process reduces the number of internal test nodes thus reducing the tree complexity while giving a better performance than the original tree. There are several pruning methods such as error-complexity [13] and pessimistic error [6]. The latter was used in this study.

The computation of multi-label evaluation metrics for model h on dataset D can be performed using two basic procedures called macro-averaging, and micro-averaging 
                        [9]. For a binary problem B, let 
                           
                              B
                              (
                              tp
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              fp
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              tn
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              fn
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              )
                              )
                           
                         denote the number of true positives, false positives, true negatives, and false negatives for label 
                           
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                           
                        , respectively. Micro-averaging values are computed globally on all labels, given by (3). On the other hand, macro-averaging metrics are calculated locally, according to (4).
                           
                              (3)
                              
                                 micro
                                 (
                                 B
                                 )
                                 =
                                 B
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   c
                                                
                                             
                                          
                                          tp
                                          (
                                          
                                             
                                                Y
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   c
                                                
                                             
                                          
                                          fp
                                          (
                                          
                                             
                                                Y
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   c
                                                
                                             
                                          
                                          tn
                                          (
                                          
                                             
                                                Y
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   c
                                                
                                             
                                          
                                          fn
                                          (
                                          
                                             
                                                Y
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 macro
                                 (
                                 B
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       c
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          c
                                       
                                    
                                 
                                 B
                                 (
                                 tp
                                 (
                                 
                                    
                                       Y
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 fp
                                 (
                                 
                                    
                                       Y
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 tn
                                 (
                                 
                                    
                                       Y
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 fn
                                 (
                                 
                                    
                                       Y
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 )
                              
                           
                        
                     

As can be seen, micro-averaging considers all examples as having the same weight; macro-averaging considers all labels having the same weight, regardless of their frequency [40]. In the reported experiments, we selected the micro-averaging computation for the F-measure (7), defined in terms of precision (5) and recall (6).
                           
                              (5)
                              
                                 Precision
                                 (
                                 h
                                 ,
                                 D
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       tp
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       tp
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       +
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       fp
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 Recall
                                 (
                                 h
                                 ,
                                 D
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             
                                                
                                                   Y
                                                
                                                
                                                   i
                                                
                                             
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       tp
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       tp
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       +
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       fn
                                       (
                                       
                                          
                                             Y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 F-measure
                                 (
                                 h
                                 ,
                                 D
                                 )
                                 =
                                 
                                    
                                       2
                                    
                                    
                                       
                                          
                                             1
                                          
                                          
                                             Precision
                                             (
                                             h
                                             ,
                                             D
                                             )
                                          
                                       
                                       +
                                       
                                          
                                             1
                                          
                                          
                                             Recall
                                             (
                                             h
                                             ,
                                             D
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The HammingLoss 
                        (8) measures the average error for all predicted labels [41], where 
                           
                              A
                              Δ
                              B
                           
                         represents the symmetric difference between sets A and B, and is equivalent to the exclusive or (XOR) logic operation. It ranges over 
                           
                              [
                              0
                              ,
                              1
                              ]
                           
                        , and small HammingLoss values indicate a better classification performance.
                           
                              (8)
                              
                                 HammingLoss
                                 (
                                 h
                                 ,
                                 D
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       N
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       |
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       
                                       Δ
                                       
                                       h
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       |
                                    
                                    
                                       c
                                    
                                 
                              
                           
                        
                     

The experiments were performed using the Weka library [8]. In the proposed BR-DT algorithm, decision trees were based on algorithm J48 [6] with default settings; pruned and unpruned trees were used to evaluate our proposal as explained in the following text. We evaluated our algorithm and five other algorithms: four from the Mulam library: Binary Relevance, Label Powerset [9], RAkEL (RAndom k-labELsets) [10] and MLkNN (Multi-Label k-Nearest Neighbours) [11]. Furthermore, the Clus library was also used for comparison.

The BR-DT algorithm was evaluated considering two situations (BR-DT Pru and BR-DT Unpr-Pr(1)), by performing two variations of pruning and balancing classes. In the first variation, BR-DT Pru, decision trees were induced unbalanced and trees were pruned in steps 1 and 3; in the second variation, BR-DT Unpr-Pr(1), decision trees were induced (from balanced samples) but not pruned in step 1, only in step 3. These variations were chosen to test the possibility of obtaining better results when generating trees in order to improve the connection between classes.

For BR, LP and RAkEL, the algorithm J48 was used with default settings, as was algorithm MLkNN. The algorithm Clus was used with reduced variance as heuristic, no binary split, and minimal weight equals 2. With these settings, two variations were used: Clus Pru (pruning method enable), and Clus Unpr (no pruning).

To analyze the performance, a 10-fold cross-validation was performed for each algorithm and each dataset, recording the metric F-measure described previously. To analyze significant results the Friedman test [42] was used, considering a significance level of 5%, and the Benjamini-Hochberg as the post hoc procedure [43].

@&#RESULTS AND DISCUSSION@&#

This section presents results concerning the F-Measure for each of the four levels of the hierarchy. We also show the average rank obtained by the Friedman. The best results for each dataset are shown in boldface and the best overall performance can be seen by analyzing the lower average rank. Furthermore, we also show the post hoc test results, where the symbol 
                        
                           ▵
                        
                      (
                        
                           ▴
                        
                     ) indicates that the variation of the specific line is better (significantly better) than the variation of the corresponding column, while the symbol 
                        
                           ▿
                        
                      (
                        
                           ▾
                        
                     ) indicates that the variation of the specific line is worse (significantly worse) than the variation of the corresponding column.

From Table 2
                        , it is possible to note that the BR-DT Pru algorithm had the second best average rank; the RAkEL algorithm achieved the best performance. Furthermore, the post hoc test does not show any significant difference in performance between BR-DT Pru and RAkEL. It can also be observed that the BR-DT Pru algorithm has got significantly better performance than algorithms BR-DT Unpr-Pr(1), LP, Clus Pru and Clus Unpr. Considering the BR-DT Unpr-Pr(1) algorithm, it presented the worst performance being worse than any other algorithm, and significantly worse than algorithms BR, RAkEL, MLkNN and Clus Pru.

From Table 3
                        , one can note that the BR-DT Pru and the BR-DT Unpr-Pr(1) algorithms obtained the fifth and sixth best average ranks, respectively. However, the post hoc test shows that the BR-DT Pru algorithm is better than the Clus Pru algorithm. It is noteworthy that only BR-DT and Clus algorithms can produce models that can be interpreted by human experts. At this level, the Clus Pru algorithm only produced tree leaves classifying all labels as negative; therefore the F-measure for all datasets was zero, except for dataset ‘Seq’.


                        Table 4
                         shows that the BR-DT Pru and the BR-DT Unpr-Pr(1) algorithms had the fourth and seventh best average ranks, respectively. It is also possible to note that in the post hoc test BR-DT Pru algorithm showed a significantly better performance than both the BR-DT Unpr-Pr(1) and the Clus Pru algorithms. Considering the BR-DT Unpr-Pr(1) algorithm, we can see that it presented the second worst performance, after Clus Pru. However, one can also observe in the post hoc test that the BR-DT Pru algorithm was significantly better than the Clus Pru algorithm, and that it was not significantly worse than the other algorithms. At this hierarchy level, the Clus Pru algorithm also produced tree leaves classifying all labels as negative; again the F-measure for all datasets was zero.

As shown in Table 5
                        , the BR-DT Pru and the BR-DT Unpr-Pr(1) algorithms obtained the third and fifth best average ranks, respectively. It can also be seen in the post hoc test that the BR-DT Pru algorithm had a better performance than the BR-DT Unpr-Pr(1), the RAkEL, the MLkNN, and the Clus Pru algorithms. The BR-DT Unpr-Pr(1) algorithm had a better performance than the MLkNN and the Clus Pru algorithms. At this hierarchy level, the Clus Pru algorithm also produced tree leaves, classifying all labels as negative; again the F-measure for all datasets was zero.

This section presents models obtained from the datasets ‘Pheno’ and ‘Seq’, considering only the first level of the hierarchy, since models generated from other datasets were tree leaves, except for the data set ‘SPO’, where a very large model was obtained.

Analyzing the tree illustrated in Fig. 5
                            and generated by the BR-DT algorithm from dataset ‘Pheno’, we can observe the presence of only one attribute (‘rapacymin’), which is a drug that inhibits the target of rapamycin (TOR) responsible for regulating growth, metabolism and aging. The model generated by the BR-DT algorithm contains four branches, and the branch that contains the greatest number of examples (99%) in the leaf is the one with value ‘n=no data’. The branch with value ‘w=wild type’ contains no examples on its leaf. Therefore, it is interesting to analyze the last two branches: the branch with value ‘s=sensitive’ predicts as 1 (present) the ‘Metabolism’ and the ‘Cellular Communications’ labels, and the branch with ‘r=resistence’ predicts to 1 (present) the label ‘Cell Cycle’.

Observing the model obtained by the Clus Pru algorithm, illustrated in Fig. 6
                           , a tree leaf only predicts the ‘Subcellular localization’ label as 1 (present). Therefore, any example predicted by this model for the ‘Subcellular Localization’ label is classified as 1 (present) and the other labels are classified as 0 (absent).


                           Fig. 7
                            shows the model generated by the BR-DT algorithm using the ‘Seq’ dataset in which it is possible to observe that the first two branches of the first tree are the most significant with respect to the number of examples (98.7%) in their leaves and they classify the ‘Metabolism’ and the ‘Subcellular Localization’ labels. Another observation is that all attributes appearing in the tree are aa_rat_pair_X_Y, meaning that the percentage of X and Y amino acid pairs appear consecutively, which is important to predict the CT (Cysteine and Threonine), GM (Glycine and Methionine), CY (Cysteine and Tyrosine), and MH (Methionine and Histidine) pairs.


                           Fig. 8
                            shows the model generated by the Clus Pru algorithm using the ‘Seq’ dataset. The last branch is the most significant with respect to the number of examples (58.0%) in its leaf, and it predicts the ‘Subcellular Localization’ label as 1 (present).

@&#CONCLUSIONS@&#

This paper presents a study on multi-label classification problem. In this scenario there is more than one label to be predicted, i.e., an instance may be related to more than one label at the same time, making the classification task more difficult. In order to improve performance and comprehensibility of the extracted model, in this study we proposed an adaptation for the Binary Relevance algorithm in order to overcome the disadvantage of the BR algorithm: we considered possible relationships among labels. This may improve the generalization ability of the model, and may possibly decrease the number of classifiers to be analyzed by human experts. When all the labels are related, our approach finds a single classifier (decision tree) that is able to classify them. Only when all labels are unrelated is the output model of our approach equal to BR (one decision tree for each label).

Experiments were conducted to compare the performance of our approach against others commonly found in the literature. The results lead us to conclude that our proposal has a performance comparable to that of other algorithms, as it obtained good results using the F-measure.

Based on these results we can observe that the variation in the BR-DT Pru algorithm in comparison with the Clus Pru algorithm at all levels had better results, although it did not obtain good results compared to the other algorithms in the second and third levels. One explanation for this result may be the high number of labels and few instances (per label) in the second and third levels.

Nowadays BR-DT only handles binary values. As future work, we intend to augment our proposal aiming to manipulate labels composed by more than two values. The current BR-DT algorithm only assigns a label to a class during classification and during the extension of the tree. After some iterations, this assignment should be rechecked to avoid error propagation. Another future work will be carried out in terms of improvement of execution time since BR-DT may be computationally expensive depending on the dataset.


                     Software Availability: Tool and thesis are available for downloading at http://dcm.ffclrp.usp.br/?pagina=dcm-eventos-pt&cod=168.

@&#ACKNOWLEDGEMENTS@&#

This research was partially funded by a joint grant between the Coordination for the Improvement of Higher Level (CAPES), and the Amazon State Research Foundation (FAPEAM) through the National Institute of Science and Technology Program, INCT ADAPTA Project (Centre for Studies of Adaptations of Aquatic Biota of the Amazon).

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.jbi.2014.12.011.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

