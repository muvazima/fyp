@&#MAIN-TITLE@&#Mechanical assembly planning using ant colony optimization

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We model an ant colony optimization based method for mechanical assembly planning.


                        
                        
                           
                           The computation framework couples both a solution generation and an optimization search.


                        
                        
                           
                           The proposed search strategy improves the performance of the assembly planning method.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Assembly information modeling

Mechanical assembly planning

Ant colony optimization

@&#ABSTRACT@&#


               
               
                  In mechanical assembly planning research, many intelligent methods have already been reported over the past two decades. However, those methods mainly focus on the optimal assembly solution search while another important problem, the generation of solution space, has received little attention. This paper proposes a new methodology for the assembly planning problem. On the basis of a disassembly information model which has been developed to represent all theoretical assembly/disassembly sequences, two decoupled problems, generating the solution space and searching for the best result, are integrated into one computation framework. In this framework, using an ant colony optimization algorithm, the solution space of disassembly plans can be generated synchronously during the search process for best solutions. Finally, the new method’s validity is verified by a case study.
               
            

@&#INTRODUCTION@&#

As an important research topic in the manufacturing automation field, the assembly sequence planning problem encompasses some very active sub-problems, e.g., the representation of assembly constraints  [1], the generation of feasible assembly plans  [2], and the selection of final assembly plans  [3]. Mathematically, this is an NP-hard problem. For a complex mechanical product with many parts, the number of possible assembly sequences may be too large to handle efficiently with traditional methods. This challenge is one important driving force to promote research on computerized assembly/disassembly planning. The pioneering work on assembly planning research had been done by Bourjault (1984,  [1]), Homem de Mello and Sanderson (1990,  [2]), who developed the basic academic idea of assembly/disassembly planning, “Product assembly model (graph)  +  Optimization algorithm for disassembly solution”—that is, modeling the solution space and then, finding out the best result. However, the combinational complexity remains a fundamental challenge even for computerized solving tools. Searching the graph model (solution space) for the best plan is not an easy job, particularly, if considering the difficulty of building an evaluation standard on assembly plan performance. Meanwhile, determining the assembly precedence relationships needs to check geometric interferences by manual or automatic computation which is also time-consuming. This is why many intelligent optimization algorithms become the main powerful tool in disassembly planning study.

During the past several years, significant work has been done to develop Artificial Intelligence (AI) and soft computing techniques applicable to assembly planning in order to attain an optimal solution efficiently. Many applications of AI technologies in assembly/disassembly sequence planning have been introduced [4–18]: particularly, genetic algorithms (GA), expert systems, simulated annealing, Petri nets, and neural networks. The genetic algorithm is a widespread approach for the assembly/disassembly sequence planning problem, owing to its capability to evolve towards optimal solutions without processing all the alternatives. In their GA methods for assembly planning, Lazzerini, Marcellon and Dini, et al.  [19], designed a three-part chromosome to represent necessary assembly information including products’ component, direction of operation, and used gripper. Konggar and Gupta  [20] also proposed a genetic algorithm for disassembly process planning. Similar to Lazzerini’s method, each chromosome (solution) consists of three parts of equal length, including the disassembly sequence of components, operational directions, and the sign of destructive or nondestructive methods. A similar encoding method was also used by Galantucci L. M. who had presented a fuzzy logic and genetic algorithm system for assembly/disassembly planning  [21]. However, the GA search usually heavily depends on the performance of encoding methods and genetic operators. Improper encoding may have a negative impact on describing/searching the space of solutions. For example, binary-coded representations are often affected by the so-called Hamming cliff problem, which may lead to bad offspring, infeasible or far different from parents. All of them may deteriorate the performance of GA algorithms.

The ant colony optimization (ACO) algorithm, one of the most promising biologically inspired optimization algorithms, is emerging as an innovative tool for solving computational problems of finding good paths through graphs. This algorithm paves an interesting way for sequencing problems even though its ability and performance in this field is still to be investigated. For instance, an ACO algorithm for the disassembly line balancing problem (DLBP) has been developed by McGovern and Gupta  [22,23]. And the studies done by F. Failli  [24] and Wang J. F.  [25] were more typical in assembly planning. F. Failli had used a graph called the Disassembly Nodes Network (DNN) to represent all possible solutions (Fig. 1
                     ). Each node in the graph represented a disassembly operation, defined as a combination of component, disassembling gripper, and disassembly direction. As F. Failli said, “The software implementation of this method is based on the schematization of the disassembly of a product in a network of nodes connected by links. Each node 
                        
                           i
                        
                        
                           (
                           
                              g
                           
                           ,
                           
                              d
                           
                           )
                        
                      represents a component 
                        
                           i
                        
                      grasped by a gripper 
                        
                           g
                        
                      and assembled along a direction 
                        
                           d
                        
                     . The set of all the nodes and all the links constitutes the possible paths for the ants. A single disassembly sequence is defined by a path leading from a start node to an end node and passing through all the components, but not through all the nodes”. J. F. Wang used the Disassembly Completed Graph (DCG) to represent all possible assembly sequences (Fig. 2
                     ) which looks like a simplification of DNN without considering the tools. In DCG, every disassembly operation was defined by the component and its disassembling direction. Based on the proposed models, Ant Colony Systems (ACS) were used to search the best disassembly/assembly solution(s). Shan also used a disassembly graph in the same way as J. F. Wang before he proposed an ACO method to solve the disassembly sequence planning problem  [26].

However, some disadvantages still exist, particularly when processing complex products with many components. Since Homem de Mello proposed his methodology  [2] that he developed a cut-set algorithm for assembly sequence planning after giving an AND/OR graph to represent assembly relationships in 1990, almost all following methods did similar work, focusing on the method of assembly plan optimization but no explanation on how to create the models (e.g., DCG and DNN) which include all solutions for a search. For example, Shan  [9,26] and Liu  [27] put their focus on assembly sequence optimization methods with the presumption of the establishment of the assembly/disassembly matrix (a typical adjacency matrix of the proposed assembly sequence graph). And F. Failli pointed out, “The network is automatically generated from the geometrical relationships existing among components, extrapolated from a representative model of the product. The network is built excluding, a priori, the nodes and the links geometrically unfeasible (e.g.: the link 
                     
                        1
                        
                           (
                           g
                           1
                           ,
                           +
                           y
                           )
                        
                        −
                        2
                        
                           (
                           g
                           3
                           ,
                           −
                           y
                           )
                        
                      
                     in Fig …)”. In fact, it is too difficult to do within an acceptable runtime, particularly for a complex product. Given an assembly with 
                        N
                      components, the possible assembly sequences would be 
                        N
                        ×
                        
                           (
                           N
                           −
                           1
                           )
                        
                        …
                        3
                        ×
                        2
                        ×
                        1
                     . Following those studies mentioned above, we should test all possible sequences to generate the assembly sequences graph, confirm the assembly constraints, and then provide the results to optimization algorithms for searching the best. Considering the fact that for testing a disassembly sequence a lot of 2D or 3D geometric computation is required, it is a time-consuming work—even on a powerful workstation, 3D geometric computation remains a costly job. And in real practice, when handling a mechanical assembly plan, engineers hardly have the time and patience to determine the final solution after comparing the performance of all possible assembly sequences in detail.

Therefore, we cannot ignore the issue of solution space generation before applying assembly planning techniques in real industrial cases, even though the generation of solution space (assembly sequence graph) and the search for the best solution are two decoupled problems. For this reason, we started a study to couple the solution space generation and disassembly solution optimization into one technical framework. Based on the Disassembly Feasibility Information Graph (DFIG) developed during the past several years, all assembly/disassembly sequences can be represented in the DFIG model. Then an integrated methodology is proposed—with the heuristic searching mechanism of ACO, the solution space can be created synchronously while ants are biased towards the best solution.

The rest of the paper is organized in the following manner. Section  2 provides an introduction of the DFIG model which we have developed in previous years. Section  3 presents the ACO-based optimization method used for the assembly/disassembly sequence planning problem while a developed assembly planning software system is described in Section  4. In Section  5, we discuss the implementation and performance of our system on the example environments. Section  6 contains future work and conclusions.

As Homem de Mello pointed out  [2], “the problem of finding out how to assemble a given assembly can be converted to an equivalent problem of finding how the same assembly can be disassembled”. Usually, a product’s assembly planning is handled as a reverse problem of its disassembly. Over the past years, we have developed the DFIG (Fig. 3
                     ) as a representation model of theoretical assembly/disassembly sequences  [28,25], which is a fundamental work in our methodology of mechanical assembly information modeling and planning. Its original form is as follows:

Definition  [16,28]: Let 
                        G
                        =
                        
                           {
                           V
                           ,
                           W
                           ,
                           D
                           }
                        
                      be a simple non-negative weight, directed graph, and: 
                        
                           (1)
                           
                              
                                 G
                               is a tree, and it has a root node, the Start Point.

The vertex set is 
                                 V
                                 =
                                 
                                    {
                                    
                                       
                                          V
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    i
                                    ∈
                                    M
                                    }
                                 
                              , where 
                                 M
                               is the number of vertices, 
                                 D
                               is the set of directed edges and 
                                 W
                               is the set of weights loaded on related edges.


                              
                                 Ω
                                 =
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    i
                                    ∈
                                    N
                                    }
                                 
                               represents the components of an assembly (product) and 
                                 N
                               is the components number. Set 
                                 R
                                 =
                                 
                                    {
                                    
                                       re
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    |
                                    
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             V
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    ,
                                    
                                    i
                                    ∈
                                    M
                                    ,
                                    
                                    j
                                    ∈
                                    M
                                    ,
                                    
                                    i
                                    ≠
                                    j
                                    }
                                 
                               is defined to describe the geometrical constraint relations among the components of set 
                                 Ω
                              .

Once a component, 
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                               is put on the vertex (node) 
                                 
                                    
                                       V
                                    
                                    
                                       j
                                    
                                 
                              , the node 
                                 
                                    
                                       V
                                    
                                    
                                       j
                                    
                                 
                                 
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                               will represent the disassembling operation of 
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                               in the sequence from the Start Point to 
                                 
                                    
                                       V
                                    
                                    
                                       j
                                    
                                 
                              .

The weight 
                                 w
                               (
                                 W
                                 =
                                 
                                    {
                                    
                                       
                                          w
                                       
                                       
                                          i
                                          j
                                       
                                    
                                    ,
                                    
                                    i
                                    ∈
                                    M
                                    ,
                                    
                                    j
                                    ∈
                                    M
                                    ,
                                    
                                    i
                                    ≠
                                    j
                                    }
                                 
                              ), implies the length of the edge connecting two nodes. And the heuristic information (
                                 η
                              ) which we will discuss in more detail later is denoted as 
                                 1
                                 /
                                 w
                              , that is, 
                                 η
                                 =
                                 
                                    {
                                    
                                       
                                          η
                                       
                                       
                                          i
                                          j
                                       
                                    
                                    ,
                                    
                                    i
                                    ∈
                                    M
                                    ,
                                    
                                    j
                                    ∈
                                    M
                                    ,
                                    
                                    i
                                    ≠
                                    j
                                    }
                                 
                              .

Let 
                                 
                                    Tour
                                 
                                 =
                                 ϑ
                                 
                                    (
                                    
                                       
                                          
                                             
                                                V
                                             
                                             
                                                i
                                             
                                          
                                       
                                       →
                                    
                                    )
                                 
                               be a vector, composed of sequenced nodes on the DFIG 
                                 
                                    (
                                    G
                                    =
                                    
                                       {
                                       V
                                       ,
                                       W
                                       ,
                                       D
                                       }
                                    
                                    )
                                 
                              , which starts from the Start Point and can make a single traverse of 
                                 Ω
                                 =
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    i
                                    ∈
                                    N
                                    }
                                 
                              . For instance, in Fig. 3, one tour is 
                                 
                                    the Start Point
                                 
                                 →
                                 D
                                 →
                                 E
                                 →
                                 C
                                 →
                                 A
                                 →
                                 B
                              .

Based on the definition above, we can convert the assembly planning problem into an optimal path search problem:

Find a directed path with 
                        
                           Max
                        
                        ξ
                        
                           (
                           ϑ
                           
                              (
                              
                                 
                                    
                                       
                                          V
                                       
                                       
                                          i
                                       
                                    
                                 
                                 →
                              
                              )
                           
                           )
                        
                      on the DFIG, in which 
                        ϑ
                        
                           (
                           
                              
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                              
                              →
                           
                           )
                        
                      has already been defined above and 
                        ξ
                        
                           (
                           ∗
                           )
                        
                      is the objective function—tour (or solution)’s performance.

With the proposed assembly sequences information modeling and representation, potential disassembly/assembly sequences would be paths on the DFIG, which can be visited by a traditional path searching method. Subsequently, it is important to note that meta-heuristic methods are efficient and widely used to solve typical path searching problems. In Fig. 3, a DFIG model is illustrated and we can find out its two possible assembly/disassembly solutions: 
                        
                           {
                           
                              the Start Point
                           
                           →
                           
                              B
                           
                           →
                           
                              A
                           
                           →
                           
                              E
                           
                           →
                           
                              D
                           
                           →
                           
                              C
                           
                           }
                        
                      and 
                        
                           {
                           
                              the Start Point
                           
                           →
                           
                              D
                           
                           →
                           
                              E
                           
                           →
                           
                              C
                           
                           →
                           
                              A
                           
                           →
                           
                              B
                           
                           }
                        
                     . It is a theoretical model of all disassembly solutions. On the DFIG, following a feasible node (for instance, the 
                        
                           E
                        
                      node in the path 
                        
                           the Start Point
                        
                        →
                        
                           B
                        
                        →
                        
                           A
                        
                        →
                        
                           E
                        
                     ), all its succeeding nodes (infeasible or feasible) are modeled on the graph. However, for an infeasible one in the node group, it does not have following nodes because in a given disassembly/assembly sequence, one infeasible operation will lead to the infeasibility of given sequence. Therefore, one infeasible node means the failure of all sequences including this node. One reason why we reserve some infeasible nodes on the graph is to illustrate the data integrity even though in a real intelligent search process, “infeasible” means no visit.

The Ant Colony System was initially proposed by Colorni, Dorigo and Maniezzo  [29,30]. Inspired by the behavior of ants, the main underlying idea is a parallel search over several constructive computational threads based on local problem data and on a dynamic memory structure containing information about the quality of previously obtained results. The collective behavior emerging from the interaction of the different search threads has been proved effective in solving combinatorial optimization problems  [31,32]. Therefore, as a powerful meta-heuristic, the ant colony algorithm has gradually been applied in widespread engineering applications  [33].

This section mainly focuses on the proposed ACO–DFIG algorithm. In the following manner, Section  3.1 gives a whole description of the ACO–DFIG algorithm for assembly planning solving, Section  3.2 tries to make the dynamic generation process of DFIG clear, and finally, the calculation of two crucial factors in ACO search/optimization, pheromone trail and heuristic information, are discussed in detail respectively in Sections  3.3 and 3.4.

We have proposed an ant colony optimization algorithm for assembly sequence planning.


                        
                           
                              
                                 
                                 
                                 
                                    
                                       Some definitions:
                                    
                                    
                                       
                                          
                                             r
                                          
                                       
                                       Current position (node) of ant 
                                             k
                                          .
                                    
                                    
                                       
                                          
                                             s
                                          
                                       
                                       Destination (node) of ant 
                                             k
                                          .
                                    
                                    
                                       SIZE
                                       The size of the ant colony.
                                    
                                    
                                       
                                          
                                             
                                                
                                                   J
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                          
                                       
                                       All possible succeeding nodes ant 
                                             k
                                           might go, which includes all nodes the ant 
                                             k
                                           has not visited yet (corresponding with the components not in the current partial sequence).
                                    
                                    
                                       
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                             ⊆
                                             
                                                
                                                   J
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                          , the subset of 
                                             
                                                
                                                   J
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                           where the disassembly feasibilities of all nodes are TRUE. A node in 
                                             
                                                
                                                   F
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                (
                                                r
                                                )
                                             
                                           can be added into ant 
                                             k
                                          ’s current partial tour, and does not violate any precedence relations.
                                    
                                    
                                       
                                          
                                             τ
                                             
                                                (
                                                r
                                                ,
                                                s
                                                )
                                             
                                          
                                       
                                       The pheromone trail of the path from 
                                             r
                                           to 
                                             s
                                          .
                                    
                                    
                                       
                                          
                                             η
                                             
                                                (
                                                r
                                                ,
                                                s
                                                )
                                             
                                          
                                       
                                       The heuristic information of the path from 
                                             r
                                           to 
                                             s
                                          . Heuristic information, named by M. Dorigo in his ACO works, “represents a priori information about the problem instance, and is used by ant to make probabilistic decision on how to move on the graph”. (Ant Colony Optimization,  [33]).
                                    
                                    
                                       
                                          
                                             s
                                             .
                                             
                                                feasibility
                                             
                                          
                                       
                                       The feasibility of the operation recorded in node 
                                             s
                                          .
                                    
                                 
                              
                           
                        
                     

A complete procedure of the ACO–DFIG algorithm for disassembly sequences planning (Fig. 4
                        ) is as follows: 
                           
                              (1)
                              Generate the initial ant colony

Current DFIG (
                                    G
                                    =
                                    
                                       {
                                       V
                                       ,
                                       W
                                       ,
                                       D
                                       }
                                    
                                 ) only has one root node: the Start Point

All ants (Ant Colony Size = SIZE) are placed at the initial position:


                                 
                                    r
                                   = the Start Point

For each ant (
                                    k
                                    ∈
                                    
                                       SIZE
                                    
                                 ), do {


                                 Search DFIG: 
                                    G
                                    =
                                    
                                       {
                                       V
                                       ,
                                       W
                                       ,
                                       D
                                       }
                                    
                                 
                              


                                 IF the succeeding nodes of 
                                    r
                                  do not exist,


                                 Then:


                                 Create the succeeding nodes of 
                                    r
                                    ,
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                 , and


                                 Add 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  into the DFIG: update the vertices (
                                    V
                                 ), edges (
                                    D
                                 ) and weights (
                                    W
                                 )


                                 (For each node:


                                 Compute its feasibility by Disassembly Planning Tool on CAD platform)


                                 IF 
                                    ∀
                                    s
                                    ∈
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                    ,
                                    s
                                    .
                                    
                                       feasibility
                                    
                                    =
                                    
                                       FALSE
                                    
                                  (that is to say, 
                                    
                                       
                                          F
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  is a null set)


                                 Then: Death of Ant 
                                    k
                                 
                              


                                 OTHERWISE, choose a node 
                                    
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             j
                                          
                                       
                                       
                                          (
                                          
                                             
                                                a
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       ∈
                                       
                                          
                                             F
                                          
                                          
                                             k
                                          
                                       
                                       
                                          (
                                          r
                                          )
                                       
                                       )
                                    
                                  to move according the probability 
                                    P
                                 : 
                                    
                                       (1)
                                       
                                          
                                             
                                                P
                                             
                                             
                                                k
                                             
                                          
                                          
                                             (
                                             r
                                             ,
                                             s
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     [
                                                                     τ
                                                                     
                                                                        (
                                                                        r
                                                                        ,
                                                                        s
                                                                        )
                                                                     
                                                                     ]
                                                                  
                                                               
                                                               
                                                                  α
                                                               
                                                            
                                                            ⋅
                                                            
                                                               
                                                                  
                                                                     [
                                                                     η
                                                                     
                                                                        (
                                                                        r
                                                                        ,
                                                                        s
                                                                        )
                                                                     
                                                                     ]
                                                                  
                                                               
                                                               
                                                                  β
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  μ
                                                                  ∈
                                                                  
                                                                     
                                                                        J
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                  
                                                                  
                                                                     (
                                                                     r
                                                                     )
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     [
                                                                     τ
                                                                     
                                                                        (
                                                                        r
                                                                        ,
                                                                        u
                                                                        )
                                                                     
                                                                     ]
                                                                  
                                                               
                                                               
                                                                  α
                                                               
                                                            
                                                            ⋅
                                                            
                                                               
                                                                  
                                                                     [
                                                                     η
                                                                     
                                                                        (
                                                                        r
                                                                        ,
                                                                        u
                                                                        )
                                                                     
                                                                     ]
                                                                  
                                                               
                                                               
                                                                  β
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                      s
                                                      ∈
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      
                                                         (
                                                         r
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      0
                                                      ,
                                                      
                                                      otherwise .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                       
                                          ∗
                                       
                                    
                                  
                                 Pheromone trail (
                                    τ
                                    
                                       (
                                       r
                                       ,
                                       s
                                       )
                                    
                                 ) and heuristic information 
                                 
                                    η
                                    
                                       (
                                       r
                                       ,
                                       s
                                       )
                                    
                                  
                                 are discussed in Sections  3.2 and 3.3   respectively.


                                 Ant 
                                    k
                                  move forward a node: 
                                    r
                                    =
                                    
                                       
                                          V
                                       
                                       
                                          j
                                       
                                    
                                    
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              

} Until ant 
                                    k
                                  completes its tour (
                                    
                                       Tour
                                    
                                    =
                                    ϑ
                                    
                                       (
                                       
                                          
                                             
                                                
                                                   V
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          →
                                       
                                       )
                                    
                                 )

Update all Pheromone Trail corresponding to the edges (
                                    D
                                 ) on 
                                    G
                                    =
                                    
                                       {
                                       V
                                       ,
                                       W
                                       ,
                                       D
                                       }
                                    
                                 , (Section  3.3)

IF not (satisfied with the Termination Condition) {


                                 Generate a new ant colony And go to step (2)

}

Assembly sequence generation involves generating one or more feasible sequences to assemble the product successfully. It includes two key tasks: generating an assembly’s DFIG and searching its DFIG for the best solution(s). Theoretically, the two tasks can be independent (uncoupled). However, as we have already mentioned, a main challenge to solve the assembly planning problem is the problem’s combinatorial complexity. With the increase of component numbers, potential assembly/disassembly solutions will increase rapidly while its DFIG will become more complex. Additionally, generating the solution space of assembly plans and determining the feasibility of those assembling operations are time-consuming due to geometrical and mechanical computation. This technical challenge fades many reported solving methods’ future in real cases because most of them assume the complete solution space already exists. A possible method to reduce the computational complexity in practical applications is to build a parallel working mechanism: to generate and extend the DFIG model synchronously with the searching process for feasible and optimal assembly planning solutions.

Different from traditional ant colony optimization algorithms, there is a unique character of the proposed algorithm—Death of Ant, which is defined as the termination condition of each ant’s path search:

For ant 
                           k
                         with uncompleted trip 
                           
                              
                                 
                                    tour
                                 
                              
                              
                                 ′
                              
                           
                           
                              (
                              k
                              )
                           
                        , if the operational feasibility of every node in 
                           
                              
                                 J
                              
                              
                                 k
                              
                           
                           
                              (
                              r
                              )
                           
                         is FALSE, ant 
                           k
                         will face Death at the current position (node 
                           r
                           =
                           
                              
                                 V
                              
                              
                                 j
                              
                           
                           
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        ). Meanwhile, the operation’s feasibility of 
                           r
                         will be set as FALSE due to no feasible following nodes. This is based on common sense: if one disassembly operation in a proposed disassembly (sequence) solution cannot be done successfully, the solution will be infeasible.


                        Fig. 5
                         illustrates this feedback mechanism (which can reconfigure the DFIG model) when ant 
                           k
                         is dead. This idea is very useful in the ant colony search. On the one hand, it offers a specified termination condition for an ant’s path search. On the other hand, it can also improve the search efficiency of ants by reconfiguring the DFIG.

This is a population-based, stochastic algorithm while the ant colony can generate the solution space and evaluate a new solution’s performance at the same time. Additionally, the following are necessary to mention:
                           
                              (1)
                              The termination condition can be triggered by two events respectively: realizing the convergence at an optimal solution, or meeting the maximum of the iteration number.

In each step, an ant moves probabilistically to the next position (node 
                                    s
                                 ). The probabilistic choice is biased according to the pheromone trail 
                                    τ
                                    
                                       (
                                       r
                                       ,
                                       s
                                       )
                                    
                                  and locally available heuristic information 
                                    η
                                    
                                       (
                                       r
                                       ,
                                       s
                                       )
                                    
                                 . The latter is a mapping function of the disassembling operation’s performance of the corresponding component.

In Eq. (1), 
                                    α
                                  and 
                                    β
                                 , two parameters of 
                                    
                                       
                                          P
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       ,
                                       s
                                       )
                                    
                                  determine the relative influence of the pheromone trail and the heuristic information. Here we choose 
                                    α
                                    =
                                    1
                                  and 
                                    β
                                    =
                                    2
                                  after many technical experiments.

Generating and extending the DFIG is a process to collect relevant assembly data and information (including constraint relationships) of assembly/disassembly planning. In this process, the focus is how to evaluate the performance of a given sequence: by using complex geometrical computation in a 3D CAD system, to determine whether/how the components can be disassembled/assembled, and furthermore, to evaluate the quality of the assembly sequence. For a product with many components, generating all nodes of its DFIG is also inefficient due to the complexity of the model. Aiming to improve computational efficiency during this process, a novel method is proposed—generating the DFIG under the guidance of ant colony search. The ACO algorithm has a significant ability biased towards the best result, despite a stochastic algorithm.

Therefore, at the beginning, the DFIG only has a root node (the Start Point). Then, during the ant colony search, the neighbor nodes relevant with their traces are created and added into the DFIG. The implementation procedures are as follows:

Let us suppose that ant 
                           k
                        ’s current partial tour is Tour 
                        
                           
                              {
                              
                                 
                                    L
                                 
                                 
                                    i
                                 
                              
                              }
                           
                        . If ant 
                           k
                         is the first ant which arrives at node 
                           r
                        , the tail node of its current tour Tour 
                        
                           
                              {
                              L
                              i
                              }
                           
                        , it performs the following steps: 
                           
                              (1)
                              Compute the potential sub-nodes set 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  of node 
                                    r
                                 .

For every node in 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                 : 
                                    
                                       (a)
                                       Evaluate its disassembly feasibility under the sequence: 
                                             
                                                start point
                                             
                                             →
                                             ⋯
                                             →
                                             r
                                             →
                                             s
                                          , by using disassembly planning tools based on a 3D CAD platform;

Store information/data relevant to the computation result into the node;

Add the node into the DFIG;

Feasible nodes will be grouped as 
                                    
                                       
                                          F
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                 , which are the candidates for ant 
                                    k
                                 ’s next step.

Although ant 
                                    k
                                  only does a single trip, its trace’s neighbors are also searched. The search results (new nodes) will be added into the DFIG, as Fig. 6
                                  illustrates. This is an important feature in the proposed ACO algorithm: expanding the DFIG with ACO searching process. Additionally, even though some nodes with feasible but poor performance also have opportunity to be extended with succeeding nodes, they seldom do this—because the ants are biased to select the better nodes. So this design can dramatically reduce the computation time.

In an ant colony system, once all ants complete their tours, the pheromone trail on each edge will be updated based on their tours respectively. At the initial time, there is a micro-pheromone on each edge. Then, the pheromone will increase proportionally in accordance with the number of nodes which the ants have passed through. With several generation evaluations, paths with a good performance will be enhanced and attract more ants while the importance of poor paths continues to shrink. This evolution process is illustrated in Fig. 7
                        .

The commonly updated formula  [33] can be expressed as follows: 
                           
                              (2)
                              
                                 
                                    
                                       τ
                                    
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    (
                                    t
                                    +
                                    1
                                    )
                                 
                                 =
                                 
                                    (
                                    1
                                    −
                                    ρ
                                    )
                                 
                                 
                                    
                                       τ
                                    
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    (
                                    t
                                    )
                                 
                                 +
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       =
                                       1
                                    
                                    
                                       M
                                    
                                 
                                 
                                    Δ
                                 
                                 
                                    
                                       τ
                                    
                                    
                                       i
                                       j
                                    
                                    
                                       k
                                    
                                 
                              
                           
                         where 
                           t
                         represents different iterations of an ant colony and 
                           0
                           <
                           ρ
                           ≤
                           1
                         is the pheromone’s evaporation rate from 
                           t
                         to 
                           t
                           +
                           1
                        . Additionally, denote (
                           i
                           ,
                           j
                        ) as the ant’s movement from node 
                           i
                         to node 
                           j
                        .
                           
                              (3)
                              
                                 
                                    Δ
                                 
                                 
                                    
                                       τ
                                    
                                    
                                       i
                                       j
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   δ
                                                
                                                
                                                   k
                                                
                                             
                                             ,
                                          
                                          
                                             if  
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                             
                                             ∈
                                             L
                                             ;
                                          
                                       
                                       
                                          
                                             0
                                             ,
                                          
                                          
                                             otherwise ;
                                          
                                       
                                    
                                 
                              
                           
                         where 
                           L
                         is the tour of ant 
                           k
                        , and 
                           
                              
                                 δ
                              
                              
                                 k
                              
                           
                         is the quantity of trail substance laid on edge 
                           
                              (
                              i
                              ,
                              j
                              )
                           
                         by ant 
                           k
                        . Here, with our experience, 
                           
                              
                                 δ
                              
                              
                                 k
                              
                           
                         is assigned as 
                           0.2
                           ⋅
                           
                              Num
                           
                        , and Num is the node number that ant 
                           k
                         has already visited.

An important thing that needs to be mentioned is the node disappearance in Fig. 7. Actually, this is a hybrid result of DFIG evolution. With the evolution, pheromone will converge at paths with good performance while the nodes with poor performance lose most of their pheromones. Another reason is that the feedback mechanism (Death of Ant, mentioned above) can also lead to a reduction of feasible nodes.

Heuristic information is very important in ant colony optimization. As we have mentioned, named by M. Dorigo in his ACO works, Heuristic Information “represents a priori information about the problem instance, and is used by ant to make probabilistic decision on how to move on the graph.” In theory, it is related to a problem instance, and bridges the meta-heuristic search (ant colony optimization algorithm) and assembly sequence planning problem. Usually, the quality (including feasibility) of an operation is heavily affected by the already completed operations in a given sequence. Therefore, we use the heuristic information of current node to reflect the performance of the partial sequence from the start point to current node.

During the DFIG’s extending (by adding new nodes), the heuristic information will be determined as follows:
                           
                              If node 
                                    s
                                  in 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  cannot be disassembled, its disassembly feasibility will be FALSE, and any disassembly sequence, which includes the sequence (
                                    
                                       start point
                                    
                                    →
                                    ⋯
                                    →
                                    s
                                 ) will be infeasible too. Therefore, a clear mark can be assigned to the heuristic information of 
                                    s
                                  to prevent an ant from choosing these kinds of paths.

If node 
                                    s
                                  in 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  can be disassembled, its disassembly feasibility will be TRUE. However, because selecting a different node in 
                                    
                                       
                                          J
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       r
                                       )
                                    
                                  will affect the performance of a potential sequence, more accurate heuristic information is needed to remind the ant to make its choice.

Based on the discussion above, we designed a mechanism of two-step computation for the heuristic information. It includes the computation of heuristic vector (Heuristic) and heuristic information (
                           η
                        ). Firstly, we define the heuristic vector Heuristic to record the feasibility of the disassembly operation (TRUE or FALSE). Secondly, we use Heuristic Information (
                           η
                        ) to reflect the performance of the current path (sequence).


                        Determination of the heuristic vector
                     

If an operation in the given sequence is feasible, the disassembly function Disassembly () will return TRUE and denote the operation in Heuristic as 1; Otherwise, Disassembly () will return FALSE and assign the operation in Heuristic as 0.

Suppose 
                           
                              
                                 
                                    
                                       T
                                    
                                    →
                                 
                              
                              
                                 ′
                              
                           
                           
                              (
                              k
                              )
                           
                           :
                           
                              Start
                           
                           →
                           B
                           →
                           A
                           →
                           E
                         as ant 
                           k
                        ’s current partial tour. As illustrated in Fig. 8
                        , ant 
                           k
                         may choose node 
                           D
                         or 
                           C
                         to move. Therefore, the vector Heuristic will be [1, 1 …1, empty …], which represents the basic status of a disassembly solution. The process of recording an operation in Heuristic will be: 
                           
                              
                                 
                                 
                                    
                                       
                                          Heuristic  = [1, 1, 1, empty, empty];
                                    
                                    
                                       IF Disassembly (
                                             D
                                          ) Is TRUE
                                    
                                    
                                       THEN Heuristic  = [1, 1, 1, 1, empty];
                                    
                                    
                                       ELSE //that is, Disassembly (
                                             D
                                          ) Is FALSE
                                    
                                    
                                       {
                                    
                                    
                                       
                                          Heuristic  = [1, 1, 1, 0, 0];
                                    
                                    
                                       //that is, when it is FALSE, all bits behind it will be set as false (0).
                                    
                                    
                                       }
                                    
                                    
                                       Note:
                                    
                                    
                                       (1) In Heuristic, if one step is infeasible, its successors will be determined as infeasible nodes directly. This is consistent with the idea of Death of Ant.
                                    
                                    
                                       (2) Function Disassembly () represents the procedure of disassembling component 
                                             D
                                           at current sequence. If the node has been built, relevant information will be read directly from current node. Otherwise, it will trigger the disassembly planning process to compute the heuristic information and add a new neighborhood of 
                                             E
                                           into the DFIG.
                                    
                                 
                              
                           
                        
                     


                        Calculating the value of Heuristic Information
                     

In our methodology, stored in a node, the Heuristic Information (
                           η
                        ) reflects the performance of current partial disassembly sequence (solution), and has a close relation with the disassembly sequence and the related disassembly operations’ cost.

Suppose: 
                           
                              (1)
                              Ant 
                                    k
                                 ’s current partial tour, 
                                    
                                       
                                          
                                             
                                                T
                                             
                                             →
                                          
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                 , has 
                                    N
                                    −
                                    1
                                  nodes (those 
                                    N
                                    −
                                    1
                                  operations can be executed successfully).

Ant 
                                    k
                                  moves to node 
                                    s
                                 .

The following procedure is used to interpret how to compute the heuristic information (
                           η
                        ) stored in 
                           s
                        : 
                           
                              IF the operating feasibility of node 
                                    s
                                  is infeasible, Heuristic Information (
                                    η
                                 ) will be 0.

Otherwise, Heuristic (
                                    k
                                 ) of the current partial path will be [1 1…1], in which the number of 1 is 
                                    N
                                 . And then: 
                                    
                                       (4)
                                       
                                          Heuristic Information
                                          
                                             (
                                             η
                                             )
                                          
                                          =
                                          λ
                                          ∗
                                          N
                                          /
                                          
                                             (
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   =
                                                   0
                                                
                                                
                                                   N
                                                
                                             
                                             
                                                Cost
                                             
                                             
                                                (
                                                
                                                   
                                                      α
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                j
                                                )
                                             
                                             )
                                          
                                       
                                    
                                  where 
                                    
                                       Cost
                                    
                                    
                                       (
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       j
                                       )
                                    
                                  represents the operational cost of disassembling component 
                                    
                                       
                                          α
                                       
                                       
                                          i
                                       
                                    
                                  at the 
                                    
                                       
                                          j
                                       
                                       
                                          t
                                          h
                                       
                                    
                                  step in the given sequence. The Cost function is very important to evaluate the performance of the disassembly operation. Technically, Cost reflects the hybrid impact of an operation’s time, tool, and complexity (including directions, reorientation, etc.). Measuring assembly complexity with the numbers of operations’ directions and reorientations in the assembly solution has already been widely used in many researches. So we defined Cost () as: 
                                    
                                       (5)
                                       
                                          
                                             Cost
                                          
                                          
                                             (
                                             
                                                
                                                   α
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             j
                                             )
                                          
                                          =
                                          A
                                          ∗
                                          
                                             Time
                                          
                                          +
                                          B
                                          ∗
                                          
                                             (
                                             
                                                Directions
                                             
                                             +
                                             
                                                Reorientations
                                             
                                             )
                                          
                                          +
                                          C
                                          ∗
                                          
                                             Tool
                                          
                                       
                                    
                                  where Time is the operational time and Tool is the operating tool. Directions represents the number of used directions in the partial sequence 
                                    
                                       (
                                       
                                          
                                             
                                                
                                                   T
                                                
                                                →
                                             
                                          
                                          
                                             ′
                                          
                                       
                                       
                                          (
                                          k
                                          )
                                       
                                       +
                                       s
                                       )
                                    
                                  and Reorientations represents the count of reorientation times in the partial sequence 
                                    
                                       (
                                       
                                          
                                             
                                                
                                                   T
                                                
                                                →
                                             
                                          
                                          
                                             ′
                                          
                                       
                                       
                                          (
                                          k
                                          )
                                       
                                       +
                                       s
                                       )
                                    
                                 .

Additionally, some simplifications need to be mentioned, which are the natural consequences of a collaborative work with many experienced assembly engineers who put much concern on the real performance in the workshop rather than a sophisticated theory. 
                                    
                                       (1)
                                       The value in Cost is simplified and mapped into  [3,11].

The operation’s time is normalized into  [3,11] as Time.

If the used tool is a general tool, Tool will be assigned as 1; if the used tool is a special tool for this process, Tool will be assigned a value of  [6,11] according to the tool’s cost/structure.


                                 Quality of solution
                              

In Eq. (4), the numerator 
                                    N
                                  is the accumulation of those operations’ feasibility in a given tour (solution), and the denominator 
                                    
                                       (
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             0
                                          
                                          
                                             N
                                          
                                       
                                       
                                          Cost
                                       
                                       
                                          (
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          j
                                          )
                                       
                                       )
                                    
                                  is the accumulation of these operations’ cost. If the solution 
                                    
                                       
                                          
                                             
                                                T
                                             
                                             →
                                          
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       (
                                       k
                                       )
                                    
                                    +
                                    s
                                  is feasible, the cost will have a vital impact on the solution’s quality. Therefore, in some degree, the cost in Eq. (4) can be regarded as a penalty item to punish a poor solution.


                                 Controlling parameter
                              

In Eq. (4), generally, the value of 
                                    λ
                                  (
                                    λ
                                    >
                                    0
                                 ) can affect the convergence speed of the whole algorithm.

The proposed ACO–DFIG algorithm has been programmed with the Microsoft Visual Studio C++. Net system. And a computer aided assembly planning system is designed and developed for mechanical product assembly design, analysis and planning, with the ACO–DFIG algorithm as its kernel engine and the PTC Pro/Engineer wildfire CAD system as its running environment. Shown in Fig. 9
                     , a simple introduction of the software is as follows.


                     Import product’s 3D model and get assembly related information
                  

As the first step, a product’s digital model is loaded, and its assembly related information is recorded into a predefined product information model (Fig. 10
                     , the Assembly Object) which will be a key information source for the system.


                     Predefine partial precedence relations
                  

This module is very useful in practice owing to the importance of precedence relationships on determining the feasible assembly sequences  [34,35]. As H. Zhang emphasized  [35], “to make sure that a disassembly sequence is feasible, all the disassembly tasks in the sequence should be feasible, i.e., no geometrically or mechanically infeasible disassembly is performed in the sequence”. Precedence relationships are corresponding to such status of geometrical or mechanical feasibility. And actually, most of the effect in assembly sequence planning is to find out all precedence relationships before determining the final best assembly plan. Therefore, in practical product assembly planning cases, if some obvious precedence relations between components can be determined directly by the engineer with his knowledge and experience, the process of finding out best assembly sequences will be more efficient. Definitely, all geometrical precedence relationships can be found out by automatic interference detection algorithms, but will cost much time. That is the main motivation why we design this module.

With user defined partial precedence relationships, the constraints in the DFIG model can be enforced which will speed up the searching efficiency for the final assembly plan. For instance, as Fig. 11
                     , in a given 
                        
                           Assembly
                        
                        =
                        
                           {
                           A
                           ,
                           B
                           ,
                           C
                           ,
                           D
                           ,
                           E
                           ,
                           F
                           ,
                           G
                           }
                        
                     , if some precedence relationships are predefined, i.e.,  
                        
                           Precedence
                        
                        =
                        
                           {
                           C
                           →
                           D
                           ,
                           B
                           →
                           E
                           }
                        
                     , only the sequences which obey those precedence constraints can be chosen as candidates for more evaluation. A particular precedence relationship in an assembly is the base part which is usually the reference for assembling, and this means that in many ways, the base part is the first part placed into an assembly or the last to disassemble. Let us discuss the case in Fig. 11, if there are no predefined precedence relationships, there will be 
                        7
                        !
                        =
                        5040
                      assembly sequences in the solution space waiting for evaluation. However, with the two user defined precedence relationships 
                        
                           {
                           C
                           →
                           D
                           ,
                           B
                           →
                           E
                           }
                        
                      and one base part 
                        
                           {
                           G
                           }
                        
                     , total assembly sequences will decrease to 
                        6
                        !
                        /
                        4
                        =
                        180
                     . A very significant reduction!

The final thing that needs to be mentioned is that even though its good performance, predefining the precedence relationships, is a sufficient but not necessary condition, because the automatic interference detection algorithms also can find out those constraints with the price of long calculation time.


                     ACO–DFIG algorithm and 3D CAD assembly planning tool
                  

This module is the system’s computational engine and it includes a 3D CAD automatic computation module. As motioned above, it combines the generating process of DFIG with the best solution search process. That is, with the evolving process of ant colony search and optimization, the DFIG will expand from the root node (start point) which we have already mentioned with Fig. 6, and new nodes (Fig. 12
                      shows its data structure) will be created and added into the DFIG. Meanwhile, ants’ tours will move closer to the optimal path during search loops.

Particularly, the process of disassembly path planning needs to describe more. To simplify the work, some presumptions are used, and the disassembly path planning is executed as the following procedures (Fig. 13
                     ): 
                        
                           (1)
                           Assume in each step only one component can be disassembled.

Assume a component only can be disassembled by translational movement and define the searching directions for disassembly as 
                                 
                                    
                                       
                                          Dir
                                       
                                    
                                    →
                                 
                                 =
                                 
                                    {
                                    +
                                    x
                                    ,
                                    −
                                    x
                                    ,
                                    +
                                    y
                                    ,
                                    −
                                    y
                                    ,
                                    +
                                    z
                                    ,
                                    −
                                    z
                                    }
                                 
                              .

Define a total disassembly distance and divide it into 
                                 N
                               steps (depending on the structural features of the assembly).

For each step, the component can move according to the direction in 
                                 
                                    
                                       
                                          Dir
                                       
                                    
                                    →
                                 
                               (directions both in the assembly coordination system and the component’s coordination system). 
                                 
                                    (a)
                                    If geometrical collisions are always found in all directions, this component will be denoted as infeasible to disassemble. Exit the path planning procedure.

If one noninterference path can be found, this step is feasible.

Continue to next step until end.

If a noninterference path (all steps) exists, this component will be feasible to disassemble.

Store all disassembly path data in the node and then quit the procedure.


                     Generate optimal solution(s)
                  

When the ACO process is over, the optimal solution(s) can be obtained. This module can help the assembly engineer to reconfirm the solution(s) based on his knowledge and understanding of practical conditions. The one regarded as best will be chosen as the final solution.


                     Simulation of assembly sequence solution
                  

In the process of the search for an optimal solution by ACO, the components’ assembling traces are recorded. This module can simulate the assembling operation/process of a selected solution on a 3D CAD environment, and help assembly engineers to analyze the performance of an assembly plan.


                     Make assembly process files
                  

For the chosen best solution, based on a designed Process File Template, the final assembly plan/process documents of a product can be made.


                     Output assembly plan/process documents
                  

Output the assembly plan/process files in Microsoft Excel format.

To evaluate the performance of the assembly planning system, an assembly with 7 components (Fig. 14
                     ) is used. Several initial parameters are as follows: 
                        
                           •
                           
                              Precedence Relationships  = { 
                                 G
                               
                              is the base part};


                              Ant colony size  = 50;


                              Iteration number  = 10–20;

The parameter 
                                 λ
                               (in Eq. (4)) = 5, and other parameters in the proposed ACO–DFIG algorithm have been mentioned respectively in related sections.

For disassembly path planning, disassembly step number 
                                 N
                                 =
                                 100
                               and the length of each step (
                                 L
                              ) is assigned as 1.5 mm.

During the process of ant colony optimization, the DFIG model is generated. Furthermore, as in the Death of Ant mentioned above, if all the succeeding nodes of a feasible node are infeasible, the ant will terminate its search. Meanwhile, it will trigger a feedback mechanism to switch this node’s feasibility to FALSE. This feedback mechanism has an obvious impact on the generation of the DFIG model. If the iteration number and ant colony size are big enough, the complete DFIG model can be generated, and finally, all the feasible nodes in DFIG will converge on these edges (tours) implying feasible assembly sequences. Fig. 15
                      indicates the result of the completed DFIG, but for the sub-tree which follows the node 
                        D
                      (in the path 
                        
                           {
                           
                              the Start Point
                           
                           →
                           A
                           →
                           D
                           }
                        
                     ), the ant colony had hardly any chances to visit (and generate) it. The main reason lies in that the operational complexity of disassembling 
                        D
                      leads to a poor performance of the path 
                        
                           {
                           
                              the Start Point
                           
                           →
                           A
                           →
                           D
                           }
                        
                     . And Fig. 16
                      shows ant colony’s selections in 20 iterations and a total of 5 min was spent on the path planning process including geometrical computation and path optimization on a 3D CAD software. The solution most ants chose is the best: 
                        
                           {
                           A
                           →
                           C
                           →
                           D
                           →
                           B
                           →
                           E
                           →
                           F
                           →
                           G
                           }
                        
                     . As shown in this stochastic search process, most ants will converge at the optimal solution(s). Actually, M. Dorigo has given a partial theory proof that the ACO algorithm can realize the global optimal solution, and many experiments using different cases by us also verify that this method can find a global optimal solution even though the runtime (to get the global optimal solution) is affected very much by the complexity of assembly and parameters of the method.

In our ACO–DFIG algorithm, as the runtime includes the time to generate the DFIG (computed on a 3D CAD environment), the expected makespan of assembly planning is very large. Particularly, at the early stages of the meta-heuristic search, much time is spent to generate the solution space (DFIG model). After the main DFIG model is completed, the search will become fast. As we have already mentioned, nearly all reported assembly planning optimization approaches have emphasized on the heuristic search rather than solution space generation. Thus we do not have comparable benchmarks. However, in practical applications of assembly planning, the structure of solution space has a crucial impact on both the feasibility and performance of heuristic methods. As follows, we can discuss the different characters between our method and other methods.

Comparably, Fig. 17
                      shows the theoretical DCG model of the case assembly while many edges (disassembly sequences) need to be checked before doing an ACO based search. Assuming the configurations of 
                        N
                        =
                        100
                      and 
                        L
                        =
                        1.5
                        
                        
                           mm
                        
                     , and considering that each disassembly operation will cost more than 1 s on 3D geometrical computation, the total time will definitely surpass 10 min because most of time is spent on the geometrical computation to generate the DCG model rather than a practical ACO search. Furthermore, as shown in Table 1
                     , a comparison among the DFIG and two other assembly/disassembly models for ACO  [24,36] is given. With J. F. Wang’s method, the theoretical growth rate of nodes in DCG will be 6 times of the increasing speed of components while edges are 36 times. F. Failli and Dini’s work indicates that the nodes of the DNN will increase even more quickly with the increase of components because the nodes of DNN is constructed by three factors: part, gripper, and direction. Therefore, for an assembly with many components, constructing the DCG and DNN models will be challengeable, and they are also too complex to be searched efficiently.

After more than 50 experiments with different parameters and presumed precedence relations, the following conclusions are worth mentioning: 
                        
                           (1)
                           The node number of a product’s DFIG is fluctuating around a steady number, in various experiments. The essential reason is that, the product’s structure and constraint relationships (geometric and technical) between components reflect the intrinsic information to determine the theoretical structure of the DFIG.

The size of ant colony has a close relationship with the iteration number of ants’ convergence (at the optimal solution). By using an ant colony with a large population, the generation of the DFIG could be completed and steady at a small iteration number. Therefore, the ant colony can converge to the optimal solution in a smaller number of iterations.

Strong constraint relationships could improve the efficiency. The runtime depends primarily on the assembly complexity and the number of components. In real cases, runtime is an important factor in evaluating the performance of experiments. Because the constraint relationships determine the structure of the DFIG, strong constraint relationships will lead to a smaller-node DFIG and a short-time search for the best solution.

@&#CONCLUSIONS AND FUTURE WORK@&#

As an NP-hard problem, the research focus of mechanical assembly planning is to find out the best solution from a large number of possible solutions (solution space) with an acceptable time. Much work has been done in this field, but most of them focus on the assembly plan optimization while another crucial problem, the generation of the solution space has received little attention in the past years. Traditionally, the generation of the solution space and the best solution search are two independent problems. Actually, creating a complete solution space of product assembly is a very hard and exhausting work which costs much time and effort. However, before applying assembly planning and optimization techniques in real industrial cases, we cannot evade the issue of solution space generation. This raises the need for a feasible methodology to generate the solution space of the sequence planning problem.

This is the motivation that got us started on research to couple the solution space generation and solution optimization in the same process. Based on the design structure of DFIG, the ACO algorithm shows a good ability on neighborhood explorations. There are two parallel threads in the proposed ACO–DFIG system: the generating process of the DFIG model and the meta-heuristic search process for the best path. During an ant colony search, along the moving direction of the ants, the nodes relevant with their traces are created, and added into the DFIG model. Meanwhile, the ant colony will move closer to the optimal path. By developing a trial system based on this methodology, and testing it with some experiments, the results show a high performance of both improving solution quality and speeding up the heuristic search process.

The proposed study has solidified a fundamental methodology for assembly/disassembly planning. More testing work of the ACO–DFIG algorithm is now in progress to develop a deeper understanding of the interactive relationship between the searching algorithm and solution space generation. Furthermore, in future work, a more detailed comparison among different assembly planning methods will be done, particularly, in the efficiency on real industrial cases.

@&#ACKNOWLEDGMENTS@&#

We are thankful for the constructive comments from the reviewers and editor whose suggestions were crucial for us to improve the quality of this paper. We also appreciate Xiaodong (Emma) Huang and her friends in the Writing Lab, the University of Texas at Dallas, for their help on correcting the linguistic mistakes in this paper.

This research was partially supported by the National Natural Science Foundation of China (Grant 51205221), the Natural Science Foundation of Beijing (Grant 3122022) and the Scientific Research Foundation for the Returned Overseas Chinese Scholars, State Education Ministry.

@&#REFERENCES@&#

