@&#MAIN-TITLE@&#Efficient global penetration depth computation for articulated models

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Novelty: The first global PD approach for high-DOF articulated models.


                        
                        
                           
                           Generality: Handling hybrid joints and links represented using polygonal models.


                        
                        
                           
                           Conservativeness: Guaranteeing that the configuration realizing PD is penetration free.


                        
                        
                           
                           Efficiency: Taking about 0.03–3 ms per runtime PD query in our experiments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Configuration space

Articulated models

Penetration depth

Support vector machine

@&#ABSTRACT@&#


               
               
                  We present an algorithm for computing the global penetration depth between an articulated model and an obstacle or between the distinctive links of an articulated model. In so doing, we use a formulation of penetration depth derived in configuration space. We first compute an approximation of the boundary of the obstacle regions using a support vector machine in a learning stage. Then, we employ a nearest neighbor search to perform a runtime query for penetration depth. The computational complexity of the runtime query depends on the number of support vectors, and its computational time varies from 0.03 to 3 milliseconds in our benchmarks. We can guarantee that the configuration realizing the penetration depth is penetration free, and the algorithm can handle general articulated models. We tested our algorithm in robot motion planning and grasping simulations using many high degree of freedom (DOF) articulated models. Our algorithm is the first to efficiently compute global penetration depth for high-DOF articulated models.
               
            

@&#INTRODUCTION@&#

Computing the magnitude of inter-penetration between two overlapping rigid/articulated objects is a fundamental problem in computational geometry. One metric that is widely used to measure the extent of inter-penetration is penetration depth (PD), which requires computing a minimum transformation (translation and rotation) to separate two overlapping objects. The resulting transformation motion can be used to compute the contact force for penalty-based methods, valid poses in grasping simulations, force/torque feedback in haptic rendering, sample generation in narrow passages for motion planning, etc.

The exact computation for PD, particularly the so-called generalized PD that involves both translation and rotation  [1], can be reduced to arrangement computation in a high-dimensional configuration space that has high computational complexity. For instance, the combinatorial complexity of exact PD is as high as 
                        O
                        
                           (
                           
                              
                                 n
                              
                              
                                 12
                              
                           
                           )
                        
                        [2] for two models with 
                        n
                      triangles in three-dimensional space. As a result, all practical algorithms tend to compute an approximate solution. A wide variety of algorithms have been proposed in the literature for rigid models (e.g.  [3,4,2,5–8]). For articulated models, the resulting configuration spaces are high-dimensional non-Euclidean spaces. For instance, the configuration space for a stationary obstacle and a six degrees of freedom (DOFs) robot arm fixed on the ground, is a six-dimensional non-Euclidean space. If we allow the arm base to move in space, its configuration space becomes nine-dimensional and non-Euclidean. As the number of joints increases, the complexity of a configuration space can become very high. In particular, if self-collisions between distinctive links must be considered, the complexity can increase rapidly. These self-collisions may correspond to many small and isolated components in the high-dimensional configuration space. Due to its high complexity, it is challenging to produce an exact representation of a space with such high dimensionality. To the best of our knowledge, only one recent study  [9] has attempted to compute PD between articulated models, but its solution yielded only locally optimal PD.


                     Main result: We present an efficient algorithm to approximate the global PD in high-dimensional spaces for articulated models. Built on the early framework proposed in  [8,10], we use a machine learning method to approximate the boundary of the obstacle regions in the configuration space for an articulated model and its surrounding obstacles. We generate a set of configuration samples to densely cover the boundary of obstacle regions. Given a query configuration for computing PD, the closest configuration can be found quickly using approximate 
                        k
                     -nearest-neighbor search. The magnitude of PD can be computed using non-Euclidean distance metrics between the query configuration and the closest configuration. Compared with existing methods, our method has the following advantages:


                     Novelty: Our algorithm is the first global PD approach for high-DOF articulated models.


                     Generality: Our algorithm can handle hybrid joints and links represented using polygonal models.


                     Conservativeness: Our algorithm can guarantee that the configuration realizing PD is penetration free. This feature is particularly important for enforcing non-penetration constraints in certain applications, such as dynamic simulation, motion planning, and grasping simulation.


                     Efficiency: Our algorithm takes about 0.03–3 ms per runtime PD query on single core. The computational complexity of runtime query depends only on the number of support vectors used in learned obstacle regions.

The rest of the paper is organized as follows. In Section  2, we provide a review of the related work on PD computation. In Section  3, we introduce the notation that we use in the paper and present the algorithm for approximating obstacle regions for articulated models. In Section  4, we describe our approach to compute PD by using approximate obstacle regions and a solution for computing conservative PD. Section  5 describes the implementation details and some basic experimental results. Section  6 highlights the results on complex scenarios.

@&#RELATED WORK@&#

There are two types of PD: translational PD and generalized PD. Translational PD corresponds to a translational motion to separate two objects, whereas generalized PD corresponds to both translational and rotational motions. Various work on PD computation has been reported in computer graphics, geometric modeling, haptics, and robotics, and most of the associated algorithms address rigid models. In the following, we offer a brief overview of these algorithms.


                     Translational penetration depth: Exact translational PD can be formulated using the Minkowski sum; it is obtained by computing the closest distance from the origin to the boundary of the Minkowski sum  [11,12]. The worst-case complexities for these approaches is 
                        O
                        
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                        
                      for convex polytopes and 
                        O
                        
                           (
                           
                              
                                 n
                              
                              
                                 6
                              
                           
                           )
                        
                      for non-convex polytopes, where 
                        n
                      is the number of features in the polytopes  [11]. Because of the high computational cost involved in computing exact translational PD, most practical approaches compute an approximation instead. For convex polytopes, many methods simply compute an approximate Minkowski sum, which is then used as an approximate translational PD calculation  [13,14]. Translational PD between non-convex objects is typically computed using convex decomposition, which is based on the fact that an exact Minkowski sum can be computed based on convex decomposition and the union of all the pairwise Minkowski sums  [15]. As it is expensive and not particularly robust to compute the union explicitly, many approximate solutions have been proposed, including GPU-based approaches  [2,16] and methods that are based on reduced convolution and filtering  [17,18]. Other methods avoid the expensive Minkowski union entirely by computing only translational PD between each pair of convex components. These approaches are called local methods because the resulting PD only depends locally on the closest point on the penetrated surfaces and may not result in a globally consistent solution. Most local PD methods are based on local features  [19,20,18,21,22], i.e., each convex piece generated by the convex decomposition is a mesh triangle. Some recent methods  [7] uses iterative optimization to compute approximate translational PD.


                     Generalized penetration depth: Few algorithms can compute generalized PD, which considers both translation and rotation. [1] estimate the upper and lower bounds for generalized PD between two general polyhedral models by decomposing the models into convex components. Most practical algorithms for generalized PD computation follow the iterative, constrained optimization framework, which generates a series of configurations on the contact space with decreasing distances to the given in-collision query. [5] generates such a series of configurations by moving a small step size from a configuration along the gradient direction. [6] first compute an approximate local contact space near a configuration and then perform random sampling within the approximate contact space to find a suitable following configuration. [23] calculate a linearized contact space in the neighborhood of a configuration and then obtain an optimal following configuration by solving a linear complementary problem (LCP). Most of these approaches  [1,6,5] are slow for interactive applications and do not have the necessary guarantees for a global solution.


                     Penetration depth for articulated models: Recently,  [9] present an algorithm to approximate PD for articulated models. Their algorithm approximated a local configuration space using iterative and constrained optimization techniques and provided a locally optimal PD.


                     Other penetration depth metrics: In addition to the related work above, there are other definitions of PD. Intersection volume and its derivative can also be used for volume-based repulsion  [24]. Distance fields are also used for local translational PD computation  [25] and can be computed in realtime using GPUs. Point-based Minkowski sum approximation  [17] can also be used to compute translational PD.

We denote an articulated model as 
                           A
                         and an obstacle as 
                           O
                        , as shown in Fig. 1
                        . We assume that 
                           A
                         has 
                           n
                         links. The 
                           i
                        th link of 
                           A
                         is denoted as 
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                        , and the link attached to 
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                         is denoted as 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                        . The joint connecting two links, 
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                        , is denoted as 
                           
                              
                                 J
                              
                              
                                 i
                              
                           
                        . Joint 
                           
                              
                                 J
                              
                              
                                 i
                              
                           
                        ’s parameter is denoted as 
                           
                              
                                 θ
                              
                              
                                 i
                              
                           
                        . We denote the configuration space composed of 
                           A
                         and 
                           O
                         as 
                           C
                         and each configuration 
                           
                              q
                           
                         in 
                           C
                         corresponds to the relative configuration (i.e., translation and rotation) of 
                           A
                         with respect to 
                           O
                        . The 
                           i
                        th component of 
                           
                              q
                           
                         is 
                           
                              
                                 q
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 θ
                              
                              
                                 i
                              
                           
                        . 
                           C
                         has two regions: the obstacle region 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                           =
                           
                              {
                              
                                 q
                              
                              :
                              A
                              
                                 (
                                 
                                    q
                                 
                                 )
                              
                              ∩
                              O
                              ≠
                              0̸
                              }
                           
                         and free space 
                           
                              
                                 C
                              
                              
                                 
                                    free
                                 
                              
                           
                           =
                           C
                           ∖
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . Intuitively speaking, 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         corresponds to configurations in which 
                           A
                         and 
                           O
                         collide, and 
                           
                              
                                 C
                              
                              
                                 
                                    free
                                 
                              
                           
                         corresponds to configurations in which 
                           A
                         and 
                           O
                         do not. If self-collisions between distinctive articulated links are considered and added to the definition of 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        , we can rewrite 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                           =
                           
                              {
                              
                                 q
                              
                              :
                              A
                              
                                 (
                                 
                                    q
                                 
                                 )
                              
                              ∩
                              O
                              ≠
                              0̸
                              }
                           
                           ∪
                           
                              {
                              
                                 q
                              
                              :
                              
                                 
                                    L
                                 
                                 
                                    i
                                 
                              
                              
                                 (
                                 
                                    q
                                 
                                 )
                              
                              ∩
                              
                                 
                                    L
                                 
                                 
                                    j
                                 
                              
                              
                                 (
                                 
                                    q
                                 
                                 )
                              
                              ≠
                              0̸
                              ,
                              
                                 |
                                 i
                                 −
                                 j
                                 |
                              
                              >
                              1
                              }
                           
                        . Note that consecutive links are excluded from the set of collision pairs because they are connected by a joint and are in contact all the time. The boundary of 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         is denoted as 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . The approximation of 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         is denoted as 
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                         and its boundary is 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . Fig. 1-(b) shows the obstacle region 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         for the models given in Fig. 1-(a) in which two revolute joints are active.


                        Uniform sampling: For an articulated model, 
                           A
                        , and an obstacle, 
                           O
                        , we use a machine learning method to compute an approximate model of their obstacle regions. We first perform uniform sampling in their configuration space, 
                           C
                        , to obtain a set of configuration points. These samples belong either to 
                           
                              
                                 C
                              
                              
                                 
                                    free
                                 
                              
                           
                         or to 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        , and their collision states are determined using discrete collision detection algorithms, such as  [26]. For the sake of simplicity, we only account for collisions between articulated links and obstacles in this section. Self-collisions are considered further below (in Section  5).


                        Machine learning: With these labeled data (configuration samples and their collision states), a support vector machine (SVM) technique is used to train a binary classifier to separate 
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 
                                    free
                                 
                              
                           
                        . Briefly speaking, an SVM maps the given original data into a feature space (
                           H
                        ) by a function 
                           ϕ
                        , to reduce a nonlinear classification to a linearly separable problem. The function 
                           ϕ
                         computes a mapping from an input space onto a feature space. A point in the feature space is the image of an input configuration. Any point in the input space corresponding to a point in the feature space is called its pre-image. Then, an optimal separating hyperplane in the feature space can be mapped back into input space via its inverse mapping. Let 
                           K
                           
                              (
                              
                                 
                                    
                                       q
                                    
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    
                                       q
                                    
                                 
                                 
                                    j
                                 
                              
                              )
                           
                           =
                           ϕ
                           
                              
                                 
                                    (
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                              
                                 T
                              
                           
                           ϕ
                           
                              (
                              
                                 
                                    
                                       q
                                    
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         represent the kernel function, which is used to calculate inner products in the feature space. The radial basis function (RBF) serves as the kernel.
                           
                              (1)
                              
                                 K
                                 
                                    (
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          j
                                       
                                    
                                    )
                                 
                                 =
                                 exp
                                 
                                    (
                                    −
                                    γ
                                    
                                       
                                          
                                             ‖
                                             
                                                
                                                   
                                                      q
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             −
                                             
                                                
                                                   
                                                      q
                                                   
                                                
                                                
                                                   j
                                                
                                             
                                             ‖
                                          
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                         where 
                           γ
                         is a positive parameter. Thus, the classifier can be modeled as 
                           
                              (2)
                              
                                 f
                                 
                                    (
                                    
                                       q
                                    
                                    )
                                 
                                 =
                                 
                                    w
                                 
                                 ⋅
                                 ϕ
                                 
                                    (
                                    
                                       q
                                    
                                    )
                                 
                                 +
                                 
                                    b
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       α
                                    
                                    
                                       i
                                    
                                 
                                 K
                                 
                                    (
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       q
                                    
                                    )
                                 
                                 +
                                 
                                    b
                                 
                                 ,
                              
                           
                         where 
                           
                              w
                           
                           ∈
                           H
                         and 
                           
                              b
                           
                           ∈
                           R
                        . Most of 
                           
                              
                                 α
                              
                              
                                 i
                              
                           
                         are non-zero and their corresponding 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 i
                              
                           
                         are the support vectors. 
                           f
                           
                              (
                              
                                 q
                              
                              )
                           
                           =
                           0
                         is referred to as a decision boundary, which corresponds to an implicit function that can be used to predict the collision state for an input configuration. This implicit function can also be used to approximate the boundary of the obstacle region, 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        .

In general, better classifiers can be trained by an SVM technique when more samples are given. However, due to the high computational cost associated with the training method, the training samples must be limited. Therefore,  [8] suggests an active learning strategy to accelerate the training process in an iterative manner. In short, a relatively coarse SVM classifier is first obtained using a small set of configuration samples. Then, it is refined iteratively by adding more samples into the training set. The main difficulty is to select good samples that can help improve the approximation quickly and lead to rapid convergence in machine learning. Here, we present a new approach to quickly select good samples for purposes of refining the trained boundary, 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . This approach is based on the following two key observations regarding support vectors. One observation is that support vectors fully determine the decision boundary, 
                           f
                           
                              (
                              
                                 q
                              
                              )
                           
                           =
                           0
                           
                           
                              (
                              ∂
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              )
                           
                        , and the other observation is that the pre-images of these support vectors are distributed near the exact boundary, 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         (i.e. the margin boundaries). Based on these two observations, our goal is to add more samples near 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         into the training data.


                        Refinement: Uniform sampling can explore unknown spaces effectively but disregards the particular space, such as obstacle regions, 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . Based on the observation discussed above, the samples around 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                         play an important role in determining the decision boundary, 
                           f
                           
                              (
                              
                                 q
                              
                              )
                           
                           =
                           0
                           
                           
                              (
                              ∂
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              )
                           
                        . Here, we propose a new strategy to generate more samples around 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        , which will help refine the coarse approximation of 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . The basic idea is to generate more samples between the margin boundaries. As shown in Fig. 2
                        -(a), margin boundaries are highlighted using two dotted curves, which can be achieved to generate more samples around support vectors. More specifically, for any support vector, 
                           
                              s
                           
                        , we uniformly generate some samples on the sphere with center 
                           
                              s
                           
                         and radius 
                           r
                        . 
                           r
                         is determined by 
                           
                              (3)
                              
                                 r
                                 =
                                 
                                    
                                       max
                                    
                                    
                                 
                                 
                                    
                                       min
                                    
                                    
                                       
                                          q
                                       
                                       ∈
                                       S
                                       
                                          
                                             V
                                          
                                          
                                             +
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                q
                                             
                                          
                                          
                                             ′
                                          
                                       
                                       ∈
                                       S
                                       
                                          
                                             V
                                          
                                          
                                             −
                                          
                                       
                                    
                                 
                                 
                                    dist
                                 
                                 
                                    (
                                    
                                       q
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 
                                    SV
                                 
                              
                              
                                 +
                              
                           
                         and 
                           
                              
                                 
                                    SV
                                 
                              
                              
                                 −
                              
                           
                         are the support vectors that are labeled as collision-free and in-collision, respectively. This equation is to compute an appropriate radius that is used to generate more samples within the margin boundaries. Intuitively, this equation implies that, for each 
                           
                              SV
                           
                        , we compute its nearest neighbor among the opposite-labeled 
                           
                              SV
                           
                        s. Then we choose the pair of 
                           
                              SV
                           
                        s that has the maximum distance and compute the radius 
                           r
                        . Since most of 
                           
                              SV
                           
                        s lie in the maximal margin boundary, radius 
                           r
                           ≥
                           
                              
                                 1
                              
                              
                                 
                                    ‖
                                    w
                                    ‖
                                 
                              
                           
                        , where 
                           
                              
                                 1
                              
                              
                                 
                                    ‖
                                    w
                                    ‖
                                 
                              
                           
                         is the half of margin boundaries. Sampling using 
                           r
                         will increase the probability of generating new sample pairs that have opposite collision states. Then this will help us generate more new samples within the margin boundaries in the next step. If the new sample has a different collision state, we generate one more sample between the new sample and the given support vector (e.g., the middle point). However, if the new sample has the same collision state as the given support vector, this sample is discarded. As shown in Fig. 2-(a), the black dot indicates a support vector. Four samples are generated on the sphere with radius 
                           r
                        . Using our approach, the four new samples on the left will be added into the training set, and the two samples on the right will be discarded. Then, a new and better classifier can be constructed incrementally by using the old decision boundary and the new samples. Our approach can also achieve better performance when there are narrow passages, as shown in Fig. 2-(b).

To gain an understanding of our refinement process, a training process is shown in Fig. 3
                        . The blue regions correspond to obstacle regions for the models given on the right. After a few iterations, the approximation 
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                         finds more isolated obstacle regions.

In this section, we first define distance metric for articulated models used in our algorithm and then present our approach to compute penetration depth.

In this paper, we consider both translational and rotational motion. For an articulated model 
                           A
                        , when its configuration changes from 
                           
                              q
                           
                         to 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 ′
                              
                           
                        , we use the following displacement to calculate distance metric  [9].
                           
                              (4)
                              
                                 
                                    dist
                                 
                                 
                                    (
                                    
                                       q
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       d
                                    
                                    
                                       0
                                    
                                 
                                 +
                                 
                                    
                                       d
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 ⋯
                                 +
                                 
                                    
                                       d
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                         is the distance component contributed by joint 
                           i
                         and its associated links.

For an articulated model, translational motion is contributed by prismatic joints. When a prismatic joint parameter of 
                           
                              
                                 J
                              
                              
                                 i
                              
                           
                         changes from 
                           
                              
                                 q
                              
                              
                                 i
                              
                           
                         to 
                           
                              
                                 q
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                        , the distance contributed by a prismatic joint and its associated link 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         is calculated by 
                           
                              (5)
                              
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                    
                                    
                                       V
                                    
                                 
                                 
                                    
                                       
                                          |
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          −
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          |
                                       
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 V
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         is the volume of 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         and 
                           V
                         is the volume of 
                           A
                        .

For a revolute joint 
                           
                              
                                 J
                              
                              
                                 i
                              
                           
                        , the displacement distance by its associated link 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         can be represented as 
                           
                              (6)
                              
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       4
                                    
                                    
                                       V
                                    
                                 
                                 
                                    
                                       sin
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    
                                       
                                          θ
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                    
                                       T
                                    
                                 
                                 
                                    
                                       I
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                         where 
                           V
                         is the volume of 
                           A
                        , 
                           θ
                         is rotation angle calculated by 
                           θ
                           =
                           
                              
                                 q
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           −
                           
                              
                                 q
                              
                              
                                 i
                              
                           
                        , 
                           
                              
                                 
                                    ω
                                 
                              
                              
                                 i
                              
                           
                         is the rotational axis of 
                           
                              
                                 J
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 I
                              
                              
                                 i
                              
                           
                         is the inertia tensor of 
                           
                              
                                 L
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         in reference frame. For a spherical joint, its distance metric can be defined analogously.

Given an approximation of obstacle region 
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                         and a query 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 0
                              
                           
                           ∈
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        , we can compute penetration depth by looking for the nearest point on 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . 
                           
                              (7)
                              
                                 
                                    
                                       PD
                                    
                                    ¯
                                 
                                 
                                    (
                                    A
                                    
                                       (
                                       
                                          
                                             
                                                q
                                             
                                          
                                          
                                             0
                                          
                                       
                                       )
                                    
                                    ,
                                    O
                                    )
                                 
                                 =
                                 
                                    
                                       min
                                    
                                    
                                       
                                          q
                                       
                                       ∈
                                       ∂
                                       
                                          
                                             
                                                
                                                   C
                                                
                                                ¯
                                             
                                          
                                          
                                             
                                                obs
                                             
                                          
                                       
                                    
                                 
                                 
                                    dist
                                 
                                 
                                    (
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          0
                                       
                                    
                                    ,
                                    
                                       q
                                    
                                    )
                                 
                                 ,
                              
                           
                         where 
                           A
                           
                              (
                              
                                 
                                    
                                       q
                                    
                                 
                                 
                                    0
                                 
                              
                              )
                           
                         corresponds to 
                           A
                         located at the configuration 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 0
                              
                           
                        , 
                           
                              
                                 PD
                              
                              ¯
                           
                         denotes penetration depth computed using an approximate obstacle region 
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        .

Solving Eq. (8) leads to an optimization problem  [8,9]. The solution proposed in  [9], depicted in Fig. 4
                        -(a), may lead to a local nearest configuration 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 2
                              
                           
                         if a random initial guess 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 g
                              
                           
                         is used. The approach suggested in  [8], shown in Fig. 4-(b) uses a nearest support vector as the initial guess and then a constrained optimization is used to search for the closest configuration. The latter may suffer from the problem of slow convergence.

Here, we extend  [8] and propose a new approach to perform fast PD computation, described as follows.


                        Discretized representation: A new discretized approximation is generated from the final trained 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . This will be a discrete representation of 
                           ∂
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                         with very dense samples. Here, we denote this discretized representation as 
                           
                              D
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                        , where 
                           
                              D
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         consists of two components: collision-free configurations 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         and in-collision configurations 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 −
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                        . This step is illustrated in Fig. 5
                        . In order to generate a discretized representation, we choose any red in-collision configuration from 
                           
                              
                                 
                                    SV
                                 
                              
                              
                                 −
                              
                           
                         and perform 
                           k
                        -NN search to compute a few collision-free neighbors from 
                           
                              
                                 
                                    SV
                                 
                              
                              
                                 +
                              
                           
                        . Then we move 
                           A
                         from a green configuration to a red in-collision configuration until a contact is found. This contact corresponds to a configuration near 
                           ∂
                           
                              
                                 C
                              
                              
                                 
                                    obs
                                 
                              
                           
                        . We add this configuration into 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                        . As shown in Fig. 5-(b), the black points denote 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         after applying our approach. A dotted line depicts a motion trajectory from a green point to a red point. In fact, these trajectories can be very complicated, especially for an articulated model. This step is relatively expensive and is performed in a pre-processing stage after 
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                         is obtained.


                        Penetration depth using approximate
                        
                           k
                        -NN: To compute penetration depth, an approximate 
                           k
                        -nearest neighbor algorithm is used to first quickly determine 
                           k
                         configurations in 
                           
                              D
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         nearest to the query configuration 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 0
                              
                           
                        . For our formulation, we use a hierarchical clustering algorithm to perform 
                           k
                        -NN search  [27]. As shown in Fig. 4-(c), 
                           
                              D
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         is depicted using a set of green and red configurations. In our experiment, we choose 
                           k
                           =
                           50
                           ∼
                           100
                        . Then the nearest point is found among these 
                           k
                         configurations. As shown in Fig. 4-(c), these 
                           k
                        -nearest neighbor configurations are enclosed in eclipses. The closest configuration is determined in a brute force manner among these 
                           k
                         configurations. The corresponding penetration depth can be computed using the following formulation. 
                           
                              (8)
                              
                                 
                                    
                                       
                                          PD
                                       
                                    
                                    ¯
                                 
                                 =
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             
                                                q
                                             
                                          
                                          
                                             1
                                          
                                       
                                       ∈
                                       K
                                    
                                 
                                 
                                    dist
                                 
                                 
                                    (
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          0
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                       
                                       
                                          1
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                        
                        
                           K
                         is the configuration set generated by 
                           k
                        -NN search. Note that the resulting configuration 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 1
                              
                           
                         that realizes the final penetration depth can either be collision free or in-collision. Also refer to Algorithm 2 for the pseudocode.


                        Conservative penetration depth: In some applications such as robotic hand grasping, a non-penetration configuration is desired to completely separate two inter-penetrating models. By slightly modifying the algorithm above, we can obtain so-called conservative penetration depth. It can guarantee the configuration realizing a penetration depth, is penetration free. A conservative penetration depth can be computed by using 
                           k
                        -NN search, yet in the subset 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                        . As shown in Fig. 5, 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         is composed of the last collision-free configurations (black) generated by moving articulated model from a green collision-free configuration to a red in-collision configuration. In Fig. 4-(d), the subset 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         is denoted by all green points, which indicates they are collision free configurations. We perform 
                           k
                        -NN search in 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                         to obtain 
                           k
                         collision free configurations for a given query 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 0
                              
                           
                         and then we use formulation (8) to compute conservative PD. Here, we choose 
                           k
                           =
                           5
                           ∼
                           10
                        . Since the resulting configuration is found in 
                           
                              
                                 
                                    D
                                 
                              
                              
                                 +
                              
                           
                           
                              [
                              
                                 
                                    
                                       
                                          C
                                       
                                       ¯
                                    
                                 
                                 
                                    
                                       obs
                                    
                                 
                              
                              ]
                           
                        , we can guarantee it is penetration free and the corresponding PD is conservative. Refer to Algorithm 2 for the pseudocode.

@&#RESULTS@&#

We implemented our algorithm under the framework of  [8], using C++ language. We used Motion Planning Kit  [28] for modeling and simulating articulated models and their surrounding obstacles. We used GraspIt!  [29] to perform grasping simulation using hand models. We used LIBSVM  [30] to perform SVM-based machine learning. We used 
                        k
                     -nearest neighbor search multiple times. In this section, we test our algorithm using a few simple articulated models. Some complex articulated models will be given in the next section.

In Fig. 1-(a), we show an articulated model and an obstacle. If we only allow two revolute joints 
                           
                              
                                 J
                              
                              
                                 0
                              
                           
                         and 
                           
                              
                                 J
                              
                              
                                 1
                              
                           
                         to be active, we can obtain their obstacle region shown in Fig. 1-(b). We will use this benchmark for comparison between three different penetration results (i.e. analytical, approximate and conservative penetration depths).

Let 
                           D
                         be the distance from the first joint 
                           
                              
                                 J
                              
                              
                                 0
                              
                           
                         to obstacle 
                           O
                        . If we increase 
                           D
                        , it is clear that the corresponding exact penetration depth will decrease. As presented in  [9], penetration depth can be analytically calculated for a query configuration 
                           
                              
                                 
                                    q
                                 
                              
                              
                                 0
                              
                           
                         in the scenario given in Fig. 1-(a). As shown in Fig. 6
                        , the red curve shows the exact penetration depth obtained using an analytical method. The green curve is for the approximate results. However, at some locations (e.g. distance is 1.3), the approximate magnitude of penetration depth is smaller than the exact penetration depth. The configuration that realizes this penetration depth does not separate two objects. The conservative penetration depth calculated by our algorithm, shown as a blue curve, is always greater than the exact penetration depth (red).


                        Computational cost: In pre-processing, our algorithm takes nearly 40 s for training a binary classifier and obtaining the approximate boundary of obstacle region. There are more than 3000 support vectors in the classifier. It takes additional 293 s in pre-processing stage to generate a discretized representation. The runtime query of penetration depth takes 0.047 ms only.

In this section, we consider the scenarios with self-collisions. Fig. 7
                        -(a) shows an example of self-collision between two links of an articulated model, where link 
                           
                              
                                 L
                              
                              
                                 3
                              
                           
                         collides with the base link 
                           
                              
                                 L
                              
                              
                                 0
                              
                           
                        . If we only allow 
                           
                              
                                 J
                              
                              
                                 0
                              
                           
                         and 
                           
                              
                                 J
                              
                              
                                 1
                              
                           
                         to rotate, it is obvious that the exact penetration depth is constant for the query configuration shown in Fig. 7-(a). To compare with our results, we first rotate 
                           
                              
                                 J
                              
                              
                                 0
                              
                           
                         only by a specified angle and compute its conservative penetration depth. The results are shown in 7-(b), where the horizontal axis is the angle of rotation and the vertical axis is the magnitudes of penetration depth.

In addition, we generate different query configurations by rotating 
                           
                              
                                 J
                              
                              
                                 1
                              
                           
                        . For a query configuration, we compute its conservative penetration depth. When 
                           
                              
                                 L
                              
                              
                                 2
                              
                           
                         and its attached links move from one side of 
                           
                              
                                 L
                              
                              
                                 0
                              
                           
                         to the other side, the penetration depth gradually increases and then decreases, as shown in Fig. 7-(c).


                        Fig. 8
                        -(a) shows a more complicated scenario. We let three revolute joints 
                           
                              
                                 J
                              
                              
                                 0
                              
                           
                        , 
                           
                              
                                 J
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 J
                              
                              
                                 3
                              
                           
                         rotate. In order to test our algorithm, we start from the configuration shown in Fig. 8-(a) where 
                           
                              
                                 L
                              
                              
                                 4
                              
                           
                         collide with 
                           
                              
                                 L
                              
                              
                                 2
                              
                           
                        . We rotate 
                           
                              
                                 J
                              
                              
                                 2
                              
                           
                         to generate some query configurations in a counterclockwise manner. Then we calculate penetration depth for these inter-penetration configurations. The results are shown in Fig. 8-(b).


                        Computational cost: In the first two scenarios, it takes 42 s for training approximate obstacle region and 355 s to generate a discretized representation. It takes 0.058 ms on average for each penetration depth query. In the three dimensional scenario, training approximate obstacle region takes 39 s and generating a discretized representation takes 138 s. Computing penetration depth takes 0.046 ms on average for each query.

We also test our algorithm for an articulated model composed of hybrid joints. Here we consider both revolute and prismatic joints. In our experiment, we add a prismatic joint between 
                           
                              
                                 L
                              
                              
                                 0
                              
                           
                         and 
                           
                              
                                 L
                              
                              
                                 1
                              
                           
                         for the articulated model shown in Fig. 1-(a). After adding one degree of freedom, its obstacle region becomes three dimensional space, two dimensions for rotation and one dimension for translation. We generate some query configurations by placing obstacle 
                           O
                         at different locations. When obstacle 
                           O
                         moves away from 
                           A
                         along horizontal axis, penetration depth magnitude decreases, as shown in Fig. 9
                        . To test the influence of translation component in penetration depth computation, we assign a weight factor to the prismatic joint (refer to Eq. (5)). Fig. 9 shows penetration depth results under three different weights for prismatic joint.

The red line is obtained using the smallest weight. In this case, two objects tend to be separated by translation (prismatic joint) rather than rotation (revolute joints) because it consumes less energy. These penetration depth magnitudes are mainly contributed by translational component and they are smaller than the results given in Fig. 6.

The blue line is obtained using the largest translational weight, so rotate joints tend to contribute more in penetration depth computation. In our experiment, the penetration depth magnitudes are similar to those results given in Fig. 6.

The green line is for the case using a medium translational weight. When the articulated model and obstacle have a deeper inter-penetration (i.e. larger penetration depth), their penetration depth is determined by both rotation and translation motion. In this case, their penetration depth magnitudes are greater than the translation dominated case (red line), but less than the rotation dominated case (blue line). However, for marginal inter-penetration, a translational component tends to contribute more than a rotational component. The resulting penetration depth tends to be equivalent to the one given in red, as shown in the portion where distance is greater than 1.6.


                        Computational cost: In our experiment, it takes 26 s to train approximate obstacle region and 68 s to generate discretized obstacle region. The average query time for penetration depth is 0.03 ms.

In this section, we applied our algorithm to different complex articulated models.


                        PUMA and cage: As shown in Fig. 10
                        -(a), a PUMA industrial robot sweeps into a cage and the two models penetrate each other during the motion. In-collision configurations and collision-free configurations are highlighted in light blue and green, respectively. The PUMA robot consists of 868 triangles and the cage consists of 432 triangles. The left image in Fig. 10-(a) shows three active revolute joints. In this benchmark, it takes 135 s to generate an approximation of obstacle regions and the number of support vectors 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           2746
                        . Computing the penetration depth takes about 1.09 ms per runtime query. For six active joints (shown in the right image of Fig. 10-(a)), it takes 350 s to generate the approximation of obstacle regions and 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           8233
                        . It takes 2.25 ms on average to compute the penetration depth for this case.


                        Arc welding robot and car: As shown in Fig. 10-(b), an arc welding industrial robot works beside a car and the two models penetrate each other during the motion, where light blue highlights an in-collision configuration and green represents a collision-free configuration. The arc welding robot consists of 3.7 K triangles and the car consists of 19 K triangles. In our experiment, it takes 117 s to generate the approximation of obstacle regions for three active joints. The number of support vectors 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           1656
                        . Computing conservative penetration depth takes 0.77 ms. When activating six active joints, it takes 382 s to generate the approximation of obstacle regions and 0.85 ms to compute penetration depth. 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           7887
                        .


                        Arc welding robot and drill: As shown in Fig. 10-(c), an arc welding industrial robot works beside a drill and the two models penetrate each other during the motion (gray). A collision-free configuration is highlighted in pink. The arc welding robot consists of 3.7 K triangles and the drill consists of 34 K triangles. It takes 62 s to generate the approximation of obstacle regions for three active joints and 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           3379
                        . Computing penetration depth takes 0.61 ms. For six active joints, it takes 383 s to generate the approximation of obstacle regions and computing penetration depth takes 1.04 ms. 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           7259
                        .


                        Spot welding robot and car body: As shown in Fig. 10-(d), a spot welding industrial robot works around a car body and the two models penetrate each other during the motion (blue). A collision-free configuration is highlighted in green. The spot welding robot consists of 5.6 K triangles and the car body consists of 4 K triangles. The left of Fig. 10-(d) is for activating three active joints, it takes 118 s to generate the approximation of obstacle regions and 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           3079
                        . Computing penetration depth takes 0.62 ms. The right of Fig. 10-(d) is for activating seven active joints, it takes 497 s to generate the approximation of obstacle regions. Computing penetration depth takes 1.91 ms. This scenario is complex, so more support vectors (
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           9254
                        ) are used.


                        Hand grasping: A robot hand grasps a glass (Fig. 11
                        ). The hand has twelve joints, consisting of 22 K triangles. The glass consists of 3.2 K triangles. A sequence of inter-penetration configurations are generated during the simulation and our algorithm is used to separate two objects. Our algorithm takes 403 s to generate the approximation of obstacle regions and 1.99 ms to compute penetration depth. 
                           
                              |
                              
                                 SV
                              
                              |
                           
                           =
                           8245
                         is fewer than the previous benchmark (spot welding robot and car body), as the geometric model of the glass is not very complex. Note that we did not take account of any constraint that makes the hand hold the glass.


                        Motion planning: We also apply our PD algorithm to a retraction-based probabilistic roadmap (PRM) planner  [31]. We generate some samples in C-space and compute their collision states. If the underlying state is collision-free, the sample is added to the roadmap. If its state is in-collision, the sample is used to compute a corresponding configuration in the free space based on our PD algorithm and a new collision-free configuration is added to the roadmap. Our PD algorithm is used to efficiently compute these collision-free configurations corresponding to given in-collision configurations. As shown in Fig. 12
                        , planning a path for welding robot takes 127 s. In total, it generates 20181 free-space samples, out of which 3309 samples are computing using our PD algorithm.

In this section, we make some comparisons. As shown in Figs. 13 and 14
                        
                        , we compare our conservative penetration depth against non-conservative penetration depth. Since the penetration depth queried using 
                           k
                        -nearest neighbor does not guarantee to lie outside the obstacle regions, our conservative penetration depths are generally greater than non-conservative penetration depth. In some cases, the non-conservative penetration magnitudes are greater than conservative. That is because the query point lie far away from the configuration space boundary. We also gave the time statistics for the two algorithms, shown in Fig. 14. Both the algorithms achieved similar runtime performance.[9] is the only work to approximate penetration depth for articulated models. Their work uses local contact space projection to iteratively find a local minimum point at the runtime. The query time includes successive perturbation to find start point and iterative contact space projection. Our query time is mainly affected by the number of support vectors 
                           
                              |
                              
                                 SV
                              
                              |
                           
                        . In general, the runtime query is more efficient than  [9] and does not suffer the iterative process. However, we need to spend more time in learning stage than theirs.


                        Learning: The time spent in the learning stage can be estimated by 
                           T
                           =
                           
                              
                                 T
                              
                              
                                 c
                              
                           
                           ⋅
                           
                              
                                 N
                              
                              
                                 s
                              
                           
                           +
                           
                              
                                 T
                              
                              
                                 L
                              
                           
                           +
                           
                              
                                 T
                              
                              
                                 R
                              
                           
                           +
                           
                              
                                 T
                              
                              
                                 D
                              
                           
                        , where 
                           
                              
                                 T
                              
                              
                                 c
                              
                           
                           =
                           
                              
                                 T
                              
                              
                                 
                                    col
                                 
                              
                           
                           ⋅
                           
                              
                                 N
                              
                              
                                 L
                              
                           
                         is the time of collision detection (
                           
                              
                                 T
                              
                              
                                 
                                    col
                                 
                              
                           
                         is collision detection time for one articulated link and 
                           
                              
                                 N
                              
                              
                                 L
                              
                           
                         is the number of links in an articulated model), 
                           
                              
                                 N
                              
                              
                                 s
                              
                           
                         is the number of samples, 
                           
                              
                                 T
                              
                              
                                 L
                              
                           
                         is the time to learn an initial approximation, 
                           
                              
                                 T
                              
                              
                                 R
                              
                           
                         is the time for refinement and 
                           
                              
                                 T
                              
                              
                                 D
                              
                           
                         is the time of generating discretized representation. 
                           
                              
                                 T
                              
                              
                                 D
                              
                           
                           =
                           k
                           ⋅
                           
                              
                                 N
                              
                              
                                 
                                    SV
                                 
                              
                           
                           ⋅
                           
                              
                                 T
                              
                              
                                 
                                    ccd
                                 
                              
                           
                        , where 
                           k
                         is a number specified by users (i.e.  
                           k
                         nearest neighbors with opposite state for a given support vector), 
                           
                              
                                 N
                              
                              
                                 
                                    SV
                                 
                              
                           
                         is the number of support vectors, 
                           
                              
                                 T
                              
                              
                                 
                                    ccd
                                 
                              
                           
                         is the time of continuous collision detection for given two configurations.


                        Query: The time of runtime query is mainly determined by the number of support vectors.

We presented an efficient algorithm to compute global penetration depth for articulated models. The performance gain is due to the use of machine learning techniques and the simplification of runtime query. The former dramatically reduces computational complexity and the latter avoids constrained optimization process. We carried out extensive experiments to demonstrate the efficiency of our algorithm.

Our algorithm has some limitations. Firstly, due to the difficulty to understand and obtain true penetration depth for high-DOF obstacle regions, we have not compared our conservative penetration with the ground truth for some complex benchmarks. Secondly, though our algorithm can guarantee the conservativeness of penetration depth, we still have difficulty deriving its upper bound. This deserves for the future research.

Besides, due to the importance of obstacle regions and penetration depth computation in many applications, it would be very interesting to characterize and visualize obstacle regions for high-DOF articulated models. Extending our algorithm to handle multiple articulated models would be another future direction. Analyzing complex configuration spaces that exhibit singularity is very difficult. However, the problem can be simplified if we treat the singular configurations as the samples in 
                        
                           
                              C
                           
                           
                              
                                 obs
                              
                           
                        
                     . Applying machine learning techniques and configuration space approximation to these problem would make it possible, especially for high-DOF articulated models. Another direction for future research is to apply our algorithm to motion planning for narrow passages. At the moment, a tight theoretical error bound is not known for the learning algorithm used in our approach, but approach, but evaluating its accuracy for specific applications is a good topic for future work.

@&#ACKNOWLEDGMENTS@&#

This research work was supported in part by the Foundation for Innovative Research Groups of the NSFC (grant no. 61321064), the Shanghai NSF (grant no. 14ZR1412300), the SRF for ROCS, SEM, the Foundation of the NSFC (grant no. 61272199), 863 Program of China (grant no. 2015AA016404) and the SRFDP (grant no. 20130076110008).

Below are the pseudocode for training a classifier using SVM to obtain the discretized representation 
                        
                           D
                        
                        
                           [
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                           ]
                        
                      (Algorithm 1) and for computing PD (Algorithm 2).

In Algorithm 1, a training procedure takes an articulated model 
                        A
                      and an obstacle 
                        O
                      as input and produces a discrete boundary 
                        
                           D
                        
                        
                           [
                           
                              
                                 
                                    
                                       C
                                    
                                    ¯
                                 
                              
                              
                                 
                                    obs
                                 
                              
                           
                           ]
                        
                     . The number of iterations in training refinement is governed by argument 
                        N
                     . 
                        Q
                      is a set of configurations obtained in sampling.


                     
                        
                           
                        
                     
                  

Note that, in step 1, any sampling scheme can be used. In our implementation, we use uniform sampling.

In Algorithm 2, the configuration that realizes PD is determined using 
                        k
                     -nearest neighbor search (denoted by procedure 
                        k
                     nn). 
                        K
                      is a set of 
                        k
                      configurations returned by the approximate 
                        k
                     nn procedure. The final penetration depth magnitude is calculated using Eqs. (4)–(6).


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

