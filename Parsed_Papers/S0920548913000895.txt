@&#MAIN-TITLE@&#Robust smart card secured authentication scheme on SIP using Elliptic Curve Cryptography

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We concentrate on the security flaws in the current SIP authentication procedure.


                        
                        
                           
                           We propose a secure ECC-based authentication mechanism to conquer many attacks.


                        
                        
                           
                           Our proposed protocol inherits the merits of ECC-based mechanism.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Session Initiation Protocol

Authentication

ECC

HTTP digest authentication

Smart card

@&#ABSTRACT@&#


               
               
                  Recently, Voice over Internet Protocol (VoIP) has been one of the more popular applications in Internet technology. For VoIP and other IP applications, issues surrounding Session Initiation Protocol (SIP) have received significant attention. SIP is a widely used signaling protocol and is capable of operating on Internet Telephony, typically using Hyper Text Transport Protocol (HTTP) digest authentication protocol. Authentication is becoming increasingly crucial because it accesses the server when a user asks to use SIP services. In this paper, we concentrate on the security flaws in the current SIP authentication procedure. We propose a secure ECC-based authentication mechanism to conquer many forms of attacks in previous schemes. By a sophisticated analysis of the security of the ECC-based protocol, we show that it is suitable for applications with higher security requirements.
               
            

@&#INTRODUCTION@&#

Session Initiation Protocol (SIP) [1] is a signaling-based protocol which can establish, modify, and terminate multimedia user sessions at the application layer and can handle all of the signaling requirements of Voice over Internet Protocol (VoIP). With regard to the widely used VoIP application, there have been numerous studies dealing with SIP issues, for instance, authentication problems. Typically, SIP uses the HTTP digest authentication protocol noted in RFC2617 [2] for identity authentication. Several studies have proven that HTTP digest authentication cannot resist off-line password guessing attacks or server spoofing attacks using the HTTP protocol [3–5]. In 2005, Yang [6] proposed a Diffie–Hellman key exchange [7] authentication protocol and Durlanik and Sogukpinar [8] proposed an Elliptic Curve Diffie–Hellman (ECDH) key exchange authentication protocol to resolve these problems. Later, [9,10] found that Yang's protocol was vulnerable to the replay attack and [11] found that Durlanik and Sogukpinar's protocol was vulnerable to the stolen-verifier attack and Denning–Sacco attack. In 2006, Ring et al. [10] provided an Agreement Key (AK) protocol for SIP authentication which used identity-based cryptography (IBC) [12]. It calculated the user's SIP identity with a hash function as the public key. However, Ring et al.'s protocol has been found to be vulnerable to the impersonating attack [12–15], and the computation cost is heavy on bilinear pairing and identity-based signature calculation. To solve these problems, Wang and Zhang [16] proposed a new Secure Authentication and Key Agreement (SAKA) mechanism based on Certificate-Less Public Key Cryptography (CL-PKC) [17]. Wang and Zhang's protocol used the Bilinear Diffie–Hellman (BDH) method to encrypt/decrypt private keys and public keys generated by the Key Generating Center (KGC). Such a protocol can overcome the impersonating attack issue but it suffers from heavy computation cost. In 2009, Tsai [18] proposed a nonce-based authentication protocol for SIP. However, Lee [19] found that Tsai's protocol still suffered from password guessing attacks and insider attacks, so Tsai's protocol is not suitable for SIP.

Since Elliptic Curve Cryptography (ECC) provides a smaller key size than any other cryptosystem and has faster computations than half of the other public key systems at the same security levels [8,20–25], ECC is suitable to be used for higher security authentication. In 2009, Wu et al. [24] proposed a SIP authentication scheme based on ECC and proved that the scheme is secure. Yoon et al.'s [25] SIP authentication scheme is also based on ECC and showed that both schemes [8,24] are prone to offline dictionary attacks, Denning–Sacco attacks, and stolen-verifier attacks. In addition, Yoon et al.'s scheme suffers from off-line password guessing attacks [26]. Recently, smart cards have been widely adopted in remote authentication schemes [27–30]. Its features contain the portability, efficiency and the cryptographic capacity, and incur the lower cost. In 2000, Hwang and Li [27] proposed a smart card based remote user authentication and were required to keep in a system without a password table. Wang et al.'s scheme [29] provided two-variant hashing operations on remote user authentication scheme using smart card and showed that Yoon et al.'s scheme [28] is still vulnerable to the guessing attack, forgery attack and denial of service (DoS) attack. Chen et al. [30] propose an enhancement of Wang et al.'s scheme suffering from impersonation and parallel session attacks. Unfortunately, Chen et al.'s improved scheme is still insecure. To solve these problems, we propose a more secure SIP authentication scheme using ECC and smart cards to reduce computation load and avoid the diverse attacks.

The remainder of this paper is organized as follows. Section 2 reviews the related protocols. In Section 3, ECC is briefly reviewed, and a secure user authentication protocol for SIP is presented. The security and performance analyses are in Section 4. Finally, the conclusion is given in Section 5.

@&#RELATED WORKS@&#

SIP is an application layer signaling protocol using text-based messages for establishing, modifying and terminating multimedia sessions among one or more participants. In SIP, the identities of the caller and callee are addressed by the Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) protocols as defined in RFC2543. Furthermore, SIP overcomes the disadvantages of the H.323 [1,31,32] standard which include slower speed and lower expansibility. Following after H.323, SIP is determined as a potential communication procedure on signaling and call control of VoIP. SIP consists of registrar servers, proxy servers, redirect servers and user agents. SIP signaling is comprised of request and response sessions between two user agents, the caller UA
                         and the callee UB
                        . The SIP scenarios can be stated as follows:
                           
                              Step 1.
                              Before UA
                                  initiates a call to UB
                                 , UA
                                  registers his/her current address using a REGISTER message to the configured registrar server and the registrar server stores the address.

When UA
                                  initiates a call to UB
                                 , UA
                                  sends an INVITE message to the proxy server.

After receiving the INVITE message, the proxy server lookups UB
                                 's address through DNS on the redirect server.

Upon obtaining UB
                                 's address, the proxy server forwards the INVITE message to UB
                                 .

When UB
                                  can accept the call, the OK (200) message is sent to UA
                                  via the proxy server.

Finally, UA
                         sends an ACK message straight forward to UB
                        . When UA
                         or UB
                         wants to terminate the call, one of them sends a BYE message and the other one sends an OK message to terminate the call.

SIP is a client–server protocol so that user authentication becomes one of the most important issues for SIP. Mostly, SIP uses the HTTP digest protocol as an authentication mechanism. We state the details as follows:
                           
                              Step 1.
                              User UA
                                  sends a REQUEST message, which includes the user's ID, to the SIP server.

The SIP server generates a nonce and sends a CHALLENGE message {nonce, realm} to UA
                                 . (Typically, realm is configuration information on the SIP server, configured to specify a name for the SIP domain or host and to share authentication information with user organization's SIP server, for instance, WWW-Authenticate: NTLM realm=“SIP Communications Service”, target name=“LNCS28.us.abc.com”.)

After obtaining the CHALLENGE message, UA
                                  enters password PW and calculates response=
                                 h (nonce, ID, PW, realm), and then sends the RESPONSE message {nonce, realm, ID, response} to the server.

According to UA
                                 's ID, the server derives UA
                                 's PW and calculates response'=
                                 h (nonce, ID, PW, realm) to verify whether response′=
                                 response. If the equation is true, the server authenticates UA
                                  and the proxy server sends the INVITE message to the UB
                                  for the next step in the SIP process.

Several studies have shown that the HTTP Digest protocol is vulnerable to off-line password guessing attacks and server spoofing attacks. Furthermore, there are some other risk issues in the HTTP digest authentication protocol [4,6,8,10,29,33]. We state the issues as follows:
                           
                              A.
                              It is vulnerable to off-line password guessing attacks wherein an adversary can obtain the legal user's password via the offline guessing attack to send a RESPONSE message and pass the authentication step.

It does not perform mutual authentication, making it vulnerable to server spoofing and man-in-the middle attacks. An attacker can obtain any legitimate user's messages to forge his/her own messages to cheat the SIP server for passing authentication.

Because SIP message tags include FROM and TO heads and other important parameters, for instance, ID, server name, etc., an attacker can easily forge SIP messages using original messages to cheat any legitimate user and to spoof the server.

In the HTTP scheme, the password table is statically configured on the SIP server, and passwords are linked to user names. Thus, the user's account is open to insider attacks and stolen verifier attacks.

In 2009, Tsai proposed an enhanced authentication for SIP using a hash function which is similar to the HTTP digest protocol. However, Lee [19] has proven that Tsai's protocol is still open to password guessing attacks and insider attacks, so Tsai's protocol is not suitable for SIP.

In 2005, Yang et al. pointed out that HTTP could not resist server spoofing attacks and off-line guessing attacks and proposed a secret authentication based on Diffie–Hellman key exchange. We describe Yang et al.'s protocol with a Diffie–Hellman based authentication example as follows.
                           
                              Step 1.
                              
                                 UA
                                  generates a nonce Ea
                                  as the private key and calculates Ya
                                 
                                 =(gEa)×(mod p) and Ka
                                 
                                 =
                                 Ya
                                 
                                 ⊕
                                 h(PW) as the public key. And then, UA
                                  sends the message {ID, Ka
                                 } to the server.

After the server receives {ID, Ka
                                 }, the server verifies ID and finds h (PW) on the server database. The server generates a nonce Eb
                                  as the private key and calculates the following formulas for sending the message {realm, Kb
                                 , Kh
                                 } to UA
                                 :
                                    
                                       
                                          
                                             
                                                Y
                                                a
                                             
                                             
                                                
                                                ∗
                                             
                                             =
                                             
                                                K
                                                a
                                             
                                             ⊕
                                             h
                                             
                                                PW
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                Y
                                                b
                                             
                                             =
                                             
                                                
                                                   g
                                                   Eb
                                                
                                             
                                             ×
                                             
                                                
                                                   mod
                                                   p
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                Y
                                                b
                                             
                                             =
                                             
                                                Y
                                                b
                                             
                                             ⊕
                                             h
                                             
                                                PW
                                             
                                             ,
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             K
                                             =
                                             
                                                
                                                   
                                                      Y
                                                      a
                                                   
                                                   
                                                      
                                                         
                                                         ∗
                                                      
                                                      Eb
                                                   
                                                
                                             
                                             ×
                                             
                                                
                                                   mod
                                                   p
                                                
                                             
                                             =
                                             
                                                
                                                   g
                                                   EbEa
                                                
                                             
                                             ×
                                             
                                                
                                                   mod
                                                   p
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                K
                                                h
                                             
                                             =
                                             h
                                             
                                                
                                                   
                                                      Y
                                                      a
                                                   
                                                   
                                                      
                                                      ∗
                                                   
                                                   ∥
                                                   K
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              

When UA
                                  has received the message {realm, Kb
                                 , Kh
                                 }, he/she calculates Yb
                                    ⁎
                                 
                                 =
                                 Kb
                                 
                                 ⊕
                                 h(PW) and K⁎
                                 
                                 =(Yb
                                    ⁎ Ea
                                 )×(mod p)=(gEbEa
                                 )×(mod p) firstly to verify whether Kh
                                 
                                 =(Ya
                                 ||K⁎
                                 ). If Kh
                                 
                                 =(Ya
                                 ||K⁎
                                 ) is true then UA
                                  verifies the server successfully. UA
                                  then calculates h (ID||realm||K) and sends the message {ID, realm, h(ID||realm||K)} to the server.

After the server receives {ID, realm, h (ID||realm|| K)}, the server authenticates whether h (ID||realm|| K) is equal to UA
                                 's message {h(ID||realm|| K)} or not. If it is true then the server verifies UA
                                  successfully.

The DH-based authentication method usually requires exponential metric computation costs to encrypt/decrypt the cipher-text. It is not suitable for the restricted resources of an SIP system. DH-based authentication usually requires polynomial computation costs for private key and public key generation that are considerably higher than the computation costs required for SIP.

In this section, we briefly review the fundamentals of Elliptic Curve and survey the Elliptic Curve Cryptography (ECC) which is suitable for our construction of a secured authentication protocol for SIP. Then, we propose a more secured authentication mechanism with ECC. The notations used through this scheme are summarized in Table 1
                     . The different phases in our protocol will be described later, namely, the initiation phase, the registration phase, mutual authentication phase and the password change phase.

Victor Miller and Neal Kobiltz proposed a secure and efficient elliptic curve cryptosystem in 1985 [21–23].

An elliptic curve is a cubic equation of the form: E:
                        y
                        2
                        +
                        axy
                        +
                        by
                        =
                        x
                        3
                        +
                        cx
                        2
                        +
                        dx
                        +
                        e, where a, b, c, and e are real numbers.

With regard to cryptography, we focus on the finite field of ECC and aim mainly at the prime p of elliptic curve group. The mathematical equation of ECC satisfies the form E
                        :
                        y
                        2
                        =(x
                        3
                        +
                        ax
                        +
                        b)mod
                        p with a, b ∈ Fp
                         satisfying (4a
                        3
                        +27b
                        2)mod
                        p
                        ≠0.

Let Fp
                         denote the finite field of points, where p is a large prime number and containing x, y, and b elements. The equation points and the point at infinity O compose the elliptic curve group over real numbers. We find a large prime number n such that n
                        ×
                        P
                        =
                        O using the elliptic curve addition algorithm. Here, × denotes an elliptic curve multiplication. The arithmetic of elliptic curve discrete logarithm problem (ECDLP) is given points Q and P, where Q, P ∈ Fp
                         and are both publicly known, determine the random number α, 0<
                        α
                        <
                        n
                        −1, and compute Q as: Q
                        =
                        α
                        ×
                        P is satisfies. It is hard to determine α given Q and P, namely, ECDLP is a complex mathematical problem such that the security is achieved. The analog of Diffie–Hellman key exchange uses elliptic curve characteristic to complete key exchange. The key exchange between UA
                         and UB
                         can be done as follows [21–23]:
                           
                              A.
                              The user UA
                                  chooses a random integer rA
                                  as a private key, where rA
                                 
                                 <
                                 n and computes the public key QA
                                  as: QA
                                 
                                 =
                                 rA
                                 
                                 ×
                                 P. Then, UA
                                  sends QA
                                  to the user UB
                                 .

The user UB
                                  selects a random integer rB
                                  as a private key, where rB
                                 
                                 <n and computes the public key QB
                                  as: QB
                                 
                                 =
                                 rB
                                 
                                 ×
                                 P. UB
                                  sends QB
                                  to UA
                                 .


                                 UA
                                  can compute shared key KA
                                 
                                 =
                                 rA
                                 
                                 ×
                                 QB
                                 
                                 =
                                 rA
                                 
                                 ×
                                 rB
                                 
                                 ×
                                 P and UB
                                  can compute shared key KB
                                 
                                 =
                                 rB
                                 
                                 ×
                                 QA
                                 
                                 =
                                 rA
                                 
                                 ×
                                 rB
                                 
                                 ×
                                 P. In this manner we find KA
                                 
                                 =
                                 KB
                                 .

The user and the server set up several system parameters and formula for session key generation. The user and server choose an elliptic curve order n over Ep
                        (a, b) generated by P, where n is a large number for the security considerations. In addition, the eligible server randomly selects qs ϵ Z⁎
                           P
                         as the private key, and then computes the point multiplication as user's authentication key. The smart card is prestored with the secret parameters {BA
                        , WA
                        , h(.), H1
                        (.), H2
                        (.), H3
                        (.)} in user and server side respectively, and the random number Nr
                         is prestored in the users' smart card.

In this phase, the user wants to register to the remote server and setup the secret codes into the smart card for the user. The phase consists of 3 exclusive operations and 4 hash computations.
                           
                              Step 1
                              client→server: {Username, pwy
                                 }

The user enters his/her username id and password pwx
                                  to compute to obtain the pwy
                                 
                                 =
                                 h (pwx
                                 
                                 ⊕
                                 Nr) where Nr is a large random number. Here, the username and pwy
                                  is to verify the identity of the user and server. That is, the user submits his/her username and pwy
                                  to remote server if the user wants to convert into a new eligible user.

The user obtains the authentication key by the server computing KIDA
                                 
                                 =
                                 qs
                                 ×
                                 H1
                                  (id) ϵ Gp
                                 . In addition, the server computes BA
                                 
                                 =
                                 h (id
                                 ⊕
                                 pwy
                                 ) and WA
                                 
                                 =
                                 h (pwy
                                  || id)⊕
                                 KIDA
                                 . Finally, the server stores the secret parameters {BA
                                 , WA
                                 , h (.), H1
                                  (.), H2
                                  (.), H3
                                  (.)} to a smart card and issues the smart card to the user over a secure channel.

When the user receives the smart card, the user stores the random number Nr
                                  in the smart card. Thus, the user stores secret parameters {BA
                                 , WA
                                 , h (.), Nr
                                 , H1
                                  (.), H2
                                  (.), H3
                                  (.)} into the smart card.

Assume that user wants to communicate with the remote SIP server; he/she must enter username and password.
                           
                              Step 1
                              client→server: REQUEST {username, T1
                                 , MA
                                 , RA
                                    ⁎
                                 }

First, the user submits a pwx
                                  and randomly chooses a large number Nr
                                  for computing pwy
                                 
                                 =
                                 h (pwx
                                 
                                 ⊕
                                 Nr
                                 ) and B′A
                                 
                                 =
                                 h (id
                                 ⊕
                                 pwy
                                 ). Next, the user confirms whether the B′A
                                  is equal to BA
                                 . If they are equal, then user calculates V
                                 =
                                 h (pwy
                                 || id) and KIDA
                                 
                                 =
                                 WA
                                 
                                 ⊕
                                 V. In addition, user chooses a random point RA
                                 
                                 =(RA
                                    x
                                 , RA
                                    y
                                 ) ϵ EP
                                  (a, b), where RA
                                    x
                                  and RA
                                    y
                                  are the x and y coordinates of point RA
                                  after user generating the authentication key KIDA
                                 . At the timestamp T1
                                 , user computes t1
                                 
                                 =
                                 H2
                                  (T1
                                 ), MA
                                 
                                 =
                                 RA
                                 
                                 +
                                 t1
                                 
                                 ×
                                 KIDA
                                  and RA
                                    ⁎
                                 
                                 =
                                 RA
                                    x
                                 
                                 ×
                                 P. Lastly, the user sends a REQUEST message to the remote server includes his/her username and pwy
                                 .

The step consists of 3 exclusive operations, 4 hash computation, 2 elliptic curve point multiplication operations, and 1 elliptic curve point addition operation.
                           
                              Step 2
                              server→client: CHALLENGE {realm, T2
                                 , MS
                                 , Mk
                                 }

The server receives the REQUEST message and uses the username to obtain UIDA
                         by transforming into one-way hash digest (H1
                        ). Furthermore, the server computes R′A
                        
                        =
                        MA
                        
                        −
                        qs
                        ×
                        t1
                        
                        ×
                        UIDA
                         where t1
                        
                        =
                        H2
                         (T1
                        ). Here, the server obtain UIDA
                        
                        =(Ux
                        , Uy
                        ) and R′
                           A
                        
                        =(RA
                           x′, RA
                           y′) of the user. After that, the server authenticates the identity of the user if the server checks whether RA
                           x′
                        ×
                        P is equal to RA
                           ⁎
                        . Then the server chooses a random point RS
                        
                        =(RS
                           x
                        , RS
                           y
                        ) ϵ EP
                         (a, b) and computes MS
                        
                        =
                        RS
                        
                        +
                        t2
                        
                        ×
                        qs
                        ×
                        UIDA
                        , common session key k
                        =
                        H3
                        (Ux
                         || RA
                           x
                        || RS
                           x
                        ) and Mk
                        
                        =(k
                        +
                        RS
                           x
                        )×
                        P at the timestamp T2
                        . In the end, the server sends the CHALLENGE message to the user.

The step consists of 3 hash computations, 1 elliptic curve polynomial operation, 2 elliptic curve point multiplication operations, and 1 elliptic curve point addition operation.
                           
                              Step 3
                              When the user receives the CHALLENGE messages, the user computes the R′S
                                 
                                 =
                                 MS
                                 
                                 −
                                 t2
                                 
                                 ×
                                 KIDA
                                  where t2
                                 
                                 =
                                 H2
                                 (T2
                                 ) to obtain R′
                                    S
                                 
                                 =(RS
                                 
                                 x′, RS
                                 
                                 y′) of server. In addition, UIDA
                                 
                                 =(Ux
                                 , Uy
                                 ) is also obtained. The user computes k⁎
                                 
                                 =
                                 H3
                                  (Ux
                                  || RA
                                    x
                                 || RS
                                    x
                                 ′) and Mk
                                    ⁎
                                 
                                 =(k⁎
                                 
                                 +
                                 RS
                                 
                                 x′)×
                                 P and verify whether Mk
                                    ⁎
                                 
                                 =
                                 Mk
                                 . If it holds, the server is authenticated by user; otherwise, terminate the process.

The step consists of 3 hash computations, 2 elliptic curve point multiplication operations, and 1 elliptic curve point addition operation.
                           
                              Step 4.
                              client→server: RESPONSE {realm, username, h (username||realm||k)}

The user computes h (username||realm||k) and sends the RESPONSE message {realm, username, h (username||realm||k)} to the server. The step consists of 1 hash computation.
                           
                              Step 5.
                              When the server receives RESPONSE message, the server computes response⁎
                                 
                                 =
                                 h (k||realm||ID). Then, the server verifies whether response⁎
                                 
                                 =
                                 response. If the equality holds, the server sends the INVITE message and accepts the connection. The step consists of 2 hash computation.


                        
                           
                              Step 1
                              The user can request to change his/her password with the new password pwx
                                    ⁎
                                  after entering a username and a pwx
                                 . Next, the user computes a new value of pwy
                                    ⁎
                                 
                                 =
                                 h (pwx
                                    ⁎
                                 
                                 ⊕
                                 Nr) to update pwy
                                  into the smart card.

After receiving the demand for password change, the server computes BA
                                    ⁎
                                 
                                 =
                                 h (id
                                 ⊕
                                 pwy
                                    ⁎
                                 ) and WA
                                    ⁎
                                 
                                 =
                                 h (pwy
                                    ⁎
                                 || id)⊕
                                 KIDA
                                 . The new value is stored to the smart card by the server.

In this phase, the smart card performs the user's password change operation without informing the server. That is, the original values of BA
                         and WA
                         have been largely supplanted by the use of new value BA
                           ⁎
                         and WA
                           ⁎
                        .

@&#DISCUSSION@&#

This section provides a security and performance analysis of the proposed SIP authentication scheme. Fig. 1
                      illustrates the proposed procedure of the authentication scheme in SIP that ensures the operation remains consistent with the RFC3261 requirements [34]. SIP was first developed by Columbia University in 1998. In 1999, the MMUSIC (Multipart Multimedia Session Control), a part of the Internet Engineering Task Force (IETF), officially formulated the standard as RFC 2543 [35]. In September of the same year, IETF established another work team with the responsibility of drawing up the new version of SIP 2.0. The new version of RFC 2543 bits was released by the IETF in 2000; subsequently, they announced RFC 3261 in 2001. The publication of RFC 3261 revealed the foundation of SIP that has been established. Our scheme keeps to the RFC 3261 requirements and is based on the challenge-response mechanism; furthermore, successfully withstands diverse attacks to enhance the security level.


                           
                              Proof
                              To successfully complete a masquerade attack, an attacker must know a user's password pwx
                                  to pass verification in the login phase and to interpret the verification message correctly for mutual authentication. Since pwy
                                 
                                 =
                                 h(pwx
                                 
                                 ⊕
                                 Nr
                                 ), BA
                                 
                                 =
                                 h(id
                                 ⊕
                                 pwy
                                 ), MA
                                 
                                 =
                                 RA
                                 
                                 +
                                 t1
                                 
                                 ×
                                 KIDA
                                  and RA
                                    ⁎
                                 
                                 =
                                 RA
                                    x
                                 
                                 ×
                                 P are calculated by one-way hash function and scalar multiplication of elliptic curve, the attacker cannot masquerade as a legitimate user without id, pwx
                                 , and Nr
                                 . Even if he/she is also a legitimate user, he/she cannot masquerade as another legitimate user without the user's password or forgery of the same messages sent to the authentication server in the mutual authentication phase.

It is a common practice for users to apply the same password to access different applications for their convenience. If a privileged inside user of a server has the knowledge of a users' password, he/she may try to impersonate the user to access other applications.
                              Proof
                              Our proposed protocol provides user registration using cipher code pwy
                                 
                                 =
                                 h(pwx
                                 
                                 ⊕
                                 Nr
                                 ) over a secret channel, which avoids the inherent risk of stolen passwords. Thus, our protocol resists insider attacks.

The proposed scheme can prevent the parallel session attack in Chen et al.'s scheme [32].
                              Proof
                              Our protocol provides the cipher message code, for instance, MA
                                 , RA
                                    ⁎
                                 , etc., which includes the timestamp, random point RA
                                 
                                 =(RA
                                    x
                                 , RA
                                    y
                                 ) ∈ EP
                                  (a, b). In other words, the parallel session attack is useless in our protocol.


                           
                              Proof
                              If the attacker wants to replay the same messages of the sender or the receiver, it is clear that user cannot succeed due to the random number MA
                                 , RA
                                    ⁎
                                  in the secret cipher that is different in each authentication session. Furthermore, the server can authenticate the validity of a user (whether RA
                                    x′
                                 ×
                                 P is equal to RA
                                    ⁎
                                 ) if the attacker replays the message to impersonate the user. That is, an attacker cannot launch replay attack due to the challenge/response mechanism. Thus, our protocol resists a replay attack.


                           
                              Proof
                              The user can securely change or update his/her password. In our scheme, the password is transformed by a one way hash digest with a random number Nr
                                 , and it is stored to the smart card. Thus, the attacker is unable to guess the password in the transmitting SIP message, in addition; he/she is also unable to gain the session key without RA
                                    x
                                  of RA
                                    x
                                 
                                 ×
                                 P and (k
                                 +
                                 RS
                                    x
                                 ) of (k
                                 +
                                 RS
                                    x
                                 )×
                                 P because of ECDLP. When a user updates or changes his/her password, the new values of BA
                                    ⁎
                                  and WA
                                    ⁎
                                  are stored on the smart card.


                           
                              Proof
                              The proposed protocol achieves mutual authentication between the user and the server. Our protocol uses the Elliptic Curve Diffie–Hellman key exchange to provide mutual authentication for the user and the server. The server can send a correct response to the client's challenge while the client can authenticate the identity of the server if RA
                                    x′
                                 ×
                                 P is equal to RA
                                    ⁎
                                 . The legitimate client can correctly replay server's challenge if the server can authenticate the client by computing k⁎
                                 
                                 =
                                 H3
                                  (Ux
                                  || RA
                                    x
                                 || RS
                                    x
                                 ′) and Mk
                                    ⁎
                                 
                                 =(k⁎
                                 
                                 +
                                 RS
                                 
                                 x′)×
                                 P and verify whether Mk
                                    ⁎
                                 
                                 =
                                 Mk
                                 . Two sides have a specific key, and they are required to provide implicit key authentication and confirmation.

Recall that the referenced protocols are [4,6,8–10,18,29,33–35]. In Table 2
                        , we compare the proposed protocol with the referenced protocols. With regard to the issues of security and communication cost, it is obvious that our scheme can resist the listed attacks and enhance the security of SIP-based service.


                        Table 2 lists the hash operation, exponentiation computation and ECC computation. We divide the ECC computation time of our scheme into three parts: the polynomial operation, scalar multiplication operation, and point addition operation. Our protocol requests only 13 hash operations and 10 ECC computations. Here, we define the notation tE
                         as the elliptic curve polynomial operation, tPM
                         as the time spent in scalar multiplication operation of elliptic curve, tPA
                         as the time spent in point addition operation of elliptic curve, th
                         as the time spent in hashing operation and tmec
                         as the exponent polynomial computation time for private key computation and public key with Diffie–Hellman's method. Obviously, tmec
                         calculates a prime exponential function, for instance, Y
                        =
                        gEN
                         mod p (where Y denotes a remainder, EN denotes a large number, p denotes a prime number as a public key and g denotes a primitive root as a public key) which is considerably higher than tE
                        , tPA
                        , and tPM
                        . We can realize that th
                        . tE
                        , tPA
                        , and t
                           PM
                         calculates a cubic equation at most and th
                         calculates a linear equation or quadratic equation at most. Besides, our proposed protocol is computed through combination of point addition and point multiplication, point multiplication is defined by repeated addition. The computation cost in our protocol definitely performs lower than Yang et al.'s, namely, 13 th
                        
                        +
                        2 tE
                        
                        +
                        6 tPM
                        
                        +
                        4 tPA
                        . Here, the cost is computed through a period of the mutual authentication phrase, and the cost of registration phrase is excluded. In addition, our protocol offers the more efficiency than DH-based protocol. Furthermore, while Tsai's protocol, which is similar to the HTTP digest authentication mechanism, performs SIP authentication using only 7th
                        , their protocol suffers from password guessing attacks and insider attacks. So Tsai's protocol is not suitable for SIP.

@&#CONCLUSIONS@&#

In this paper, we have analyzed Diffie–Hellman's concept authentication protocols for SIP. Since SIP needs more efficient methods to perform mutual authentication in an insecure network environment, for applications such as VoIP, we propose a more efficient secret authentication mechanism with ECC. The proposed protocol is more efficient than DH-based authentication and performs secured mutual authentication. To sum up, our proposed protocol inherits the merits of ECC-based mechanism, and enhances the SIP authentication with higher security than HTTP and hash-based protocols. The security of the proposed protocol in the SIP authentication scheme is strengthened.

@&#REFERENCES@&#

