@&#MAIN-TITLE@&#Designing vehicle routes for a mix of different request types, under time windows and loading constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New vehicle routing model with operational constraints.


                        
                        
                           
                           Routes satisfy a blend of plain delivery and pick-up and delivery requests.


                        
                        
                           
                           Feasible pallet packing patterns must be identified for the transported goods.


                        
                        
                           
                           Local-search framework equipped with appropriate memory components.


                        
                        
                           
                           Results are reported on new benchmark instances, derived from well-known routing problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing

Pick-up and delivery

Time windows

Pallet loading

Local search

@&#ABSTRACT@&#


               
               
                  This article introduces and solves a new rich routing problem integrated with practical operational constraints. The problem examined calls for the determination of the optimal routes for a vehicle fleet to satisfy a mix of two different request types. Firstly, vehicles must transport three-dimensional, rectangular and stackable boxes from a depot to a set of predetermined customers. In addition, vehicles must also transfer products between pairs of pick-up and delivery locations. Service of both request types is subject to hard time window constraints. In addition, feasible palletization patterns must be identified for the transported products. A practical application of the problem arises in the transportation systems of chain stores, where vehicles replenish the retail points by delivering products stored at a central depot, while they are also responsible for transferring stock between pairs of the retailer network. To solve this very complex combinatorial optimization problem, our major objective was to develop an efficient methodology whose required computational effort is kept within reasonable limits. To this end, we propose a local search-based framework for optimizing vehicle routes, in which feasible loading arrangements are identified via a simple-structured packing heuristic. The algorithmic framework is enhanced with various memory components which store and retrieve useful information gathered through the search process, in order to avoid any duplicate unnecessary calculations. The proposed solution approach is assessed on newly introduced benchmark instances.
               
            

@&#INTRODUCTION@&#

Transportation of goods and services is a crucial operational activity in the modern business environment, representing a major part of the overall running costs of a company. For this reason, great research interest has been attracted on both modeling practical transportation systems, as well as developing methodologies to generate cost-effective solutions for these models. In this context, the present article introduces and solves a new vehicle routing variant which belongs to the category of models recently referred to as rich vehicle routing problems. These models incorporate complex operational aspects which are considered essential for real-world transportation systems, however in the past were not taken into account mainly due to lack of adequate computational power (Hartl et al., 2006). Let pick-up and delivery routing problem with time windows and pallet loading (PDRP-TWP) denote the problem introduced. The PDRP-TWP model has three key features: (a) vehicles are assumed to service two distinct types of requests, namely plain delivery requests, as well as pick-up and delivery ones, (b) requests are served within hard time windows, and (c) products are considered to be transported in pallets, thus feasible pallet loading patterns must be identified.

As mentioned above, PDRP-TWP assumes that two request types are raised. The first type calls for the delivery of products from a central depot – acting as the base of a fixed size vehicle fleet – to a known in advance set of customer locations, exactly as in the case of the vehicle routing problem (VRP) (Baldacci et al., 2011a, Groër et al., 2011, Laporte, 2009). The second request type requires products to be shipped between predetermined pairs of network locations. This latter service type is closely related to the pick-up and delivery problem (PDP). Briefly, PDP assumes that a set of vehicles must satisfy a predetermined set of customer requests. Each request requires a single vehicle to load a predetermined amount of goods at one location (pick-up point) and to deliver them to its paired location (delivery point). Some of the most important studies for this category of transportation models were published by Baldacci et al. (2011b), Nanry and Barnes (2000) and Savelsbergh and Sol (1995). The interested reader may find additional information on pick-up and delivery models and relevant published methodologies in the reviews of Parragh et al. (2008) and Cordeau et al. (2008). We note that the blend of plain deliveries integrated with pick-up and delivery requests is modeled by the General Pick-Up and Delivery framework of Savelsbergh and Sol (1995). However, to our knowledge, the present article is the first to explicitly study and solve a problem with the aforementioned routing characteristics.

Apart from the routing requirements, PDRP-TWP imposes loading constraints closely related to the ones of the Pallet Packing Vehicle Routing Problem (PPVRP) presented in Zachariadis et al. (2012). More specifically, transported goods are considered to be packaged into three-dimensional, rectangle and stackable boxes. These boxes must be feasibly stacked within pallets to be loaded onto the vehicle loading spaces. Regarding previous works on routing-loading problems, the first such study is due to Iori et al. (2007). It introduces the capacitated vehicle routing problem with two-dimensional loading constraints (2L-CVRP) which calls for the determination of the optimal routes to satisfy customer demand composed by sets of two-dimensional items. These items must be feasibly placed onto the loading surface of the vehicles (Leung et al., 2012). Methodologically, the authors propose a branch-and-cut algorithm which is capable of dealing with rather small-scale problems of 30 customers and 90 transported items. To solve larger-scale 2L-CVRP instances, Gendreau et al. (2008) propose a tabu search algorithm. More recently, 2L-CVRP metaheuristic approaches have been published by Leung et al. (2011), Duhamel et al. (2011), Zachariadis et al. (2009, in press) and Fuellerer et al. (2009). Regarding routing models with two-dimensional packing constraints, Malapert et al. (2008) have introduced the pick-up and delivery extension of 2L-CVRP, called Two-dimensional Pickup and Delivery Routing Problem with Loading Constraints (2L-PDP). Gendreau et al. (2006) generalized the 2L-CVRP model by introducing the three dimensional capacitated vehicle routing problem (3L-CVRP) which assumes that customer demand is composed by three-dimensional, orthogonal and stackable boxes. The 3L-CVRP model calls for the determination of the optimal routes to satisfy customer demand. In addition, for each of the generated routes, a feasible packing arrangement of the transported boxes must be specified. The 3L-CVRP practical significance is strengthened by three operational constraints which ensure integrity of sensitive items in transit, stability of the packing arrangements and efficient unloading of delivered boxes. In methodological terms, Gendreau et al. (2006) developed a tabu-search algorithm, Tarantilis et al. (2009) proposed a local search scheme for the routing aspects and a bundle of fast packing heuristics for the packing requirements, while Fuellerer et al. (2010) published a tabu search and an Ant Colony Optimization approach. Another 3L-CVRP approach is due to Bortfeldt (2012). In terms of further routing problems with three-dimensional loading constraints, Moura and Oliveira (2009) have introduced the vehicle routing with time windows and loading problem (VRTWLP). Doerner et al. (2007) and Tricoire et al. (2011) have studied another integrated routing-packing problem referred to as the Multi-Pile vehicle routing problem (MP-VRP). Zachariadis et al. (2012) introduced the pallet packing vehicle routing problem (PPVRP). The basic difference of PPVRP compared to the above-listed models is that boxes are not directly stacked into the loading space of vehicles. Instead, they are firstly assigned and stacked in pallets which are then placed into the vehicles. In other words, for each of the generated routes, one must solve a set of packing sub-problems equal in number to the pallets transported by each vehicle. A pick-up and delivery routing problem integrated with loading constraints has been studied by Côté et al. (2012). A review article on integrated routing-packing problems has been published by Iori and Martello (2010).

From the managerial perspective, composite routing-packing models are aimed at effective decision-making for dealing with tactical dispatching problems that arise in a daily basis. This is why they have been a subject of intense research interest recently. Routing problem models integrated with explicit loading constraints improve upon traditional approaches which tackle the routing and loading sub-problems independently. These independent approaches suffer from the following drawback: vehicle routes are firstly constructed without taking into account the actual physical dimensions of the items to be shipped. Instead, at this first stage, the loading constraints are treated as one-dimensional ones with the use of empirical assumptions. When the vehicle tours have been produced, they are communicated to the warehouse, where orders are appropriately grouped and palletized. If at this second stage, no feasible loading patterns are identified, great disruption is caused. For example, the dispatcher may have to hire additional vehicles for delivering the goods which could not be loaded onto the vehicles, to redesign the produced route set, or to partially satisfy product demands. On the other hand, routing models integrated with loading constraints and relevant solution strategies overcome such risks and promote consistent and cost-effective decision-making.

The purpose of the present article is to introduce and solve the PDRP-TWP. The proposed solution approach has mainly been built to deal with this very complex combinatorial optimization problem within reasonable computational time. The routing aspects are optimized via a local search-based framework. The search process is coordinated via a diversification scheme inspired by the regional aspiration criteria of tabu search. Regarding the loading requirements, they are tackled with the use of a heuristic procedure especially designed for the examined problem. The overall algorithm is tested on various newly introduced test problems, derived from the VRPTW benchmarks of Solomon (1987).

The remainder of this article is organized as follows: Section 2 analytically describes the introduced problem, discussing several modeling and practical aspects. Section 3 presents the proposed PDRP-TWP solution approach, followed by Section 4 which introduces a collection of new PDRP-TWP benchmarks and provides the results obtained after several experimental runs of the algorithm. Finally, Section 5 concludes the paper.

Let G
                     =(V,
                     A) be a complete graph, where V
                     ={0,1,…,
                     n} is the vertex set, and A is the set of arcs (i,
                     j) connecting all vertex pairs. For each arc (i,
                     j)∈
                     A, there exists a non-negative travel time (cost) c(i,
                     j). Vertex 0 represents the central depot where a set of homogeneous vehicles K
                     ={1,…,
                     v} is available. Each vehicle k
                     ∈
                     K can carry a set of identical pallets P
                     
                        k
                     
                     ={1,…,
                     ppv} with length, width and maximum stacking height equal to L, W, and H, respectively. Let N denote the set of customer vertices (N
                     =
                     V ⧹{0}) composed of three disjoint subsets, 
                        
                           N
                           =
                           P
                           ∪
                           D
                           ∪
                           S
                        
                     . Set P
                     ={1,2,…,
                     pu} is the set of pick-up customers, D
                     ={pu
                     +1,…,2pu} represents the set of delivery customers, and S
                     ={2pu
                     +1,…,
                     s} corresponds to the set of customers which require boxes from the central depot (thereafter referred to as single customers). With each vertex i
                     ∈
                     S, is associated a set of required boxes IT
                     
                        i
                     
                     ={1,…,
                     m
                     
                        i
                     } which must be transported from the depot to the location of i. The length, width and height dimensions of a box b
                     ∈
                     IT
                     
                        i
                      are equal to l
                     
                        ib
                     , w
                     
                        ib
                      and h
                     
                        ib
                     , respectively. Regarding the pick-up and delivery requirements of PDRP-TWP, every pick-up vertex i
                     ∈
                     P is associated to the corresponding delivery vertex (pu
                     +
                     i)∈
                     D (i
                     =1,…,
                     pu), raising in total pu pick-up and delivery requests. Let j
                     
                        i
                     
                     ∈
                     D denote the delivery stop associated with each vertex i
                     ∈
                     P. PDRP-TWP considers that boxes located at i
                     ∈
                     P must be transported to customer j
                     
                        i
                     
                     ∈
                     D. These boxes are assumed to be already palletized at the location of i, so that they are directly loaded onto the vehicle loading space. Furthermore, PDRP-TWP assumes that the boxes moved between any pick-up and delivery pair (i,
                     j
                     
                        i
                     ) where i
                     ∈
                     P and j
                     
                        i
                     
                     ∈
                     D, are stacked within a single pallet. With every customer vertex i
                     ∈
                     N, is associated a service start time window [a(i),
                     b(i)]. Both vertices of a pick-up and delivery pair (i,
                     j
                     
                        i
                     ) are considered to share a common time window ([a(i),
                     b(i)]=[a(j
                     
                        i
                     ),
                     b(j
                     
                        i
                     )]), within which the intra-route pallet shipment must be performed. If a vehicle arrives at any vertex location before the corresponding time window, it must wait until the time window opening, and then initiate service. In addition, with each vertex i
                     ∈
                     N is associated a service time s
                     
                        i
                      required for performing the loading or unloading tasks. Finally, PDRP-TWP considers a depot time window [a(0),
                     b(0)] defining the earliest departure and latest arrival of vehicles from and to the depot, respectively.

The aim of the PDRP-TWP model is to generate a set of v routes (one route per vehicle) which satisfy the following requirements: (i) Each customer vertex of N is visited once by exactly one route; (ii) Each route starts and terminates at the depot; (iii) Each route starts and terminates within the depot time window; (iv) Customers are serviced within their time windows; (v) All boxes required by the set of customers which belong to S and are served by a single route must be loaded into the pallets of the vehicle traveling this route; (vi) For ease and efficiency of unloading operations, all boxes demanded by a single customer of S must be stacked within the same pallet (PDRP-TWP assumes that a pallet is always sufficient for accommodating the demand of every customer contained in S); (vii) For each pallet, there exists a feasible orthogonal three-dimensional packing pattern for all contained boxes; (viii) All boxes must be packed within the pallets with fixed vertical (h-axis) orientation, however they can be rotated 90° degrees on the plane perpendicular to the h-axis (w
                     −
                     l plane); (ix) To obtain stable packing structures, every palletized box must be fully supported either by the pallet surface or by other boxes placed below it; (x) Every pick-up and delivery pair (i,
                     j
                     
                        i
                     ), where i
                     ∈
                     P and j
                     
                        i
                     
                     ∈
                     D, is assigned to the same route. Obviously, vertex i must precede j
                     
                        i
                      within this route; (xi) To accommodate the pallet transferred between any pick-up and delivery pair (i,
                     j
                     
                        i
                     ), where i
                     ∈
                     P and j
                     
                        i
                     
                     ∈
                     D, there must be an available (empty) pallet position when the vehicle travels along the path connecting vertices i and j
                     
                        i
                     ; and (xii) The total travel time of the arcs traversed by the generated routes must be minimized.

An example feasible solution for a PDRP-TWP instance of one vehicle, four pallets per vehicle, six delivery customers and two pick-up and delivery requests is depicted in Fig. 1
                     : vehicle visits the pick-up stop 2 of the pick-up and delivery request (2,4), after having emptied pallet 1 by delivering the demanded boxes of customer 5. In addition, pallet 2 is emptied after visiting customers 7 and 9, so that the vehicle can accommodate the pick-up pallet of vertex 1. Note that the pick-up and delivery requests (1,3) and (2,4) are fulfilled by visiting the delivery stops 3 and 4 after the pick-up locations 1 and 2, respectively.

The PDRP-TWP model has important applications in the real-world business environment. The most significant of them is encountered in computer and electronic chain stores, as well as restaurant and coffee shop chains. In a daily basis, customers (retailers) raise orders to replenish their stock. To satisfy these orders, required products stored in the depot are palletized and loaded onto the vehicles to be delivered to the retailer stores. Apart from this type of service, vehicles may also transport goods directly between pairs of retailers. This additional service type may occur under the following circumstances: if insufficient stock is held in the depot, requests can only be satisfied by transferring products directly between retailer locations. In addition, unforeseen fluctuations of demand may cause some retail stores to unexpectedly run out of stock and others to have excess inventory, raising the necessity of shipping products between retailer pairs. An additional problem application arises in distribution systems consisting of two supplementary markets, namely retail stores and stock-houses. Retailers receive products exclusively from the central depot of the wholesaler (or manufacturer), whereas stock-houses are stocked directly from the retailer stores. More specifically, unsold inventory of retail stores is transferred to stock-houses to be cleared at lower prices. This transportation system is commonly operated by companies supplying goods which depreciate over time, due to varying market trends and seasonality of demand. Examples of these products include clothing, cosmetics, electronics and household appliances. As a result, the vehicle fleet must be routed both for delivering goods from the depot to the retail stores, as well for transferring products between pairs of the distribution network.

As already mentioned, PDRP-TWP can be considered as the mix of two sub-problems. The first one is related to the routing aspects of the problem and calls for the determination of the minimal cost set of routes for satisfying a predetermined customer demand, generalizing the NP-hard Capacitated VRP (Laporte, 2009). The second sub-problem is aimed at determining feasible orthogonal packing arrangements for the transported boxes into pallets. It is related to the well-known three-dimensional bin-packing problem (3BPP) (Crainic et al., 2008) which is also an NP-hard optimization problem. Therefore, PDRP-TWP constitutes a very complex problem medium- and large-scale instances of which cannot be solved by exact solution methods in tractable computational time. Thus, to effectively deal with practical sized PDRP-TWP instances, the focus of the decision-maker has to be on heuristic and metaheuristic approaches.

To solve the PDRP-TWP, we employ a local search-based strategy for dealing with the routing aspects of the problem. As far as the loading sub-problems are concerned, we make use of a simple-structured packing heuristic procedure. Several memory components are incorporated into the algorithm, to reduce the required CPU time whenever possible. The proposed methodology extends the strategy proposed for the PPVRP model (Zachariadis et al., 2012), in order to effectively deal with the additional particularities raised by the pick-up and delivery requirements. More precisely, the packing procedure for obtaining feasible packing arrangements of boxes into pallets (Section 3.1) remains unmodified, while the following algorithmic components have been extended for the pick-up and delivery requests: (a) procedure for loading investigation of complete routes (Section 3.2), (b) initial solution generation method (Section 3.3) and (c) local search method for routing optimization (Section 3.4). For completeness of presentation, we briefly describe the elements of the original PPVRP approach and emphasize on the necessary algorithmic extensions.

The method which investigates if the boxes required by a given group of single customers S
                        
                           r
                        
                        ⊆
                        S can be feasibly stacked within a pallet was mainly designed for speed, as it is repeatedly invoked by the master algorithm described in Section 3.4.3. The proposed method is inspired by the packing algorithm of Crainic et al. (2008).

Let 
                           
                              PI
                              =
                              
                                 
                                    ⋃
                                 
                                 
                                    i
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          r
                                       
                                    
                                 
                              
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                              
                           
                         be the complete set of boxes required by the customer set S
                        
                           r
                        . The method is initiated by sorting boxes of PI according to a sorting criterion (SC). Then, a list of available loading positions is generated. This list contains the coordinates of all candidate positions for placing the bottom left back corner (BLB) of a box. Initially, the only position inserted into the list is (0,0,0) corresponding to the pallet’s BLB corner. Boxes are sequentially selected from PI to be loaded into the pallet. For each selected box and for both box orientations (rotated or not), the method goes through the list of available loading positions. The position which can feasibly accommodate the box (does not cause box overlaps, or violation of pallet boundaries) is selected according to given placement criterion (PC). The box BLB corner is placed at the selected position which is removed from the list of candidates and substituted by new six loading positions which become available for accommodating subsequent PI boxes. The mechanism for updating the list of candidate positions, when a box is loaded in the pallet, is graphically depicted in Fig. 2
                        .

If, for any box, no feasible loading position is identified, the proposed method reinitializes both the available position list and the PI set. It is then reapplied using a different SC and PC combination. In total, 6 sorting (SC1-SC6) and 24 placement (PC1-PC24) criteria are employed. These criteria are reported in Table 1
                        . Their combinations define in total 144 different packing attempts. If all 144 attempts fail to produce a feasible packing arrangement, the examined box set is considered to violate the loading constraints. The method for examining the packing feasibility of the boxes required by a given customer set is presented in Pseudocode 1 which uses the notation of the verbal description of the method.

To examine the loading feasibility of a route r which is assigned to vehicle k, serves pick-up locations P
                        
                           r
                        
                        ⊆
                        P, the associated delivery locations D
                        
                           r
                        
                        ⊆
                        D, and single customers S
                        
                           r
                        
                        ⊆
                        S, a two-stage procedure is employed (Pseudocode 2). In the first stage, pick-up and delivery requests are straightforwardly assigned to the vehicle pallets. If the pallets of P
                        
                           k
                         cannot cover all pick-up and delivery requests, the route is declared infeasible. On the contrary, if every pick-up and delivery pair (every vertex contained in the sets P
                        
                           r
                         and D
                        
                           r
                        ) is assigned to some pallet, the methodology proceeds to the second stage which is aimed at packing the boxes of the remaining single customers in the available vehicle pallets.
                           Pseudocode 1
                           Palletization Feasibility Method 
                                 
                                    
                                       
                                       
                                          
                                             
                                                bool PalletizationFeasibility (List<Customer>S
                                                
                                                   r
                                                )
                                          
                                          
                                             
                                                
                                                Sorting Criteria 
                                                SC
                                                
                                                   i
                                                 (i
                                                =1,…,6)
                                          
                                          
                                             
                                                
                                                Placement Criteria 
                                                PC
                                                
                                                   j
                                                 (j
                                                =1,…,24)
                                          
                                          
                                             
                                                
                                                List <Position>posList
                                             
                                          
                                          
                                             
                                                
                                                while (i
                                                ⩽6)
                                          
                                          
                                             
                                                
                                                while (j
                                                ⩽24)
                                          
                                          
                                             
                                                
                                                
                                                List <Box> 
                                                   
                                                      PI
                                                      =
                                                      
                                                         
                                                            ⋃
                                                         
                                                         
                                                            i
                                                            ∈
                                                            
                                                               
                                                                  S
                                                               
                                                               
                                                                  r
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            IT
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                sort PI according to SC
                                                
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                posList
                                                ={(0,0,0)}
                                          
                                          
                                             
                                                
                                                
                                                for (k
                                                =1,2,…,∣PI∣)
                                          
                                          
                                             
                                                
                                                
                                                Box 
                                                b
                                                =
                                                PI
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                Position 
                                                p
                                                =feasible position for b contained in posLis according to criterion PC
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                if (no feasible position exists)
                                          
                                          
                                             
                                                
                                                
                                                
                                                break
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                place b into p
                                             
                                          
                                          
                                             
                                                
                                                update posList (as per Fig. 2)
                                          
                                          
                                             
                                                
                                                
                                                if (k
                                                ==∣PI∣)
                                          
                                          
                                             
                                                
                                                
                                                
                                                return 
                                                true
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                end while
                                             
                                          
                                          
                                             
                                                
                                                end while
                                             
                                          
                                          
                                             
                                                
                                                return 
                                                false
                                             
                                          
                                       
                                    
                                 
                              
                           

Based on the first-stage assignment (pick-up and delivery pairs to pallets), we create a compatibility matrix between the single customers of S
                        
                           r
                         and the available vehicle pallets. Obviously, the boxes of a single customer visited after a pick-up and delivery pair cannot be loaded onto the pallet reserved for accommodating the goods transported between this pick-up and delivery pair. For every pallet p
                        ∈
                        P
                        
                           k
                        , let S
                        
                           p
                        
                        ⊆
                        S
                        
                           r
                         and z
                        
                           p
                         denote the set of single customers, and the number of pick-up and delivery pairs assigned to this pallet respectively. The second stage of the method is initiated by setting U
                        =
                        S
                        
                           r
                        . Then it iteratively assigns customers of U to the set of vehicle pallets P
                        
                           k
                        . At each iteration, we identify the pallet-customer (p
                        ∗,
                        s
                        ∗) pair (p
                        ∗
                        ∈
                        P
                        
                           k
                         and s
                        ∗
                        ∈
                        U), which is compatible, all boxes of 
                           
                              
                                 
                                    ⋃
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          
                                             
                                                p
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                    ⋃
                                    {
                                    
                                       
                                          s
                                       
                                       
                                          ∗
                                       
                                    
                                    }
                                 
                              
                              
                                 
                                    IT
                                 
                                 
                                    j
                                 
                              
                           
                         can be feasibly packed in p
                        ∗ via the method of Section 3.1, and maximizes the utility function 
                           
                              u
                              (
                              p
                              ,
                              s
                              )
                              =
                              M
                              ·
                              
                                 
                                    z
                                 
                                 
                                    p
                                 
                              
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          p
                                       
                                    
                                    ⋃
                                    {
                                    s
                                    }
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    r
                                    ∈
                                    
                                       
                                          IT
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                              (
                              
                                 
                                    w
                                 
                                 
                                    jr
                                 
                              
                              ·
                              
                                 
                                    l
                                 
                                 
                                    jr
                                 
                              
                              ·
                              
                                 
                                    h
                                 
                                 
                                    jr
                                 
                              
                              )
                           
                        , where M is a very large positive number. The method assigns customer s
                        ∗ to pallet p
                        ∗ and proceeds to the next iteration by removing s
                        ∗ from the customer set U and inserting it into S
                        
                           p∗. If no such pair can be identified, the procedure is terminated by declaring route r infeasible in terms of the loading constraints. On the contrary, if all customers are successfully assigned to the vehicle pallets (U
                        =∅), route r is considered to satisfy the PDRP-TWP loading constraints.
                           Pseudocode 2
                           Route Loading Feasibility Method 
                                 
                                    
                                       
                                       
                                          
                                             
                                                bool RouteLoadingFeasibility (Route 
                                                r)
                                          
                                          
                                             
                                                
                                                Vehicle 
                                                k, List <Pallet> P
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                assign pick-up and delivery pairs (P
                                                
                                                   r
                                                 and D
                                                
                                                   r
                                                ) to the pallets of P
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                
                                                if (P
                                                
                                                   k
                                                 cannot serve all pick-up and delivery vertex pairs of P
                                                
                                                   r
                                                 and D
                                                
                                                   r
                                                )
                                          
                                          
                                             
                                                
                                                return 
                                                false
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                create compatibility matrix between the P
                                                
                                                   k
                                                 pallets and S
                                                
                                                   r
                                                 customers based on the pick-up and delivery assignment
                                          
                                          
                                             
                                                
                                                Pallet 
                                                p
                                                ∗, Customer 
                                                s
                                                ∗
                                             
                                          
                                          
                                             
                                                
                                                List <Customer> U
                                                =
                                                S
                                                
                                                   r
                                                
                                             
                                          
                                          
                                             
                                                
                                                while (U
                                                ≠∅)
                                          
                                          
                                             
                                                
                                                double 
                                                u
                                                =0, u
                                                ∗
                                                =0
                                          
                                          
                                             
                                                
                                                p
                                                ∗
                                                =null, s
                                                ∗
                                                =null
                                          
                                          
                                             
                                                
                                                for (q
                                                =1,…,∣U∣)
                                          
                                          
                                             
                                                
                                                
                                                for (r
                                                =1,…,∣P
                                                
                                                   k
                                                ∣)
                                          
                                          
                                             
                                                
                                                
                                                Customer 
                                                s
                                                =
                                                U
                                                
                                                   q
                                                , Pallet 
                                                p
                                                =
                                                P
                                                
                                                   k,r
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                if (s and p are compatible)
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      u
                                                      =
                                                      M
                                                      ·
                                                      
                                                         
                                                            z
                                                         
                                                         
                                                            p
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            j
                                                            ∈
                                                            
                                                               
                                                                  S
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ⋃
                                                            {
                                                            s
                                                            }
                                                         
                                                      
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            r
                                                            ∈
                                                            
                                                               
                                                                  IT
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            w
                                                         
                                                         
                                                            jr
                                                         
                                                      
                                                      ·
                                                      
                                                         
                                                            l
                                                         
                                                         
                                                            jr
                                                         
                                                      
                                                      ·
                                                      
                                                         
                                                            h
                                                         
                                                         
                                                            jr
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                if ((u
                                                >
                                                u
                                                ∗) AND (PalletizationFeasibility (S
                                                
                                                   p
                                                
                                                ∪{s}))==
                                                true)
                                          
                                          
                                             
                                                
                                                
                                                
                                                u
                                                ∗
                                                =
                                                u, p
                                                ∗
                                                =
                                                p, s
                                                ∗
                                                =
                                                s
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                if (p
                                                ∗
                                                ==null)
                                          
                                          
                                             
                                                
                                                
                                                return 
                                                false
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                U
                                                =
                                                U ⧹{s
                                                ∗}, S
                                                
                                                   p
                                                   ∗
                                                
                                                =
                                                S
                                                
                                                   p
                                                   ∗
                                                 ∪ {s
                                                ∗}
                                          
                                          
                                             
                                                
                                                end while
                                             
                                          
                                          
                                             
                                                
                                                return 
                                                true
                                             
                                          
                                       
                                    
                                 
                              
                           

The proposed hierarchical utility function is primarily aimed at utilizing the pallets reserved for many pick-up and delivery pairs and secondarily at maximizing the pallet volume utilization. This is because the pallets reserved for pickup and delivery pairs are compatible with only a subset of single customers, i.e. only those served before the pick-up and delivery stops. On the contrary, pallets which are not reserved by pick-up and delivery pairs are compatible with any single customer, so that their space should not be occupied by boxes of clients served early on the route. Consider for example the following case: A two-pallet (P1 and P2) vehicle visits locations A, B, C and D. Vertices A and C correspond to single customers, while B and D correspond to a pick-up and delivery pair. The required boxes of A and C have a total volume of 60% and 50% of the pallet volume, respectively. Let the pallet picked up from vertex B assigned to the position of pallet P1 (z
                        
                           P1
                        =1, z
                        
                           P2
                        =0). As a result, P1 can accommodate the boxes of A, while P2 can accommodate the boxes of both A and C. If the M
                        ·
                        z
                        
                           p
                         component was removed from the utility function, the methodology could assign A to P2. In this case, the route would be found infeasible, as C would not be able to be assigned to P1 (reserved for the pickup and delivery pair), or P2 (packing constraints). The use of the M
                        ·
                        z
                        
                           p
                         component forces the method to firstly assign A to P1, leaving P2 empty to feasibly accommodate the demand of customer C. Preliminary runs of the feasibility method evidenced that the hierarchical utility function was more effective than executions which were solely aimed at maximizing the pallet utilization space, disregarding the pick-up and delivery-pallet assignments (i.e. setting M
                        =0).

The construction method for obtaining an initial PDRP-TWP solution consists of two phases, one for routing the single customers and one for the pick-up and delivery requests. In the first phase, single customers of S (requiring boxes from the depot) are iteratively assigned to the available routes. More precisely, every member of S is inserted into the set of unserviced customers U
                        
                           S
                        . Then, customers are extracted from U
                        
                           S
                         and inserted into routes, as in the sequential heuristic I1 of Solomon (1987) for the VRPTW. Customer insertions are considered, only if they lead to routes which respect all constraints imposed by the PDRP-TWP model. The first phase terminates if every customer of U
                        
                           S
                         has been inserted into the generated route set (U
                        
                           S
                        
                        =∅), or if there is no feasible insertion position for any U
                        
                           S
                         customer, after v routes have been created. When the first phase is complete, the second phase is applied to iteratively insert the pick-up and delivery pairs into the partial feasible PDRP-TWP routes. All pick-up and delivery pairs (i,
                        j
                        
                           i
                        ), where i
                        ∈
                        P and j
                        
                           i
                        
                        ∈
                        D, are placed in the set U
                        
                           PD
                        . At each second phase iteration, the most economical feasible insertion is identified. The selected pick-up and delivery pair is removed from set U
                        
                           PD
                        , and inserted into the PDRP-TWP solution. The second phase is terminated when all pairs have been assigned to the routes available (U
                        
                           PD
                        
                        =∅), or when no feasible insertion position can be identified for any unserviced pair (U
                        
                           PD
                        
                        ≠∅). Consequently, the overall constructive method generates an initial solution which is either partial or complete and consists of feasible PDRP-TWP routes.

The proposed improvement algorithm is a local-search procedure which iteratively performs structural modifications to the candidate PDRP-TWP solution by using a blend of five local-search operators. Modifications are applied according to the best admissible strategy: at each iteration, one of the five local search operators is randomly selected. The solution neighborhood defined by the selected operator is exhaustively examined and the algorithm transits to the highest-quality solution contained in these neighborhoods. This behavior may lead to cycling phenomena which confine the conducted search in locally optimal solutions. To reduce this risk, the proposed method is equipped with a diversification mechanism based on the aspiration criteria of tabu-search implementations. The proposed solution approach makes use of several memory components for avoiding unnecessary calculations both in terms of the routing aspects and the loading constraints of the problem.

The proposed approach explores five solution neighborhood structures (NS
                           
                              i
                           ,
                           i
                           =1,…,5) defined by five local search operators. Three of them are related with the single customers (set S) and are widely used for tackling vehicle routing problems, whereas the other two have been designed for dealing with the pick-up and delivery pairs. Regarding the three classical operators for vehicle routing variants (Zachariadis and Kiranoudis, 2010), we make use of: (a) the 1–0 exchange which relocates a single customer from its current service position to a new one by replacing three solution arcs, (b) the 1–1 exchange which swaps the service positions of a pair of single customers by replacing four solution arcs, and (c) the 2-opt operator which substitutes any pair of solution arcs with a new arc pair. The aforementioned three local-search operators are used to perform both intra- and inter-route modifications.

Concerning the operators designed for the pick-up and delivery services, they are essentially an adaptation of the 1–0 exchange (customer relocation) and the 1–1 exchange (customer swap) to handle the pick-up and delivery requirements. The first operator removes a vertex pair from its current position, and reinserts it to another service position. Obviously, both vertices of the pick-up and delivery pair must be inserted in the same route, and the pick-up stop must precede the delivery one within this route. The application of a pick-up and delivery pair relocation move involves the replacement of six solution arcs, as illustrated in Fig. 3
                           a. The relocation operator may involve a single route (intra-route move) or a route pair (inter-route move), and thus can be seen as the union of the single paired insertion and within route insertion neighborhoods used by Nanry and Barnes (2000). The second move type exchanges the positions of two pick-up and delivery pairs. Specifically, it swaps the positions of the two pick-up and two delivery vertices involved in the move, by replacing eight solution arcs, as illustrated in Fig. 3b. The employed pair swap operator is inspired by the swapping pairs between routes of Nanry and Barnes (2000), extended for considering pick-up and delivery pair swaps within a single route.

As previously mentioned, the proposed methodology employs the best admissible strategy. In other words, it exhaustively examines the solution neighborhoods defined by the operators of Section 3.4.1 and selects the highest-quality neighbor solutions, even if these new solutions deteriorate the objective function value. This deterministic criterion of move selection causes cycling phenomena which confine the search around locally optimal solutions. To eliminate this behavior, the proposed algorithm makes use of the following diversification policy, based on the regional aspiration criteria used in tabu-search procedures: when a local search move m is applied to a candidate solution S of cost z(S), a set of arcs E
                           
                              m
                           
                           ⊆
                           A is eliminated from the candidate solution. With each arc a
                           ∈
                           E
                           
                              m
                           , is associated a cost tag a
                           
                              cst
                           
                           =
                           z(S). During future neighborhood evaluations, any tentative move m which transforms solution S′ into S″ by generating the arc set C
                           
                              m
                           
                           ⊆
                           A is allowed, only if a
                           
                              cst
                           
                           >
                           z(S″), ∀a
                           ∈
                           C
                           
                              m
                           . Obviously, the tabu policy is initialized by setting the cost tags of all graph arcs equal to +∞ (a
                           
                              cst
                           
                           =+∞,∀a
                           ∈
                           A).

The adopted tabu policy effectively diversifies the search. However, as the search proceeds, the diversification effect strongly outweighs the intensification potential of the method and drives the algorithm towards low-quality solution regions. Thus, to achieve an overall balanced behavior, the arc cost tags are periodically reset to +∞, every λ algorithmic iterations. We use λ
                           =
                           n/2 for which a robust behavior was observed (Section 4.3).

The proposed methodology iteratively performs local search moves to modify the structure of the candidate solution. It is initiated from the initial PDRP-TWP solution generated by the constructive heuristic of Section 3.3. Each iteration begins by randomly selecting one of the five local search operators of Section 3.4.1. Every tentative move defined by the selected operator is examined. The method identifies the move that (a) is feasible in terms of the PDRP-TWP constraints, (b) respects the tabu-based diversification scheme presented in Section 3.4.2, and (c) minimizes the PDRP-TWP objective function change. As already stated, this move can either improve or deteriorate the objective function value. The loading feasibility of tentative routes is investigated by the heuristic method described in Section 3.2, whereas the time window constraints are efficiently examined with the use of the push-forward approach of Solomon (1987). The method applies the selected local search move by modifying accordingly the candidate solution. The cost tags of the eliminated solution arcs are appropriately valued. After the move is performed, the method checks whether unrouted customers of sets U
                           
                              S
                            and U
                           
                              PD
                            (single customers and pick-up delivery pairs, respectively) can be feasibly inserted into the modified PDRP-TWP candidate solution. The method terminates after 100,000 iterations by returning the best solution encountered (Pseudocode 3). At this point, we note that if the problem instance under consideration exhibits very tight constraints, the algorithm may fail to push every U
                           
                              S
                            and U
                           
                              PD
                            vertex into the candidate solution. In this case, our method declares the problem instance infeasible by returning a null solution.
                              Pseudocode 3
                              Overall Metaheuristic Method 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   Solution method (Solution 
                                                   S
                                                   0, List <Customer> U
                                                   
                                                      PD
                                                   , List <Customer> U
                                                   
                                                      S
                                                   )
                                             
                                             
                                                
                                                   
                                                   Solution 
                                                   S
                                                   =
                                                   S
                                                   0, S
                                                   ∗
                                                   =null
                                             
                                             
                                                
                                                   
                                                   Neighborhood Structure 
                                                   NS
                                                   
                                                      i
                                                    (i
                                                   =1,…,5)
                                             
                                             
                                                
                                                   
                                                   int 
                                                   f
                                                   =0, itr
                                                   =0
                                             
                                             
                                                
                                                   
                                                   double 
                                                   λ
                                                   =
                                                   n/2
                                             
                                             
                                                
                                                   
                                                   a
                                                   
                                                      cst
                                                   
                                                   =+∞, ∀a
                                                   ∈
                                                   A
                                                
                                             
                                             
                                                
                                                   
                                                   while (itr < 100,000)
                                             
                                             
                                                
                                                   randomly select i from {1,…,5}
                                             
                                             
                                                
                                                   identify highest-quality Local Search Move 
                                                   m leading to Solution 
                                                   S′∈
                                                   NS
                                                   
                                                      i
                                                   (S) such that:
                                             
                                             
                                                
                                                   
                                                   (a)S′ is feasible in terms of the PDRP-TWP constraints
                                             
                                             
                                                
                                                   
                                                   (b)a
                                                   
                                                      cst
                                                   
                                                   >
                                                   z(S′),∀
                                                   a
                                                   ∈
                                                   C
                                                   
                                                      m
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   a
                                                   
                                                      cst
                                                   
                                                   =
                                                   z(S), ∀a
                                                   ∈
                                                   E
                                                   
                                                      m
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   S
                                                   =
                                                   S′
                                             
                                             
                                                
                                                   
                                                   if (U
                                                   
                                                      PD
                                                   
                                                   ≠∅ OR 
                                                   U
                                                   
                                                      S
                                                   
                                                   ≠∅)
                                             
                                             
                                                
                                                   
                                                   attempt to feasibly insert any unserviced customers of U
                                                   
                                                      PD
                                                    and U
                                                   
                                                      S
                                                    into the routes of S
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   if (z(S)<
                                                   z(S
                                                   ∗) AND 
                                                   U
                                                   
                                                      PD
                                                   
                                                   ==∅ AND 
                                                   U
                                                   
                                                      S
                                                   
                                                   ==∅)
                                             
                                             
                                                
                                                   
                                                   
                                                   S
                                                   ∗
                                                   =
                                                   S
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   itr
                                                   =
                                                   itr
                                                   +1, f
                                                   =
                                                   f
                                                   +1
                                             
                                             
                                                
                                                   
                                                   if (f
                                                   >
                                                   λ)
                                             
                                             
                                                
                                                   
                                                   
                                                   f
                                                   =0
                                             
                                             
                                                
                                                   
                                                   
                                                   a
                                                   
                                                      cst
                                                   
                                                   =+∞, ∀a
                                                   ∈
                                                   A
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                             
                                                
                                                   
                                                   if (U
                                                   
                                                      PD
                                                   
                                                   ≠∅ 
                                                   end while
                                                
                                             
                                             
                                                
                                                   
                                                   return null
                                             
                                             
                                                
                                                   
                                                   return 
                                                   S
                                                   ∗
                                                
                                             
                                             
                                                
                                                   
                                                   end if
                                                
                                             
                                          
                                       
                                    
                                 
                              

To accelerate the proposed method, we use several memory components for recording useful computational data obtained through the search and consequently avoid any unnecessary calculations. Two types of information are recorded: the first one refers to the objective function change of candidate local search moves, whereas the second type of information is related to the packing feasibility investigation of local search moves.

Concerning the objective function change induced by local search moves, we make use of the Static Move Descriptor concept, originally proposed in Zachariadis and Kiranoudis (2010). Under the SMD strategy, tentative local-search moves are encoded into a collection of SMD instances. Each SMD instance contains the following characteristics: (a) the type of local search operator, (b) the solution point where the encoded local search move is to be applied, and (c) the cost (objective function change) incurred when the encoded move is applied. The type of the local search operator and the solution point of an SMD instance are both independent of the shape of the candidate solution (static information). On the other hand, the SMD cost depends on the shape of the candidate solution (dynamic information). To better present the SMD strategy, we provide Fig. 4
                         which illustrates an SMD instance with the following static characteristics: it encodes a 1–1 exchange move which swaps the service positions of vertices B and F. Fig. 4 also presents the way in which the solution is modified when this SMD instance (the encoded local-search move) is applied and how this application affects its cost. Obviously, whenever the candidate solution is modified, the cost of a limited subset of the total SMD instances (tentative moves) has to be updated. More specifically, the cost of those SMD instances whose cost depends on the solution arcs affected by the move has to be recalculated according to the modified solution state. On the contrary, the cost of the rest of the local search moves remains valid under the modified solution state. For example, consider a 1–1 exchange SMD instance which encodes the position swap of vertices D and H in the example of Fig. 4. Before the move application, the cost of this SMD would be c
                        CH
                        +
                        c
                        H0
                        +
                        c
                        GD
                        +
                        c
                        D0
                        −(c
                        CD
                        +
                        c
                        D0
                        +
                        c
                        GH
                        +
                        c
                        H0). The application of the presented move (swap of vertices B and F) has no effect on the cost of the aforementioned SMD instance (swap of D and H). Thus, by using the SMD move representation which keeps track of the local-search move costs, the proposed method avoids re-evaluating local search moves which have been already evaluated at earlier search stages and as a result, drastically reduces the computational time required for examining the neighborhood structures defined by the employed local search operators.

In terms of the packing feasibility memory components, the feasibility status of tentative moves is incorporated into the corresponding SMD objects. More precisely, each SMD instance contains the feasibility status of the encoded move and the algorithmic iteration when this information was specified. When the method needs to investigate whether a local search move satisfies the loading constraints of PDRP-TWP, it checks whether the routes involved have been modified since the iteration when the relevant feasibility information was specified and recorded into the corresponding SMD instance. If the routes have remained unmodified, the method collects the feasibility status directly from the SMD instance and thus avoids the execution of the packing heuristics.

Additionally, the proposed method makes use of two hashtable structures for recording feasibility information obtained for complete routes (Section 3.2), as well as for palletizing the boxes of particular customer subsets (Section 3.1). Whenever the algorithm needs to determine the loading feasibility of either complete routes or pallets, it firstly examines whether the relevant information has been already obtained, so that it can be directly retrieved from the hashtable structures. In this way, the proposed method eliminates repetitive and unnecessary executions of the feasibility methods described in Sections 3.1 and 3.2 which strongly contribute to the total computational effort of the proposed methodology. Regarding the mechanism of storing obtained feasibility information into the hashtables, we use a straightforward approach: the subset of vertices whose feasibility has been examined is mapped into a string which contains the vertex IDs and a standard separator (i.e. ‘∗’). This string is used as the key of the hashtable entry. The value associated with each particular key is simply the feasibility status determined by the packing components of our approach. Consider for example the solution of Fig. 1. The pallet feasibility hashtable would contain the following four entries: (“5”, true), (“7∗9”, true), (“6”, true) and (“8∗10”, true), corresponding to the feasible palletization patterns determined. Similarly, the hashtable used for recording the feasibility status of complete routes would contain the following entry: (“5∗2∗7∗9∗1∗10∗4∗8∗6∗3”, true). Both hashtables have been implemented using the System.Collections.HashTable class of .NET Framework 2.0.

In this paragraph, we discuss on two PDRP-TWP model assumptions concerning the demand level of the single customers, as well as the pick-up and delivery pairs. For both types of service, the problem considers that a pallet is always sufficient for accommodating the boxes of one request. If the decision maker has to deal with PDRP-TWP instances which violate this assumption, the proposed solution approach can be executed with some modifications.

If the boxes IT
                        
                           i
                         required by any single customer (i
                        ∈
                        S) cannot be stacked within one pallet, the proposed algorithm can be initiated by applying a pre-processing method responsible for dividing the IT
                        
                           i
                         set into two disjoint subsets 
                           
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         and 
                           
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ″
                                 
                              
                           
                         
                        
                           
                              (
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              ∪
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ″
                                 
                              
                              )
                           
                        . Set 
                           
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         is considered to be assigned to a certain number of whole pallets required by customer i. The main PDRP-TWP algorithm is then executed by setting the demand of customer i equal to 
                           
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ″
                                 
                              
                           
                        . Obviously, the procedure which investigates the loading feasibility of routes (Section 3.2) is applied by reserving the number of necessary whole pallets demanded by each single customer. The aforementioned scheme for dividing the required box set into two disjoint subsets may use a simple objective such as the maximization of the utilized volume of the pallets accommodating the boxes of 
                           
                              
                                 
                                    IT
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         (Zachariadis et al., 2012). However, more elaborate approaches may have to be designed, especially when the demand of customers is composed of box sets of strongly diversified dimensions. This is due to the fact that the preprocessing method practically determines whether the required boxes of the customer 
                           
                              
                                 
                                    
                                       
                                          
                                             IT
                                          
                                          
                                             i
                                          
                                          
                                             ″
                                          
                                       
                                    
                                 
                              
                           
                         can be feasibly palletized together with boxes of other customers, when the main optimization method is executed. In other words, this preprocessing method defines the feasibility of composing customers into pallets, which in turn drastically affects the shape of the feasible solution space and as a result the routing quality of the generated solutions.

If the boxes to be transferred between any pick-up and delivery pair fit in more than one pallet, the algorithm can be executed as presented, with the route loading feasibility procedure (Section 3.2) reserving the necessary number of pallets.

To assess the effectiveness of our PDRP-TWP solution approach and provide a basis for future algorithmic comparisons, we have introduced and solved a class of new PDRP-TWP benchmark instances. Note that this is the first study to introduce the PDRP-TWP model. Consequently, there are no previously published solution values in order to directly compare the effectiveness of our algorithm to other methods in the literature. However, as the PDRP-TWP method extends the algorithm presented in Zachariadis et al. (2012) which has been tested on various routing models producing fine quality results, we can build confidence in the effectiveness and robustness of the proposed PDRP-TWP solution approach.

We have also conducted experiments for investigating the role of the proposed diversification component, the CPU time required by the proposed algorithm and the acceleration effect of the feasibility memory components. An additional run was executed for tracking the effect of the PDRP-TWP packing constraints on solution quality. Finally, to assess the algorithmic performance mainly in terms of the routing aspects of the problem, we have constructed and solved an additional class of benchmark instances with one-dimensional capacity constraints. The proposed algorithm was coded in Visual C# and executed on a single core of an 6600 (2.4GHz) processor. Benchmark instances and results are available at http://users.ntua.gr/ezach/.

To generate PDRP-TWP benchmark instances, we used the PPVRPTW test problems introduced in Zachariadis et al. (2012), which in turn were derived from the well-known C1 series of VRPTW problems introduced by Solomon (1987). Each PPVRPTW instance was converted to a PDRP-TWP one, according to the following mechanism: customer pairs were arbitrarily selected from the original PPVRPTW vertex set, to construct the PDRP-TWP pick-up and delivery customer sets P and D. The time window for both vertices of each pick-up and delivery pair (i,
                        j
                        
                           i
                        ) (i
                        ∈
                        P,
                        j
                        
                           i
                        
                        ∈
                        D), where i
                        ∈
                        P and j
                        
                           i
                        
                        ∈
                        D, was set equal to [min (a(i),
                        a(j
                        
                           i
                        )), max (b(i),
                        b(j
                        
                           i
                        ))], where [a(i),
                        b(i)] and [a(j
                        
                           i
                        ),
                        b(j
                        
                           i
                        )] represent the time windows of customers i and j
                        
                           i
                        , respectively, in the original VRPTW problem. Obviously, a PDRP-TWP instance is feasible, only if b(j
                        
                           i
                        )⩾
                        a(j
                        
                           i
                        )+
                        s
                        
                           i
                        
                        +
                        c(i,
                        j
                        
                           i
                        ), for every pick-up and delivery pair (i,
                        j
                        
                           i
                        ) (i
                        ∈
                        P, j
                        
                           i
                        
                        ∈
                        D). After pu pick-up and delivery pairs had been created, the remaining (n
                        −2pu) customers of the PPVRPTW vertex set were inserted into the PDRP-TWP single customer set S. To specify the number of vehicles (v), the algorithm was applied reducing the size of the available fleet. The value of v was set to the minimum value for which a complete PDRP-TWP solution was produced. Each vehicle is considered to carry 4 pallets with W
                        =800mm, L
                        =1200mm, whereas the maximum stacking height is H
                        =1550mm. In total, 36 PDRP-TWP test problems were generated derived from the PPVRPTW instances c101-c109 with 3, 5, 10, and 20 box types, respectively. They are presented in Table 2
                        . The instance name is followed by the number of single customers and the number of pick-up and delivery requests (s
                        −
                        pu). For each box type category, Table 2 provides the number of vehicles (v), the pallets carried by each vehicle (ppv), and the total number of boxes to be transported (#
                           
                              bx
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    ∈
                                    S
                                 
                              
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                           
                        ). In addition, we provide the loading space utilization (u) under the assumption that every pick-up and delivery pair requires a full pallet (
                           
                              u
                              =
                              (
                              pu
                              ·
                              L
                              ·
                              W
                              ·
                              H
                              +
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    ∈
                                    S
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          IT
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              (
                              
                                 
                                    l
                                 
                                 
                                    ij
                                 
                              
                              ·
                              
                                 
                                    w
                                 
                                 
                                    ij
                                 
                              
                              ·
                              
                                 
                                    h
                                 
                                 
                                    ij
                                 
                              
                              )
                              )
                              /
                              v
                              ·
                              ppv
                              ·
                              L
                              ·
                              W
                              ·
                              H
                           
                        . We also give the range of demanded boxes per customer [m
                        
                           min
                        ,
                        m
                        
                           max
                        ], where m
                        
                           min
                        
                        =
                        min
                        
                           i∈S
                        
                        m
                        
                           i
                        ,m
                        
                           max
                        
                        =
                        max
                        
                           i∈S
                         
                        m
                        
                           i
                        . To improve presentation of the instances, we provide Table 3
                         which contains the length, width and height dimensions (in mm) of the various box types.

The proposed algorithm was executed 20 times on each PDRP-TWP benchmark instance. The termination condition for each execution was the completion of 100,000 iterations. These runs did not necessarily reach to the same final solution. This is because various parameter settings and seed customers were used for the I1 insertion heuristic (Solomon, 1987) which contributes to the production of the initial solutions. In addition, as explained in Section 3.4.3, the proposed method randomly selects which of the five local search operators is performed at each algorithmic iteration. Table 4
                         summarizes the obtained results. It contains the following columns: the average solution cost of the 20 solutions generated (avg), the best objective function value obtained (bst), the average CPU time (in seconds) elapsed when the final solutions were encountered (t) and the percent deviation between the best and average solution scores (%gap
                        =100(avg-bst)/bst). As seen from the obtained results, the proposed algorithm exhibited a rather stable performance over the 20 runs. The percent deviation between the best and average objective scores achieved for each instance ranges from 0.62% up to 1.43%, averaging at a satisfactory 1.02%. In terms of the average computational time required for obtaining the final solution of each run, it varied from 3.7 to 20.1 CPU min. Taking into account the complexity of the problem and the scale of the benchmark instances, these computational times prove the efficiency of the algorithm.

One of the basic components of the proposed methodology is the diversification policy which coordinates the exploration of the search space. Recall that a cost tag is associated with each graph arc and acts as a threshold value for accepting local-search moves. These tags are reinitialized to infinity every λ algorithmic iterations, in order to promote a fair intensification-diversification interplay. To test the effectiveness of the algorithm against the value of λ, we have performed the following experimental procedure: we solve instances C101, C105 and C109 for 3, 5, 10 and 20 box types (12 instances), using λ values taken from {0,
                        n/8,
                        n/4,
                        n/2,
                        n,2n}. Setting λ
                        =0 implies that the algorithm is executed without the diversification component. The algorithm was applied 50 times on each problem instance (50,000 iterations). For each λ value, Table 5
                         contains the average solution scores (avg) and the percent deviation of each average score from the minimal average score obtained for each test instance (%gap). The %gap value is evaluated as 100(avg-min)/min, where min denotes the best average solution scores obtained among all λ values. Note that ‘–’ entries denote that the algorithm failed to produce any feasible complete solution. From Table 5, we observe that for λ
                        =
                        n/2 the algorithm obtained the best average scores for eight out of the 12 test instances, while for λ
                        =
                        n/8 and λ
                        =
                        n/4, we obtained the best scores for one and three instances, respectively. On average, the avg solution scores were 3.66%, 1.42%, 0.21%, 2.12% and 3.25% above the minimal average ones when λ was set to n/8, n/4, n/2, n and 2n, respectively. Finally, setting λ
                        =0 (i.e. executing the algorithm with no diversification component), yielded very poor results. More specifically, the method failed to produce any complete solution for 10 test cases; while for two problem instances the solutions obtained were approximately 20% worse than the minimal average scores.

To give additional information concerning the computational effort required by the proposed methodology, we have used the time-to-target (TTT) plots (Aiex et al., 2002; Aiex et al., 2007). The TTT plot analysis assumes that the CPU time required by heuristic procedures fit a two-parameter exponential distribution. Based on this assumption, for a given problem instance, TTT plots present the probability of the heuristic method to obtain a solution at least as good as a given target value versus the required CPU time. To generate a TTT plot, the algorithm is applied q times to a given benchmark instance. These q runs are considered independent, as distinct seeds are used for the algorithm’s random number generator. With each run, the required time for obtaining a solution at least as good as a target value objective is recorded. The running times are sorted in increasing order and the ith (i
                        =1,…,
                        q) sorted running time is associated to a probability value equal to p(i)=(i-1/2)/q. The TTT plot is then constructed by plotting the points (t(i),
                        p(i)), for i
                        =1,…,
                        q.

To generate TTT plots, we have applied the proposed methodology 50 times for solving instances C101, C105 and C109 for 3, 5, 10 and 20 box types (12 test instances). The target values (tv) used correspond to the avg column of Table 4. From the TTT plots (Fig. 5
                        ), we observe that for all test problems, a 2000seconds run time is enough to ensure a 80–90% probability of obtaining the target objective values. Bearing in mind the great complexity of the problem examined and that the target values are approximately 1% higher than the best solution scores identified by the proposed methodology, the required computational effort is deemed acceptable for practical decision-making purposes.

To illustrate the acceleration role of the loading feasibility memory components, we applied the solution approach to problems C101, C105 and C109 for 3, 5, 10 and 20 box types. Through iterations 49,900–50,000, the algorithm was executed under five distinct memory configurations (M1–M5): (M1) with the combined use of all memory components, (M2) with retrieving feasibility information from the SMD instances, (M3) with retrieving route feasibility information from the route hashtable, (M4) with retrieving palletization feasibility from the pallet hashtable and (M5) without using any memory component. We measured the CPU time required for the execution of the aforementioned 100-iteration interval. Note that our tests involved this rather limited number of iterations, because without using the memory components, the computational burden becomes prohibitive. Table 6
                         reports the findings of the experimental procedure. For each memory configuration, it contains the required CPU times in seconds (t), and the speed-up factors observed calculated relatively to M5 (su).

From the results presented in Table 6, we see that the pallet hashtable is the most effective in terms of accelerating the search. This is due to the fact that the pallet hashtable is the ultimate filtering mechanism for avoiding any unnecessary calls to the packing heuristic. More specifically, the use of the pallet hashtable (M4) leads to speed-up factors ranging from 73.4 to 368.1. Next, the use of the vehicle hashtable (M3) and the recording of feasibility into the SMD instances (M2) have a slighter acceleration effect with speed-up factors averaging at 8.8 and 1.4, respectively. The great importance of the memory components which practically make the algorithm applicable is evidenced by the speed-up effect of their synergetic use (M1): The search is accelerated from 104.2 to 379.8 times compared to the M5 memory configuration, while the average speed-up factor is equal to 256.7.

To quantify the impact of the packing constraints on the solution quality, we performed 20 algorithmic runs on each of the 36 PDRP-TWP instances disregarding only the packing requirements (i.e. pick-up and delivery pairs must be served by the same route, with the pick-up stop preceding the delivery one, all services must take place within the time windows). The obtained comparative results are provided in Table 7
                         which contains the following fields: the best PDRP-TWP solution cost obtained (bst), best solution cost obtained disregarding the loading constraints (bst
                        
                           TW
                        ) and the impact of the packing constraints on the solution cost (%gap
                        =100(bst
                        −
                        bst
                        
                           TW
                        )/bst). Evidently, the packing constraints have a significant impact on the solution quality, as the average gaps between the best PDRP-TWP solution scores (Table 4), and those reached by ignoring the packing requirements are equal to 8.62%, 7.51%, 10.91%, and 9.67% for the instances of 3, 5, 10, and 20 box types, respectively.

To assess the effectiveness of the proposed methodology in terms of the routing aspects of the problem, we constructed an additional class of benchmark instances. These instances impose the exact same constraints as those imposed by the PDRP-TWP model; however the loading constraints are relaxed so that a one-dimensional capacity constraint is taken into account. More specifically, with each single customer i
                        ∈
                        S is associated a demand d
                        
                           i
                         corresponding to the product units that must be transported from the depot to the location of i. In addition, for each pick-up and delivery request pair (i,
                        j
                        
                           i
                        ), where i
                        ∈
                        P and j
                        
                           i
                        
                        ∈
                        D, it is assumed that d
                        
                           ij
                         product units must be transferred from i to j. Finally, vehicles are assumed to have a maximum carrying load equal to Q. The one-dimensional capacity constraints guarantee that the fluctuating carrying load of the vehicles does not exceed Q along any arc of the generated routes.

In total, 56 problems were constructed, derived from the 100-customer VRPTW test problems of Solomon (1987). The customer sets S, P, D and the corresponding time windows were specified as per the rationale presented in Section 4.1 for the pure PDRP-TWP benchmark instances (s
                        =50,
                        pd
                        =25). In terms of the one-dimensional demand levels, with each single customer i
                        ∈
                        S, we set d
                        
                           i
                        
                        =
                        d
                        
                           i
                        ′, whereas for each pick-up and delivery request pair (i,
                        j
                        
                           i
                        ), where i
                        ∈
                        P and j
                        
                           i
                        
                        ∈
                        D, we used 
                           
                              
                                 
                                    d
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              +
                              
                                 
                                    d
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                        , where 
                           
                              
                                 
                                    d
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           
                         denotes the demand of vertex k
                        ∈
                        V in the original VRPTW instance. The size of the vehicle fleet and the maximum carrying load Q were jointly tuned to impose binding capacity constraints and ensure feasibility of the produced benchmark instances. The 56 problems generated are presented in Table 8
                         which reports the number of vehicles (v) and the total product units to be transported divided by the total capacity of the vehicle fleet (%load).

As in the case of the pure PDRP-TWP problems, the algorithm was applied 20 times on each benchmark problem. The results obtained are reported in Table 9
                         which uses the notation of Table 4. The gap between the best and average solution scores achieved for each problem ranged from 0.00% to 1.60%, averaging at 0.56%. This implies that for the one-dimensional capacity constraint configuration, the algorithm demonstrates a more stable performance compared to the three-dimensional loading constraints of the complete PDRP-TWP model, for which the respective average gap was 1.02% (Table 4). Obviously, the CPU times required for obtaining the final solution of each run were significantly lower, as the three-dimensional packing heuristic procedures which drastically contribute to the total computational effort were substituted by simple capacity feasibility checks. More specifically, the average time elapsed, when the final solutions over the 20 runs were reached, varied from 0.4 to 2.2 CPU min.

@&#CONCLUSIONS@&#

In the present paper we have introduced and solved a new rich vehicle routing problem, which belongs to the category of routing variants integrated with loading constraints. In terms of the routing aspects, the problem introduced considers that vehicles have to serve two distinct request types. The first one calls for the transportation of products from a central depot to a set of customers (delivery service), whereas the second request type assumes that products must be moved between pairs of customer locations (pick-up and delivery service). Both requests must be served within hard time windows. As far as the loading aspects are concerned, it is assumed that products are transported into pallets. Goal of the problem is to generate the optimal routes for fulfilling both request types. In addition, feasible palletization patterns for the transported products must also be specified.

In methodological terms, the proposed solution approach tackles the routing aspects of the examined problem via a local-search strategy coordinated by a diversification scheme based on the regional aspiration criteria used in tabu search methodologies. As far as the loading aspects are concerned, we employ a fast and simple-structured packing heuristic procedure for examining the loading feasibility of generated routes. The major objective of the adopted algorithmic design is to keep the required computational effort at minimum levels, in order to solve the very complex PDRP-TWP within reasonable time. Towards this direction, we employ several memory components that record useful information gathered through the search process, and thus help the method to avoid unnecessary duplicate calculations. To assess the proposed methodology, several experimental runs and tests were conducted on a series of newly-introduced benchmark instances, derived from the well-known VRPTW test problems of Solomon (1987).

@&#ACKNOWLEDGMENT@&#

The authors are indebted to the anonymous referees for extensively reviewing their paper and offering constructive remarks and directions for the completion of their work.

@&#REFERENCES@&#

