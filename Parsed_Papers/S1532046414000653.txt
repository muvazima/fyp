@&#MAIN-TITLE@&#A medical diagnostic tool based on radial basis function classifiers and evolutionary simulated annealing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a method for developing neural network classifiers for medical diagnosis.


                        
                        
                           
                           We use radial basis function networks trained with non-symmetric fuzzy means.


                        
                        
                           
                           The classifiers are optimized using evolutionary simulated annealing (ESA).


                        
                        
                           
                           ESA helps to escape from local minima and train classifiers with increased accuracy.


                        
                        
                           
                           The method is evaluated successfully on nine medical diagnostic datasets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Decision support systems

Evolutionary computation

Medical diagnosis

Neural networks

Radial basis function

Simulated annealing

@&#ABSTRACT@&#


               
               
                  Objective
                  The profusion of data accumulating in the form of medical records could be of great help for developing medical decision support systems. The objective of this paper is to present a methodology for designing data-driven medical diagnostic tools, based on neural network classifiers.
               
               
                  Methods
                  The proposed approach adopts the radial basis function (RBF) neural network architecture and the non-symmetric fuzzy means (NSFM) training algorithm, which presents certain advantages including better approximation capabilities and shorter computational times. The novelty in this work consists of adapting the NSFM algorithm to train RBF classifiers, and suitably tailoring the evolutionary simulated annealing (ESA) technique to optimize the produced RBF models. The integration of ESA is critical as it helps the optimization procedure to escape from local minima, which could arise from the application of the traditional simulated annealing algorithm, and thus discover improved solutions. The resulting method is evaluated in nine different medical benchmark datasets, where the common objective is to train a suitable classifier. The evaluation includes a comparison with two different schemes for training classifiers, including a standard RBF training technique and support vector machines (SVMs). Accuracy% and the Matthews Correlation Coefficient (MCC) are used for comparing the performance of the three classifiers.
               
               
                  Results
                  Results show that the use of ESA helps to greatly improve the performance of the NSFM algorithm and provide satisfactory classification accuracy. In almost all benchmark datasets, the best solution found by the ESA-NSFM algorithm outperforms the results produced by the SFM algorithm and SVMs, considering either the accuracy% or the MCC criterion. Furthermore, in the majority of datasets, the average solution of the ESA-NSFM population is statistically significantly higher in terms of accuracy% and MCC at the 95% confidence level, compared to the global optimum solution that its rivals could achieve. As far as computational times are concerned, the proposed approach was found to be faster compared to SVMs.
               
               
                  Conclusions
                  The results of this study suggest that the ESA-NSFM algorithm can form the basis of a generic method for knowledge extraction from data originating from different kinds of medical records. Testing the proposed approach on a number of benchmark datasets, indicates that it provides increased diagnostic accuracy in comparison with two different classifier training methods.
               
            

@&#INTRODUCTION@&#

Medical diagnosis refers to the act of identifying a disease from its signs and symptoms, or, in other words, classifying input symptoms into some known disease category. As medical diagnosis often involves a degree of uncertainty, physicians could reap the benefits of appropriate decision support systems, able to help them assess medical situations. The profusion of data accumulating in the form of medical records could be of great help for designing such systems; however, unlocking the knowledge contained in historical data is associated with a number of difficulties. The relationship between a diagnosis and the associated symptoms or clinical findings is usually rather complex and nonlinear in nature and the mechanisms that govern the operation of the human body are quite often poorly understood; these facts impede the formulation of explicit laws that could be fitted to the available data, and thus, make the extraction of knowledge from medical records rather cumbersome.

Though the aforementioned difficulties hinder the task, recent advances in machine learning and data mining methodologies are catalyzing the development of medical decision support systems. In this context, a variety of techniques have been used for building medical diagnostic tools [1], a significant portion of which involve a family of algorithms known as neural networks (NNs). NNs are a set of powerful mathematical tools [2] that simulate the way that the human brain deals with information and the procedure of learning. NNs have the ability to identify and learn highly complex and nonlinear relationships from input–output data only, without the use of first principle equations describing the system. This is accomplished by storing information in computational nodes called neurons. The development of an NN is based on a set of input–output examples, which the network learns during the training phase. In this stage, the network parameters associated with the neurons and/or the interconnection links are determined using an optimization procedure, which minimizes the errors between the true outputs and the network predictions over a set of training examples. A successfully trained NN model should be capable of producing accurate estimations given a new set of input data.

A number of publications exploiting the use of NNs for building medical diagnostic tools have appeared during the last decades. A method for using variations in electrical impedance over frequency to distinguish basal cell carcinoma from benign skin lesions based on NN classifiers is introduced in [3]. The authors in [4] present a neural network-based biomarker association information extraction approach for cancer classification. A system called GEMS (gene expression model selector) has been developed for the automated development and evaluation of high quality cancer diagnostic models, including NN methodologies [5]. Several NN-based classifier approaches have been proposed for diagnosing heart diseases [6]. Training NN classifiers for medical decision making is studied in [7], focusing on the effects of imbalanced datasets on classification performance. The important issue of feature selection in building support vector machine (SVM) classifiers for biomedical diagnostic datasets has been studied in [8]. The use of NNs for medical data classification tasks is reviewed in [9]. Other similar machine learning approaches employed for building medical diagnostic tools include Bayesian methods [10–12], fuzzy logic [13], decision trees [14] and multivariable statistical techniques [15].

Depending on the way the nodes of the network are interconnected and the calculations that each node performs, NNs are categorized to a variety of architectures. Radial basis function (RBF) networks [16] constitute a special network architecture that presents some remarkable advantages over other NN types including: (a) better approximation capabilities when performing interpolation, i.e. providing predictions in-between the training data points, (b) simpler network structures comprising a single hidden layer and (c) faster learning algorithms which are usually split into two stages [17,18]. Due to these advantages, RBF networks have been used extensively for modeling complex systems, with many successful applications in developing medical diagnostic tools [19–21]. Especially in this area, improving the accuracy of the network predictions is vital in achieving high performance diagnosis. Unfortunately, calculating optimal values for the parameters of an RBF network – as with other NN architectures – is a rather cumbersome task. When viewing the NN training procedure as an optimization problem, one realizes that the objective function usually presents some rather unwelcome properties including: (a) multimodality, possibly trapping the algorithm in a non-satisfactory local optimum, (b) non-differentiability, which impedes the use of derivative-based methods and (c) high levels of noise, typically present in the training data [17]. As these characteristics make the use of standard optimization methods inefficient, it is no surprise that interest is shifting to optimizing the RBF training procedure through the use of alternative approaches, like evolutionary-based computation techniques.

Evolutionary computation [22] refers to a family of probabilistic optimization techniques that mimic processes from natural evolution, where the main concept is the survival of the fittest. Evolutionary algorithms (EAs) form a class of generic purpose search methods, which strike a remarkable balance between exploration and exploitation—two apparently conflicting objectives in any optimization technique. There are certain differences between EAs and conventional optimization methods: EAs manipulate coded versions of the problem parameters instead of the parameters themselves; they do not use any auxiliary information about the objective function, such as derivatives; they operate in parallel on a population of solutions instead of manipulating a single solution. Hence, EAs are considered to be efficient and robust optimization methods that are able to escape from local optima. These properties have made EAs very popular in various and diverse scientific fields, including applications of medical interest [23–26]. Not surprisingly, EAs have also been used for RBF network optimization. In [27], a new algorithm is introduced for developing dynamic RBF models based on genetic algorithms. Particle swarm optimization (PSO) is another methodology drawn from the arsenal of EA methods that has been exploited in this area; a novel algorithm for training RBF regression models based on PSO is presented in [17].

The contribution of this paper lies in presenting a new methodology for building and optimizing RBF-based diagnostic tools with increased classification capabilities. The proposed approach uses the non-symmetric fuzzy means (NSFM) algorithm [28], which in this work is modified properly to train RBF classifiers. Furthermore, the evolutionary simulated annealing (ESA) [29] technique is suitably tailored and incorporated to the proposed scheme to optimize the fuzzy partition of the produced classifiers, with respect to the classifying accuracy. The resulting classification method is applied on medical diagnosis-related datasets.

The rest of this paper is organized as follows: In the next section, we describe the applied techniques, including a brief introduction to the RBF architecture and the NSFM algorithm, full presentation of the proposed approach for training RBF classifiers, and a description of the methods used for evaluation and testing. Experimental results are presented in Section 3, followed by discussion in Section 4. The paper concludes by outlining the advantages of the proposed approach and setting directions for future work.

@&#METHODS@&#


                        Fig. 1
                         depicts the typical structure of an RBF classifier, able to discern between M different classes. The input layer distributes the N input variables to the L nodes of the hidden layer. Each node in the hidden layer is associated with a center, equal in dimension with the number of input variables. Thus, the hidden layer performs a nonlinear transformation and maps the input space onto a new higher dimensional space. The activity μl
                        (u(k)) of the lth node is the Euclidean norm of the difference between the kth input vector and the node center and is given by:
                           
                              (1)
                              
                                 
                                    
                                       μ
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                                 =
                                 ‖
                                 u
                                 (
                                 k
                                 )
                                 -
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ˆ
                                          
                                       
                                    
                                    
                                       l
                                    
                                 
                                 ‖
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   u
                                                
                                                
                                                   i
                                                
                                             
                                             (
                                             k
                                             )
                                             -
                                             
                                                
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         ˆ
                                                      
                                                   
                                                
                                                
                                                   i
                                                   ,
                                                   l
                                                
                                             
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 ,
                                 
                                 k
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 K
                              
                           
                        where K is the total number of data, u
                        
                           T
                        (k)=[u
                        1(k),
                        u
                        2(k),…,
                        uN
                        (k)] is the input vector and 
                           
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    l
                                 
                                 
                                    T
                                 
                              
                              =
                              [
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    1
                                    ,
                                    l
                                 
                              
                              ,
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    2
                                    ,
                                    l
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    N
                                    ,
                                    l
                                 
                              
                              ]
                           
                         is the center of the lth node.

The activation function for each node is a radially symmetric function. This work employs the thin plate spline function:
                           
                              (2)
                              
                                 g
                                 (
                                 μ
                                 )
                                 =
                                 
                                    
                                       μ
                                    
                                    
                                       2
                                    
                                 
                                 log
                                 (
                                 μ
                                 )
                              
                           
                        
                     

Thus, the hidden node responses z(k) become:
                           
                              (3)
                              
                                 z
                                 (
                                 k
                                 )
                                 =
                                 [
                                 g
                                 (
                                 
                                    
                                       μ
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                                 )
                                 ,
                                 g
                                 (
                                 
                                    
                                       μ
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                                 )
                                 ,
                                 …
                                 ,
                                 g
                                 (
                                 
                                    
                                       μ
                                    
                                    
                                       L
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                                 )
                                 ]
                              
                           
                        
                     

The output layer of the RBF classifier consists of M summation units, where M is the number of possible output classes. The numerical output 
                           
                              
                                 
                                    
                                       
                                          y
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    m
                                 
                              
                              (
                              k
                              )
                           
                         for each summation unit is produced by a linear combination of the hidden node responses:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             y
                                          
                                          
                                             ˆ
                                          
                                       
                                    
                                    
                                       m
                                    
                                 
                                 (
                                 k
                                 )
                                 =
                                 z
                                 (
                                 k
                                 )
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       m
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          L
                                       
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       l
                                       ,
                                       m
                                    
                                 
                                 g
                                 (
                                 
                                    
                                       μ
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                                 )
                              
                           
                        where w
                        
                           m
                        
                        =[w
                        1,
                        
                           m
                        ,
                        w
                        2,
                        
                           m
                        ,…,
                        wL
                        
                        ,
                        
                           m
                        ]
                           T
                         is a vector containing the synaptic weights corresponding to output m. The classifier prediction for the output class 
                           
                              C
                              (
                              k
                              )
                           
                         corresponds to the summation unit triggering the maximum numerical output [2]:
                           
                              (5)
                              
                                 C
                                 (
                                 k
                                 )
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          m
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             y
                                          
                                          
                                             ˆ
                                          
                                       
                                    
                                    
                                       m
                                    
                                 
                                 (
                                 k
                                 )
                                 ,
                                 
                                 m
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 M
                              
                           
                        
                     

After fixing the RBF centers and nonlinearities in the hidden layer, the synaptic weights are typically calculated using linear regression of the hidden layer outputs to the real measured outputs (target values). The regression problem can be trivially solved using linear least squares in matrix form:
                           
                              (6)
                              
                                 W
                                 =
                                 
                                    
                                       (
                                       
                                          
                                             Z
                                          
                                          
                                             T
                                          
                                       
                                       ·
                                       Z
                                       )
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 ·
                                 
                                    
                                       Z
                                    
                                    
                                       T
                                    
                                 
                                 ·
                                 Y
                              
                           
                        where Z
                        =[z(1),
                        z(2),…,
                        z(K)]
                           T
                         is a matrix containing the hidden layer responses for all input vectors, W
                        =[w
                        1,
                        w
                        2,…,
                        w
                        
                           M
                        ] is a matrix containing the synaptic weights for the output layer units and Y
                        =[y(1),
                        y(2),…,
                        y(K)]
                           T
                         is a matrix containing the target vectors. Each target vector y(k) carries the information of which class the k-th input vector actual belongs to. When a target vector y(k) belongs to output class m, then all its elements yi
                        (k) are set equal to zero, except from the m-th element, which is set equal to 1:
                           
                              (7)
                              
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 k
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   i
                                                   =
                                                   m
                                                
                                             
                                             
                                                
                                                   0
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   i
                                                   
                                                   ≠
                                                   
                                                   m
                                                
                                             
                                          
                                       
                                    
                                 
                                 ,
                                 
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 M
                              
                           
                        
                     

The FM algorithm [30] is a method for selecting the hidden node centers of an RBF network. It has several advantages over the standard approaches like the k-means algorithm [31], including automatic determination of the size of the network, i.e. the number of hidden nodes, and faster computational times. The FM algorithm has been used successfully in a number of applications [32,33]. A variant of this algorithm, utilizing a non-symmetric fuzzy partition of the input space (NSFM algorithm) has been recently proposed [28]. What follows is a brief description of the main concepts behind the NSFM algorithm.

Consider a system with N normalized input variables ui
                           , where i=
                           1,…,
                           N. A non-symmetric fuzzy partition of the input space, implies that the domain of each input variable i is partitioned into a different number ci
                            of one-dimensional triangular fuzzy sets. Each fuzzy set can be written as:
                              
                                 (8)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    ,
                                    δ
                                    
                                       
                                          α
                                       
                                       
                                          i
                                       
                                    
                                    }
                                    ,
                                    
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    N
                                    ,
                                    
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    
                                       
                                          c
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           where ai
                           
                           ,
                           
                              j
                            is the center element of fuzzy set Ai
                           
                           ,
                           
                              j
                            and δ αi
                            is half of the respective width. It should be noted that the widths are different for each input direction, depending on the selected number of fuzzy sets ci
                           .

This partitioning technique creates a total of C multi-dimensional fuzzy subspaces A
                           
                              l
                           , where l=
                           1,…,
                           C:
                              
                                 (9)
                                 
                                    C
                                    =
                                    
                                       
                                          
                                             ∏
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                        

Each multi-dimensional fuzzy subspace is generated by combining N one-dimensional fuzzy sets, one for each input direction. Thus, the fuzzy subspaces can be defined using a center vector α
                           
                              l
                            and a side vector δ
                           α:
                              
                                 (10)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          l
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          α
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    δ
                                    α
                                    }
                                    =
                                    {
                                    [
                                    
                                       
                                          a
                                       
                                       
                                          1
                                          ,
                                          
                                             
                                                j
                                             
                                             
                                                1
                                             
                                          
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          2
                                          ,
                                          
                                             
                                                j
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          l
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          N
                                          ,
                                          
                                             
                                                j
                                             
                                             
                                                N
                                             
                                          
                                       
                                       
                                          l
                                       
                                    
                                    ]
                                    ,
                                    [
                                    δ
                                    
                                       
                                          α
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    δ
                                    
                                       
                                          α
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    δ
                                    
                                       
                                          α
                                       
                                       
                                          N
                                       
                                    
                                    ]
                                    }
                                    ,
                                    
                                    l
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    C
                                 
                              
                           where 
                              
                                 
                                    
                                       a
                                    
                                    
                                       i
                                       ,
                                       
                                          
                                             j
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       l
                                    
                                 
                              
                            is the center element of the one-dimensional fuzzy set 
                              
                                 
                                    
                                       A
                                    
                                    
                                       i
                                       ,
                                       
                                          
                                             j
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                            that has been assigned to input i. The produced fuzzy subspaces form a grid where each node is candidate for becoming an RBF center. An example of the non-symmetric partition is displayed in Fig. 2
                            using a two-dimensional case for visualization purposes. The domain of input variable u
                           1 is partitioned into 7 fuzzy sets, whereas the domain of u
                           2 is partitioned into 5 fuzzy sets, thus defining a total of 35 fuzzy subspaces. The grid forms 24 equal rectangles in the input space and the two edges of each rectangle are twice the widths of the respective fuzzy sets δα
                           1, δα
                           2.

The objective of the FM algorithm is to assemble the RBF network hidden layer by selecting only a small subset of the fuzzy subspaces. The number of the selected fuzzy subspaces should be kept low so as to produce a parsimonious model, but at the same time the produced RBF centers should cover sufficiently the available input data. The NSFM algorithm performs the selection based on the multidimensional membership function 
                              
                                 
                                    
                                       μ
                                    
                                    
                                       
                                          
                                             A
                                          
                                          
                                             l
                                          
                                       
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                              
                            of an input vector u(k) to a fuzzy subspace A
                           
                              l
                            
                           [34]:
                              
                                 (11)
                                 
                                    
                                       
                                          μ
                                       
                                       
                                          
                                             
                                                A
                                             
                                             
                                                l
                                             
                                          
                                       
                                    
                                    (
                                    u
                                    (
                                    k
                                    )
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      1
                                                      -
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            r
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      (
                                                      u
                                                      (
                                                      k
                                                      )
                                                      )
                                                      ,
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            r
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      (
                                                      u
                                                      (
                                                      k
                                                      )
                                                      )
                                                      ⩽
                                                      1
                                                   
                                                
                                                
                                                   
                                                      0
                                                      ,
                                                   
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    
                                       d
                                    
                                    
                                       r
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                              
                            is a function of the distance between the fuzzy subspace A
                           
                              l
                            and the input data vector u(k). The function 
                              
                                 
                                    
                                       d
                                    
                                    
                                       r
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 u
                                 (
                                 k
                                 )
                                 )
                              
                            defines a hyper-ellipse on the input space, described by the following equation:
                              
                                 (12)
                                 
                                    
                                       
                                          d
                                       
                                       
                                          r
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    u
                                    (
                                    k
                                    )
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                N
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              a
                                                                           
                                                                           
                                                                              i
                                                                              ,
                                                                              
                                                                                 
                                                                                    j
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                              
                                                                           
                                                                           
                                                                              l
                                                                           
                                                                        
                                                                        -
                                                                        
                                                                           
                                                                              u
                                                                           
                                                                           
                                                                              i
                                                                           
                                                                        
                                                                        (
                                                                        k
                                                                        )
                                                                     
                                                                  
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   N
                                                   
                                                      
                                                         (
                                                         δ
                                                         
                                                            
                                                               a
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           Fig. 2 depicts the ellipse that is formulated in the two-dimensional case.

Having defined the membership function, the algorithm proceeds with finding the subset of fuzzy subspaces that assign a nonzero multidimensional degree to all input training vectors. This is accomplished using a non-iterative algorithm which requires only one pass of the input data, thus rendering the center calculation procedure extremely fast, even in the presence of a large database of input examples. Algorithm 1, presents an overview of the NSFM algorithm.
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm 1 – NSFM Algorithm
                                          
                                       
                                       
                                          
                                             Input: {Utrain,Ytrain
                                             }: Training Dataset,
                                       
                                       
                                          
                                             
                                             
                                             
                                                
                                                   c
                                                   =
                                                   [
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  1
                                                               
                                                            
                                                            ,
                                                         
                                                         
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                            ,
                                                         
                                                         
                                                            …
                                                            ,
                                                         
                                                         
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  N
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   ]
                                                
                                             : Number of fuzzy sets
                                             
                                             for partitioning each input dimension
                                       
                                       
                                          
                                             Output: 
                                             L: Number of selected RBF centers,
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                                
                                                   
                                                      
                                                         U
                                                      
                                                      
                                                         ^
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         [
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              u
                                                                           
                                                                           
                                                                              ˆ
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                  
                                                                  ,
                                                               
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              u
                                                                           
                                                                           
                                                                              ˆ
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                                  ,
                                                               
                                                               
                                                                  …
                                                                  ,
                                                               
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              u
                                                                           
                                                                           
                                                                              ˆ
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        L
                                                                     
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                            
                                                         
                                                         ]
                                                      
                                                      
                                                         T
                                                      
                                                   
                                                
                                             : Selected RBF center
                                             
                                             
                                             locations
                                       
                                       
                                          1: Take the first data point: k
                                             ←1
                                       
                                       
                                          2: Begin calculations for the first RBF center: L
                                             ←1
                                       
                                       
                                          3: For 
                                             i
                                             =1:N 
                                             Do:
                                          
                                       
                                       
                                          4:Calculate the fuzzy set with maximum membership ineach dimension i:
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   =
                                                   {
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   δ
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   }
                                                   ←
                                                   
                                                      
                                                         
                                                            max
                                                         
                                                         
                                                            1
                                                            ⩽
                                                            j
                                                            ⩽
                                                            
                                                               
                                                                  s
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   [
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         
                                                            
                                                               A
                                                            
                                                            
                                                               i
                                                               ,
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   (
                                                   1
                                                   )
                                                   )
                                                   ]
                                                
                                             
                                          
                                       
                                       
                                          5: End For
                                          
                                       
                                       
                                          6: Generate the first RBF center 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               ˆ
                                                            
                                                         
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             : 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               ˆ
                                                            
                                                         
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   =
                                                   [
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         N
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ]
                                                
                                             
                                          
                                       
                                       
                                          7: For 
                                             k = 2:K 
                                             Do:
                                          
                                       
                                       
                                          8:
                                             If data point k lies outside the hyper-ellipses defined by the already selected centers:
                                       
                                       
                                          
                                             
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            min
                                                         
                                                         
                                                            1
                                                            ⩽
                                                            l
                                                            ⩽
                                                            L
                                                         
                                                      
                                                   
                                                   [
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         r
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                   (
                                                   u
                                                   (
                                                   k
                                                   )
                                                   )
                                                   ]
                                                   >
                                                   1
                                                   ,
                                                
                                              where 
                                                
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         r
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                
                                              is calculated by (12)
                                       
                                       
                                          9:
                                             Add a new RBF center: L
                                             ←
                                             L
                                             +1
                                       
                                       
                                          10:
                                             
                                             For 
                                             i
                                             =1:N 
                                             Do:
                                          
                                       
                                       
                                          11:
                                             
                                             Calculate the fuzzy set with maximum membership
                                             
                                             
                                             
                                             in each dimension i:
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   =
                                                   {
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ,
                                                   δ
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   }
                                                   ←
                                                   
                                                      
                                                         
                                                            max
                                                         
                                                         
                                                            1
                                                            ⩽
                                                            j
                                                            ⩽
                                                            
                                                               
                                                                  s
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   [
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         
                                                            
                                                               A
                                                            
                                                            
                                                               i
                                                               ,
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   (
                                                   k
                                                   )
                                                   )
                                                   ]
                                                
                                             
                                          
                                       
                                       
                                          12:
                                             
                                             End For
                                          
                                       
                                       
                                          13:
                                             Generate the L-th RBF center 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               ˆ
                                                            
                                                         
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                
                                             : 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               ˆ
                                                            
                                                         
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   =
                                                   [
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         N
                                                      
                                                      
                                                         L
                                                      
                                                   
                                                   ]
                                                
                                             
                                          
                                       
                                       
                                          14:
                                             End If
                                          
                                       
                                       
                                          15: End for
                                          
                                       
                                    
                                 
                              
                           
                        

Though the NSFM algorithm can lead to significant improvements in both accuracy and parsimony of the produced model, the non-symmetric partition necessitates the determination of an increased number of operational parameters, in an optimal way. For problems involving a very low number of samples and input variables, the optimal number of fuzzy sets for each variable could be calculated using an exhaustive search procedure, where all possible combinations of non-symmetric partitions are tested. Unfortunately, as the number of possible combinations increases explosively with the dimension of the input space, the excessive computational burden imposed by even slightly larger problems, makes the use of exhaustive search practically infeasible in this case. In this work, we introduce a novel method for optimizing the non-symmetric partition of the input space through the use of evolutionary simulated annealing (ESA), thus leading to a new integrated procedure for developing high accuracy RBF-based classifiers.

Simulated Annealing (SA) is a stochastic optimization technique based on the work of Metropolis [35]. The SA method parallelizes the search of the minimum energy state, which occurs during the annealing process applied in metallurgy, to the search for the minimum of a mathematical function, through an iterative procedure. The original SA algorithm operates on a single solution which is usually expressed as a vector of integer or real values. The algorithm starts with a randomly selected solution of the problem. In each iteration, a new solution is generated by applying a random change to the previous one. The new solution is evaluated using the objective function and can be accepted or deleted depending on the difference with the previous evaluation. During the first iterations even a worst solution compared to the previous one can probably be accepted; this corresponds to the random movement of molecules in high temperatures. Such degradations in the solution quality can be proven essential to avoid paths leading to local minima. As the algorithm progresses, the probability pB
                            that a worst solution will be accepted gradually becomes smaller, imitating the reduced mobility of the molecules as the temperature decreases. In fact, this probability is given by the Boltzmann–Gibbs distribution:
                              
                                 (13)
                                 
                                    
                                       
                                          p
                                       
                                       
                                          B
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      1
                                                      ,
                                                   
                                                   
                                                      if
                                                      
                                                      f
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      <
                                                      f
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                            -
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                                
                                                   
                                                      exp
                                                      
                                                         
                                                            
                                                               -
                                                               
                                                                  
                                                                     f
                                                                     (
                                                                     
                                                                        
                                                                           x
                                                                        
                                                                        
                                                                           i
                                                                        
                                                                     
                                                                     )
                                                                     -
                                                                     f
                                                                     (
                                                                     
                                                                        
                                                                           x
                                                                        
                                                                        
                                                                           i
                                                                           -
                                                                           1
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     kT
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                   
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where T is the temperature at each iteration, k is the Boltzmann constant, f is the objective function and x
                           
                              i
                           , x
                           
                              i
                           
                           −1 represent two consecutive solutions during the annealing procedure. An annealing schedule is applied, starting from an initial high temperature T
                           max and gradually decreasing until reaching the lower temperature T
                           min. The most common annealing schedule is exponential cooling, which lowers the temperature in successive discrete steps t according to the following equation:
                              
                                 (14)
                                 
                                    T
                                    (
                                    t
                                    +
                                    1
                                    )
                                    =
                                    aT
                                    (
                                    t
                                    )
                                    ,
                                    
                                    
                                    0
                                    <
                                    a
                                    <
                                    1
                                 
                              
                           where a is the exponential cooling constant

Unlike classic evolutionary techniques, e.g. genetic algorithms (GAs) or particle swarm optimization (PSO), the original SA algorithm operates on a single solution, instead of using a population of them. This is beneficial with respect to the computational burden of the algorithm, but decreases the possibility of finding a global minimum. Another difference of SA compared to the aforementioned techniques, is that though detrimental moves are allowed during the first iterations of SA, later-on the method behaves almost like a hill-climbing algorithm, accepting only an improved solution. This makes it harder to escape from local minima during the last stages of the algorithm.

To obviate these drawbacks, SA was hybridized with evolutionary techniques, thus creating the evolutionary simulated annealing algorithm (ESA) [29]. ESA starts with a population of randomly initialized solutions, coded as chromosomes. In contrast with genetic algorithms though, there are no genetic operators like crossover or mutation involved. The only operator acting on the chromosomes is in fact the SA operator. This implies that each chromosome in the current generation is used as an initial solution for performing the original SA algorithm. The terminal solution produced by SA is then compared to the initial solution and the best of the two survives for the next generation. The algorithm is repeated until a stopping condition is met. Criteria that could be used as stopping conditions for ESA include:
                              
                                 •
                                 Maximum number of generations is reached.

No improvement is accomplished in the objective function over a number of successive generations.

An acceptable solution is found.

It should be noted that the two first criteria refer to the generations corresponding to the evolutionary procedure. The iterations performed by SA are kept to a constant value selected by the user.

The ESA algorithm can be used as a search method for calculating the optimum non-symmetric partitioning given as input to the NSFM algorithm. In this case, the chromosomes that participate in the evolutionary procedure represent different ways of partitioning the input space. Applying this formulation, each chromosome c
                           
                              p
                           (q), corresponds to the number of fuzzy sets in each dimension:
                              
                                 (15)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          p
                                       
                                    
                                    (
                                    q
                                    )
                                    =
                                    
                                       
                                          [
                                          
                                             
                                                c
                                             
                                             
                                                1
                                             
                                          
                                          (
                                          q
                                          )
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          q
                                          )
                                          ,
                                          …
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                N
                                             
                                          
                                          (
                                          q
                                          )
                                          ]
                                       
                                       
                                          T
                                       
                                    
                                    ,
                                    
                                    p
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    P
                                    ,
                                    
                                    q
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    Q
                                 
                              
                           where P and Q denote the size of the population and the total number of generations, respectively. In each generation, all chromosomes in the population undergo the SA operator. The random change which is applied to the chromosomes in each SA iteration is of the form:
                              
                                 (16)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          p
                                       
                                    
                                    (
                                    q
                                    +
                                    1
                                    )
                                    =
                                    round
                                    {
                                    
                                       
                                          c
                                       
                                       
                                          p
                                       
                                    
                                    (
                                    q
                                    )
                                    +
                                    r
                                    (
                                    q
                                    )
                                    }
                                 
                              
                           where r(q) is a vector containing N random numbers drawn from a Gaussian distribution ∼N(0,
                           σ). The parameter σ defines the standard deviation of the random applied changes to the chromosomes. The round operator is used to round the chromosomes to the nearest integer, as the number of fuzzy sets in each dimension can receive only integer values.

Optimization of the non-symmetric fuzzy partitioning of the input space using ESA, forms the basis for an integrated RBF classifier training methodology. The algorithm starts by randomly dividing the available data in three datasets, namely the training, validation and testing datasets. The classifier is trained on the training dataset, while the validation dataset is used for model selection. Alternatively, model selection can be performed using a k-fold cross-validation procedure, albeit at the cost of increasing the computational burden of the algorithm. As k-fold cross-validation is by itself a computationally expensive procedure, incorporating it to an evolutionary cycle would mean repeating the RBF network training procedure many times for each chromosome and each iteration. In any case, the existence of a third independent dataset for testing the produced RBF classifier is crucial, since the optimization procedure could result in overfitting the model to the data used for validation. During the particle initialization stage, P different partitions of the input space are selected randomly, and coded as chromosomes. Each chromosome then gives birth to an RBF classifier by applying the NSFM algorithm. The latter, calculates the number and coordinates of the RBF centers based on Eq. (11). After fixing the RBF centers, the synaptic weights can be trivially calculated using Eq. (6). Based on the emerging RBF networks, a fitness value is calculated for each chromosome, by applying an error-related criterion. The proposed algorithm adopts the accuracy% criterion, defined as follows:
                              
                                 (17)
                                 
                                    Accuracy
                                    %
                                    =
                                    
                                       
                                          Total number of correctly classified data
                                       
                                       
                                          Total number of data
                                       
                                    
                                    ·
                                    100
                                 
                              
                           
                        

Alternative error functions can also be used. The next step is to create a new generation of chromosomes by applying the SA operator. SA starts with the initial chromosome and performs random changes using Eq. (16). The resulting solution can be accepted or rejected with a probability calculated by the Boltzmann–Gibbs distribution (Eq. (13)). As soon as the temperature reaches its minimum value, the SA algorithm returns the produced solution, which is compared to the initial one. The best of the two solutions is passed onto the next generation. The algorithm then returns at the RBF network generation stage, until a stopping condition has been met. The stopping condition in this case is satisfied when a maximum number of generations is reached. A schematic overview of the ESA-NSFM method is given in Fig. 3
                           , whereas the algorithm structure is presented in Algorithm 2.
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm 2 – ESA-NSFM Algorithm
                                          
                                       
                                       
                                          
                                             Input:
                                             {U
                                             train,
                                             Y
                                             train}: Training Dataset,
                                       
                                       
                                          
                                             
                                             
                                             {U
                                             val,
                                             Y
                                             val}: Validation Dataset,
                                       
                                       
                                          
                                             
                                             
                                             
                                             s
                                             min, s
                                             max, σ: Minimum and maximum number of fuzzy sets, and standard deviation of the random applied changes to the number of fuzzy sets
                                       
                                       
                                          
                                             
                                             
                                             
                                             P: Population,
                                       
                                       
                                          
                                             
                                             
                                             
                                             Tmin
                                             , Tmax
                                             , k, a: ESA operational parameters (Minimum and maximum temperatures, Boltzmann constant, and cooling constant, respectively)
                                       
                                       
                                          
                                             
                                             
                                             
                                             Q: Maximum number of generations
                                       
                                       
                                          
                                             Output:
                                             
                                             Lf
                                             : Number of selected RBF centers,
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               U
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                      
                                                      
                                                         f
                                                      
                                                   
                                                
                                             : Selected RBF center locations,
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             W
                                             
                                                f
                                             : Selected RBF synaptic weights
                                       
                                       
                                          1: For 
                                             p = 1:P 
                                             Do:
                                          
                                       
                                       
                                          2:
                                             Initialize chromosome coordinates at random integer
                                             
                                             
                                             numbers between s
                                             min and s
                                             max:
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                                
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         p
                                                      
                                                   
                                                   (
                                                   0
                                                   )
                                                   ←
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 rand,
                                                                              
                                                                              
                                                                                 rand,
                                                                              
                                                                              
                                                                                 …
                                                                                 ,
                                                                              
                                                                              
                                                                                 rand
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        ︸
                                                                     
                                                                  
                                                               
                                                               
                                                                  N
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          3:End For
                                          
                                       
                                       
                                          4:For 
                                             q = 1:Q 
                                             Do:
                                          
                                       
                                       
                                          5:
                                             
                                             For 
                                             p = 1:P 
                                             Do:
                                          
                                       
                                       
                                          6:
                                             
                                             Pass c
                                             
                                                p
                                             (q) and the training dataset {U
                                             train,
                                             Y
                                             train} to algorithm 1, in order to calculate the total number of RBF centers Li
                                             (t) and their locations 
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               ˆ
                                                            
                                                         
                                                      
                                                      
                                                         p
                                                      
                                                   
                                                   (
                                                   t
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          7:
                                             
                                             Use (5) to calculate the synaptic weights W
                                             
                                                p
                                             (q)
                                       
                                       
                                          8:
                                             
                                             Calculate fitness function f(c
                                             
                                                p
                                             (q)) on the validation dataset {U
                                             val,
                                             Y
                                             val}
                                       
                                       
                                          9:
                                             
                                             Initialize the solution c
                                             ′
                                             
                                                p
                                             (0) for the annealing process c
                                             ′
                                             
                                                p
                                             (0)←
                                             c
                                             
                                                p
                                             (q) and the annealing iterations t
                                             ←0
                                       
                                       
                                          10:
                                             
                                             While the temperature T is greater than T
                                             min 
                                             Do:
                                          
                                       
                                       
                                          11:
                                             
                                             
                                             Proceed to the next annealing iteration t
                                             ←
                                             t
                                             +1
                                       
                                       
                                          12:
                                             
                                             
                                             Calculate a new solution c
                                             ′
                                             
                                                p
                                             (t) using (16)
                                       
                                       
                                          13:
                                             
                                             
                                             
                                             If the old solution c
                                             ′
                                             
                                                p
                                             (t
                                             −1) is better than the new solution c
                                             ′
                                             
                                                p
                                             (t)
                                       
                                       
                                          14:
                                             
                                             
                                             
                                             Calculate the Boltzmann probability pB
                                              using (13)
                                       
                                       
                                          15:
                                             
                                             
                                             
                                             
                                             If a random number is greater than pB
                                             
                                          
                                       
                                       
                                          16:
                                             
                                             
                                             
                                             
                                             
                                             Substitute the old solution with the new one
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             c
                                             ′
                                             
                                                p
                                             (t)←
                                             c
                                             ′
                                             
                                                p
                                             (t
                                             −1)
                                       
                                       
                                          17:
                                             
                                             
                                             
                                             End If
                                          
                                       
                                       
                                          18:
                                             
                                             
                                             
                                             End If
                                          
                                       
                                       
                                          19:
                                             
                                             
                                             Update temperature using (14)
                                       
                                       
                                          20:
                                             
                                             End While
                                          
                                       
                                       
                                          21:
                                             
                                             If SA terminal solution c
                                             ′
                                             
                                                p
                                             (t) is better than the current generation solution c
                                             
                                                p
                                             (q)
                                       
                                       
                                          22:
                                             
                                             Substitute the current generation solution with SA terminal solution c
                                             
                                                p
                                             (q)←
                                             c
                                             ′
                                             
                                                p
                                             (t)
                                       
                                       
                                          23:
                                             
                                             End If
                                          
                                       
                                       
                                          24:
                                             End For
                                          
                                       
                                       
                                          25: End For
                                          
                                       
                                    
                                 
                              
                           
                        

To demonstrate the effectiveness of the proposed method as a diagnostic tool in medicine, the algorithm was applied on several datasets of medical interest, downloaded from the UCI Machine Learning Repository [36]. The common objective in all datasets is to predict the output class (category) based on a number of input variables (attributes), which are continuous or ordinal. Table 1
                         presents an overview of the conducted experiments, depicting the numbers of input variables, total data points, output classes, and positive cases (only for datasets with two output classes), for the tested datasets. Some datasets included examples with missing values, which, for the purposes of this study, were discarded. A brief description for each dataset is given in Appendix A, whereas additional information can be found in [36].

For each dataset, data were split randomly to training, validation and testing subsets. In general, there is no consensus in the relative literature regarding the amount of data that should be allocated to each subset. In this work, a 50%–25%–25% ratio (Training–Validation–Testing) was adopted, taking special care so as to maintain the same splitting ratio not only for the whole dataset, but also for each class individually.

As far as the operational parameter selection is concerned, it was based on theoretical aspects, as well as experimentation. Regarding the NSFM part-related parameters, the minimum and maximum number of fuzzy sets define the lower and upper bounds of the search space, respectively. Previous experiments with both symmetric and non-symmetric versions of the FM algorithm have shown that partitions outside these bounds are not likely to result to successful models. The standard deviation of applied changes σ actually defines the expected magnitude of change that will be applied to the fuzzy sets, in each iteration of the SA procedure. This parameter can be used to control the exploitation–exploration trade-off in the ESA-NSFM algorithm. Small values of σ will result to a thorough local search but poor exploration of the search space, while large values will have the opposite effect. Obviously, the choice for this parameter is closely related to the size of the search space. The latter depends on the values for s
                        min and s
                        max, which define its bounds, and on the dimensionality of the input space, which coincides with the dimensionality of the search space. As the dimensionality of the input space increases, the parameter σ should be also allowed to increase, in order to guarantee that the search space will be sufficiently explored within reasonable simulation times. In this work, two different values for σ are used, depending on the input space dimensionality of the problem. The values were selected after experimental testing, as they were found to provide a good balance between exploration and exploitation.

As far as the ESA parameters are concerned, the size of the population and the maximum number of generations are parameters that significantly affect the computational load of the algorithm. Likewise, the minimum and maximum temperatures, together with the cooling constant, actually determine the total number of iterations that will be performed by the SA operator in each generation. In this study their respective values were chosen so as to perform 500 iterations. Experiments showed that increasing these three parameters (population, number of generations and number of SA iterations), could result to improved classifier accuracy, albeit at the cost of additional computational burden. For the purposes of this study we have kept these parameters at small values, as our experiments showed that satisfactory results can be obtained in relatively fast computational times. Finally, the Boltzmann constant controls whether a worse solution compared to the current one will be accepted or rejected inside the SA loop. Choice for this parameter also affects the exploitation–exploration balance, although its effect is somewhat muffled by the evolutionary cycle which repeats the SA procedure using as an initial solution, the terminal solution of the previous SA run. Thus, a more uniform distribution of random moves is provided throughout the ESA procedure. This was also verified experimentally, as the results showed that there was small sensitivity when changing this parameter around the value of 0.05, while the results deteriorated only for significantly lower or higher values.


                        Table 2
                         presents the selected operational parameters for the ESA-NSFM algorithm. It should be noted that the results presented in the next sub-section were all derived using the same operational parameter values in all datasets, with the exception of σ. The rationale behind this choice was to highlight the generic character of the method, which can be applied in medical records of diverse nature without a tedious tuning procedure. Nevertheless, further improvements could be achieved by customizing the parameters individually for each dataset along the lines discussed in the previous paragraphs.

For comparison purposes, two additional types of classifier were also tested, namely RBF classifiers trained with the symmetric version of the FM algorithm [37] and standard SVM classifiers [38] with Gaussian kernel function [39]. In all cases, the classifier parameters were determined using the training dataset and then model selection was performed using the validation dataset, with respect to the accuracy% criterion. In the case of RBF classifiers trained with SFM, model selection was controlled by only one parameter, namely the number of fuzzy sets c for partitioning each input variable. Selection of c was made after testing all partitions from 4 to 50 fuzzy sets. The SVM classifiers with Gaussian kernel function were optimized with respect to the width of the Gaussian kernels σ and the penalty factor C. An exhaustive search procedure based on a grid search method [40] was applied, testing different combinations of σ and C. In the case of datasets with more than two output classes, a one-against-all technique was applied, as recommended by Vapnik [39].

A standard method for comparing the performance of different classifiers, which is also used in this study, is the accuracy% criterion. This metric comes as a natural choice, as it assesses the total success rate of each classifier; however there are cases where additional information from the confusion matrix is needed to fully characterize the classifier performance. A common example is the classification of data with imbalanced class distribution, where even a total failure in predicting a rare class, would have only a small impact on the total accuracy%. To overcome these weaknesses, the Matthews correlation coefficient (MCC) was introduced [41], summarizing the confusion matrix of a binary classification task into a single value. As in this work datasets with more than two classes are employed, we adopt a generalization of MCC for the multi-class case [42], which has been reported as a good generic comparison basis, among different classifier performance metrics [43]. MCC is defined as:
                           
                              (18)
                              
                                 MCC
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             ,
                                             l
                                             ,
                                             m
                                             =
                                             1
                                          
                                          
                                             M
                                          
                                       
                                       
                                          
                                             C
                                          
                                          
                                             kk
                                          
                                       
                                       
                                          
                                             C
                                          
                                          
                                             ml
                                          
                                       
                                       -
                                       
                                          
                                             C
                                          
                                          
                                             lk
                                          
                                       
                                       
                                          
                                             C
                                          
                                          
                                             km
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                
                                                   M
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            l
                                                            =
                                                            1
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            lk
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     f
                                                                     ,
                                                                     g
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     f
                                                                     ≠
                                                                     k
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            gf
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                
                                                   M
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            l
                                                            =
                                                            1
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            kl
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     f
                                                                     ,
                                                                     g
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     f
                                                                     ≠
                                                                     k
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            fg
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Cij
                         is the number of elements of true class i that have been assigned to class j by the classifier. MCC lives in the range [−11], 1 indicating perfect classification.

@&#RESULTS@&#

The results for all datasets are summarized in Tables 3 and 4
                     
                     ; Table 3 depicts the accuracy% and the MCC in the validation and testing datasets, while the optimized parameters and computational times for all three methodologies, together with the selected fuzzy partitions for the two RBF models, can be seen in Table 4. All computational times were measured on a PC with Intel Core 2 Quad processor (2.83GHz) with 4GB of RAM. All values shown in the two tables correspond to the model achieving the best result in terms of accuracy% in the validation dataset; for the ESA-NSFM algorithm, the population average and 95% confidence intervals are also given in parentheses. Fig. 4
                      presents the evolution of the accuracy% in the validation dataset for the best chromosome produced by ESA-NSFM in each case; the horizontal axis depicts the total iterations run (TIs), combining the generations of the evolutionary procedure with the iterations of SA. It should be noted that for the sake of improving clarity, each graph displays only the TIs needed for reaching for the first time the respective best solution. The computational times shown in Table 4, however, correspond to the full time needed for running all 10,000 iterations which were performed in each case.

@&#DISCUSSION@&#

Each iteration in the graphs shown in Fig. 4 actually represents the performance of NSFM on a specific fuzzy partition tested by ESA. It is obvious that the performance of NSFM varies significantly depending on the fuzzy partition, but in all tested cases, ESA eventually manages to greatly improve the performance of NSFM. It should also be noted that the ESA-NSFM classifier accuracy often remains steady for a number of iterations; this means that the algorithm is briefly trapped to a solution corresponding to a local minimum. The use of ESA helps the algorithm to escape the local minimum and discover a path that leads ultimately to an improved solution. It should be noted that the path towards the improved solution, often passes transiently through worse solutions.

A comparison between the three classifiers shows that in almost all cases the best solution found by the ESA-NSFM algorithm outperforms the SFM algorithm and the SVMs in terms of the best accuracy% calculated in both validation and testing sets. A similar result is observed when comparing the methods in terms of the MCC, as the best solution found by ESA-NSFM outperforms its rivals in 8 out of 9 datasets, taking into account the validation or testing data. As the proposed approach is a stochastic process, generating a different result for each run and each chromosome, it is also interesting to attempt a comparison using the average solution of the ESA-NSFM population, instead of the best. The proposed approach again proves to be superior in the majority of the datasets, considering either the accuracy% or the MCC criterion, even when applying the lowest bound of the 95% confidence interval as a comparison measure. The superiority of ESA-NSFM becomes more obvious, keeping in mind that the solution found by the comparison classifiers was the global optimum solution that these classifiers could achieve, as a result of the exhaustive procedure used for training them. Even though comparing the average solution of a number of runs of the proposed approach to the best possible solution found by its rivals puts ESA-NSFM at a disadvantage, the latter can still provide statistically significantly higher accuracy.

As far as speed is concerned, the ESA-NSFM algorithm requires more computational effort to arrive to completion compared to the SFM training method. This is expected due to the significant increase in the size of the search space that needs to be explored by the proposed approach. However, it is important to note that in most cases, the RBF model generated by the ESA-NSFM algorithm outperforms the final outcome of SFM in terms of accuracy%, within a few iterations. Thus, the proposed approach generates a highly accurate model within the first iterations, but further improvements are being made until completion of the algorithm. SVM training on the other hand proves to be the slowest method, as the exhaustive search procedure in this case runs concurrently for two parameters.

The total computational time needed for all classifiers is profoundly affected by the size of the dataset, defined by the numbers of training data and input variables, though the latter does not appear to have any explicit effects on their accuracy performance. The number of output classes on the other hand, affects the classifier performance; to be more specific, the prediction accuracy seems to drop as the number of output classes in the dataset increases. A good example can be drawn from the two Cardiotocography datasets, where there is a significant deviation between the performance of the classifiers for the NSP case (3 classes) and the FHR case (10 classes). This can be attributed to the fact that the classification task becomes more difficult, as the number of possible output categories increases. It is interesting to note, however, that the ESA-NSFM algorithm appears to have a slightly larger advantage over the SVM classifier in datasets with more than two output classes. A possible explanation is that SVMs are binary classifiers which need to be modified accordingly for predicting more than two output classes, in contrast to the ESA-NSFM algorithm which can inherently handle such cases.

As with all data-driven classification approaches, the presence of outliers in the training data may have a detrimental effect on the performance of the proposed classifier; therefore, it is recommended to perform data preprocessing prior to applying the method to raw medical records (e.g. see [44]). As far as the treatment of missing values is concerned, the technique used in this study, i.e. discarding the respective examples, works adequately for the particular datasets. However, it could result in problems with smaller datasets, as there may not be enough data left for successfully training the RBF network. In this case, a number of more elaborate techniques, which have been found to work well with RBF classifiers [45], could be applied in conjunction with the proposed methodology for missing value imputation. Finally, it should be noted that an increase in the number of examples and the problem dimensionality, results to higher computational times. The increase in complexity could ultimately lead to computational times that are not practically feasible. However, the performance of the proposed approach on datasets with relatively high complexity and the advantage of acquiring an adequate model within the first few iterations of the algorithm, indicate that the algorithm can handle successfully such cases.

@&#CONCLUSIONS@&#

This paper introduces a new method for training classifiers based on RBF neural networks. At the heart of the proposed approach lies the NSFM training algorithm, which has been found to produce RBF networks of increased accuracy in shorter computational times. The NSFM algorithm operates on a given non-symmetric fuzzy partition of the input space, so as to calculate the number of RBF hidden nodes and their locations and give birth to a fully trained RBF classifier. The ESA technique is then suitably modified and wrapped around the NSFM algorithm to optimize the fuzzy partition. The evolutionary nature of ESA, helps the iterative search procedure to avoid getting stuck in local minima that could result from the traditional SA algorithm, thus producing classifiers with increased accuracy. To assess the performance of the ESA-NSFM algorithm, nine datasets of medical interest are utilized. Two different types of classifiers are used for comparison purposes, namely RBF neural network classifiers trained with the SFM algorithm and standard SVM classifiers with Gaussian kernel functions. The results show that the proposed approach outperforms its rivals in terms of more accurate diagnosis, in the majority of tested cases; furthermore it proves to be faster, compared to the SVM approach.

Future research plans include exploiting the inherent potential of ESA for parallel implementation to design a distributed optimizer. This is expected to be of particular interest in the case of large databases of medical records. The authors also plan to release to the research community a distributable implementation of the ESA-NSFM algorithm.

The two cardiotocography datasets contain a number of fetal cardiotocograms (CTGs), which were automatically processed with their respective diagnostic features. The aim of the “Cardiotocography dataset FHR” is to predict the fetal heart rate (FHR) morphologic pattern (1–10), whereas the purpose of the “Cardiotocography dataset NSP” is to predict the fetal state (Normal, Suspect, Pathologic). The available features for building the classifier are common for the two datasets.

This dataset is formulated from continuous EEG measurement with the Emotiv EEG Neuroheadset. The objective is to determine the state of the eye, based on 14 different EEG features.

The scope of the Pima Indian Diabetes dataset is to build a classifier for predicting whether a patient will develop diabetes, based on clinical findings. All patients in the database were females at least 21years old of Pima Indian heritage. The dataset contains 39 instances with missing values.

The objective in this dataset is to discriminate between three possible states of the thyroid gland (euthyroidism, hyperthyroidism or hypothyroidism). Input data to the classifier include 5 different hormones that are acquired after testing blood samples from the patients.

Vertebral Column datasets are related to diagnosis of people with vertebral column disorders. The data have been organized in two different, but related classification tasks. The task in “Vertebral Column Dataset – 3 Classes” is to classify patients to one out of three categories: Normal (healthy people), Disk Hernia or Spondylolisthesis. The task in “Vertebral Column Dataset – 2 Classes” on the other hand is to discriminate healthy people (Normal category) from those who suffer from Disk Hernia or Spondylolisthesis (Abnormal category).

These datasets [46,47] involve measurements taken from digitized images of breast mass. The objective in both datasets is to diagnose breast cancer in patients, classifying tumors as benign or malignant; each dataset is based on different input variables. The WOBC dataset contains 16 instances with missing values.

@&#REFERENCES@&#

