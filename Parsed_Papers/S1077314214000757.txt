@&#MAIN-TITLE@&#On the relevance of sparsity for image classification

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We investigate the role of sparsity in unsupervised filter learning.


                        
                        
                           
                           We consider the image categorization and pixel classication tasks.


                        
                        
                           
                           We show that sparsity constraints are not needed at run-time.


                        
                        
                           
                           This significantly reduces the time required to compute an image descriptor.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Sparse representations

Image descriptors

Image categorization

Pixel classification

@&#ABSTRACT@&#


               
               
                  In this paper we empirically analyze the importance of sparsifying representations for classification purposes. We focus on those obtained by convolving images with linear filters, which can be either hand designed or learned, and perform extensive experiments on two important Computer Vision problems, image categorization and pixel classification. To this end, we adopt a simple modular architecture that encompasses many recently proposed models.
                  The key outcome of our investigations is that enforcing sparsity constraints on features extracted in a convolutional architecture does not improve classification performance, whereas it does so when redundancy is artificially introduced. This is very relevant for practical purposes, since it implies that the expensive run-time optimization required to sparsify the representation is not always justified, and therefore that computational costs can be drastically reduced.
               
            

@&#INTRODUCTION@&#

Sparse image representations are at the heart of many modern approaches to classification, such as [1–4]. Some neurophysiological evidence [5,6] supports their presence in the human visual cortex. Although this evidence is still in dispute [7], the fact that sparsity constraints can be used to derive filters exhibiting a structure very close to that of receptive fields in V1 [8,9] has played a major role in their widespread acceptance.

On a more practical note, the usefulness of sparsity for image processing purposes is widely recognized [10,11,4] along with its suitability as a regularizer for general inverse problems [12]. Part of the appeal of sparse representations is that they are believed to be easily separable in high-dimensional spaces [1,13,14]. They have also been successfully used for classification and shown to improve performance in specific cases [15].

In this paper, we will show that the reported classification performance increases [15] stem from the specific setup in which the experiments were performed and that, under different experimental conditions, they do not materialize. More specifically, we will demonstrate that in a shallow recognition architecture and when using convolutional features [16,17] that rely on the now classic functional proposed by Olshausen and Field [9], no gain arises from sparsifying the representations prior to classification. Similar or better results are obtained by directly feeding the features to a classifier. In this setup, sparsity remains key to learning effective features but becomes unnecessary at run-time. By contrast, if we replace the convolutional features by features derived from overlapping patches, which introduce additional redundancy, run-time sparsity helps as reported in [15].

This analysis validates in a systematic manner casual observations about convolutional architectures that appeared in the literature over the years [1,18]. It also has important practical consequences since eliminating the run-time sparsifying step can result in substantial computational savings and markedly increase the size of the problems that can be handled. This is because sparsifying remains computationally expensive, even though many recent efforts [19–21], driven in part by the needs of the Compressed Sensing community [22,23], have produced efficient algorithms.

In this paper we operate in the context of two key Computer Vision tasks, image categorization and pixel classification. While these two problems might seem only loosely related, state-of-the-art solutions to both involve computing image descriptors either at given locations or densely, post-processing them, and performing a final classification step.

This work extends the investigations performed in [16] by comparing our results with related studies available in literature, in particular [15]. Moreover, the inclusion of the pixel classification task in our analysis allows us to validate our claims in two different settings, thus helping us to discount domain-specific biases.

Our investigation relies on the modular classification pipeline depicted by Fig. 1
                     , which is designed to encompass representative state-of-the-art methods and to allow for comparisons. In the following section we briefly review these methods. We then describe and analyze our experiments in the fields of image categorization and pixel classification.

@&#RELATED WORK@&#

Sparsity constraints have featured many image modeling papers [13,24–27]. In fact, they pervade the modern Computer Vision and Pattern Recognition literature, where they are used both as a means to tune feature extractors to the statistics of the data, and as a feature encoding scheme. A comprehensive review of the applications of sparsity is presented in [4]. However, the authors’ claim that sparsity is helpful for classification is supported by only few experiments in a very constrained, supervised or semi-supervised setting, and not in an unsupervised one. A more systematic investigation on the different training and encoding schemes is reported in [15]. It analyzes different dictionary learning techniques and the corresponding sparsity-promoting encoders, and concludes that the main benefit of sparse coding lies in its nonlinear encoding scheme. The performance of sparse coding is, therefore, closely matched by simple soft-thresholding, except when very few training samples are used. Note that the conclusions of [15] depend on the use of overlapping patches, while we propose a scheme that can operate efficiently on whole images and avoids stitching artifacts. A similar choice has been made, independently and concurrently, by [28–31]. The use of overlapping patches introduces unwanted redundancies which, as will be discussed below, explains some of the apparent discrepancies between the outcome of the earlier study [15] and ours.

We now briefly review the relevant literature specific for the two tasks we used to investigate our claims.

Image categorization is a well-researched topic. A recent trend focuses on the analysis of modular architectures, where each component is tuned to improve the final performance [32,26,27]. In particular, the system developed by Jarrett et al. [26] shares many similarities with ours. In their work they show both the importance of using the absolute value as a nonlinear operation between the feature extraction and the pooling stages depicted by Fig. 1 and the power of stacking multiple layers. They do not, however, present an evaluation of the effects of sparsity, as they just compare filters learned under sparsity constraints with random filters.

The image categorization literature contains some works, such as [1,33], where sparse representations enforced at learning time but relaxed at test time to improve performances. None of these works, however, systematically investigates the issue. An interesting approach which avoids the sparsification costs is proposed in [29,26], where a regressor is trained to approximate the sparse code that is obtained by the optimization process, but no formal guarantees on the approximation error are given.

Tubular structures, such as blood vessels or dendritic arbors, are pervasive in biological images and their modeling is critical for analysis purposes. Automated delineation techniques are thus key to exploiting the endless streams of image data that modern imaging devices produce. Among them there is a whole class of approaches, such as [34–36], that take as input image segmentations in which pixels or voxels within linear structures are labeled as one and others as zero. The better the initial segmentation, the more effective these methods are. To generate them, most approaches start by making strong assumptions on the shape of the corresponding signal. For example, assuming the intensity profile is U-Shaped, optimal steerable filters for neurite tracing can be derived [37]. An even more widespread approach is to rely on the Hessian matrix of the image and its eigenvalues [38–41]. To detect filaments of various widths, a range of variances for the Gaussian derivative filters must be used and compared. Other models use differential kernels [42], look for parallel edges [43], or fit superellipsoids to the image [44,45]. Of particular interest is the Optimally Oriented Flux Filter (OOF) [46], obtained by convolving the second derivatives of the image with the indicator of a sphere, which is a steerable filter designed for detecting ideal sharp ridges. Compared to Hessian-based detectors, the OOF is simpler to normalize over scale and less sensitive to adjacent features of filaments. Real linear structures, however, do not necessarily conform to these ad hoc models, and this can drastically impact performance. As a result, machine learning-based approaches that can learn complex appearances are an attractive alternative. In [47], the distribution of the eigenvalues of the structure tensor are estimated via Expectation Maximization. Probabilistic Boosting Trees with sparse rotational features have also been demonstrated for vessel segmentation purposes [48]. Support Vector Machines operating on the Hessian’s eigenvalues have been used to discriminate between filament and non-filament pixels [49].

In our own earlier work [50], we compute the responses of steerable filters at every pixel and feed them to an SVM to classify pixels as filament-like or not. Because the filters are separable, they can be implemented very efficiently, which is critical when dealing with very large data volumes. However, as we will see in the result section, they are less expressive than the ones we derive here.

To properly discuss the influence of sparsity on recognition rates, we rely on the shallow modular architecture of Fig. 1, which is very similar to the ones used in recent works, such as [26,51,24,32,52]. In particular, it can be considered as the first of a sequence of layers that constitute a Deep Network architecture [53,54]. These models recently gained relevance for their effectiveness in solving multiple Computer Vision problems [55]. Understanding the behavior of a layer as we do in this paper is therefore important for these promising approaches.

In our architecture, after a pre-processing step, we extract features by using filters that are either learned or handcrafted. These dense features result from a simple convolution between the image and the filters, and their sparsified version can be obtained using a sparse optimization procedure. The usual modules of a biologically-inspired classification architecture, namely a nonlinearization and a pooling step, follow.

We perform extensive experiments on the challenging CIFAR-10 dataset [56,57], and we validate the resulting insights on the Caltech-101 dataset [58] for which a thorough analysis would be prohibitively costly. Besides illuminating the role played by sparsity in convolutional models, this methodical exploration of the architecture and parameter spaces allows us to get useful insights on the structure of an effective classification model.

We detail below the filter learning algorithms and the individual components of our framework. We introduce acronyms for these different modules, which we will use in our result tables. Finally, we describe the datasets we use and the comparative results we obtain.

Olshausen and Field [9] suggested that V1, the first layer of the visual cortex, builds a sparse image representation. Under this assumption, and the hypothesis that a perfect reconstruction is attainable, the problem one would like to solve can be stated as
                           
                              (1)
                              
                                 
                                    
                                       
                                          argmin
                                       
                                       
                                          M
                                          ,
                                          {
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       0
                                    
                                 
                                 
                                 s.t.
                                 
                                 ∀
                                 
                                 i
                                 ,
                                 
                                 
                                    
                                       Mt
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                        where 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         are training images, 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         are the corresponding feature vectors, and 
                           
                              M
                           
                         is a matrix whose columns form the dictionary. The 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    0
                                 
                              
                           
                         norm formulation in Eq. (1) is, however, non-convex, making the optimization very difficult. Even more importantly, the perfect reconstruction premise is never satisfiable with real images. The version proposed in [9] solves therefore a relaxed problem that, under certain assumptions, converges to the true solution. In particular, in many recent works such as [25,26,4], a dictionary of filters is learned by optimizing the objective function
                           
                              (2)
                              
                                 
                                    
                                       
                                          argmin
                                       
                                       
                                          M
                                          ,
                                          {
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 ‖
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       Mt
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       ‖
                                    
                                    
                                       2
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       λ
                                    
                                    
                                       learn
                                    
                                 
                                 ‖
                                 
                                    
                                       t
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       ‖
                                    
                                    
                                       1
                                    
                                 
                                 ,
                              
                           
                        where the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                         norm enforces sparsity on the 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         vectors and has other desirable properties that have been thoroughly investigated in the Compressed Sensing literature [22,23,12,20].

Solving Eq. (2) yields a dictionary 
                           
                              M
                           
                         such that the images 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         can be reconstructed from only a few columns of 
                           
                              M
                           
                         by computing the product 
                           
                              
                                 
                                    Mt
                                 
                                 
                                    i
                                 
                              
                           
                        . The sparseness in the 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         vectors is enforced by the last term. 
                           
                              
                                 
                                    λ
                                 
                                 
                                    learn
                                 
                              
                           
                         is a regularization parameter that establishes the relative importance of the reconstruction error 
                           
                              ‖
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    Mt
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                                 
                                    2
                                 
                              
                           
                         against the regularization term 
                           
                              ‖
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    1
                                 
                              
                           
                        . To prevent the algorithm from decreasing the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                         norm of the coefficients by increasing the magnitude of the filters, each column of 
                           
                              M
                           
                         is normalized at each optimization step [9]. Moreover, the dictionary is overcomplete: 
                           
                              M
                           
                         has more columns than rows, and this gives us the degrees of freedom we need to choose a representation among all the possible ones. The resulting filter bank contains many filters that differ just by a translation [59]. Note that solving Eq. (2) for large images would be slow and difficult because many coefficients in 
                           
                              M
                           
                         have to be optimized simultaneously. In earlier approaches it was therefore done only for relatively small patches. In this work, to handle whole images, we instead adopt a convolutional approach where the matrix–vector product is replaced by a convolution. We will refer to it with the acronym OLS in the remainder of the paper. An underlying assumption is that local image properties are translation invariant, which seems reasonable. As a side effect we get a strongly overcomplete representation, since all the possible translations of the non-zero components of each filter are implicitly taken into account. The optimization problem in Eq. (2) hence becomes
                           
                              (3)
                              
                                 
                                    
                                       
                                          argmin
                                       
                                       
                                          {
                                          
                                             
                                                f
                                             
                                             
                                                j
                                             
                                          
                                          }
                                          ,
                                          {
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ∗
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                2
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                λ
                                             
                                             
                                                learn
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where the 
                           
                              
                                 
                                    f
                                 
                                 
                                    j
                                 
                              
                           
                        
                        s are linear filters and 
                           
                              ∗
                           
                         denotes the convolution operator. The 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                           
                        
                        s can now be seen as a set of images with the same size as the 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         images, whose cardinality is equal to that of the filter bank. Similar intermediate representations have been called “feature maps” in the Convolutional Neural Networks literature [60]. The relationship between Eqs. (2) and (3) is readily understood by analyzing separately the two terms composing the equations: Since the convolutions in Eq. (3) are linear transformations, they could actually be written as a matrix–vector product of the form 
                           
                              
                                 
                                    Mt
                                 
                                 
                                    i
                                 
                              
                           
                        , where 
                           
                              M
                           
                         would be an extremely large matrix, and 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         a vector obtained concatenating the 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                           
                         feature maps together. The first terms of Eqs. (2) and (3) are therefore equivalent. The sum of the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                        -norm of the 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                           
                         maps is equal to the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                        -norm of the corresponding 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         vector. The second terms are therefore equivalent as well.

The optimization problem of Eq. (3) is not convex, but the two sub-problems obtained by alternatively minimizing on the filters and on the feature maps, keeping the other variables fixed, are convex [61]. We therefore optimize on the feature maps using a proximal method [19] and on the filters with Stochastic Gradient Descent [62]. Proximal methods allow to extend gradient descent techniques to some nonsmooth problems, and in the case of 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                        -norm regularization the corresponding proximal operator [19] used in the minimization is the soft-thresholding, whose expression is 
                           
                              
                                 
                                    prox
                                 
                                 
                                    λ
                                 
                              
                              (
                              x
                              )
                              =
                              sgn
                              (
                              x
                              )
                              max
                              (
                              |
                              x
                              |
                              -
                              λ
                              ,
                              0
                              )
                           
                        . The optimization on the feature maps thus reduces to performing a step in the direction opposite to the gradient of the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    2
                                 
                              
                           
                        -regularized term, followed by a component-wise soft-thresholding of the argument of the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                        -penalized term. This algorithm is also known in literature as Iterative Thresholding [63].

The resulting filter banks learned on the CIFAR-10 and on the Caltech-101 dataset are depicted by Fig. 2
                        . While there is no guarantee that the algorithm converges to a global optimum, the optimization consistently converges from random initializations for a wide range of 
                           
                              
                                 
                                    λ
                                 
                                 
                                    learn
                                 
                              
                           
                         values. Nevertheless, the algorithm exhibits a strong sensitivity to the gradient descent step size both for filters and coefficients; We manually tuned these step sizes. Each filter in a filter bank being optimized independently from the others, nothing prevents a subset of them becoming identical. However, in practice, the large variety of structures present in the used datasets partially mitigates this problem and we have observed that the presence of some replicated filters does not severely affect the performance for image categorization purposes. As we will discuss later, for pixel classification purposes replication is more of a problem and we had to devise a strategy to prevent it.

We only use grayscale images and the first pre-processing step therefore maps input color images into a grayscale representation in 
                              
                                 [
                                 -
                                 1
                                 ,
                                 1
                                 ]
                              
                           . For convolution purposes, we replicate the image borders.

To speed up convergence, we found it helpful to whiten the data. Whitening also happens in the human visual system, where it is performed by the Lateral Geniculate Nucleus [64]. As we will discuss later, we have observed that whitening plays an important role in artificial classification systems too. A whitening operator can be learned from the covariance matrix 
                              
                                 C
                              
                            of the original data [64]. By applying an eigenvalue decomposition to 
                              
                                 C
                                 ,
                                 
                                 C
                                 =
                                 
                                    
                                       EDE
                                    
                                    
                                       ⊤
                                    
                                 
                              
                           , a whitening matrix 
                              
                                 W
                              
                            can be computed as 
                              
                                 W
                                 =
                                 
                                    
                                       ED
                                    
                                    
                                       -
                                       1
                                       /
                                       2
                                    
                                 
                                 
                                    
                                       E
                                    
                                    
                                       ⊤
                                    
                                 
                              
                           .

However, as in Eq. (2), this is not really practical for large images. Fortunately, owing to the shift invariance of image statistics, 
                              
                                 W
                              
                            describes a per pixel linear operation that is independent of translation, we can therefore efficiently implement whitening as a convolution.

We evaluate different types of filter banks for feature extraction. As mentioned earlier, the abbreviations in parentheses are used to denote the different possible modules:
                              
                                 •
                                 Filter banks made of filters learned as discussed in Section 3.1 (OLS). As the learning procedure depends on several parameters, many such filter banks are possible.

The Leung–Malik (LM) filter bank [65].

A filter bank constituted by randomly generated filters (RND), with values sampled from 
                                       
                                          N
                                          (
                                          0
                                          ,
                                          1
                                          )
                                       
                                    .

These filters are used to extract features 
                              
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                              
                            from an image 
                              
                                 x
                              
                            in two different ways:
                              
                                 •
                                 Features computed by direct convolution (CONV). The 
                                       
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    s result from direct convolution with the filters, as
                                       
                                          (4)
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   j
                                                
                                             
                                             =
                                             
                                                
                                                   f
                                                
                                                
                                                   j
                                                
                                             
                                             ∗
                                             x
                                             ,
                                             
                                             ∀
                                             
                                             j
                                             .
                                          
                                       
                                    
                                 

Sparse features with Iterative Thresholding (SPARSEIT). The 
                                       
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    s, initialized by direct convolution, are then sparsified using Iterative Thresholding to solve
                                       
                                          (5)
                                          
                                             
                                                
                                                   
                                                      argmin
                                                   
                                                   
                                                      {
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      }
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         x
                                                         -
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               f
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         ∗
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                                
                                                   2
                                                
                                             
                                             +
                                             
                                                
                                                   λ
                                                
                                                
                                                   extract
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   1
                                                
                                             
                                             .
                                          
                                       
                                    
                                 

This optimization is the same as the one posed in Eq. (3) after fixing the filters 
                                       
                                          
                                             
                                                f
                                             
                                             
                                                j
                                             
                                          
                                       
                                     and considering only the given image. In this setting, the problem we are solving is convex [61], and therefore the correctness of the optimization scheme is easily verifiable. We consider a termination condition for the algorithm based on the amount of variation in the functional value between two subsequent steps.

Before the pooling stage we apply a nonlinear transformation to the feature maps 
                              
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                              
                           , as is usually done in multilayer architectures. This operation gives a new set of feature maps 
                              
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                              
                           . Again, we try different possibilities:
                              
                                 •
                                 Taking the absolute values of the coefficients of the 
                                       
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                       
                                     vectors (ABS). The mth coefficient 
                                       
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                          [
                                          m
                                          ]
                                       
                                     is simply taken to be: 
                                       
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                          [
                                          m
                                          ]
                                          =
                                          |
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                          [
                                          m
                                          ]
                                          |
                                       
                                    . This operation is identified as very effective in [26] for recognition performance despite its simplicity.

Separating the negative coefficients from the positive ones (POSNEG). The values in 
                                       
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                       
                                     are spread over 
                                       
                                          
                                             
                                                u
                                             
                                             
                                                2
                                                j
                                             
                                          
                                       
                                     and 
                                       
                                          
                                             
                                                u
                                             
                                             
                                                (
                                                2
                                                j
                                                +
                                                1
                                                )
                                             
                                          
                                       
                                     according to:
                                       
                                          (6)
                                          
                                             
                                                
                                                   u
                                                
                                                
                                                   2
                                                   j
                                                
                                             
                                             [
                                             m
                                             ]
                                             =
                                             
                                                
                                                   [
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   [
                                                   m
                                                   ]
                                                   ]
                                                
                                                
                                                   +
                                                
                                             
                                             ,
                                             
                                             
                                                
                                                   u
                                                
                                                
                                                   (
                                                   2
                                                   j
                                                   +
                                                   1
                                                   )
                                                
                                             
                                             [
                                             m
                                             ]
                                             =
                                             
                                                
                                                   [
                                                   -
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   [
                                                   m
                                                   ]
                                                   ]
                                                
                                                
                                                   +
                                                
                                             
                                             ,
                                          
                                       
                                    where 
                                       
                                          
                                             
                                                [
                                                x
                                                ]
                                             
                                             
                                                +
                                             
                                          
                                          =
                                          x
                                       
                                     if 
                                       
                                          x
                                          >
                                          0
                                       
                                     and 0 otherwise. This operation doubles the descriptor’s size.

This stage pools the coefficients of the 
                              
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                              
                            vectors to provide invariance to small displacements and distortions. Having a pooling stage is advisable for two reasons:
                              
                                 •
                                 From a biological perspective, the pooling stage corresponds to a complex cells’ layer in Hubel and Wiesel’s model of the V1 cortex [66]. The role of pooling is to enable a certain degree of invariance to minor pose and appearance changes. The importance of pooling layers is also acknowledged by their employment in Convolutional Neural Networks [60].

From a computational perspective, plain descriptors have a dimensionality which is too high for practical applications. The downsampling step is therefore vital for subsequent operations.

We test three different pooling mechanisms found in literature:
                              
                                 •
                                 Gaussian pooling (GAUSS). This is used in [67]: the 
                                       
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    s are first convolved with a Gaussian filter, then downscaled by a factor that is a multiple of 2.

Average pooling (BOXCAR). This is similar to GAUSS, except that we use a boxcar filter.

Maximum value pooling (MAX). We retain the maximum absolute value in a given neighborhood. This is used for example in [24,26], and also evaluated in [27].

The final step is to apply a classifier to the unitary normalized vectors obtained from the previous stages. We report results using two different methods
                              1
                              We have also tried other classifiers: Feed-Forward Neural Networks, ensembles of Classification Trees, and Naive Bayes classifiers. As they do not give better results than SVMs, we do not report them.
                           
                           
                              1
                           :
                              
                                 •
                                 Approximate Nearest Neighbor classification (NN). It provides a direct measure of the discriminative capabilities of the derived descriptor.

Support Vector Machines (SVM). They are commonly adopted in pipelines similar to ours and usually achieve the best results.
                                       2
                                       We performed our experiments with the LIBSVM library (http://www.csie.ntu.edu.tw/cjlin/libsvm).
                                    
                                    
                                       2
                                     In particular, we use an RBF-SVM, since theoretical results show that it is better than a sigmoid-SVM [68]. Since we explore thoroughly the parameter space, we do not need to explicitly consider a linear-SVM [69].

Logistic Regression (LOG-REG). While having generally worse performances than Support Vector Machines, it is very fast and can efficiently operate on large feature vectors; these characteristics made it suitable for our experiments with the Caltech-101 dataset. We have used the implementation provided by the authors of [26].

Solving the image categorization problem involves the derivation of a mapping from the feature space to the label space, so as to assign to a given input image the label of the corresponding category. Recent analysis demonstrated the difficulties in the choice of a dataset that truly gauges the capabilities of a classification system [70,71]. We have opted for CIFAR-10 [56,57] as our reference dataset, because it avoids the pitfalls exposed by [70], while at the same time the reduced dimensionality of its images enabled us to perform extensive experimentations. We have then validated our insights on the renowned Caltech-101 dataset [58], which is commonly adopted in other works in the field.

The CIFAR-10 dataset is composed of 
                              
                                 32
                                 ×
                                 32
                              
                            pixels images, yet it exhibits a large variability in pose, appearance, scale, and background composition, making it an ideal test case. Despite the low resolution of the input images, the feature maps after pooling 
                              
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                              
                            are very large, and therefore a dimensionality reduction step before classification is desirable. We investigate the following methods:
                              
                                 •
                                 No dimensionality reduction (NONE).

Principal Component Analysis (PCA).

Local Discriminant Embedding (LDE) [72]. We use a power regularization fixing the signal to noise ratio to 15% as was done in the original paper since it was performing well in our experiments.

Random Projections (RP). We try random projections because they can be applied to sparse signals with limited information loss. [23].

In both the PCA and the LDE case we normalize the feature maps to unit norm after the projection, as this is deemed to give significant improvements on the final result [72]. To choose the best size of the eigenspace we perform for each specific configuration an extensive cross-validation for all dimensions in a range 
                              
                                 d
                                 =
                                 {
                                 8
                                 ,
                                 10
                                 ,
                                 …
                                 ,
                                 256
                                 }
                              
                           , and we select the value that scores best in an Approximate Nearest Neighbor classification. The dimensionality of the eigenspace, as selected by the procedure above, usually ranges between 20 and 70. To perform more extensive experimentations, we first downsample the dataset to 
                              
                                 16
                                 ×
                                 16
                              
                            pixels and identify the various trade-offs and the best components of the pipeline. Once the most effective choices are determined, we validate the resulting architectures on the original 
                              
                                 32
                                 ×
                                 32
                              
                            images.

We perform additional experiments using the Caltech-101 dataset, which is widely acknowledged as a reference dataset in the Computer Vision community, and has been used in the related works [26,28]. We have adopted the same testing methodology of [26]; At first, we have learned, on the grayscale Caltech-101 images resized to 
                              
                                 151
                                 ×
                                 151
                              
                            pixels, the filter bank composed by 64 
                              
                                 9
                                 ×
                                 9
                              
                            filters depicted by Fig. 2b. We then extracted the features, eventually imposing sparsity via SPARSEIT, followed by rectification using the ABS function, and boxcar pooling with a 
                              
                                 10
                                 ×
                                 10
                              
                            filtering and a 5× downscaling. The resulting features are passed to the logistic regression classifier provided by the authors of [26], as their high-dimensionality makes them unsuitable for SVM classification. Our approach corresponds therefore to the 
                              
                                 64
                                 .
                                 
                                    
                                       F
                                    
                                    
                                       CSG
                                    
                                    
                                       9
                                       ×
                                       9
                                    
                                 
                              
                           -
                              
                                 
                                    
                                       R
                                    
                                    
                                       abs
                                    
                                 
                              
                           -
                              
                                 
                                    
                                       P
                                    
                                    
                                       A
                                    
                                 
                              
                           -log_reg architecture of [26]. Experiments have been performed with 30 training and 30 test images, with a fixed choice of the images in both sets across the different experiments.

@&#RESULTS AND DISCUSSION@&#

Our first experiment aims at evaluating the influence of the way the features are extracted on the recognition rate. Fig. 3
                        
                         reports the results of our classification pipeline for different filter banks and different feature extraction methods. For the experiment in this section we use either 49 (OLS,RND) or 48 (LM) 
                           
                              11
                              ×
                              11
                           
                         filters. The other components of the model are set to POSNEG, GAUSS, PCA, SVM, which is one of the best combinations we have found.
                           3
                           For more results, as well as for details on the parameters, please refer to the supplemental material.
                        
                        
                           3
                        
                     

As shown in Fig. 3 the key experimental result is that performing simple convolutions (CONV) at detection-time works just as well as enforcing sparsity (SPARSEIT), no matter how the filters were derived in the first place. Furthermore, imposing too much sparsity by increasing the 
                           
                              
                                 
                                    λ
                                 
                                 
                                    extract
                                 
                              
                           
                         parameter eventually results in a severe performance loss. To prevent this loss, the 
                           
                              
                                 
                                    λ
                                 
                                 
                                    extract
                                 
                              
                           
                         used for SPARSEIT must be much smaller than the 
                           
                              
                                 
                                    λ
                                 
                                 
                                    learn
                                 
                              
                           
                         used to learn the filter bank, as also noted in [33].

By contrast, enforcing sparsity at learning time is very useful, as evidenced by the fact that filters learned in this way perform better than handcrafted or random ones.

To investigate further when sparsity can be useful, we ran the same experiments on images from the CIFAR-10 dataset after corruption by noise. The most significant results are reported in Table 1
                        . We experiment with both Gaussian and structured noise, where the latter consists of randomly generated lines superimposed to the images (see Fig. 5
                        ). In all these experiments, we worked with the original 
                           
                              32
                              ×
                              32
                           
                         images of CIFAR-10, in order to avoid that the signal is prevailed by the noise. SPARSEIT performs well in presence of strong Gaussian noise, but it does not help for structured noise, as it focuses its efforts around the noisy area skipping the parts of the images that convey discriminative information. This is reasonable, as the sparse coding equations in [9] were derived under a Gaussian prior on the noise. Since the original images of the dataset are mostly noise free, the denoising capabilities of sparsity are a property unexploited when evaluating categorization algorithms on these benchmarks.

Individual choices for the different pipeline components bear a strong influence on the final outcome. In Table 2
                         the classification rates for different pooling/subspace projection methods are reported, and it can be seen that Gaussian pooling outperforms the highly acclaimed MAX pooling strategy [27]. Table 3
                         evaluates the two nonlinearities, namely POSNEG and ABS, for the different choices of the subspace projections and with both learned and handcrafted filters. POSNEG scores consistently better than ABS. In Fig. 4a, we compare the performance of handcrafted filters applied to images with and without whitening. Since the convolution operator is commutative, applying whitening to an image and then convolving it with a filter bank is equivalent to applying whitening to the filters and then convolving them with the original image. From the graph it can be deduced that there is a huge gap, more than 
                           
                              10
                              %
                           
                        , between the two results. The performance of the Leung–Malik filter bank without whitening is below that of random filters with whitening. These structural insights have been confirmed in two recent papers, namely Coates et al. [52] for what concerns the importance of the architecture and of the whitening step, and Saxe et al. [73] for the amazing performance of random filters.

In all of our experiments and irrespective of the chosen feature extraction and pooling strategies the results after pooling are dense, as shown in Fig. 4b for Gaussian pooling. We have observed a similar behavior with MAX pooling, despite its alleged sparsity-preserving properties. This suggests that, in architectures that employ pooling stages, sparsity is a temporary condition only.

Despite its simplicity, our best architecture performs well on the CIFAR-10 dataset, yielding a 
                           
                              75.18
                              %
                           
                         classification rate (average over 5 random dataset splits, with standard deviation 
                           
                              0.27
                              %
                           
                        ) by using grayscale images only, whereas competing methods also use color information. On the Caltech-101 dataset, however, the performance are well below the state-of-the-art results of [74], which achieves an exceptional 
                           
                              84.3
                              %
                           
                        . Nonetheless, the architecture we propose is not aimed at achieving high classification scores by exploiting, for instance, prior knowledge about the image content, but at studying systematically a property of feature descriptors. Similar architectures that were developed with the same goal in mind, such as that of [26], achieve comparable classification rates.

Traditional, sparsity-based image categorization architectures operate on small overlapping image patches extracted on a regular grid. This is mostly an heritage of the original optimization scheme for obtaining sparse representations proposed by Olshausen and Field [9]. Recently, this approach has been subject to an accurate analysis where different training and encoding schemes have been chained and the resulting combinations evaluated in terms of their recognition capabilities [15].

At first sight, its conclusions appear to contradict ours. In particular, while soft-thresholding performs comparably with sparse coding most of the times, some form of sparsification in the encoding is always required to achieve good performance. Also, using an architecture strongly resembling ours but using just a linear SVM classifier, they obtain a classification rate of over 
                           
                              80
                              %
                           
                         on the CIFAR-10 dataset.

Starting with the publicly available source code, we first validated these insights by observing that, with default parameters – 1600 filters with size 
                           
                              6
                              ×
                              6
                           
                        , linear SVM classifier – setting to zero the threshold parameter 
                           
                              α
                           
                         in the soft-thresholding encoding, which corresponds to CONV-POSNEG in our architecture, negatively affects the performances, moving from 
                           
                              78.18
                              %
                           
                         when 
                           
                              α
                              =
                              0.25
                           
                         to 
                           
                              75.80
                              %
                           
                         when 
                           
                              α
                              =
                              0
                           
                        . We then investigated the apparent discrepancy between our findings.

An obvious difference is that we operate on grayscale images instead of color ones. While color information is mostly redundant, it still has an impact on the classification rate. Simply converting the images to grayscale makes the results drop from 
                           
                              78.18
                              %
                           
                         to 
                           
                              74.08
                              %
                           
                        . Please note that the same reasoning applies in the comparison between our architecture and other color-based machine learning architectures which have been specifically tuned to operate on the CIFAR-10 dataset, such as the factorized third-order Boltzmann Machine proposed in [75] or the improved version of the 2009 PASCAL image classification challenge winning system presented in [76].

A more subtle difference concerns the feature extraction process. In [15] filters are applied on patches extracted on a regular grid with a stride of one, while we apply our filters convolutionally. In a convolutional architecture all the extracted coefficients contribute to the reconstruction of the input image, and the learned filters account for this. The resulting redundancy is therefore lower compared to using overlapping patches [29], as altering even a single coefficient stymies the final image reconstruction. An approach which exhibits the same characteristics but in a patch-wise setting has to constrain the patches to be non-overlapping.

To verify how the extraction procedure affects the final score, we have analyzed the classification rate for different degrees of sparsity imposed by soft-thresholding the coefficients computed on both overlapping and distinct patches. We have then compared these results with those obtained by plugging the feature maps computed by the extraction step of our convolutional architecture in the same code. The results are reported in Table 4
                        .

As can be observed, the basic architecture of [15] benefits from a soft-thresholding of its features when the source image patches are extracted in an overlapping way (Table 4a. This is also true when the patches are distinct, but color information is used (Table 4b. Note that the number of filters in the color case has been divided by three, to account for the difference in size of the descriptors compared with the grayscale case. However, when either grayscale non-overlapping patches, convolutional extraction, or very few filters are considered (Table 4b–e), sparsely-encoded features do not perform better than non-thresholded ones. When just 500 training samples per category are considered (Table 4f), if the same number of filters as in Table 4b is considered, sparse encoding is again relevant. The same applies when fewer filters are used.

These results suggest that, when redundant information is introduced in the feature extraction step, an encoding which removes feeble components and therefore promotes sparsity has to be preferred. However, when this redundancy is absent, experimental results do not support the sparsification. Moreover, by comparing the results in Table 4c and d, for a given number of filters and total operations, convolutional feature extraction appears to perform better than schemes based on overlapping patches, at least when linear SVMs — which give a significantly better result than Nearest Neighbor classification — are used as classifiers. Finally, a feature extraction scheme based overlapping patches scores much better than one based on distinct patches for a fixed descriptor size.

Starting with [77], pixel classification has become a popular way to address the image segmentation problem. A particular case of segmentation is represented by the extraction of extended linear structures, such as those present in the images of Fig. 6
                     . In this case the image is not subdivided into regions, but the elements of interest are enhanced with respect to a background. It is therefore natural to interpret each pixel as either belonging to the target structure or not, and it makes sense to express class membership in probabilistic terms.

We explore here the classification of pixels as belonging or not to extended linear structures such as those of Fig. 6, in the same spirit of [77,50]. The target structures appear at many different scales and in many different contexts, such as micrometer scale dendrites in light microscopy image-stacks, millimeter-scale blood vessels in retinal scans, or meter-scale road networks in aerial images, and are of fundamental importance in many applications. To this end, we use a simplified version of the shallow modular architecture of Fig. 1. It forgoes the whitening and the pooling steps, as we have empirically found them to negatively affect the classification score. Our interpretation is that whitening removes important information from the data by eroding the vessels’ profiles, while pooling drops their localization and erases the thinner ones. Nonlinearization has been removed as well, since the absence of a pooling step made it unnecessary.

As in the previous section, we detail below the filter learning algorithms and the individual components of our framework, describe the datasets we use, and the comparative results we obtain.

We first tried using the unsupervised filter learning algorithm of Section 3. As discussed, one key weakness of this formulation is that, even though the filter replication due to translations is avoided, nothing prevents two filters from independently converging to an identical solution. This is usually caused by strong gradients, which dominate the reconstruction error term. This is particularly true in images containing neat, curvilinear profiles, such as those of Fig. 6. While the regularization term pushes for an economical representation, the regularization parameter 
                           
                              
                                 
                                    λ
                                 
                                 
                                    learn
                                 
                              
                           
                         cannot make the sparsity penalty prevail over the reconstruction error without trivial filters appearing. Furthermore, the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                         regularizer penalizes similarly all cases where a certain amount of energy is equally split among similar filters. In fact, this is the main difficulty in using the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    1
                                 
                              
                           
                         norm in place of the 
                           
                              
                                 
                                    ℓ
                                 
                                 
                                    0
                                 
                              
                           
                         norm for sparsity promotion. The precondition requiring the original image to be truly sparse, which is requested for the solutions obtained by the two norms to be equivalent [22,23], is indeed generally satisfied by natural images [9]. We therefore introduce an additional term in the objective function of Eq. (3) that penalizes filters that are too similar, where the similarity is expressed in terms of the squared dot product. We look for
                           
                              (7)
                              
                                 
                                    
                                       
                                          argmin
                                       
                                       
                                          {
                                          
                                             
                                                f
                                             
                                             
                                                j
                                             
                                          
                                          }
                                          ,
                                          {
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ∗
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                2
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          ξ
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   k
                                                   ≠
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      〈
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      〉
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                λ
                                             
                                             
                                                learn
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Even though this does not completely prevent replication, it makes it much rarer. A related approach has been independently proposed in [78]. Fig. 7
                         depicts the filter banks learned on the three datasets of Fig. 6. Unsurprisingly, the resulting shapes match the structures present in each image type, i.e., curvilinear profiles with ridges for the DRIVE dataset, pointwise structures for the noisy neurons images, and straight, parallel elements for the more geometrically defined roads dataset.

We used three very different datasets.

The first one is the publicly available DRIVE dataset of retinal images, where the aim is to automatically segment blood vessels [79]. It is composed of 40 RGB-formatted retinal scans, which were originally obtained for the diagnosis of diabetic retinopathy. In our experiments we used only the green channel, since it has been shown to give the highest contrast between background and vessels [80]. Fig. 6a shows an example retinal scan from this dataset. The images typically have a uniform background with the vessels appearing as dark linear structures. We use segmentations of the underlying vasculatures provided by expert ophthalmologists as ground truth for performing our evaluations.

The second dataset is made of minimum intensity projections of bright-field micrographs, such as that of Fig. 6b, paired up with annotations made by a human expert. The bright-field micrographs are obtained from biocityne-dyed rat neurons. Due to irregularities in the staining process, they contain both structured and unstructured noise that is difficult to distinguish from the dendrites. Also, the minimum intensity projection of points from a 3D stack to a 2D image introduces a significative noise component.

The third dataset is made of aerial images, such as the one of Fig. 6c, which contain road networks of a residential area in the United States. Segmenting streets from these images is a challenging task as they are often occluded by trees along roadsides and medians. Furthermore the image intensities of the streets vary according to the quality of the asphalt, and the background is cluttered with many complex structures that can be mistaken for roads such as houses, swimming pools, and parking lots. We manually annotated the streets and used these annotations as ground truth for both training and testing.

We manually delineated the centerlines of the training images to distinguish between the target linear structures and the background in the supervised training phase. In total we traced 8 training images for the DRIVE dataset and 1 high-resolution image for both the neurons and the roads dataset. Please note that these delineations are only used at training time for the acquisition of training samples. No such tracing is therefore required for the test images. We collected potentially ambiguous negative instances by randomly sampling points within a short distance from the traced centerlines. These examples constitute half of the negative samples, and the other half was also randomly selected from the rest of the background. The same training methodology has been utilized in [50], and therefore the results can be quantitatively compared. To account for contrast and brightness variations across different images we rescale pixel intensity values using a zero-mean unit-variance normalization. For each sample in the dataset we then compute a feature vector by convolving the learned filters with the normalized images. These feature vectors are used to train classifiers at training time and to obtain classification scores at test time. In this paper we use Support Vector Machines as baseline classifiers.

@&#RESULTS AND DISCUSSION@&#

We compare our results against the very widely used Hessian-based technique of [39], the Oriented Flux Filter of [46], and our earlier supervised learning approach [50] that relies on steerable filters instead of the learned filters presented here. We use multiscale implementations for all the competing methods and compare their output to that of our filter banks learned at a single scale.


                        Fig. 8
                         summarizes the results on our three datasets by using Precision/Recall curves, while the corresponding F-measure values are reported in Table 5
                        . Our method consistently scores better than our three baselines. As a final remark, the non-monotonic shape of some curves in Fig. 8 can be explained by strong responses due to the high contrast present in some areas, such as the image boundaries or, for the DRIVE dataset case, the optical disc, as discussed in [81].

While the performance of a classifier on a given dataset is readily established by computing the number of successfully classified items, no such measure exist for the pixel classification task. For this reason we include in Table 5 the Area Under Curve (AUC) and two analytic measures of segmentation quality, namely the Variation of Information (VI) [82] and the Rand Index (RI) [83]. Both the VI and the RI require a thresholded image, and we automatically pick the best threshold identified by the F-measure. The results are consistent with the Precision/Recall curves. More extensive results, including the ROC curves corresponding to the Precision/Recall curves of Fig. 8, are included in the appendices.

The method in [50] uses a richer vocabulary of filters than those of [39,46], which can account for irregularities in the data. Nonetheless, these filters being weighted sums of Gaussians and Gaussian derivatives, they only have limited expressive power. Our filters are learned on the data itself and they are therefore more expressive, especially for non-standard profiles which cannot be reliably detected by methods such as [39]. The main drawback of our filters, compared with steerable ones, is that they can adapt to the data only at the cost of losing the separability of the Gaussian filters.

In Fig. 8, note the good performance of random filters in both the neurons and the roads datasets. This result can be easily explained by the fact that both datasets are heavily corrupted by noise, up to a point that even the human segmentation presents gross mistakes. The SVM is at ease with the representation provided by the random filters of such images, which is a sort of Compressively Sensed representation of them, while it gets confused by the unstable representation obtained when, for example, the smooth Gaussianly shaped filters adopted by [50] are fitted to the given data. A visual inspection of the resulting pixel classifications reveals that the profiles extracted by random filters are not as sharply defined as those obtained by learned filters or rotational features (see Fig. 9
                        ). Also, the performance of random filters drops quickly as the number of filters decreases.

Using the result obtained with learned filters as a baseline, we investigate whether our approach to learning the filters can also be used to optimize the feature maps as was done for the image categorization task. We therefore compare the classification scores for the plain convolution case against those achieved by the Iterative Thresholding algorithm for different levels of sparsity by solving the minimization problem of Eq. (5). Since the results of the learning-based approaches depend on the samples collected during the supervised training, we fix these points to provide a fair comparison. The most significant results are reported in Fig. 8d, and they show that feature vectors computed by convolution perform better than the ones computed from sparsified feature maps.

@&#CONCLUSIONS@&#

We performed an in-depth analysis of the role of sparsity for image categorization and pixel classification. The consistency of our results for these two very different tasks suggests that sparsity is essential to learn effective filter banks at training time but that enforcing it at run-time is not particularly useful in convolutional architectures, at least when the level of noise remains reasonable. On the other hand, sparsity turns out to be important when redundancy is either introduced (e.g., by extracting features on overlapping patches) or already present in the data (e.g., by considering strongly correlated image channels). Given the high computational burden involved in the enforcement of sparsity, these findings should be taken into account when building actual recognition systems designed to work on large images.

One weakness of our approach is that, since the filters are not separable, the convolutions are difficult to compute very efficiently, and generalizing this approach to cubes of data as opposed to images as in [50] would be prohibitively expensive. Future work will therefore focus on optimizing the filters so that this difficulty can be overcome.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.cviu.2014.03.009.


                     
                        
                           Supplementary data 1
                           
                        
                     
                  

@&#REFERENCES@&#

