@&#MAIN-TITLE@&#Use of proactive and reactive hotspot detection technique to reduce the number of virtual machine migration and energy consumption in cloud data center

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Time-series based forecasting methods are used to predict future load of a system.


                        
                        
                           
                           If the current and the next predicted load of a server exceed the dynamic upper threshold then migration will take place.


                        
                        
                           
                           The forecasting methods are also used to predict multiple (n) future load of the system.


                        
                        
                           
                           Our algorithms are able to find more suitable destination host for VM placement.


                        
                        
                           
                           They are capable of saving energy by reducing number of over-utilized hosts and virtual machine migration.


                        
                        
                           
                           Maximum QoS requirements are fulfilled due to less violation of SLA.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cloud computing

Energy efficiency

Hotspot mitigation

Load prediction

VM consolidation

VM migration

@&#ABSTRACT@&#


               
               
                  The increasing demand of cloud computing motivates the researchers to make cloud environment more efficient for its users and more profitable for the providers. Though virtualization technology helps to increase the resource utilization, still the operational cost of cloud gradually increases mainly due to the consumption of large amount of electrical energy. So to reduce the energy consumption virtual machines (VM) are dynamically consolidated to lesser number of physical machines (PMs) by live VM migration technique. But this may cause SLA violation and the provider is penalized. So to maintain an energy-performance trade-off, the number of VM migration should be minimized. VM migration primarily takes place in two cases: for hotspot mitigation and to switch off the underutilized nodes by migrating all its VMs. If a host is found to be overloaded then instead of immediately migrating some of its VMs we can check whether the migration is really required or not. For this we have proposed a load prediction algorithm to decide whether the migration will be performed or not. After the decision has been taken the algorithm finds a suitable destination host where the VM will be shifted. For this we have proposed a novel approach to decide whether a particular host is suitable as destination depending on its probable future load. We have simulated our algorithms in CloudSim using real world workload traces and compared them with the existing benchmark algorithms. Results show that the proposed methods significantly reduce the number of VM migration and subsequent energy consumption while maintaining the SLA.
               
            

@&#INTRODUCTION@&#

As defined by NIST [1] “Cloud computing is a model for enabling ubiquitous, convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction”. Lack of upfront capital investment, elasticity of resource provisioning and the pay-as-you-go pricing model are continuously attracting people toward cloud computing. Use of multi-tenant model increases the resource utilization. Multi-tenancy allows sharing the same resource among multiple customers in an isolated manner. As cloud can be accessed anytime and anywhere through commodity hardware, its demand is increasing day by day. So it must provide high performance gain to the user and at the same time must be beneficial for the Cloud Service Provider (CSP).

Virtualization is the key technology behind cloud computing that allows the simultaneous execution of diverse tasks over a shared hardware platform. It provides the potential for on-the-fly and on-demand configuration of physical machines to run diverse tasks, hence avoiding resource waste [2]. Cloud provides computing resources in the form of virtual machine, which is an abstract machine that runs on physical machine [3]. Typically a software layer called a hypervisor (e.g. Xen, KVM etc.) or virtual machine monitor (VMM) that resides above the hardware maps the virtual machine to physical resources. Each of the VMs executes either unmodified (full virtualization) or little modified (para-virtualization) version of operating system. Hypervisors support different functions for the hosted VMs such as creation, deletion, restart, suspend and migration [4].

The mapping between VMs and PMs can be changed while applications are running by VM live migration technique [5]. It transfers state of a VM from one physical machine to another with minimum downtime. Three main techniques used for live migration are suspend-and-copy, pre-copy and post-copy. Suspend-and-copy, suspends a VM, copies all its pages and then resumes the VM on the target machine [5]. In this method the downtime is proportional to the size of the VM and the available bandwidth. Pre-copy approach first copies the memory state to the destination through a repetitive process and after that its processor state is transferred to the target machine [6]. Whereas post-copy migration transfers a VM’s memory contents using demand-paging after its processor state has been sent to the target host. However, there is a delay associated with each migration, comprising of the time required for the VM [2] to stop execution at the current server, move the accompanying data to the new one and initialize the new VM there.

Irrespective of this overhead, VM migration is indispensable as it helps in hotspot mitigation, dynamic VM consolidation and enables uninterrupted maintenance activities [7]. Hotspot is defined as a condition when a host has inadequate resources to meet the performance demands [7]. Detection of hotspot can be done both proactively and reactively. Compare to proactive hotspot detection technique, reactive one is easier to implement. In this technique a host is considered as overloaded when its utilization level goes beyond a certain threshold. Whereas the former method uses forecasting technique to find hosts which may become overloaded in near future. As prevention is always better than cure, the pre-hotspot-detection technique (proactive) will reduce the number of migration more than the post-hotspot-detection technique (reactive). However, due to inefficient distribution of load, more heat is generated by these overloaded servers which in turn increase the cost of cooling system and substantial emission of CO2 contributing to greenhouse effect [8]. So to reduce the environmental impact and fulfill the Quality of Service (QoS) requirements specified by users via SLA, some of the VMs have to be migrated. On the other hand, in VM consolidation, VMs are migrated to fewer PMs to reduce server sprawl. Studies have found that servers in many existing data centers are often severely underutilized due to over provisioning for the peak demand [9]. It not only leads to poor resource utilization but also increases the operational cost due to higher consumption of energy. It has been stated that even completely idle server consumes about 70% of the peak power [10]. VM consolidation maximizes the number of inactive physical servers by consolidating the VMs on a minimum number of active physical servers. Ideally, due to the static energy consumed by server components (especially the CPUs), the servers must be kept at that utilization level where it is most energy efficient. The highest utilization level must be less than 100% because at this point performance degradation occurs causing more consumption of energy due to longer execution time [11]. The optimum utilization level varies from processor to processor. For simplicity we have considered a dynamic threshold which denotes the upper limit of the CPU utilization depending on the current system load. However, due to the lack of energy-proportionality in modern server hardware, there’s a big difference in energy consumption between an idle and suspended server, suspending an inactive server provides another opportunity for saving energy [12].

There is an inherent trade-off between overload avoidance for achieving high performance gain and dynamic consolidation of VMs to save energy. As to reduce overloading of hosts we should keep the utilization of PM low so that it can deal well with future resource needs. But it results in poor resource utilization and the underutilized servers cause more energy consumption. VM migration is the solution to both problems. So the number of VM migrations should be such that it provides an optimum level of performance as well as saves energy. To ensure the future growth of cloud computing an energy-performance trade-off has to be maintained which helps the cloud providers to fulfill the demand of users with less operational costs.

Most of the current research works [7,8,13–19,21] are based on the current load of the system. If a host is found to be overloaded at present then VM migration is initiated immediately [13]. But each VM migration is associated with some performance degradation which in turn increases the SLA violation. As a result each VM migration increases the operational cost. So the problem is to determine when a VM migration should be initiated so that the cost associated with extra energy consumption and SLA violation can be minimized. To achieve this goal we have proposed a load prediction method which decides whether a VM migration should be initiated or not. Our contributions in this paper are as follows:
                        
                           •
                           Time-series based forecasting methods are used to predict future load of a system. If a server is currently overloaded and the next predicted load is also greater than the dynamic upper threshold then migration will take place.

The forecasting method is used to predict multiple (n) future load of the system. If the server is currently overloaded and at least k of the predicted load are greater than the dynamic upper threshold then migration will be initiated.

The load forecasting method is also used to find suitable destination host for VM placement. If a host is found to be overloaded in the near future then it will be excluded from the set of probable target host while migrating a VM. It will be also not considered as under-utilized server while VM consolidation.

Due to the use of load predication model our algorithm is capable of reducing number of virtual machine migration and at the same time saves energy providing a green IT solution.

The rest of the paper is organized as follows: Section 2 briefly describes the related works. Details of the forecasting method used are presented in Section 3. The working of the proposed algorithms is discussed in Section 4. Section 5 presents a performance analysis of the proposed algorithm. Finally, Section 6 concludes the paper with final remarks and scope for future research directions.

@&#RELATED WORK@&#

Load prediction model is also used in [20] to predict the future resource usages of applications accurately. But they have used this method in dynamic VM consolidation only. If the predicted future load of an underutilized server is high then VM migration will not take place. It reduces the number of VM migration as well as number of hotspot. The authors of [20] also introduced the concept of “skewness” to improve the overall utilization of servers. While migration that server is used as destination whose skewness can be reduced the most by accepting the migrating VM. Different from [20] our work has used the load prediction model to find a destination host while evaluating migrations.

Khanna et al. [15] monitor the resources (CPU and memory) of physical and virtual machines. They have proposed the idea of fixed threshold value which will limit the maximum utilization of resources. If a resource exceeds a predefined threshold and there is a chance of SLA violation then the system migrates a VM to another physical machine. Unlike this we have used the concept of adaptive threshold and load prediction model to decide whether migration will take place or not.

In [14] Anton et al. have proposed algorithms for energy-efficient mapping of VMs to suitable cloud resources. They have designed different VM selection methods like “minimization of migration policy”, “highest potential growth policy” and “random choice policy” to choose a particular VM for migration. The authors suggested that it is not a wise decision to keep the utilization threshold fixed as the workload is continuously changing. In their later paper [13] the authors have proposed Median Absolute Deviation (MAD) and Inter Quartile Range (IQR) methods to find the upper threshold of a server dynamically. According to the authors, if the current load of the host is greater than the upper threshold then it is considered as overloaded. The concept of adaptive threshold performs far better than the static threshold in the dynamic cloud environment. They have also proposed methods like Local Regression (LR) and Robust Local Regression (LRR) to predict future load. But in these methods hosts are considered to be overloaded only when the predicted utilization is greater than or equal to 100%. Our proposed work considers a server as overloaded when the current as well as future load of the server are greater than the adaptive upper threshold. Thus it can prevent the unnecessary migrations which are initiated due to momentous spike in load. We have used time-series based forecasting technique to calculate the future load of the server depending on the historical data.

In [21] authors presented a system called Sandpiper to automate the task of hotspot detection and to determine a new mapping of physical to virtual resources and initiating the necessary migrations in a virtualized data center. To ensure that a small transient spike does not trigger needless migrations, a hotspot is flagged only if thresholds or SLAs are exceeded for a sustained time. Migration takes place only when at least k out of the n most recent observations as well as the next predicted value exceeds a threshold. The threshold considered in this paper is static. The authors here use auto regression method to calculate the next predicted value. After a hotspot has been detected the VM whose volume-to-size ratio (VSR) is maximum will be migrated. When the system load is high it is not possible to migrate the VM having highest VSR. In that case swapping of VMs take place to reduce the load on hotspot. This process will not work effectively during peak system load as the swapping of VMs will increase the migration overhead unnecessarily. Different from [21] we have used dynamic threshold in our proposed approach. Simple and Double Exponential Smoothing Techniques are being used to predict the future load of the system.

In [11] the authors observed that when the resource utilization is low, idle power is not amortized effectively and hence the energy per transaction is high. On the other hand high resource utilization leads to performance degradation which causes high energy consumption due to longer execution time. So to provide an energy-performance trade-off, the authors have proposed a heuristic that maximizes the sum of the Euclidean distances of the current allocations to the optimal point at each server. But this approach is application dependent, whereas our proposed method, that reduces the energy consumption by limiting the number of VM migration, is workload independent.

Norman et al. have developed a management algorithm for dynamic allocation of virtual machines to physical servers in [16]. The algorithm is based on measuring historical data, forecasting the future demand, and remapping VMs to PMs, and is subsequently referred to as Measure-Forecast-Remap (MFR). Time series forecasting techniques and bin packing heuristic are combined to minimize the number of physical machines required to support a workload. In this algorithm the forecasting method is used to find the resource demand of individual VMs. Based on the predicted values the VMs are arranged in descending order and then first-fit heuristic is used to migrate the VMs. In our algorithm we have used the predicted load to find the overutilized nodes as well as to find a more appropriate set of destination hosts for the migrating VMs and more suitable under-utilized servers for VM consolidation.

Kochut and Beaty [4] proposed an analytical model of VM migration that provides estimates of the expected gain in response time due to a migration decision. The model is based on M/M/1 queueing model and considers the characteristics of a virtualized environment such as migration cost and overhead caused due to additional resource consumption. That VM is selected for migration which minimizes the response time of the system. Unlike it, our proposed algorithm is based on the time-series based forecasting model and is mainly concerned with the energy-performance trade-off.

In [17] authors presented a new metric that captures the load of the physical servers and is a function of the resident VMs. Load imbalance is measured using this metric. The proposed load balancing algorithm follows a greedy approach. The VM which will yield the greatest improvement of the imbalance metric is selected for migration. Apart from load balancing, VM migration in our work will also make the system more energy-efficient by dynamic VM consolidation.

Andreolini et al. proposed a novel management algorithm in [18] to decide about reallocations of virtual machines in a cloud environment. Instead of the traditional threshold based method, the authors used the load profile evaluated through a cumulative sum based stochastic model. This method eliminates unnecessary VM migrations caused due to momentous hike in load. Traditional best-fit bin packing algorithm is used for reallocation of the selected VM. Our proposed algorithm also eliminates unnecessary VM migrations by predicting the future load of the system.


                     Table 1
                      summarizes the different methods used for VM migration to achieve energy efficiency, as well as to maintain system load. The methods are categorized into two types – Predictive and Non-predictive. The first category uses prediction model to forecast the future load, whereas the second category depends only on the present load. What methodologies are being used and how the allocation decision is taken are briefly discussed in the table. Whether the algorithms depend on specific workload or not, is also mentioned in Table 1.

Live migration of virtual machine helps to distribute load evenly across the physical machines by hotspot mitigation. It also reduces server sprawl by consolidation of VM [7]. In spite of its advantages VM migration is an expensive operation as it consumes resources of the source and destination hosts as well as network bandwidth to transfer the memory image of the VM. So VM migration must be performed in a restricted manner, otherwise it may lead to performance degradation by unnecessary movement of virtual machines.

To reduce the number of VM migration we have proposed an algorithm that will decide whether it is really necessary to migrate a VM depending on the present as well as future load which is predicted using time-series forecasting technique. A time series is a sequence of data points, typically consisting of successive measurements made over a time interval [19]. Time series forecasting is the use of a model to predict future values based on previously observed values. We have applied the Exponential Smoothing technique to time series data to make forecasts.

Exponential smoothing is a particular type of weighted moving average method. In moving average all the past observations are given equal importance. But sometimes it is beneficial to give more priority to the recent observations. This is done in the weighted moving average technique by assigning different weights so that recent observations have more impact on the predicted value compare to the old observations. The simplest form of exponential smoothing is given by the following formula:
                        
                           (1)
                           
                              
                                 
                                    s
                                 
                                 
                                    t
                                 
                              
                              =
                              α
                              ∗
                              
                                 
                                    x
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              +
                              (
                              1
                              -
                              α
                              )
                              ∗
                              
                                 
                                    s
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                           
                        
                     where α is the smoothing factor which actually provides the weight and 0<
                     α
                     <1.In other words, the smoothed statistic st
                      is a simple weighted average of the previous observation xt
                     
                     −1 and the previous smoothed statistic st
                     
                     −1 
                     [22].

In our proposed algorithm {x
                     1,
                     x
                     2,
                     …,
                     xt
                     
                     −1} is the set containing total CPU utilization history of a physical host for the past time interval of duration t. It is actually the sum of the CPU utilization of all the active VMs running on that host. {s
                     1,
                     s
                     2,
                     …,
                     st
                     
                     −1} are the corresponding predicted values of CPU utilization. From these set of values the mean square error (MSE) is calculated as follows:
                        
                           (2)
                           
                              MSE
                              =
                              
                                 
                                    1
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              
                                 
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          i
                                       
                                    
                                    -
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 
                                    2
                                 
                              
                           
                        
                     
                  

To find the CPU utilization at the tth time (st
                     ) that optimum value of α is used which produces the least MSE. Trial and error method is used to find the optimum value of α.

Simple exponential smoothing does not perform well when there is a trend in the data [23]. To handle such situations “second-order exponential smoothing” or “double exponential smoothing” method is used. “Holt-Winters double exponential smoothing” is one such technique. It works almost similar to simple smoothing except that two components must be updated in each period – level and trend [24]. The level is a smoothed estimate of the value of the data and trend is a smoothed estimate of average growth at the end of each period. The formulae used are:
                        
                           (3)
                           
                              
                                 
                                    s
                                 
                                 
                                    t
                                 
                              
                              =
                              α
                              ∗
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              +
                              (
                              1
                              -
                              α
                              )
                              ∗
                              (
                              
                                 
                                    S
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              +
                              
                                 
                                    b
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              )
                              
                              0
                              <
                              α
                              <
                              1
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    b
                                 
                                 
                                    t
                                 
                              
                              =
                              γ
                              ∗
                              (
                              
                                 
                                    S
                                 
                                 
                                    t
                                 
                              
                              -
                              
                                 
                                    S
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              )
                              +
                              (
                              1
                              -
                              γ
                              )
                              ∗
                              
                                 
                                    b
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              
                              0
                              <
                              γ
                              <
                              1
                           
                        
                     
                  

where γ is the trend smoothing factor, 0<
                     γ
                     <1 and α is same as before. {st
                     } and {xt
                     } are same as simple smoothing technique. {bt
                     } is the best estimate of the trend at time t. The output of the algorithm i.e. Ft
                     
                     
                        +
                     
                     
                        m
                     , an estimate of the value of x at time t
                     
                     +
                     
                     m, m
                     
                     >
                     0is:
                        
                           (5)
                           
                              
                                 
                                    F
                                 
                                 
                                    t
                                    +
                                    m
                                 
                              
                              =
                              
                                 
                                    s
                                 
                                 
                                    t
                                 
                              
                              +
                              m
                              ∗
                              
                                 
                                    b
                                 
                                 
                                    t
                                 
                              
                              .
                           
                        
                     Several methods exist to choose the initial values for St
                      and bt
                     . Generally s1 is set to x
                     1. Three possible values for b
                     1 are:
                        
                           (6)
                           
                              
                                 
                                    b
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    b
                                 
                                 
                                    1
                                 
                              
                              =
                              [
                              (
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                              )
                              +
                              (
                              
                                 
                                    y
                                 
                                 
                                    3
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              )
                              +
                              (
                              
                                 
                                    y
                                 
                                 
                                    4
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    3
                                 
                              
                              )
                              ]
                              /
                              3
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    b
                                 
                                 
                                    1
                                 
                              
                              =
                              (
                              
                                 
                                    y
                                 
                                 
                                    n
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                              )
                              /
                              (
                              n
                              -
                              1
                              )
                           
                        
                     
                  

Now the main question is how the forecasts actually influence the outcome [25]. Rather than using the forecasted value directly, our proposed method uses it to take some crucial decision regarding migration. So migration will take place or not and if it is happening then where the VM will be migrated depend on the current as well as predicted CPU utilization. Efficiency of our algorithm does not directly depend on the accuracy of prediction rather it depends on the accuracy of the decision taken regarding migration.


                     Figs. 1 and 2
                     
                      show the CPU utilization of two different physical hosts for a particular time interval. The black line shows the actual value whereas the blue and magenta lines show the predicted values using Simple Exponential (SE) and Double Exponential (DE) smoothing technique respectively. The red straight line parallel to x-axis shows the upper threshold for that particular time interval. From the graph it is clear that the value predicted by double exponential smoothing technique more resembles the actual value. For more clarity some of the values are shown in Table 2
                     . The table contains the actual and predicted values of CPU utilization. We have calculated the MSE of SE and DE model using Eq. (1). The error rate of SE model is 1.076%, whereas that of DE model is 0.039%. The reason is obvious. We have already mentioned that if the data follow a trend then the double exponential smoothing technique is more suitable. We have not used triple exponential smoothing technique as it also considers the seasonal changes in data along with the trend. Seasonality is the tendency of time-series data to exhibit behavior that repeats after a certain period of time [22]. As the CPU utilization changes very frequently so here we have predicted the future value based on observation of short time duration. So generally seasonality is not found.

In a highly dynamic environment like cloud it is not possible to exactly predict the future value of CPU utilization. Still our proposed algorithm performs more efficiently as it does not work on the predicted value directly. It takes the migration decision by checking whether the predicted value is greater than the current upper threshold or not. So the accuracy of the algorithms calculated using Mean Square Error or Mean Absolute Deviation [26] does not have direct effect on the output. What exactly matters is whether the migration decision taken is correct or not. We can see in both Figs. 1 and 2 that in most of the cases actual value and predicted value using double exponential smoothing method give the same output to the above question. As a result we are able to take a better migration decision.

The problem of VM migration can be divided into three parts: (I) When to migrate (II) Which VM to migrate and (III) Where to migrate [27]. We have proposed two algorithms which resolve the first and third issues of migration. For VM selection Minimum Utilization policy given in [13] is used. As the name depicts it will choose the VM having minimum CPU utilization. So the overhead associated with migration will also be less.
                        
                           
                              
                              
                                 
                                    Algorithm 1: Efficient VM Migration
                                 
                              
                              
                                 
                                    1. Input: host Output: migration decision (true/false)
                                 
                                 
                                    2. flag=false
                                 
                                 
                                    3. find current utilization of host h
                                 
                                 
                                    
                                       utilization=
                                 
                                 
                                    
                                       totalRequestedMips/h.getTotalMips()
                                 
                                 
                                    4. data[]=h.getUtilizationHistory()
                                 
                                 
                                    5. find upper threshold using MAD
                                 
                                 
                                    upperThreshold=1−s∗Mad
                                 
                                 
                                    6. if (utilization>upperThreshold) then
                                 
                                 
                                    
                                       flag=true
                                 
                                 
                                    7. if (data.length<10 or flag==false) then
                                 
                                 
                                    
                                       return flag
                                 
                                 
                                    8. currentOverUtilizedHosts.add(h)
                                 
                                 
                                    9. find future utilization using exponential smoothing technique
                                 
                                 
                                    
                                       future_utilization=getHostFutureLoad(data)
                                 
                                 
                                    10. if (future_utilization>upperThreshold) then
                                 
                                 
                                    
                                       
                                       flag=true
                                 
                                 
                                    
                                       else
                                 
                                 
                                    
                                       
                                       flag=false
                                 
                                 
                                    11. if (flag==true) then
                                 
                                 
                                    
                                       overUtilizedHosts.add(h)
                                 
                                 
                                    12. return flag
                                 
                              
                           
                        
                     The above algorithm takes host as input and takes the decision of migration (line No. 1). The decision is based on dynamic upper threshold policy. In this policy a host is considered as overloaded if its utilization is above the upper threshold. Upper threshold is found using Median Absolute Deviation (MAD) method (line No. 5) described in [13]. The threshold value varies according to the change in workload. The proposed algorithm initially compares the current CPU utilization (calculated in line No. 3) with the upper threshold like the traditional method (line No. 6). If the host is not overloaded then migration is not performed and there is no change in the existing process.

But if the host is found to be overloaded and we have at least 10 numbers of historical data of CPU utilization then, unlike the traditional process future utilization of CPU is calculated using time-series based forecasting method (line No. 9) like Moving Average, Simple and Double Exponential Smoothing technique. To properly forecast the future value sufficient past data must be passed to the forecasting technique. This historical data are maintained in log file. We have done our experiments with data length equals to 5, 10, 15, 20 and found that our algorithms perform best with data length of 10. In [13] the authors have used the minimum data length as 12 for calculation of MAD. To find the future load using LR or LRR method they have used data of length 10. Our experiments show that the performances of the algorithms are similar with data length of 10 and 12. So we have chosen the length of historical data to be 10. If the predicted CPU utilization is greater than the upper threshold (line No. 10) then the host is added to the list of overutilized nodes (line No. 11) and migration will take place. Otherwise, migration will not occur as it is forecasted that in near future the host will not remain overloaded. As a result migrations due to momentous hike in load are prevented at the cost of SLA violation for a short duration.

The shortcoming of this algorithm is that it does not take special care of the nodes which are not overloaded now but may become in near future i.e. the nodes which are predicted to be overloaded. They are not excluded while searching a destination host for migrating VMs or minimum-utilized hosts while VM consolidation. So if such hosts are selected as destination or minimum-utilized host then they may initiate unnecessary VM migration causing performance degradation. To solve this problem we have modified the algorithm a little so that it can generate a more suitable list of probable destination hosts and minimum-utilized hosts.
                        
                           
                              
                              
                                 
                                    Algorithm 2: Optimized destination host selection
                                 
                              
                              
                                 
                                    1. Input: host Output: migration decision (true/false)
                                 
                                 
                                    2. flagP=flagF=false
                                 
                                 
                                    3. find current utilization of host h
                                 
                                 
                                    
                                       utilization=
                                 
                                 
                                    
                                       totalRequestedMips/h.getTotalMips()
                                 
                                 
                                    4. data[]=h.getUtilizationHistory()
                                 
                                 
                                    5. find upper threshold using MAD
                                 
                                 
                                    upperThreshold=1−s∗Mad
                                 
                                 
                                    6. if (utilization>upperThreshold) then
                                 
                                 
                                    
                                       flagP=true
                                 
                                 
                                    7. if (data.length<10) then
                                 
                                 
                                    
                                       if(flagP==true)
                                 
                                 
                                    
                                       overUtilizedHosts.add(h)
                                 
                                 
                                    
                                       return flagP
                                 
                                 
                                    8. find future utilization using exponential smoothing technique
                                 
                                 
                                    
                                       future_utilization=getHostFutureLoad(data)
                                 
                                 
                                    9. if (future_utilization>upperThreshold) then
                                 
                                 
                                    
                                       
                                       flagF=true
                                 
                                 
                                    
                                       else
                                 
                                 
                                    
                                       
                                       flagF=false
                                 
                                 
                                    10. if (flagF==false and flagP==true) then
                                 
                                 
                                    
                                       currentOverUtilizedHosts.add(h);
                                 
                                 
                                    11. if (flagF==true and flagP==false) then
                                 
                                 
                                    
                                       predictedOverUtilizedHosts.add(h);
                                 
                                 
                                    12. if (flagF==true and flagP==true) then
                                 
                                 
                                    
                                       overUtilizedHosts.add(h)
                                 
                                 
                                    
                                       return true
                                 
                                 
                                    else
                                 
                                 
                                    
                                       return false
                                 
                              
                           
                        
                     As the second algorithm looks very similar to the first one, so here we will discuss only the difference between the two. Unlike the first one here we will predict the future utilization of CPU irrespective of the current status. We have used two flags: flagP for present and flagF for future CPU utilization (line No. 2). There can be three cases:
                        
                           (i)
                           Currently it is overloaded but not in future. In this case the host is added to the list of current overutilized hosts but not migrated (line No. 10).

Currently it is not overloaded but it may become in future. In this case the host is added to the list of predicted overutilized hosts but not migrated (line No. 11).

It is overloaded both now and in future. In this case the host is added to the list of overutilized hosts and migration is performed (line No. 12).

These new steps help to find the destination host more efficiently. The current as well as predicted list of overutilized hosts will be excluded from the set of destination hosts. Not only that, they are also not considered during the search of minimum-utilized hosts. So it will eliminate those unnecessary migrations which have occurred in the first method.

We have also modified both of the above algorithms by predicting n future values instead of one. If among these n values at least k values are greater than the upper threshold then migration will take place. The values of n and k can vary. We have done our experiments using n
                     =5 and k
                     =3, 4. Larger values of n may be taken but as n increases the accuracy of prediction will decrease.

The above algorithms will select the hosts for migration. After that, VMs will be selected from the overUtilizedHosts list using Minimum Utilization VM selection policy. The last step is the VM placement which is basically a bin packing problem. Here we have modified the list of destination hosts available by predicting their future load. The rest part is kept intact. All the VMs are sorted in decreasing order based on their current CPU utilizations. Then each VM is allocated to a host that provides least increase in power consumption after the VM allocation [14].

According to our algorithm, migration decision is taken depending on current and future load of the system. In case of overwhelming condition, the utilization level of all the servers will exceed the upper threshold. So no suitable destination host could be found for the migrating VM. As a result migration will not occur. It will increase the execution time and will lead to SLA violation. This can be avoided by activating some servers from sleep state to ready state and migrating VMs to these servers.

In this section we have analyzed the performance of our proposed algorithms. In a highly dynamic environment like cloud it is not possible to do experiments in a repeatable and dependable fashion. That’s why we have chosen the CloudSim simulation tool [28] to test our algorithms before deploying them in real cloud. Other simulators like GangSim, SimGrid, GridSim [29–31] do not provide suitable environment that can be directly used for modeling cloud computing environment. They are unable to isolate the multilayer service abstractions i.e. SaaS, PaaS and IaaS required by Cloud. On the other hand CloudSim supports modeling and simulation of data centers on a single physical computing node.

Our algorithms basically improved the performance of the existing algorithm proposed in [13]. So to compare their performance we have used the same experiment setup as used in [13]. A data center has been simulated having 800 heterogeneous physical hosts and 1052 virtual machines. Half of the hosts are HP ProLiant ML110 G4 servers and rest half are ProLiant ML110 G5 servers. Depending on the CPU and memory capacity four types of single-core VMs are used: High-CPU Medium Instance: 2500 MIPS, 0.85GB; Extra Large Instance: 2000 MIPS, 3.75GB; Small Instance: 1000 MIPS, 1.7GB and Micro Instance: 500 MIPS, 0.633GB.

The experiments are conducted using workload traces from CoMon Project, a monitoring infrastructure for PlanetLab [32]. Data used are on the CPU utilization by more than a thousand VMs from servers located at more than 500 places around the world. Data are measured in 5min interval. The detailed workload characteristics are in [13]. To make a proper comparison with [13] we have used the same 10days workload traces collected during March and April 2011 and are available in the CloudSim Package.

To compare the performance of our proposed algorithms with the existing algorithms we have chosen seven parameters: number of over-utilized nodes, total number of VM migration occurred either for hotspot mitigation or for VM consolidation; total energy consumption by the physical resources for executing variable workloads; average SLA violation which describes how many times allocated resources are less than required resources, performance degradation that occurs due to migration of VM from one host to another while balancing load or switching off underutilized servers, percentage of SLA violation time per active host and SLA%.

Here we will first describe the nomenclature of the different algorithms which we have compared in the above figures. MM algorithm uses Median Absolute Deviation (MAD) technique to find the dynamic upper threshold and Minimum Utilization VM Selection Policy to select VM for migration. This algorithm is already implemented in CloudSim by the authors of [13]. All other techniques described in this paper are modified versions of this method. As mentioned in Section 4 along with this technique our algorithms have also used some time-series based forecasting method. 1 and 2 in the name denote whether algorithm 1 or 2 has been used; “n” denotes that n loads have been predicted and at least k of them must be greater than upper threshold for performing migration. The results shown in Table 3
                         consider n
                        =5 and k
                        =3. Absence of n indicates that only the next load is predicted. MA, SES and DES represent Moving Average, Simple and Double Exponential Smoothing technique respectively.


                        Fig. 3
                         compares the total number of over-utilized nodes generated by different algorithms. The original algorithm proposed in [13] (MAD_MU) generates the maximum number of overloaded nodes, whereas our proposed algorithms minimize their numbers. SES_1 shows a minimum reduction of 27.47%, whereas maximum reduction of 66.89% is obtained by DES_2_n. The reduction in number of overloaded nodes proves that our prediction-based algorithms are successful in solving the problem of hotspot mitigation.


                        Fig. 4
                         shows the number of VM migration by different algorithms. As we take the migration decision based on current as well as future load so the migrations generated due to momentous hike in CPU utilization will be minimized depending on the accuracy of the prediction algorithm. It will in turn reduce the total number of migration. Minimum reduction of 10.33% is obtained using MA_1 whereas DES_2 provides the maximum reduction of 61.08%. We have already mentioned that Double Exponential Smoothing technique performs the best if the data show a particular trend. Moreover Algorithm 2 performs more efficiently than Algorithm 1 as the former migrates VMs to more suitable destination eliminating the chances of repeated migrations of the same VMs that may occur if the destination hosts become overloaded in near future. Unlike Algorithm 1, Algorithm 2 adds the list of predicted over-utilized nodes to the excludedList of hosts created to find destination hosts. So the VMs which will be migrated either from over-utilized hosts or from under-utilized hosts will be prevented from migrating to the hosts that may become overloaded in near future. It avoids the chances of thrashing i.e. repeated migration of the same VM from one host to another without performing any task. Algorithm 1 causes more number of migrations due to the inability of finding the most suitable target host.


                        Fig. 5
                         compares the energy consumption (in Kwh) by different algorithms. There is an extra overhead associated with each VM migration. Table 3 shows that energy consumption decreases with the decrease in number of migration. The reduction varies from 5.87% to 34.59%. DES_2 provides the maximum decrement in energy consumption.

Percentage of Average SLA violation and performance degradation due to migration are also reduced as shown in Figs. 6 and 7
                        
                         respectively. Excessive migration will degrade the overall performance of the system. So number of migration should be such that Quality of Service (QoS) requirements are fulfilled and at the same time migration overhead is less. Our algorithm is able to produce optimum number of migrations which in turn decreases both performance degradation due to migration (PDM) and average SLA violation. The minimum reduction of PDM is 14.2% which is obtained by MA_1 and DES_2 produces the maximum reduction of 57.14%. Average SLA violation is measured as the mean of the difference between total requested resources and total allocated resources. The decrement in average SLA violation varies between 4.08% and 19.26%.

SLA is defined as the product of SLATimePerActiveHost (SLATAH) and PDM [13]. We can see in Table 3 that as the number of migration get reduced the first parameter i.e. SLATAH increases in Algorithm 1 whereas it decreases in Algorithm 2. SLATAH is the total time duration during which the allocated resources are less than the amount of resources requested by the VMs. Algorithm 2 is able to migrate the VMs to proper destination hosts where they will get their required resources without further migration. So SLATAH is reduced. The graph obtained by plotting percentages of SLATAH and SLA are shown in Figs. 8 and 9
                        
                        . DES_2 provides the maximum reduction of 7.66% and 63.92% in SLATAH and SLA respectively.

From the above discussion we can conclude that our proposed Algorithm 2 using Double Exponential Smoothing technique performs the best almost in all cases (except average SLA violation%). Energy consumption as well as SLA violation is reduced by 34.59% and 63.92%. As a result maximum QoS requirements are fulfilled and it is also better from the environmental point of view as minimum consumption of energy will reduce the cost of cooling system and emission of carbon-di-oxide. It is very much suitable for the provider as it helps to decrease the overall operational cost and penalty which has to be paid by the providers in case of violation of service level agreement.

Simple/Single Exponential Smoothing technique though performs better than the benchmark algorithm; the predictions made by this method are not as accurate as DES. Moreover our experiments have shown that the “n” versions of the algorithms i.e. where the algorithms have predicted multiple values instead of one do not perform better than those that have predicted single value as the accuracy of the prediction decreases with multiple predictions. Moreover effectiveness of the predicted values depends on the choice of n and k. Still they also perform better than the benchmark algorithm. The algorithms have chosen the best value of the smoothing constants (α and γ) so that the mean square error is minimized.

Our main aim is to reduce the number of migration that take place mainly during hotspot mitigation and VM consolidation. We have achieved this goal successfully. To perform the experiments in a repeatable manner we have simulated the algorithms in CloudSim simulator. But to apply this practically we have to implement them in real cloud platform. So in future we plan to do this by creating a private cloud using Openstack cloud framework.

In this work we have used load prediction model to take the decision of migration and to find suitable destination host. No method is proposed for VM selection. In our future work we will propose a new method for this also. Moreover, while VM consolidation, the nodes having minimum utilization is considered as being under loaded. But this may not be true during peak hours and it can cause unnecessary migrations. We will handle this type of scenario in our future work.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.compeleceng.2015.07.020.


                     
                        
                           Supplementary data 1
                           
                        
                     
                  

@&#REFERENCES@&#

