@&#MAIN-TITLE@&#Building trust from context similarity measures

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We have defined the concept of similarity measure.


                        
                        
                           
                           We have used similarity measures to define similarity networks.


                        
                        
                           
                           We have defined a trust model based on similarity networks in order to establish trust along a path of entities.


                        
                        
                           
                           The trust model has been validated in a proximity-based scenario where the most trusted entity is identified.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Similarity networks

Trust model

@&#ABSTRACT@&#


               
               
                  Trust is an essential feature of any system where entities have to collaborate. Trust can assist entities making decisions before establishing collaborations. It is desirable to simulate the behaviour of users as in social environments where they tend to trust users who have common interests or share some of their opinions, i.e., users similar to them. In this paper, we introduce the concept of context similarity among entities and derive a similarity network. Then, we define a trust model that allows us to establish trust along a path of entities. We validate our model in a proximity-based trust establishment scenario.
               
            

@&#INTRODUCTION@&#

Online communities are becoming more and more popular as it is shown by the growth on the number of users. The types of relationships that are taking place in an online community might vary. Sometimes users have to interact among them and some other times they might only be interested in knowing the opinion of others about a certain issue. Due precisely to the growth of these networks there are a huge variety of users registered, not all of them honest or reliable enough. When information is to be shared or a user is interested in knowing the opinions of others, uncertainty might be a problem. It would be desirable to have a tool that aids users in overcoming this uncertainty, and it is then when trust can play an essential role. The question that arises is to whom to trust in an online community and how to establish that trust. Moreover, this trust cannot be a general concept or a general value that can be obtained by a user and valid for all its functions in the network. Trust has to depend on specific contexts where the user or entity is involved. It is a well-known example that one might trust a dentist to take care of your teeth but not for repairing your car. There is not a consensus on the definition of trust. Many different definitions can be found in the literature, depending in most of the occasions, on the type of system where they are applied and on the problem they address. However, it is becoming an essential feature to be considered in any system where entities have to collaborate among them. Trust can assist the decision-making process by determining which is the most suitable entity to collaborate with in a system.

In a social setting, people tend to trust those who are close to them in taste, opinion or hobbies, i.e., those who they believe are similar to them. It becomes then natural to try to simulate this behaviour in a computational setting. Nowadays, social networks are experiencing the growth of the so-called recommender systems [1,2]. These systems use the opinions of members of a community to help others in identifying what products or information they might be interested in following other users' opinions or tastes.

In this paper we intend to establish trust in computational settings by following a similar approach as the one users adopt in social settings. That is, we are interested in finding which users are similar to a given one for a specific context in an online community. Following this similarity between users a function for deriving trust is defined. As a first step towards determining similarity between users we create similarity networks that can be represented by a graph. Then, we derive trust by using the similarity graph. This similarity graph will have a trust graph associated to it. Once the trust graph is also established we calculate trust by following a specific trust propagation model [3], and the similarity values we have calculated earlier.

We introduce the concept of similarity networks and design a formal model for them. Similarity between entities or users is defined with respect to a specific context that is relevant to the environment where these entities are. We define trust on top of this concept. This differs from another attempt to relate trust and similarity [4] where the assumption is that certain correlation already exists between trust and similarity and it is shown through some empirical examples. On the contrary, our only assumption is that users are related through a numerical value that defines how far in terms of a specific context they are from each other. This numerical value is a distance in our case. Then, similarity can be calculated by using this distance and a certain threshold that determines the size of the network. It could be the case when there are users who are not related at all since the similarity network depends on the threshold.

There are many cases where our model can be used and proven useful. We have presented two case scenarios, a profile matching in social networks and in an emergency scenario where the entities involved are interested in the most suitable entity that could deal with the situation in a satisfactory manner.

The structure of the paper is as follows. Section 2 reviews the related work. The first step towards building our trust model is the definition of similarity networks, which is done in Section 3. The trust model we propose is based on a specific type of trust models called Propagation models, which are presented in Section 4. The proposed model is introduced in Section 5. Some use cases are presented in Section 6. We have validated our model in one of these cases, in particular, a scenario where an emergency arises. The experimental results of the validation are presented in Section 7. Section 8 concludes the paper and outlines the future work.

@&#RELATED WORK@&#

Many definitions of trust have been provided along the years. The concept is complex and it spans across several areas such as psychology, sociology, economics, law, and more recently, computer science. The vagueness of this term is well represented by the statement ‘trust is less confident than know, but also more confident than hope’ [5].

Gambetta [6] defines trust as ‘a particular level of the subjective probability with which an agent will perform a particular action […] in a context in which it affects our own action’. McKnight and Chervany [7] explain that trust is ‘the extent to which one party is willing to depend on the other party in a given situation with a feeling of relative security, even though negative consequences are possible’. For Olmedilla et al. [8], ‘trust of a party A to a party B for a service X is the measurable belief of A in that B behaves dependably for a specified period within a specified context (in relation to service X)’. Ruohomaa and Kutvonen [9] state that trust is ‘the extent to which one party is willing to participate in a given action with a given partner, considering the risks and incentives involved’. Finally, Har Yew [10] defines trust as ‘a particular level of subjective assessment of whether a trustee will exhibit characteristics consistent with the role of the trustee, both before the trustor can monitor such characteristics (or independently of the trustor's capacity ever to be able to monitor it) and in a context in which it affects the trustor's own behaviour’. Moyano et al. [11] define trust as a subjective, context-dependent property that is required when (i) two entities need to collaborate (i.e. there is a dependence relationship between them and there exists the willingness to collaborate), but they do not know each other beforehand, (ii) and when the outcome of this collaboration is uncertain (i.e. entities do not know if they will perform as expected) and risky (i.e. negative outcomes are possible). In this situation, trust acts as a mechanism to reduce the uncertainty in the collaboration and to mitigate the risk. As risk increases (either the probability or the impact of negative outcomes), trust becomes more crucial.

Similarity graphs have been used in many applications such as for example matching text in documents [12,13]. Finding similarity between texts becomes important for instance for document clustering or web searching. Jeh and Widom [14], however, proposed an approach called SimRank that could be applied to any domain where similarity can be applied object to object. Our approach to define similarity graphs is context-independent but among other differences with this approach we consider also the case where more than one similarity graph or network can be used.

The trust model we introduce here can be seen as a propagation trust model, based on the model presented in [3], where the authors use a sequential and a parallel operator in order to compute trust along a path. These types of models assume that trust and reputation values exist regardless of how to compute them. They provide ways to calculate indirect trust relations by propagating these trust values along trust chains or trust paths. Advogato [15] is also an example of a trust propagation model that computes a reputation flow through a network where members are nodes and edges are referrals between nodes. Appleseed [16] is another trust propagation model that uses local groups in order to infer trust in them. Subjective logic [17] uses a discounting operator to compute opinions along different trust paths and a consensus operator to combine them into a final opinion.

The main contribution of this paper is the use of similarity for inferring trust. There are some approaches that consider the fact of how similar entities are for the purpose of deriving trust, however aiming at most of the cases at trust-based recommendation systems. In our approach, the purpose is not on the recommendation phase, although in a step beyond it could be used for this as well. The goal of recommender systems [1] is to suggest to the users of a system items they might be interested in. A particular type of recommender systems are those based on collaborative filtering (CF) [18], which try to automatize the search for similar users by taking into account their opinions and ratings on the items. However, these systems present some weaknesses that Massa et al. try to overcome in [19] by enhancing recommender systems by using trust information. They propose the so-called trust-aware recommender system. The idea of this enhancement is not to search for similar users as CF does but to search for trustable users by exploiting trust propagation on the trust network. Thus, if a user A trusts users B and C, A will be recommended the items that B and C appreciate.

There are in the literature some other trust-based recommender systems [20–22] that assume that similarity is already present when deriving trust between users. The relationship between similarity and trust is investigated in [4]. The authors show that these relationships exit. They made the hypothesis that there is a dependency in between these two concepts and show some empirical evaluations on the FilmTrust social network [23]. The main difference between this work and our proposal is that we do not assume the existence of similarity between users. On the contrary, we propose a model for calculating it according to certain criteria such as distance in between these users for a specific context. In [24] the authors show that the existing relationship is not only in between trust and similarity but more specifically in between trust and profile similarity, which includes many aspects of similarity with other users and not only an overall similarity.

As we have pointed out in Section 2 there is no a unique definition of the concept of trust. We observe that for these definitions there are several factors that might affect trust. The context where the entities are interacting is one of them as it can also be the task they are to perform. Together with the importance of the context or task to be carried out another important factor to be taken into account is how similar the trustor and trustee are or how similarly they are behaving in a specific context.

In real live interactions, a natural mechanism to build trust upon is similarity. People tend to trust other people that behave like them, whereas the opposite is not generally true, i.e. we do not necessarily distrust people that behave in a different way. Our intention is to simulate this behaviour that is common in social settings. We thus present a trust model that bootstraps trust as a function that considers as input the similarity of two entities regarding a particular context. A specific context might also be influenced or compose of many different factors or characteristics that can be measured and that are meaningful for the process of deriving trust. For example, in a social network environment where users exchange pictures or statements one of these influencing factors could be ‘liking a picture’.

We need to determine similarity between users for these specific factors and how similarity networks are derived. First, we need to introduce the essential concepts and methods.

Let us assume a network where different entities establish certain relationships. We denote the set of entities of the network or system by 
                        E
                     . Each entity e in 
                        E
                      can measure several factors that influence their behaviours. We will call these factors characteristics.
                        Definition 1
                        Measurable characteristic


                        A measurable characteristic is a metric space (C, d) with a minimal element denoted by 0.

This definition identifies the characteristic itself with its measure set. As an example, if we consider the temperature as a measurable characteristic in our system, the corresponding C in the metric space will be all the values that correspond to different measurements of temperature in a given setting for a certain entity. That is, a subset of the real numbers, i.e., C
                     ⊂ℝ, where each element in C is represented by c and corresponds to the different values given for a certain measurable characteristic. Since the measures are referred to the same characteristic, the only thing that distinguishes them is in what instant they were taken. Thus, we can say that measures depend on time. Then, a measure, c is really the output of a function that maps a time instant into an acceptable value from the measure set, i.e. f:T→C, where T is the time domain and f(t)=
                     c.

Let 
                        C
                      be the set of measurable characteristics in a given system, where its elements are Cj
                      for 1≤
                     j
                     ≤
                     m and m is the total number of measurable characteristics.
                        Definition 2
                        We define the measured context, 
                              
                                 
                                    
                                       C
                                       e
                                    
                                    →
                                 
                                 
                                    t
                                 
                              
                           , of an entity e as the vector of all the measured characteristics considered for e in a specific time instant, t. That is, 
                              
                                 
                                    
                                       C
                                       e
                                    
                                    →
                                 
                                 
                                    t
                                 
                                 =
                                 <
                                 
                                    c
                                    e
                                    i
                                 
                                 
                                    t
                                 
                                 >
                              
                            for i
                           =1…
                           m.


                     
                        
                           
                              
                                 C
                                 e
                              
                              →
                           
                           
                              t
                           
                        
                      can also be seen as a function, 
                        
                           
                              
                                 C
                                 e
                              
                              →
                           
                           
                              t
                           
                           :
                           T
                           →
                           
                              
                                 ∏
                                 
                                    i
                                    =
                                    1
                                 
                                 m
                              
                              
                                 
                                    C
                                    i
                                 
                              
                           
                           .
                        
                     
                  

In order to calculate how similar two entities are we have to take into account how far these measurable characteristics are for them in different situations — in a one dimension setting and in a more realistic setting as it could be a multidimensional setting.

Let us assume first the case where we need to determine how similar two entities are with respect to only one characteristic, i.e., 
                           
                              
                                 
                                    C
                                    e
                                 
                                 →
                              
                              
                                 t
                              
                           
                         is a one-dimensional vector 
                           
                              
                                 
                                    C
                                    e
                                 
                                 →
                              
                              
                                 t
                              
                              =
                              
                                 c
                                 e
                              
                              
                                 t
                              
                           
                        .

In order to determine how similar two entities are, we use the distance in the measurable characteristic set. This distance represents how close two measures are at a given instant of time. The distance between two entities e and f in time instant t for a common measurable characteristic, 
                           
                              C
                              ∈
                              C
                           
                         is defined as d(ce
                        (t), cf (t)). For simplicity, if the time and the characteristic are known we will denote this distance as d(e, f).
                           Definition 3
                           We define 
                                 
                                    
                                       G
                                       δ
                                    
                                    ⊂
                                    E
                                    ×
                                    E
                                 
                               as the set of all pairs of entities such as the distance between them is lower or equal than a given threshold δ, i.e.,
                                 
                                    
                                       
                                          
                                             G
                                             δ
                                          
                                          =
                                          
                                             
                                                
                                                   e
                                                   f
                                                
                                                ∈
                                                E
                                                ×
                                                E
                                                
                                                such
                                                
                                                that
                                                
                                                d
                                                
                                                   e
                                                   f
                                                
                                                ≤
                                                δ
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           

The closer two entities are the more similar they are. Therefore, the smaller the distance the higher the similarity is. Formally, we can define similarity as follows:
                           Definition 4
                           A similarity measure for a set 
                                 
                                    G
                                    ⊂
                                    E
                                    ×
                                    E
                                 
                               is a function, ∆ associated to a distance, d, where 
                                 
                                    Δ
                                    :
                                    G
                                    →
                                    
                                       0
                                       1
                                    
                                 
                               verifies the following properties:
                                 
                                    ●
                                    ∆(e, e)=1

∆(e, f)=∆(f, e)


                                       Δ(e,f)≤
                                       Δ(e,g) if d(e,f)≥
                                       d(e,g).

The idea of deriving a similarity function, ∆, from a distance is not new. In the literature we can find many approaches of which we can highlight the following two: ∆=
                        e
                        −d
                         
                        [25] (e is the exponential function) or 
                           
                              Δ
                              =
                              
                                 1
                                 
                                    1
                                    +
                                    d
                                 
                              
                           
                         
                        [26].

We propose a choice for this function that depends on a specific value δ. This δ could be seen as a way to bound the distance. For any δ
                        >0, the function 
                           
                              
                                 Δ
                                 δ
                              
                              :
                              
                                 G
                                 δ
                              
                              →
                              
                                 0
                                 1
                              
                           
                         is defined as follows:
                           
                              
                                 
                                    
                                       Δ
                                       δ
                                    
                                    
                                       e
                                       f
                                    
                                    =
                                    1
                                    −
                                    
                                       
                                          d
                                          
                                             e
                                             f
                                          
                                       
                                       δ
                                    
                                    .
                                 
                              
                           
                        
                     

All the three possible definitions for similarity functions work for unbounded distances, i.e., when it holds that for any λ
                        >0 there are two elements x and y such as d(x, y)λ. The main difference between our definition and the two others is that in our case δ is an upper bound for the distance, i.e. for any e,
                        f,
                        e′,
                        f′∈
                        C such as d(e,f)>
                        δ and d(e′,f′)>
                        δ, Δ(e,f)=Δ(e′,f′)=0. This means that our similarity measure does not differentiate when the distance is beyond the δ bound. In this case the similarity is set to 0 interpreting then that the entities are not similar at all.

However, in any of the different cases it for the three similarity functions the following holds,
                           
                              
                                 
                                    
                                       lim
                                       
                                          d
                                          →
                                          ∞
                                       
                                    
                                    Δ
                                    =
                                    0
                                    .
                                 
                              
                           
                        
                     

In Section 3.1 we have considered only the case where one measurable characteristic is considered. However, in real scenarios this might not be the case. It might occur that, for example, in a social network where an entity has to interact with certain users one needs information about them related to more than one characteristic such as movies I like or museums I like. Even though the two characteristics might not seem to be very related, the user building his graph of trust might be interested in these two specific characteristics.

Let us assume a scenario where there are more than one measurable characteristic to be considered, c
                        
                           j
                        (t) for a time instant t and j
                        =1,…,
                        m.

For those distances di
                         that are bounded we need to normalize them by dividing by the upper bound δi
                        , i.e., 
                           
                              
                                 
                                    d
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 d
                                 i
                              
                              
                                 δ
                                 i
                                 
                                    −
                                    1
                                 
                              
                           
                        . For the distances that are not bounded we have to use an equivalent bounded distance, e.g., 
                           
                              
                                 
                                    d
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 
                                    d
                                    i
                                 
                                 
                                    
                                       d
                                       i
                                    
                                    +
                                    1
                                 
                              
                           
                        .

We can define a new distance for the new combined characteristic 
                           
                              
                                 C
                                 ^
                              
                              =
                              
                                 
                                    ∏
                                    
                                       j
                                       =
                                       1
                                    
                                    m
                                 
                                 
                                    
                                       C
                                       j
                                    
                                 
                              
                           
                        ,
                           
                              
                                 
                                    
                                       
                                          
                                             d
                                             ^
                                          
                                          :
                                       
                                       
                                          
                                             C
                                             ^
                                          
                                          ×
                                          
                                             C
                                             ^
                                          
                                       
                                       
                                          →
                                       
                                       
                                          
                                             0
                                             1
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      c
                                                      i
                                                   
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                
                                                   
                                                      c
                                                      i
                                                      ′
                                                   
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                          
                                       
                                       
                                          ↦
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                
                                                   α
                                                   i
                                                
                                                
                                                   
                                                      d
                                                      i
                                                   
                                                   ¯
                                                
                                                
                                                   
                                                      c
                                                      i
                                                   
                                                   
                                                      c
                                                      i
                                                      ′
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 m
                              
                              
                                 
                                    α
                                    j
                                 
                                 =
                                 1
                              
                           
                        . αi
                         are representative of the relevance of each characteristic as all the distances have been normalized.

Once a new measurable characteristic, 
                           
                              
                                 C
                                 ^
                              
                              
                                 d
                                 ^
                              
                           
                        , has been defined we can derive a similarity measure by using Definition 4. Even though the values for αi
                         have been normalized in order to represent meaningful characteristics it could be that as the new similarity is defined as a summation the result goes beyond the bound. Therefore, we might need to be more strict in these cases and impose a lower bound for each characteristic instead of the one defined above.

The entities in the network will form a network where they have established some relationships based on the similarities that can be calculated as described in Sections 3.1 and 3.2. From these definitions of similarity we can build the similarity network, which can be defined as follows.
                           Definition 5
                           The similarity network for a characteristic C in instant 
                                 
                                    t
                                    ∈
                                    T
                                 
                               with threshold δ, S
                              
                                 t,δ
                              
                              
                                 c
                              , is defined as a the set of elements (e,
                              f,
                              Δ
                              
                                 δ
                              (e,f))∈
                              
                                 E
                              
                              ×
                              
                                 E
                              
                              ×
                              ℝ where Δ
                              
                                 δ
                              (e,f)>0, is the proposed similarity measure for characteristic C.

Let us consider a similarity network where their users are connected and a different value for δ is set. Thus, if the vertical axis corresponds to the values of δ, we can see in Fig. 1
                               how the similarity network becomes smaller as δ increases. The edges of the connected nodes in the network are represented in the figure by a thicker line.

In the previous section we defined how a similarity network can be obtained. According to this definition a similarity network can be seen as a labelled graph. If we consider a graph in which edges represent some kind of similarity or special relationship, we can easily transform it into a characteristic, forcing the similarity network to be always a sub-graph of it.

Let us consider first an example of a graph such as in Fig. 2
                        :

We can construct the following characteristic C
                        ={Aa,Ab,Ac,Ad}, the distance in C is the graph distance, defined as the minimal number of hops needed in order to reach one node from another one, i.e. d(Aa,Ab)=1, d(Aa,Ac)=2, d(Ab,Ac)=1, d(Aa,Ad)=1 and d(Ad,Ac)=1.

We can now use Δ2 in order to enforce that two entities are similar with regards to the defined characteristic. In this case Δ2
                        =0 if the nodes are connected by more than 1 vertex and Δ2
                        =0.5 if they are neighbours. Using this similarity measure in a multidimensional setting with 
                           
                              Δ
                              ^
                           
                         will result in a similarity graph that is in fact a sub-graph of the initial graph.

Moreover, our model also supports mobility of nodes because the characteristics are measured in time.

In Section 3 we have presented a way to determine similarity networks. These networks can be seen as a labelled graph. Taking advantage of the graph structure it would be very convenient to have an appropriate model for deriving trust that is used then as the underlying method. Trust in a virtual community can be modelled by using a trust graph, that is, a graph where the vertices are the entities of the network and the edges are the trust relationships established between two entities.

The trust model that can fit into these requirements are propagation models. Propagation models often assume that several trust relationships have already been established and quantified, although this is not always the case. They aim to create new trust relationships by disseminating the trust value information to other entities. For example, Advocato [27] is a reputation model that allows users of the community to provide a ranking for other users. However, it is also a propagation model, since it allows computing a reputation flow through a network where members are nodes and edges are referrals between nodes. New trust values are often computed by means of operators, and in several models, we find two of them: a concatenator and an aggregator. The former is used to compute trust along a trust path or chain, whereas the latter aggregates the trust values computed for each path into a final trust value. For example, in [3] the authors use a sequential and a parallel operator in order to compute trust along a path. Subjective logic [17] uses a discounting operator to compute opinions along different trust paths, and a consensus operator to combine them into a final opinion.

In order to define the trust graph it has to be refereed to a certain context. This is what we will define next as trust domain.
                        Definition 6
                        Trust domain


                        A trust domain is a partially ordered set (TD,<,0) where every finite subset of TD has a minimal element in the subset and 0 represents the minimal element of TD.

A particular trust domain is the interval [0, 1), where 0 means that there is no trust and 1 means full trust. By 0 we do not mean distrust but absence of trust evidences. Distrust can be modelled as trust or belief that a certain entity will behave dishonestly.

Let us assume a network where the nodes interact among them. Trust can be modelled by using a directed graph where the vertices are the entities and the edges correspond to the trust relationships between the entities that the edge links.

Our definition of trust states that trust can be defined as the level of confidence that an entity s places on another entity t for performing a given task in a proper and honest way. The confidence level may vary depending on the task, or as we called it in previous sections a measurable characteristic. Assuming that the level of confidence is a real number and that for each task there is only one associated trust value in our reasoning system, the trust graph is a weighted digraph.

Trust can be tailored to tasks [28] but in our case we use a broader concept, context. The context includes all relevant information for the trust making decision.

In order to define the function for deriving trust we need to use the definition of trust statement.
                        Definition 7
                        Trust statement


                        A trust statement is an element (Trustor,
                           Trustee,
                           c,
                           t,
                           Trust
                           
                              c,t
                           ) in 
                              
                                 E
                                 ×
                                 E
                                 ×
                                 C
                                 ×
                                 T
                                 ×
                                 TD
                              
                           , where 
                              E
                            and 
                              C
                            are the sets defined above and 
                              TD
                            is a trust domain whose elements Trust
                           
                              c,t
                            are calculated as a function, f such that Trust
                           
                              c,t
                           
                           =
                           f(Δ
                              c,t
                           (e,f)).

Note that Δ
                        c,t
                     (e,f) is the similarity measure corresponding to each 
                        
                           C
                           ∈
                           C
                        
                     .

One important property of function f is that it is monotonically increasing. This means that the smaller the distance in between elements is the more similar they are and therefore the value of trust that one of them places on the other one is higher as well.

In Definition 7 we have introduced how trust is calculated in between two entities by means of the similarity measures. However, in a trust graph representation, as we are considering, trust should be calculated along a path. Therefore, we need to use specific functions that allow us to calculate these trust values. For this reason we introduce the notion of trust evaluation.
                           Definition 8
                           A trust evaluation is a function 
                                 
                                    F
                                    :
                                    E
                                    ×
                                    E
                                    ×
                                    C
                                    ×
                                    T
                                    →
                                    TD
                                 
                               where 
                                 E
                              , 
                                 C
                              , 
                                 T
                               and 
                                 TD
                               are the sets defined above.

We will concentrate on local trust evaluations that can be decomposed into sequential and parallel trust functions. This decomposition will allow us to operate with the evaluations that could be applied to a variety of scenarios. For convenience we will assume that the elements of 
                           E
                         and 
                           C
                         are given and we can omit them.
                           Definition 9
                           Sequential trust function


                           A sequential trust function is a function, 
                                 
                                    f
                                    :
                                    
                                       
                                          ∪
                                          
                                             n
                                             =
                                             2
                                          
                                          ∞
                                       
                                       
                                          
                                             
                                                
                                                   TD
                                                   ×
                                                   ⋯
                                                   ×
                                                   TD
                                                
                                                ︷
                                             
                                             n
                                          
                                          →
                                          TD
                                       
                                    
                                 
                              , that calculates the trust level associated to a path or chain of trust statements, such that f(v
                              1,…,v
                              
                                 n
                              )=0 if, and only if, v
                              
                                 i
                              
                              =0 for any i
                              ∈{1,…,n}, where 
                                 
                                    
                                       v
                                       i
                                    
                                    ∈
                                    TD
                                 
                               and 
                                 TD
                               is a trust domain.

Each path of trust statements in a graph G is represented as the chain, 
                           
                              
                                 e
                                 1
                              
                              
                                 
                                    →
                                    
                                       v
                                       1
                                    
                                 
                              
                              
                              
                                 e
                                 2
                              
                              
                                 
                                    →
                                    
                                       v
                                       2
                                    
                                 
                              
                              ⋯
                              
                                 
                                    →
                                    
                                       v
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                 
                              
                              
                              
                                 e
                                 n
                              
                              
                                 
                                    →
                                    
                                       v
                                       n
                                    
                                 
                              
                              
                              
                                 e
                                 
                                    n
                                    +
                                    1
                                 
                              
                           
                        , where ei
                         are entities in 
                           E
                         and vi
                         are respectively the trust values associated to each statement.
                           Definition 10
                           Parallel trust function


                           
                              A parallel trust function is used to calculate the trust level associated to a set of paths or chains of trust statements. it is defined as, 
                                 
                                    g
                                    :
                                    
                                       
                                          ∪
                                          
                                             n
                                             =
                                             2
                                          
                                          ∞
                                       
                                       
                                          
                                             
                                                
                                                   TD
                                                   ×
                                                   ⋯
                                                   ×
                                                   TD
                                                
                                                ︷
                                             
                                             n
                                          
                                          →
                                          TD
                                       
                                    
                                 
                              , where 
                                 TD
                               is a trust domain and
                                 
                                    1.
                                    
                                       g(z
                                       1,…,z
                                       
                                          i
                                          −1,z
                                       
                                          i
                                       ,z
                                       
                                          i
                                          +1,…,z
                                       
                                          n
                                       )=
                                       g(z
                                       1,…,z
                                       
                                          i
                                          −1,z
                                       
                                          i
                                          +1,…,z
                                       
                                          n
                                       )if
                                       z
                                       
                                          i
                                       
                                       =0


                                       g(z)=
                                       z.

The sequential and parallel trust functions verify certain properties as stated in [3]. Some examples of functions that verify those definitions are the following:
                           
                              •
                              Sequential. Minimum, Product, Maximum, Mean.

Parallel. Minimum, Maximum, Mean, Median.

That is, we first apply the sequential function f to each path connecting entities e and f, obtaining the partial values pi
                        . Finally, we apply the parallel function to the set of values {p
                        
                           i
                        }
                           i
                           =0
                        
                           n
                        .

The model presented is this paper can be easily adapted to specific scenarios. In particular, we are going to consider an emergency scenario where trust is established by a proximity-based relationship. The experimental results from its validation are going to be shown in Section 7.

By proximity-based trust establishment we understand that two entities are to trust each other if their locations are close enough. Location can be easily modelled as a characteristic and the similarity measure will indeed establish a kind of threshold for distance between two entities that are to trust each other.

Location can be encoded as a GPS coordinate or as descriptive areas. In any case, it is important to define the distance associated with the characteristic set. For the GPS coordinates, the distance can be measured as the linear distance or it could measure actual distances using specific routes. For descriptive areas, in case they can be located in a map we can measure the distance between their gravity centre or use a similar technique and, in case they are abstract locations we can make use of discrete distances that represent levels of proximity, e.g. 1 for close, 2 for far and 3 for very far. The precision will determine the granularity of the corresponding similarity networks.

Proximity on its own can be used to establish trust but it can also be combined with other characteristics. If there are two different characteristics C
                        1 and C
                        2, being C
                        2 the location, we can use the 
                           
                              
                                 Δ
                                 ^
                              
                              δ
                           
                         similarity function in such a way that no matter how similar two nodes are regarding C
                        1, they will not be connected in the similarity network unless some threshold for the location distance, dependant on δ, holds. When they are below the threshold the other characteristics, C
                        1, could make the difference.

Let us consider a situation where an emergency comes up, for instance, someone is suffering a heart attack. It would be desirable to find sanitary staff that can attend to the ill person as soon as possible. It might be that there are more than one person around and some of them are capable of dealing with the situation. We would be however interested in finding the most suitable person close by.

In this kind of situation we are assuming that the users are connected through a type of social network for emergencies. Each of the entities involved in this social network carries with them a device (for instance an Android mobile device) that allows them to connect to a central server that is in charge of gathering values related to position, similarity and trust. This same central server will also be in charge of providing the information related to these values that the entities might request.

In our scenario we are assuming someone suffering from a heart attack. The affected entity would not share any information related to his health records under normal circumstances, but in this case he decides to trust all suitable entities in the surroundings. Our model will help him determine what is the most trusted entity, and therefore the most suitable one, for attending him on this emergency.

The measurable characteristics we are considering are the location and the medical speciality of the entity in the surrounding. The medical specialities that are going to be relevant are cardiologist, specialist other than cardiologist, general practitioner, nurse and non-medical staff. Let the entity that is requesting medical aid be e and the entities holding medical specialities f. The characteristic is defined as follows:
                              
                                 
                                    
                                       
                                          c
                                          t
                                       
                                       
                                          e
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   1
                                                   
                                                   if
                                                   
                                                   e
                                                   
                                                   is
                                                   
                                                   a
                                                   
                                                   cardiologist
                                                
                                             
                                             
                                                
                                                   0.9
                                                   
                                                   if
                                                   
                                                   e
                                                   
                                                   is
                                                   
                                                   a
                                                   
                                                   specialist
                                                   
                                                   other
                                                   
                                                   than
                                                   
                                                   a
                                                   
                                                   cardilogist
                                                
                                             
                                             
                                                
                                                   0.8
                                                   
                                                   if
                                                   
                                                   e
                                                   
                                                   is
                                                   
                                                   a
                                                   
                                                   general
                                                   
                                                   practitioner
                                                
                                             
                                             
                                                
                                                   0.7
                                                   
                                                   if
                                                   
                                                   e
                                                   
                                                   is
                                                   
                                                   a
                                                   
                                                   nurse
                                                
                                             
                                             
                                                
                                                   0
                                                   
                                                   if
                                                   
                                                   e
                                                   
                                                   is
                                                   
                                                   non
                                                   −
                                                   medical
                                                   
                                                   staff
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

This is a standard approximation where all the values relevant to the use case are close between them; whereas non-medical staff are significantly separated from the rest, i.e. d(e,f)≥0.7 when e is any entity who is a medical staff and f is not.

Defining trust relationships in social networks is often complicated and prone to errors. Our model could automatically define trust relationships based on similarity measures. In this way, users only need to choose some relevant characteristic that define them and the corresponding similarity measures.

Computations in our model can be performed in a centralized way, by the social network provider or distributively, where each user computes their own similarity networks based on the available information.

Let us consider a social network about films where users can even rate the movies they like. We can then define a measurable characteristic, ci
                        , as ‘Movies I like’. One of the users on this site, e is interested in a movie l. For the sake of simplicity we are going to consider two other users that can be compared to e (f,
                        g,
                        h). A possible graph representation for these users can be seen in Fig. 3
                        .

The first step is to calculate the similarity between these entities. If the set of movies that a specific user likes is denoted by Ci
                         where i is the entity we could measure the similarity between two entities as ♯(C
                        
                           i
                        
                        ∩
                        C
                        
                           j
                        ), where ♯ denotes the cardinality of the intersection set.

Let us assume that we set the threshold mentioned in Section 3 to δ
                        =5 and that after analysing the sets of movies that the users like and the cardinality on the intersections are calculated, the results on the similarity areas follow:
                           
                              
                                 
                                    
                                       
                                          
                                             Δ
                                             
                                                e
                                                ,
                                                f
                                             
                                          
                                          
                                             c
                                             i
                                          
                                       
                                       
                                          =
                                       
                                       
                                          5
                                       
                                    
                                    
                                       
                                          
                                             Δ
                                             
                                                f
                                                ,
                                                g
                                             
                                          
                                          
                                             c
                                             i
                                          
                                       
                                       
                                          =
                                       
                                       
                                          6
                                       
                                    
                                    
                                       
                                          
                                             Δ
                                             
                                                e
                                                ,
                                                g
                                             
                                          
                                          
                                             c
                                             i
                                          
                                       
                                       
                                          =
                                       
                                       
                                          4
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

A possible available path for computing trust in between e and g will be the one that follows the direct link that exists between them. However, since Δ
                           e,g
                        
                        c
                        
                           i
                        
                        =4, which is below the threshold δ this path is discarded and then if we are interested in computing trust between e and h we should follow the other path, whose all the similarity values are beyond the threshold.

@&#EXPERIMENTAL RESULTS@&#

In order to acquire a better understanding of how the model proposed in Section 5 works we run some experiments for the use case presented in Section 6. In these experiments we analysed how the behaviour of the model depending on the parameters δi
                     , αi
                      and the choices for the sequential and parallel operators in a multidimensional setting.

We have chosen a scenario with the characteristics that we described in Section 6, where there are ten entities involved. The positions of these entities have been represented in Fig. 4
                     .

In this scenario entity 0 is the person who is having the emergency. Entity 3, represented in black, is a cardiologist. We have used a scale of darker to lighter grey to represent the most suitable staff for attending these specific emergencies, where darker grey means more suitable than a lighter one. In our case these entities are 2, 1 and 4. Thus, 2 is specialist other than a cardiologist, 1 is a general practitioner (GP in the following) and 4 is a nurse. Nodes 5 to 7 are non-medical staff.

In this particular scenario we defined the distance associated to the positions as:
                        
                           
                              
                                 
                                    d
                                    P
                                 
                                 
                                    e
                                    f
                                 
                                 =
                                 
                                    
                                       
                                          d
                                          e
                                       
                                       
                                          
                                             
                                                c
                                                t
                                             
                                             
                                                e
                                             
                                             ,
                                             
                                                c
                                                t
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                    
                                       d
                                       max
                                    
                                 
                                 ,
                              
                           
                        
                     where de
                      is the Euclidean distance and dmax
                      is the measure of the diagonal of the box where all entities are placed, in our case 
                        
                           
                              d
                              max
                           
                           =
                           250
                           
                              2
                           
                        
                     .

For the characteristic related to the speciality we can define the distance as
                        
                           
                              
                                 
                                    d
                                    S
                                 
                                 
                                    e
                                    f
                                 
                                 =
                                 
                                    
                                       
                                          
                                             c
                                             t
                                          
                                          
                                             e
                                          
                                          −
                                          
                                             c
                                             t
                                          
                                          
                                             f
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  

Those two distances are bounded by a threshold of 1. We defined the following weights for the multidimensional distance, α
                     
                        P
                     
                     =0.9 and α
                     
                        S
                     
                     =0.1, i.e. d(e,f)=0.9d
                     
                        P
                     (e,f)+0.1d
                     
                        S
                     (e,f) when the priority is given to the position with respect to the medical speciality of the entity. We also invert the weight to give more relevance to the speciality over the position.

We filter the similarity graph by using the approach mentioned in Section 3.2. We used two parameters δE
                      and δP
                      to denote the upper bounds for the speciality and position distance respectively. In this case, δ
                     =
                     α
                     
                        E
                     
                     δ
                     
                        E
                     
                     +
                     α
                     
                        P
                     
                     δ
                     
                        P
                     .

We increase the parameters δE
                      and δP
                      in hops of 0.1 from 0.1 to 1.

For each pair of values we could use different combinations of sequential and parallel functions, as we outlined in Section 5. We have chosen the following combinations, as representative for this example:
                        
                           ●
                           <
                              Min, Max>

<
                              Min, Mean>.

For all the possible paths this combination chooses the one with the highest value by applying the maximum. We follow the weakest link approach by assigning the weights of the paths as the minimum value for each edge.

In Fig. 5
                         we can see the evolution of the trust values for two entities, 3 (on the left-hand side), who is a cardiologist, and 9 (on the right-hand side) who is non-medical staff. On the upper side we represent the case where the position is the most relevant characteristic, whereas in the lower side we represent the case where the relevance is given to the medical speciality. We can observe that in all cases the distance regarding the position of entities restrict the trust values when the threshold is lower than 0.5. If we focus on the trust value for entity 3 we can see that it reaches a high value when the threshold for the speciality is greater than 0.2, whereas for entity 9 only for high values of the speciality threshold (0.7) the values of trust are not 0, however relatively low.

We can also observe that where the relevance is given to the position trust values are better for entity 9 and worse for 3, and the other way around when the relevance is given to the speciality.

For all the possible paths this combination computes the average mean for the trust values. We still follow the weakest link approach by assigning the weights of the paths as the minimum value for each edge but the overall result will be lower because trust is computed as a consensus instead of choosing the better path.


                        Fig. 6
                         is structured as in the last section. In this figure we can also observe that in all cases the distance regarding the position of entities restrict the trust values when the threshold is lower than 0.5. In this case, the trust values do not increase as the threshold increases. We can see a peak between 0.6 and 0.7 and then a decrease. The reason is that when the thresholds increase the number of paths increase too. All paths that pass by a non-medical staff will be assigned a low value for the sequential function, i.e. the minimum, corresponding to the worst link.

In Fig. 7
                         we can see the peak in 0.7 from another perspective, where there is a decrease for the speciality threshold when giving more relevance to the speciality in the similarity function. If we fix the threshold for the position and increase the threshold for the speciality from 0.1 to 1 by 0.1 hops, there are relatively few paths up to when 0.8 is reached. In this case, the number of paths moves from 11 to 1311 paths, where only 1% obtains a trust value greater than 0.1. This explains why the Mean trust value, computed using the parallel function, decreases drastically. The explanation for the increase on the number of paths is that when the speciality threshold increases from 0.7 to 0.8, non-medical staff (c
                        =0) begin being considered neighbours of medical staff (c≥0.7).

If we look at the other axis (the position threshold) we can also observe that when fixing the speciality threshold to 0.8 the situation changes from having only one path connecting node 0 (position threshold equal to 0.6 and 0.7) with node 3 to having 1311 (position threshold equal to 0.8) as it happened earlier, with the same effect of drastic decrease of trust levels.

In order to avoid this undesirable effect we could use another parallel function as we did in Section 7.1 (the maximum) or restrict the mean only to meaningful paths, i.e. those with a trust value over some given lower threshold. If we do not restrict the mean, the resulting trust values for both thresholds set to 0.8 recommend non-medical staff whereas if we impose a lower bound of 0.1 only medical staff are recommended with high trust values (greater than 0.6).

In this paper we have presented a trust model based on similarities. In order to find the similarities between users we built similarity networks that depend on specific contexts where the entities are interacting. The similarity networks lead to the deployment of a similarity graph that is used for deriving the trust graph we are interested in. This trust graph determines the trust along a path of entities.

The main difference of our model with respect to our models that compare similarity and trust is that we do not assume that the similarity exists beforehand but we developed a way to calculate it and use it for deriving trust later on.

We have shown an example of a use case where our model could be applied. We have used a multidimensional setting where we combine proximity-based trust establishment and a profile matching. In this scenario we have assumed that an emergency arises and our model aids at finding the most suitable person to deal with it depending on the position and role of the persons involved in the scenario. This scenario has been validated and the results showed that by adjusting the thresholds and weights we can customize the behaviour of our trust model. In the examples of the validation that we have shown we could also observe that the choice of the appropriate sequential and parallel functions is crucial, and sometimes some of them could give us unsatisfactory results. The choice of these functions should be determined by the scenario and they should be adjusted according to the context where they are applied to.

In the future, we will apply our model and the implementation to other use cases. In particular, it will be very interesting how this model can be used in internet of things scenarios.

@&#ACKNOWLEDGEMENTS@&#

This work has been partially funded by the European Commission through the research project NESSoS under grant agreement number 256980 and by the Spanish Ministry of Science and Innovation through the project SPRINT (TIN2009-09237).

@&#REFERENCES@&#

