@&#MAIN-TITLE@&#The freight consolidation and containerization problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Introduced a new freight transportation problem.


                        
                        
                           
                           Proposed a linear programming formulation for the problem.


                        
                        
                           
                           Designed a customized memetic algorithm to solve problem instances of practical size.


                        
                        
                           
                           Generated benchmark instances for the problem based on typical values encountered in practice.


                        
                        
                           
                           Demonstrated our approach is superior to CPLEX for large instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Packing

Freight consolidation

Containerization

Memetic algorithm

Third-party logistics

@&#ABSTRACT@&#


               
               
                  In today’s global free market, third-party logistics providers (3PLs) are becoming increasingly important. This paper studies a problem faced by a 3PL operating a warehouse in Shanghai, China, under contract with a major manufacturer of children’s clothing based in the United States. At the warehouse, the 3PL receives textile parcel shipments from the suppliers located in China; each shipment is destined for different retail stores located across the United Sates. These shipments must be consolidated and loaded into containers of varying sizes and costs, and then sent along shipping routes to different destination ports. An express company, such as UPS and FedEx, unloads the shipments from the containers at the destination ports and distributes them to their corresponding stores or retailers by parcel delivery. The objective is to find an allocation that minimizes the total container transportation and parcel delivery costs. We formulate the problem into an integer programming model, and also propose a memetic algorithm approach to solve the problem practically. A demonstration of a good solution to this problem was a decisive factor in the awarding of the contract to the 3PL in question.
               
            

@&#INTRODUCTION@&#

The use of third-party logistics providers (3PL) has become an increasingly integral part of modern supply chain management (Marasco, 2008). Major business enterprises commonly span across several geographical locations at different sides of international borders, which makes central logistics planning difficult and inefficient. Consequently, companies prefer to employ the services of 3PLs for the storage and transportation of goods along parts of the supply chain. There are several benefits for doing so: (1) the company avoids the setup costs involved in managing the logistics in a new location; (2) 3PLs specialize in logistics and are likely to perform the required tasks more efficiently than the customer by taking advantage of economies of scale; and (3) 3PLs possess regional expertise and are therefore better able to take local conditions into account during logistics management. Furthermore, in addition to the storage and transportation of goods, 3PLs often provide other value-added services such as inbound operations, inspection, sorting, labeling, containerization, tracking and outbound operations. These and other services position 3PLs as one-stop shops for the logistical needs of their customers.

We consider the case of a major manufacturer of clothing for babies, toddlers and children. Products bearing the manufacturer’s brand are sold at over 400 company-owned retailer stores as well as thousands of national department stores and some of the largest retailers across the United States. The company has outsourced some of its manufacturing needs to suppliers located in China, taking advantage of the lower costs in this rapidly developing region. As a result, they have contracted with 3PLs based in China for transporting these manufactured products to their target markets. This enables the company to focus on its core business while saving on costs without sacrificing product quality.

This study is motivated by a project awarded to our team by a 3PL that services the manufacturer via a warehouse hub in Shanghai, China. The 3PL industry in China has experienced significant and rapid growth since the economic reforms of 1978 when its borders were opened to foreign investors, and especially since its entry into the World Trade Organization in 2001. Historically, the main concern of investors with regards to logistics in China is its poor transport infrastructure (Ta, Choo, & Sum, 2000), a concern that has been addressed by the rapid development and modernization of the country in the past decades. There is therefore tremendous growth potential in the Chinese logistics market, resulting in intense competition that requires 3PLs in China to constantly seek new sources of competitive advantage (Wang, Zantow, Lai, & Wang, 2006).

The transportation process that concerns the 3PL in question is briefly described as follows. First, the suppliers send the finished goods from their manufacturing plants to the warehouse hub operated by the 3PL via domestic truck transportation. Next, the 3PL loads the goods into containers of various sizes and ships these containers to distribution hubs situated in the United States, each of which is operated by an express delivery company such as FedEx or UPS. Finally, the express company unloads the goods from the containers and distributes them to the corresponding stores or retailers by parcel delivery.


                     Fig. 1
                      illustrates the transportation network, which can be viewed as a type of hub-and-spoke network. At the warehouse hub, the 3PL provides the manufacturer with value-added services; no extra services beyond the delivery of the goods are required from the express company at the distribution hubs. The goods can be shipped to any of several distribution hubs from the warehouse hub. Therefore, there are several possible transportation routes that a shipment of goods destined for a particular store can take, as illustrated in Fig. 2
                     . This study examines the scenario that is relevant to our client, where there is only a single warehouse hub with multiple distribution hubs. We refer to the warehouse hub in Shanghai as the origin hub, and the distribution hubs in the United States as destination hubs.

The inventory of the stores is replenished periodically, and each store may demand goods from one or several suppliers. For each period, the manufacturer aggregates the demands of its stores and places orders with suppliers. In most cases, the total volume of demanded goods for a single store in one time period is much less than the capacity of a single container, which is one Twenty-foot Equivalent Unit (TEU); hence, consolidating goods for different stores into one container becomes necessary for reducing transportation cost. In order to facilitate the consolidation process, the manufacturer stipulates that the suppliers must send their goods to the origin hub within a predetermined time window that ranges from one day to several days. Since there is only one origin hub in our problem, the cost of truck transportation is fixed and we can assume that all goods have already arrived at the origin hub. The goods heading to the same store are combined into one shipment at the origin hub, so a single shipment may consist of one or several items. To simplify some store operations such as tracking and receiving goods, it is required that all items in one shipment must be transported along a single route, but they are allowed to be loaded into different containers.

In this study, we investigate the freight consolidation and containerization problem (FCCP). It models the task faced by the 3PL, which requires the assignment of shipments to routes as well as items to containers, with the objective of minimizing the total cost of two transportation modes, namely container transportation and parcel delivery. We assume that each item transported by the 3PL is an indivisible textile package that must be loaded into only one container. Moreover, the flexibility and non-fragility of textiles allow us to treat the process of loading items into containers as a variable sized bin packing problem (VSBPP). The main difficulty lies in managing the tradeoff between container transportation cost and parcel delivery cost: on one hand, if we send every shipment to the destination hub with the cheapest associated parcel delivery cost, the containers may be underutilized; on the other hand, if we try to minimize container cost by loading each container as fully as possible, then higher parcel delivery costs may be incurred for some shipments.

The FCCP models an actual problem that combines goods consolidation and containerization (i.e., container loading). In contrast to other typical services such as inspection and tracking, a good solution to this problem translates directly into cost savings that can be passed onto the customers, which provides the 3PL with a competitive advantage. In fact, a demonstration of this capability was a decisive factor in the awarding of the contract by the manufacturer to the 3PL in question. Furthermore, consolidation and containerization often exist in tandem in the logistics industry, and the FCCP is likely to be applicable in a variety of practical scenarios. To the best of our knowledge, this problem has not been investigated in the existing literature.

The contributions of this paper are twofold. Firstly, we formally define the problem examined in this article, and also provide an integer programming (IP) model for it. Secondly, the problem is easily shown to be NP-hard. To solve it practically, we focus our efforts on devising an efficient heuristic approach that provides high quality solutions within a reasonable amount of computing time. Consequently, we propose a memetic algorithm (MA) for the FCCP that combines genetic algorithm operations, local search, and a heuristic for the VSBPP. The effectiveness of our algorithm was verified via extensive experiments on a large number of generated test instances.

The remainder of this paper is structured as follows. In Section 2, we give an overview of the relevant research in existing literature. We provide a formal description of the problem in Section 3, along with a mixed integer formulation and a brief discussion of the computational complexity of the problem. Section 4 describes the details of our MA approach. We evaluate our approach using a large set of generated test instances, which are described in Section 5 along with the computational results. Finally, we conclude our article in Section 6 and suggest some possible directions for future research.

@&#LITERATURE REVIEW@&#

Freight consolidation, which is an important practice in logistics management, has been investigated extensively. The related research can be categorized into two main categories depending on whether the decisions are made at the strategic level or the operational level. The strategic level is concerned with the design of networks, involving decisions on factors such as the number and locations of consolidation centers and the capacity of each center. The aim is to minimize the long-term overall cost, including transportation cost, consolidation center setup cost, inventory cost and labor cost. We refer the reader to Ahuja, Magnanti, and Orlin (1993) for a thorough review of these network design problems. Hub-and-spoke is a typical network topology for freight consolidation that has been widely adopted in different transport sectors. Consequently, there is a large body of literature studying the design of hub-and-spoke networks, such as air transportation (Martín & Román, 2004), truck transportation (Cunha & Silva, 2007), railway transportation (Jeong, Lee, & Bookbinder, 2007), sea transportation (Takano & Arai, 2009), and express delivery service (Kara & Tansel, 2001).

The operational level deals with the planning and execution of product distribution on an existing network configuration. Klincewicz (1990) presented a model in which each shipment can be sent from source to destination either directly or via a consolidation terminal. At the terminal, the products bound for the same destination are combined into one shipment and incur linear inventory holding cost. To embody the value of consolidation, i.e., economics of scale, the authors assumed that the shipping costs are piecewise linear concave functions of the shipping volume. Heuristics incorporating facility location techniques were developed to solve the model. Liu, Li, and Chan (2003) studied a transportation model allowing two delivery methods: one is direct shipment, where goods are collected from a supplier and directly sent to multiple customers, and the other is hub-and-spoke shipment in which various types of goods are collected from suppliers and consolidated at hubs, and then redistributed to multiple customers. Homogeneous vehicles are used to carry out all goods movements, and the objective is to minimize the total traveling distance of the vehicles. The authors designed a heuristic that utilizes a solution improvement procedure to determine the delivery method for the goods demanded by each customer and to schedule the vehicles.


                     Song, Hsu, and Cheung (2008) introduced a consolidation problem that aims at coordinating shipments between suppliers and customers through a consolidation center. This problem requires decisions to be made on the inbound and outbound times of the shipments while considering multiple factors including product release and latest arrival times, different consolidation policies, multiple transportation options, and inventory costs. A dual-based heuristic was devised to solve the problem. Leung, Hui, Wang, and Chen (2009) proposed a problem of determining the optimal integrations and consolidations of air cargo shipments. A shipment commonly goes through a number of sequential activities, such as pickup, truck transportation, warehousing and air transportation. Integration and consolidation are defined as assigning consecutive activities of a shipment and the similar activities of different shipments to one agent, respectively. A solution procedure that includes heuristics and a branch-and-bound algorithm was designed for the problem. Other freight consolidation models at the operational level can be found in Popken (1994), Croxton, Gendron, and Magnanti (2003), Dror and Hartman (2007), etc.

This study addresses a freight consolidation problem at the operational level with a hub-and-spoke distribution network. The most significant difference between our research and previous work is the fact that the loading of items into containers of various sizes is explicitly considered; this reflects the use of containers with different standard sizes in industry, such as the standard 20-ft, the standard 40-ft and the 40-ft high cube containers.

It has been shown that since the VSBPP is an extension of the one-dimensional bin packing problem (1DBPP), it is NP-hard (Friesen & Langston, 1986). Three types of solution approaches have been applied to the VSBPP, namely exact algorithms (Alves & Valério de Carvalho, 2007; Correia, Gouveia, & Saldanha-da Gama, 2008; Haouari & Serairi, 2011), approximation algorithms (Epstein & Levin, 2008; Kang & Park, 2003), and heuristics (Haouari & Serairi, 2009). Over the course of our MA, a large number of VSBPPs must be solved. Therefore, an efficient and effective solution approach to the VSBPP is crucial. After comparing the solution qualities and running times of several solution approaches, we came to the conclusion that a heuristic approach is most suitable for handling the VSBPPs in our MA.

We assume that each shipping route can provide a sufficient number of containers of different sizes. Each container is characterized by three attributes: shipping route, price, and capacity. In practice there is a fourth attribute of weight limitation, but since the products in our problem are light textiles that commonly do not exceed the container weight limitations even when being fully loaded, so we do not include this aspect in the model.

The FCCP can be modeled in the following manner. Let S and R be the sets of shipments and shipping routes, respectively. Each shipment k
                     ∈
                     S may consist of one or multiple items, and set I comprises all items, each having a size v
                     
                        i
                     . The shipment containing item i
                     ∈
                     I is denoted by S(i). The collection of all containers is denoted by set B, and the attributes of each container j
                     ∈
                     B are shipping route R(j), price p
                     
                        j
                      and capacity V
                     
                        j
                     . We assume that all containers with the same size and shipping route have the same price. The parcel delivery cost associated with assigning item i to container j is given by r
                     
                        i, j
                     . Note that once an item is assigned to a shipping route, its parcel delivery cost is determined since this cost is only related to the locations of the destination hub and its store. In particular, assigning an item to any container in a given shipping route would incur the same parcel delivery cost r
                     
                        i, j
                     .

We define three types of binary decision variables in our model. Let x
                     
                        i, j
                      be a binary decision variable that is equal to 1 if item i is loaded into container j, and 0 otherwise; let z
                     
                        k, l
                      be equal to 1 if shipment k is assigned to route l, and 0 otherwise; and let y
                     
                        j
                      be equal to 1 if container j is used, and 0 otherwise. The following is an IP model for the FCCP:
                        
                           (1)
                           
                              (
                              IP
                              )
                              :
                              
                              
                                 min
                              
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       B
                                    
                                 
                              
                              
                                 
                                    p
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       B
                                    
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              s
                              .
                              t
                              .
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       B
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              =
                              1
                              ,
                              
                              for
                              
                              all
                              
                              i
                              ∈
                              I
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ⩽
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                              for
                              
                              all
                              
                              i
                              ∈
                              I
                              
                              and
                              
                              j
                              ∈
                              B
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ⩽
                              
                                 
                                    z
                                 
                                 
                                    k
                                    ,
                                    l
                                 
                              
                              ,
                              
                              for
                              
                              all
                              
                              i
                              ∈
                              I
                              :
                              S
                              (
                              i
                              )
                              =
                              k
                              
                              and
                              
                              j
                              ∈
                              B
                              :
                              R
                              (
                              j
                              )
                              =
                              l
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       R
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    k
                                    ,
                                    l
                                 
                              
                              =
                              1
                              ,
                              
                              for
                              
                              all
                              
                              k
                              ∈
                              S
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                              
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ⩽
                              
                                 
                                    V
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                              for
                              
                              all
                              
                              j
                              ∈
                              B
                           
                        
                     
                     
                        
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          ,
                                          
                                             
                                                y
                                             
                                             
                                                j
                                             
                                          
                                          ∈
                                          {
                                          0
                                          ,
                                          1
                                          }
                                          ,
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          I
                                          
                                          and
                                          
                                          j
                                          ∈
                                          B
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                z
                                             
                                             
                                                k
                                                ,
                                                l
                                             
                                          
                                          ∈
                                          {
                                          0
                                          ,
                                          1
                                          }
                                          ,
                                          
                                          for
                                          
                                          all
                                          
                                          k
                                          ∈
                                          S
                                          
                                          and
                                          
                                          l
                                          ∈
                                          R
                                       
                                    
                                 
                              
                           
                        
                     
                  

The objective (1) is to minimize the total transportation cost. Constraints (2) guarantee that each item is loaded into only one container. The container into which any item is loaded must be marked as “used”, which is realized by Constraints (3). Constraints (4) state that if item i is loaded into container j, the shipment that includes item i must be assigned to the shipping route that provides container j. Constraints (5) ensure that each shipment must be assigned to only one shipping route. Constraints (6) require that the capacity limitations of the containers are not violated.

Observe that a special case of the FCCP that involves only one shipping route is essentially a generalized cost variable-sized bin packing problem (Epstein & Levin, 2008). From another perspective, if we assume that each container is large enough to accommodate all items in I, then only a single (cheapest) container will be needed on each shipping route. Consequently, by viewing container prices as facility setup costs, the classical uncapacitated facility location problem (Drezner & Hamacher, 2004) can also be reduced to the FCCP. These observations prove the NP-hardness of the FCCP, which implies that it is impossible to find a polynomial-time algorithm to solve the problem unless P
                     =
                     NP. In addition, preliminary experiments revealed that although small instances of the FCCP can be solved by the leading commercial IP solver ILOG CPLEX 11.1, the computation time required increases astronomically as the size of the problem increases. Hence, to obtain high quality solutions to the FCCP in a practical time frame, we developed an MA for the problem.

Genetic algorithm (GA) is a search meta-heuristic based on the process of natural evolution, such as natural selection and sexual reproduction. Since the pioneering work of Holland (1975), GA has proven to be a highly successful technique for solving a wide variety of combinatorial optimization problems (see Goldberg, 1989; Mitchell, 1998; Sivanandam & Deepa, 2008). A natural modification of the GA approach is to include a local search component in order to find better solutions over the course of the evolutionary process. This technique has been called a memetic algorithm (MA), which has been successfully employed in a variety of applications. The reader is encouraged to refer to Moscato (1999), Lu and Hao (2010), Ngueveu, Prins, and Wolfler Calvo (2010) for the details and applications of MA.

Our MA approach begins by generating an initial chromosome set, each member of which corresponds to a feasible solution to the FCCP. A fitness function is used to evaluate chromosomes. We maintain two chromosome sets of fixed sizes: a population set P
                     
                        I
                      for generating offspring, and an offspring set P
                     
                        O
                      that includes all the newly generated offsprings. In each generation, we choose chromosomes from the population set using an elitist scheme favoring fitter members to be parents, and then use the chosen chromosomes to generate offspring set by reproduction. We call the set P
                     
                        I
                     
                     ∪
                     P
                     
                        O
                     , which is the combination of the population and offspring sets, the candidate set; the same elitist strategy is employed to select chromosomes from the candidate set to construct the population for the next generation. The above process runs iteratively until a termination criterion is satisfied and a near-optimal solution can be retrieved from the fittest member of the population.

In summary, the MA proposed in this paper consists of six components: (1) chromosome representation; (2) generation of the initial population; (3) fitness function; (4) selection process; (5) offspring generation, including crossover, mutation and local refinement of chromosomes; and (6) termination criterion. The process of our MA approach is shown in Algorithm 1. The remainder of this section presents the detailed description of its components.
                        Algorithm 1
                        Process of the memetic algorithm.
                              
                                 
                                    
                                    
                                    
                                       
                                          1:
                                          
                                             P
                                             
                                                I
                                             ← generate the initial population;
                                       
                                       
                                          2:
                                          Evaluate the chromosomes in P
                                             
                                                I
                                             ;
                                       
                                       
                                          3:
                                          
                                             while the termination criterion is not satisfied do
                                          
                                       
                                       
                                          4:
                                          
                                             
                                             P
                                             
                                                O
                                             
                                             ←∅
                                       
                                       
                                          5:
                                          
                                             
                                             repeat
                                          
                                       
                                       
                                          6:
                                          
                                             Randomly select two parent chromosomes from P
                                             
                                                I
                                             ;
                                       
                                       
                                          7:
                                          
                                             Produce two offsprings from the parent chromosomes using crossover;
                                       
                                       
                                          8:
                                          
                                             Insert offsprings into P
                                             
                                                O
                                             ;
                                       
                                       
                                          9:
                                          
                                             
                                             until 
                                             P
                                             
                                                O
                                              is full;
                                       
                                       
                                          10:
                                          
                                             
                                             for each chromosome in P
                                             
                                                O
                                              
                                             do
                                          
                                       
                                       
                                          11:
                                          
                                             Perform the mutation operation;
                                       
                                       
                                          12:
                                          
                                             Perform the refinement operations;
                                       
                                       
                                          13:
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          14:
                                          
                                             Evaluate the chromosomes in P
                                             
                                                O
                                             ;
                                       
                                       
                                          15:
                                          
                                             
                                             P
                                             ←
                                             P
                                             
                                                I
                                             
                                             ∪
                                             P
                                             
                                                O
                                             ;
                                       
                                       
                                          16:
                                          
                                             
                                             P
                                             
                                                I
                                             
                                             ←∅;
                                       
                                       
                                          17:
                                          
                                             Insert the best chromosome of P into P
                                             
                                                I
                                             ;
                                       
                                       
                                          18:
                                          
                                             Select chromosomes using roulette-wheel selection from P to insert into P
                                             
                                                I
                                              until P
                                             
                                                I
                                              is full;
                                       
                                       
                                          19:
                                          
                                             end while
                                          
                                       
                                       
                                          20:
                                          Return the best chromosome in P
                                             
                                                I
                                             .
                                       
                                    
                                 
                              
                           
                        

In our approach, the information coded into a chromosome simultaneously specifies the assignment of shipments to shipping routes and the loading sequence of items into containers. A gene consists of a 2-tuple and the number of genes in a chromosome is equal to the number of items, i.e., n
                        =∣I∣. Formally, we express a chromosome as a vector χ
                        =((τ
                        1, σ
                        1), …, (τ
                        
                           i
                        , σ
                        
                           i
                        ), …, (τ
                        
                           n
                        , σ
                        
                           n
                        )), where τ
                        
                           i
                         and σ
                        
                           i
                         represent the shipping route and loading order of item i, respectively. The genes in a chromosome are grouped into ∣S∣ blocks, each corresponding to a shipment. Since our chromosome encoding does not contain information on how the items are loaded into containers, to transform a chromosome into a feasible solution of the FCCP requires the solutions of several one-dimensional VSBPPs with a pre-determined item loading sequence; the VSBPP requires that a set of items is loaded into a number of containers with different volumes and costs such that the total cost of containers used is minimized.

An example chromosome is shown in Fig. 3
                        . This chromosome involves shipments 1, 2 and 3, which contain item sets {1, 2}, {3, 4, 5, 6} and {7, 8}, respectively. Items 1–6 and 7–8 are assigned to shipping routes 1 and 2, respectively, and the loading sequence of items 1–8 is (3, 8, 2, 4, 7, 6, 5, 1). Note that the item loading sequence is relative; for instance, on shipping route 1 we sequentially load items 3, 1, 4, 6, 5, 2 into containers since their loading orders have the relationship 2<3<4<6<7<8. As the items of each shipment must be transported along a unique shipping route, the first element of all 2-tuples in the same block are identical. To obtain a feasible solution from this chromosome, we need to solve two VSBPPs with item sequences (3, 1, 4, 6, 5, 2) and (8, 7).

To highlight the benefits of our chromosome encoding scheme, consider the alternative scheme where the number of genes is equal to the number of shipments and each gene specifies a shipping route. Using the previous example, this encoding scheme is illustrated in Fig. 4
                        , where shipments 1 and 2 are assigned to shipping route 1, and shipment 3 is assigned to shipping route 2. This encoding scheme does not explicitly specify the item loading sequence. Therefore, to calculate the cost of the containers associated with a chromosome, we need to solve at most ∣R∣ VSBPPs without fixed item loading sequences. For example, for the chromosome shown in Fig. 4, we must solve two VSBPPs, one for shipping route 1 with item set {1, 2, 3, 4, 5, 6}, the other for shipping route 2 with item set {7, 8}.

Over the course of the MA, a large number of chromosomes are generated. Consequently, since we require high quality solutions to the corresponding VSBPPs within a reasonable amount of computation time, we can only employ very simple heuristics for this purpose, e.g., adaptations of the first-fit, best-fit, first-fit decreasing, or best-fit decreasing heuristics for the 1DBPP (Simchi-Levi, 1994), and such heuristics only generate one packing pattern for a given input item set. In contrast, the first encoding scheme allows the MA to produce multiple packing patterns (Haouari & Serairi, 2009), which greatly increases the potential of identifying high quality solutions.

The first chromosome in the initial population corresponds to the greedy assignment of all items in a shipment such that the shipping route τ
                        
                           i
                         for item i is the route with the smallest parcel delivery cost r
                        
                           i, j
                        ; this greedy heuristic approximates the approach employed by the decision-makers at the 3PL prior to this research. For the remaining chromosomes, the values of τ
                        
                           i
                         are randomly selected from the set S. The item loading sequences (σ
                        1, …, σ
                        
                           n
                        ) for all chromosomes are randomly generated permutations.

The MA ranks chromosomes based on a value that is calculated using a fitness function. Given a chromosome, let the vector ξ
                        
                           l
                        
                        =(ξ
                        
                           l
                        (1), …, ξ
                        
                           l
                        (n
                        
                           l
                        )) denote the loading sequence of the n
                        
                           l
                         items assigned to shipping route l. For the chromosome shown in Fig. 3, we have ξ
                        1
                        =(3, 1, 4, 6, 5, 2) and ξ
                        2
                        =(8, 7).

Each shipping route l
                        ∈
                        R in a chromosome χ is given a fitness value Θ
                        
                           l
                        (χ), computed as: Θ
                        
                           l
                        (χ)=
                        D
                        
                           l
                        (χ)+
                        C
                        
                           l
                        (χ)+
                        α(1−
                        F
                        
                           l
                        (χ)), where D
                        
                           l
                        (χ) is the parcel delivery cost, C
                        
                           l
                        (χ) is the container cost, F
                        
                           l
                        (χ) is a measure of the utilization rate of the containers, and α is a user-defined parameter. When no items are assigned to shipping route l, Θ
                        
                           l
                        (χ)=0. The overall fitness of a chromosome χ is the sum of the fitness values of its component shipping routes, i.e., 
                           
                              Θ
                              (
                              χ
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    l
                                    ∈
                                    R
                                 
                              
                              
                                 
                                    Θ
                                 
                                 
                                    l
                                 
                              
                              (
                              χ
                              )
                           
                        .

Recall from Section 3 that once an item is assigned to a particular shipping route, its parcel delivery cost is determined. Therefore, D
                        
                           l
                        (χ) can be directly computed from the information in ξ
                        
                           l
                        .

To compute C
                        
                           l
                        (χ), we need to solve a VSBPP with a predetermined item loading sequence (we refer to this problem as VSBPPS). The VSBPPS assumes the following procedure: starting from the first item, select a container and sequentially load the items into it according to the loading sequence. If the current container cannot accommodate the current item, close it and select another container for loading. When all items are loaded into containers, we have found a feasible solution to the VSBPPS. The task is to find the best selection of containers so as to minimize the total container cost.


                        Haouari and Serairi (2009) introduced a technique to optimally solve the VSBPPS. The authors defined an acyclic digraph G
                        =(V, A), where V consists of a node for each item and an additional dummy node, and A is constructed based on the item sizes, item loading sequence and bin sizes. The optimal solution for the VSBPPS can be obtained by identifying a shortest path in G
                        =(V, A), which is achieved using an algorithm with time complexity O(∣A∣). In a worst case, O(∣A∣) can be equal to O(∣V∣2). For the practical problem instances faced by the 3PL, the cardinality of A is generally very close to ∣V∣2 when solving most of VSBPPSs using this technique, i.e., the time complexity approaches 
                           
                              O
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             l
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                         for a given chromosome and shipping route l. Since the MA will generate a large number of chromosomes and the evaluation of each chromosome requires the solution of up to ∣R∣ VSBPPSs, this technique is too slow for our purposes.

Consequently, we devised the following dynamic programming approach to solve the VSBPPS to near optimality. Let the price and capacity of a type q container be c
                        
                           q
                         and V
                        
                           q
                        , respectively. We define the vector Π
                           m
                        
                        =(1, …, m) to be the collection of m container types for a certain shipping lane, sorted in ascending order of capacity (i.e., 1⩽
                        q
                        1
                        <
                        q
                        2
                        ⩽
                        m implies 
                           
                              
                                 
                                    V
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ⩽
                              
                                 
                                    V
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        ). Instead of solving the VSBPPS, our approach solves a modified version of the problem with the additional restriction that a newly selected container must be no larger than any previously selected container; we call this problem the restricted VSBPPS. This approach is motivated by the observation that larger containers almost always have a lower cost per unit capacity in practice, i.e., 
                           
                              
                                 
                                    c
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              /
                              
                                 
                                    V
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ⩽
                              
                                 
                                    c
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              /
                              
                                 
                                    V
                                 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         for 1⩽
                        q
                        1
                        <
                        q
                        2
                        ⩽
                        m. Therefore, selecting larger containers first is a good greedy approach for minimizing total container cost.

For a given loading sequence ξ
                        
                           l
                         and a set of available containers Π
                           m
                        , our approach solves this restricted VSBPPS optimally. Preliminary experiments revealed that the optimal solution to the restricted VSBPPS is usually very close to that of the corresponding VSBPPS, and in fact they are equal in certain instances.

We next describe our dynamic programming algorithm for the restricted VSBPPS. Let ξ(s, t)=(ξ(s), ξ(s
                        +1), …, ξ(t
                        −1), ξ(t)), t
                        ⩾
                        s be the loading sequence from item ξ(s) through ξ(t), which involves t
                        −
                        s
                        +1 items. In addition, let function f
                        
                           q
                        (ξ(s, t)) be the minimum number of type q containers required for packing ξ(s, t) if only type q containers are employed; note that the value of f
                        
                           q
                        (ξ(s, t)) can be computed in O(m) time by following the packing procedure. We denote the minimum cost of the restricted VSBPPS on loading sequence ξ(s, t) and containers Π
                           m
                         by C(ξ(s, t), Π
                           m
                        ), which can be defined recursively as follows:
                           
                              (7)
                              
                                 C
                                 (
                                 ξ
                                 (
                                 s
                                 ,
                                 t
                                 )
                                 ,
                                 
                                    
                                       Π
                                    
                                    
                                       m
                                    
                                 
                                 )
                                 =
                                 
                                    min
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   min
                                                
                                                
                                                   s
                                                   ⩽
                                                   i
                                                   <
                                                   t
                                                
                                             
                                          
                                          {
                                          C
                                          (
                                          ξ
                                          (
                                          i
                                          +
                                          1
                                          ,
                                          t
                                          )
                                          ,
                                          
                                             
                                                Π
                                             
                                             
                                                m
                                             
                                          
                                          )
                                          +
                                          
                                             
                                                c
                                             
                                             
                                                m
                                             
                                          
                                          
                                             
                                                f
                                             
                                             
                                                m
                                             
                                          
                                          (
                                          ξ
                                          (
                                          s
                                          ,
                                          i
                                          )
                                          )
                                          }
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                m
                                             
                                          
                                          
                                             
                                                f
                                             
                                             
                                                m
                                             
                                          
                                          (
                                          ξ
                                          (
                                          s
                                          ,
                                          t
                                          )
                                          )
                                          ,
                                          C
                                          (
                                          ξ
                                          (
                                          s
                                          ,
                                          t
                                          )
                                          ,
                                          
                                             
                                                Π
                                             
                                             
                                                m
                                                -
                                                1
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        where C(∅, Π
                           m
                        )=0, C(ξ(s, t), ∅)=+∞ and C(ξ(i
                        1, t), Π
                           m
                        )⩾
                        C(ξ(i
                        2, t), Π
                           m
                        )>0, if s
                        ⩽
                        i
                        1
                        <
                        i
                        2
                        ⩽
                        t.

This recursion divides the choice of container made during the packing procedure of the VSBPPS into three cases: (1) the next several items in the sequence are loaded into a number of the largest legal containers, (2) all remaining items are loaded into the containers with the largest size, or (3) the largest legal container is not selected.

For a given loading sequence ξ(s, t) and bin type q, let i
                        
                           q
                        (s) be the largest index i, s
                        ⩽
                        i
                        ⩽
                        t of an item such that all items from s to i in the loading sequence can be contained in a single container of type q, i.e., i
                        
                           q
                        (s)=max{i: f
                        
                           q
                        (ξ(s, i))=1, s
                        ⩽
                        i
                        ⩽
                        t}.

The following theorem allows us to compute the values of C(ξ(s, t), Π
                           m
                        ) efficiently using dynamic programming:
                           Theorem 1
                           
                              Let 
                              
                                 
                                    
                                       
                                          i
                                       
                                       
                                          ¯
                                       
                                    
                                    =
                                    
                                       
                                          i
                                       
                                       
                                          m
                                       
                                    
                                    (
                                    s
                                    )
                                    =
                                    max
                                    {
                                    i
                                    :
                                    
                                       
                                          f
                                       
                                       
                                          m
                                       
                                    
                                    (
                                    ξ
                                    (
                                    s
                                    ,
                                    i
                                    )
                                    )
                                    =
                                    1
                                    ,
                                    
                                    s
                                    ⩽
                                    i
                                    ⩽
                                    t
                                    }
                                 
                              
                              . Then,
                              
                                 
                                    (8)
                                    
                                       C
                                       (
                                       ξ
                                       (
                                       s
                                       ,
                                       t
                                       )
                                       ,
                                       
                                          
                                             Π
                                          
                                          
                                             m
                                          
                                       
                                       )
                                       =
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            min
                                                         
                                                         {
                                                         C
                                                         (
                                                         ξ
                                                         (
                                                         
                                                            
                                                               i
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                         +
                                                         1
                                                         ,
                                                         t
                                                         )
                                                         ,
                                                         
                                                            
                                                               Π
                                                            
                                                            
                                                               m
                                                            
                                                         
                                                         )
                                                         +
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               m
                                                            
                                                         
                                                         ,
                                                         C
                                                         (
                                                         ξ
                                                         (
                                                         s
                                                         ,
                                                         t
                                                         )
                                                         ,
                                                         
                                                            
                                                               Π
                                                            
                                                            
                                                               m
                                                               -
                                                               1
                                                            
                                                         
                                                         )
                                                         }
                                                         ,
                                                         
                                                         if
                                                         
                                                         
                                                            
                                                               i
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                         +
                                                         1
                                                         ⩽
                                                         t
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               m
                                                            
                                                         
                                                         ,
                                                         
                                                         if
                                                         
                                                         
                                                            
                                                               i
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                         =
                                                         t
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

See Appendix A. □

Before executing the dynamic programming algorithm, we perform a preprocessing phase to calculate i
                        
                           q
                        (s) for all combinations of ξ(s, t) and bin type q. In this phase, a sliding window algorithm is invoked for each bin type (see Algorithm 2). For each shipping route l in the restricted VSBPPS, Algorithm 2 runs in O(n
                        
                           l
                        ) time. Since the algorithm is performed once for each of the m bin types, the overall time complexity of the preprocessing phase is O(mn
                        
                           l
                        ). The values of i
                        
                           q
                        (s) obtained from the preprocessing phase can then be employed by the dynamic programming algorithm to run in O(mn
                        
                           l
                        ) time. Hence, the restricted VSBPPS can be solved optimally in O(mn
                        
                           l
                        ) time in this manner.

Now, we have two approaches to compute C
                        
                           l
                        (χ): one is to solve the VSBPPS with time complexity 
                           
                              O
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             l
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                         and the other is to solve the restricted VSBPPS with time complexity O(mn
                        
                           l
                        ).
                           Algorithm 2
                           Preprocessing for Type q bin.
                                 
                                    
                                       
                                       
                                       
                                          
                                             1:
                                             INPUT: size of type q bin V
                                                
                                                   q
                                                , and an item sequence ξ(s, t);
                                          
                                          
                                             2:
                                             OUTPUT: i
                                                
                                                   q
                                                (s), i
                                                
                                                   q
                                                (s
                                                +1), …, i
                                                
                                                   q
                                                (t
                                                −1), i
                                                
                                                   q
                                                (t);
                                          
                                          
                                             3:
                                             Let v[ξ(i)] be the size of item ξ(i);
                                          
                                          
                                             4:
                                             Initialize head
                                                =
                                                tail
                                                =
                                                s and volume
                                                =0;
                                          
                                          
                                             5:
                                             
                                                while 
                                                tail
                                                ⩽
                                                t 
                                                do
                                             
                                          
                                          
                                             6:
                                             
                                                
                                                while 
                                                head
                                                ⩽
                                                t and volume
                                                +
                                                v[head]⩽
                                                V
                                                
                                                   q
                                                 
                                                do
                                             
                                          
                                          
                                             7:
                                             
                                                
                                                volume
                                                =
                                                volume
                                                +
                                                v[head];
                                          
                                          
                                             8:
                                             
                                                
                                                head
                                                =
                                                head
                                                +1;
                                          
                                          
                                             9:
                                             
                                                
                                                end while
                                             
                                          
                                          
                                             10:
                                             
                                                
                                                volume
                                                =
                                                volume
                                                −
                                                v[tail];
                                          
                                          
                                             11:
                                             
                                                
                                                i
                                                
                                                   q
                                                (tail)=
                                                head
                                                −1;
                                          
                                          
                                             12:
                                             
                                                
                                                tail
                                                =
                                                tail
                                                +1;
                                          
                                          
                                             13:
                                             
                                                end while
                                             
                                          
                                       
                                    
                                 
                              
                           

In practice, each container can accommodate many items because containers are usually much larger than the individual items to be loaded. For example, a 20-ft container can contain about 30 items with average size of 1 cubic meter. Good solutions to the FCCP tend to have a high proportion of containers with high utilization due to the high costs of containers. Thus, the MA may encounter several VSBPPSs where the number of items n
                        
                           l
                         allocated to the shipping route l is large. However, the number of container types m is comparatively much smaller. Therefore, our O(mn
                        
                           l
                        ) approach is much faster than the 
                           
                              O
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             l
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                         approach by Haouari and Serairi (2009). This allows us to increase the sizes of the population and candidate sets as well as the number of generations in the MA, which enables the algorithm to explore more item sequences and increases the probability of identifying better solutions.

The process of computing C
                        
                           l
                        (χ) also generates a packing pattern for item sequence ξ
                        
                           l
                        , which is a set of containers B
                        
                           l
                        (χ) along with the items in each container. With this information, we can compute the utilization rate measure F
                        
                           l
                        (χ) as: 
                           
                              
                                 
                                    F
                                 
                                 
                                    l
                                 
                              
                              (
                              χ
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          B
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    χ
                                    )
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                    
                                    /
                                    
                                       
                                          V
                                       
                                       
                                          j
                                       
                                    
                                    )
                                 
                                 
                                    2
                                 
                              
                              /
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    ∈
                                    
                                       
                                          B
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    χ
                                    )
                                 
                              
                              
                                 
                                    V
                                 
                                 
                                    j
                                 
                              
                           
                        , where a
                        
                           j
                         is the total size of the items in container j. Given a set of containers and a set of items loaded into these containers, the measure F
                        
                           l
                        (χ) favors a loading configuration with several well-filled containers over one with mostly equally-filled containers. Several papers on the 1DBPP (e.g., Falkenauer, 1996; Osogami & Okano, 2003; Loh, Golden, & Wasil, 2008) have applied F
                        1(χ) as the fitness function. Note that since F
                        
                           l
                        (χ)⩽1 and the objective of the FCCP is to minimize cost, we include this utilization rate measure as a part of the fitness value Θ
                        
                           l
                        (χ) using the term α(1−
                        F
                        
                           l
                        (χ)), where α is a user-defined coefficient that determines its relative importance.

In each generation, the MA selects parents from the population set for reproduction (line 6 in Algorithm 1), and also selects members from the candidate set to form the population set for the next generation (line 18 in Algorithm 1). We use the same elitist roulette-wheel (or fitness proportionate) selection criterion for both purposes. For a chromosome χ
                        ∈
                        X, its probability of being selected is given by: 
                           
                              prob
                              (
                              χ
                              )
                              =
                              
                                 
                                    1
                                    /
                                    Θ
                                    (
                                    χ
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          χ
                                          ∈
                                          X
                                       
                                    
                                    1
                                    /
                                    Θ
                                    (
                                    χ
                                    )
                                 
                              
                           
                        .

The above selection criterion defines an inverse relationship between the fitness value of a chromosome and its selection. When selecting parents for reproduction, it is possible for the same chromosome to be selected multiple times. However, each chromosome from the candidate set can only be selected once to be a member of the population set for the next generation. Note that the best chromosome in each generation is always retained for the next generation (line 17 in Algorithm 1). Other applications that have used this type of selection method include Back, Fogel, and Michalewicz (1999), Moon Kratica, Stanimirovic, Tosic, and Filipovic (2002), Kratica et al. (2007).

After two parent chromosomes are selected, the MA produces two offsprings by performing a crossover operation. With our encoding scheme, the offsprings obtained by applying classical crossover operators would be infeasible in most cases. To deal with this issue, we devised an adapted two-point partially mapped crossover (APMX) operator for the MA. The partially mapped crossover (PMX) operator is a common operator in the approaches for the traveling salesman problem. It allows information contained in subsequences in the parent chromosomes to be transferred to offsprings. Our APMX operator is a combination of the PMX and classical crossover operators.

Our APMX is performed in three steps. (1) Two block boundaries are randomly selected from the parent chromosomes as crossover points, thereby dividing each chromosome into three segments (see Fig. 5
                        (a)). (2) The genes in the middle segments (between the crossover points) are exchanged to generate two offsprings (Fig. 5(b)), which may be infeasible because two different items may have the same loading order. The middle segments also define mappings between the corresponding loading orders; in our example, the mappings are 2↔3, 3↔4, 7↔5, 6↔6. Note that due to transitivity, the first two mappings effectively become 2↔4 (Fig. 5(c)). (3) The loading orders in the first and third segments that lead to conflicts are replaced according to the mapping (see Fig. 5(d)). In this case, we find that the second gene has a duplicate order number 2, so it is replaced by 4 using the mapping 2↔4. The remaining conflicting genes are replaced in a similar manner for both chromosomes.

The effect of the APMX operator on the affected genes is to perform a classical block-based crossover on the shipping routes, and the PMX operation on the loading orders. This preserves the loading sequence information contained in the middle segments of the parent chromosomes.

Mutation operations allow the exploration of wider regions of the solution space, generally by introducing random variations into the chromosomes. In our MA, we perform mutation on the set of offsprings produced by the crossover operations. Two types of mutations are implemented (see Fig. 6
                        ). For each shipment in the chromosome, a Type 1 mutation occurs with probability ρ
                        1, which modifies the shipping route for the shipment to another value that is uniformly and randomly chosen from R. For each gene in the chromosome, a Type 2 mutation occurs with probability ρ
                        2; another gene is uniformly and randomly selected, and the loading orders of the two genes are exchanged. If an offspring has been selected for mutation, we conduct the Types 1 and 2 mutations in order.

After the crossover and mutation operators, we attempt to locally improve the resultant offsprings (in terms of the fitness function) using three types of refinement operations:
                           
                              1.
                              
                                 Consolidation. Choose λ shipments at random and assign them to a single shipping route that results in the biggest improvement in the fitness value. If there does not exist a shipping route whereby the assignment of the shipments improves the fitness, then do nothing. In our implementation of the MA, we perform this operation on λ
                                 ={2, 3, 4}. Fig. 7
                                  shows an example consolidation with λ
                                 =2.


                                 Route swap. Choose two shipments at random and swap their shipping routes if the resultant solution has a superior fitness value.


                                 Loading-order swap. Choose two items at random and swap their loading orders if the resultant solution has a superior fitness value.

These operations are applied in the following order: consolidation with λ
                        =2, 3, 4, route swap, and finally loading-order swap. An operation is repeatedly applied until no improvement is found after β consecutive tries, whereupon the next operation is applied.

The MA terminates when the number of generations reaches a user-defined value N
                        
                           maxGen
                        .

In this section, we evaluate the merits of our proposed MA on a large number of randomly generated test instances. To provide a benchmark for the performance of our approach, we also applied the branch-and-cut search scheme in ILOG CPLEX 11.1 with default settings to solve the IP model. Both algorithms were implemented in C++ and executed on an Intel Xeon (R) 2.66GHz server with 3GB RAM. All computation times reported here are in CPU seconds on this server.

The FCCP is a new problem, and therefore there are no specific benchmark test sets available in existing literature. Consequently, we generated a number of test instances using the following scheme, which was developed after discussions with experts from the 3PL in question. We take the number of shipments (∣S∣) from {20, 50, 80} and the number of shipping routes (∣R∣) from {5, 10}. For each shipment, the number of items is selected from U
                        
                           d
                        [3, 12], where U
                        
                           d
                        [a, b] denotes the discrete uniform distribution in the interval [a, b]. The item sizes (v
                        
                           i
                        ) in cubic meters are independently randomly generated using two distributions U
                        
                           c
                        [0.3, 1] and U
                        
                           c
                        [2, 6], where U
                        
                           c
                        [a, b] denotes the continuous uniform distribution in the interval [a, b]. For convenience, we refer to the items with sizes generated by U
                        
                           c
                        [0.3, 1] and U
                        
                           c
                        [2, 6] as small and big items, respectively.

We represent the territory of the United States with a planar rectangle with Cartesian coordinates [0, 1000]×[0, 1000], while the origin hub in Shanghai can be conceptually visualized as a point outside this rectangle (see the map shown in Fig. 8
                        ). There are 30 retailer stores randomly distributed in the planar rectangle. The destination store for each shipment is randomly selected so that some stores may receive more than one shipment while others may receive none.

All test instances make use of three types of containers: standard 20-ft, standard 40-ft and 40-ft high cube, which have capacities of 29.4, 58.8 and 67.2 cubic meters, respectively. Each shipping route corresponds to a unique destination hub whose location is randomly chosen from the boundary of the planar rectangle (resulting in ∣R∣ destination hubs in total).

We illustrate our method of assigning container costs for each container type on each shipping route using Fig. 8. On the boundary of the planar rectangle, we define six points A
                        1, …, A
                        6, each with the fixed value 
                           
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          μ
                                       
                                    
                                 
                              
                              (
                              1
                              ⩽
                              μ
                              ⩽
                              6
                              )
                           
                         as shown in the figure: 
                           
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              =
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          5
                                       
                                    
                                 
                              
                              =
                              2400
                              ,
                              
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              =
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          4
                                       
                                    
                                 
                              
                              =
                              3000
                           
                        , 
                           
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              3400
                           
                        , and 
                           
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          6
                                       
                                    
                                 
                              
                              =
                              2000
                           
                        . These values were chosen based on the shipping distance between the warehouse in Shanghai and points on the coast of North America.

Consider a destination hub on the boundary of the planar rectangle at point A
                        
                           h
                        ; observe that A
                        
                           h
                         must lie on some line segment (A
                        
                           μ
                        , A
                        
                           ν
                        ), where ν
                        =(μ
                        +1)mod6. Let L(A
                        
                           μ
                        , A
                        
                           ν
                        ) be the Euclidean distance between points A
                        
                           μ
                         and A
                        
                           ν
                        . We set the cost of a standard 20-ft container for the shipping route with destination hub A
                        
                           h
                         to 
                           
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          ν
                                       
                                    
                                 
                              
                              +
                              (
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          μ
                                       
                                    
                                 
                              
                              -
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          ν
                                       
                                    
                                 
                              
                              )
                              ×
                              L
                              (
                              
                                 
                                    A
                                 
                                 
                                    ν
                                 
                              
                              ,
                              
                                 
                                    A
                                 
                                 
                                    h
                                 
                              
                              )
                              /
                              L
                              (
                              
                                 
                                    A
                                 
                                 
                                    μ
                                 
                              
                              ,
                              
                                 
                                    A
                                 
                                 
                                    ν
                                 
                              
                              )
                           
                        . In our example, this cost would be 2000+(2400−2000)×
                        L(A
                        6, A
                        
                           h
                        )/L(A
                        6, A
                        1). We found that the relative shipping costs for each route generated in this manner closely approximate the actual data we received from the 3PL. For each shipping route, the costs of the standard 40-ft and 40-ft high cube containers are set to be 1.2 and 1.3 times that of the standard 20-ft container.

The cost r
                        
                           i, j
                         of delivering item i from a destination hub to its retailer store is a function of the item size and delivery distance. For example, if item i is loaded into container j heading to destination hub A
                        
                           h
                         and its store is situated at point A
                        
                           s
                        , we set r
                        
                           i, j
                        
                        =
                        γ
                        ×
                        v
                        
                           i
                        
                        ×
                        L(A
                        
                           h
                        , A
                        
                           s
                        ), where γ is a multiplicative factor for the delivery cost. A higher value of γ increases the relative cost of delivery compared to the container cost. In our test instances, the value of γ is taken from {0.08, 0.16, 0.32}.

Hence, our test instances are divided into 36 groups, corresponding to all combinations of the number of shipments (3 possible values), the number of shipping routes (2 possible values), the item sizes (2 possible distributions) and the values of γ (3 possibilities). Each instance group is identified by four numbers separated by dashes (‘–’): the first two numbers are the number of shipments and shipping routes, respectively; the third number is the value of γ; and the last number indicates item size distribution, where “1” stands for U
                        
                           c
                        [0.3, 1] and “2” stands for U
                        
                           c
                        [1, 3]. For each instance group, we generated 10 random instances, for a total of 360 instances. All the instances and results can be found on http://www.computational-logistics.org/orlib/fccp.

We set a time limit of 1 CPU hour for all CPLEX executions when solving the IP model. Recall from Section 4.3 that computing our fitness function requires a solution to the VSBPPS. We implemented the MA using our near-optimal O(mn
                        
                           l
                        ) VSBPPS solution (denoted simply as MA1) as well as the optimal 
                           
                              O
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             l
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                         VSBPPS solution by Haouari and Serairi (2009) (denoted by MA2). Since the MA is not deterministic, we executed each of the two MA implementations ten times for each instance with different random seeds and recorded the best, average and worst solutions of the ten runs.

When solving the IP model using CPLEX, an increase in the cardinality of set B (the collection of all containers) corresponds to an increase in the number of decision variables, which has a significant effect on the performance of CPLEX. Therefore, it is important to minimize the size of set B while ensuring that no optimal solution is omitted.

Consider a special instance involving only one shipping route. Suppose all items can be completely loaded into twenty standard 20-ft or ten standard 40-ft or nine 40-ft high cube containers by some approach; this implies that the optimal solution to the IP model with a set B including these thirty-nine containers is an optimal solution to the FCCP instance. This observation allows us to determine the set B for each test instance in the following manner. For all items with different sizes and for each shipping route, we solve two 1DBPPs with the first-fit decreasing heuristic (Coffman, Garey, & Johnson, 1996), one using only standard 40-ft containers, and the other using only 40-ft high cube containers. The solutions to these problems are upper bounds for the numbers of these two types of containers, which we include in set B. Note that the capacity and cost ratios of the standard 40-ft container to the standard 20-ft container are 2 and 1.3, respectively, so no optimal solution can employ two standard 20-ft containers because they can be combined into one standard 40-ft container with reduced cost. Consequently, we include only one standard 20-ft container in set B.

Our MA approach contains a number of parameters as given in Table 1
                        . These parameters can be divided into two classes: one class consists of N
                        
                           maxGen
                        , ∣P
                        
                           I
                        ∣, ∣P
                        
                           O
                        ∣ and β, which mainly affect the computation speed of the algorithm, and the other class contains the remaining parameters that mainly affect the quality of final solutions. Our parameter tuning process is conducted in two phases. In phase one, we set all parameters of the second class to zero and calibrated the parameters in the first class by conducting a 33 full factorial experimental design on the fifth instance in each of the instance groups with 50 shipments using the MA1 implementation (∣P
                        
                           I
                        ∣=∣P
                        
                           O
                        ∣ for all configurations). In this phase, we solved each instance 27 times, recorded its lowest cost and calculated a gap for each run by: (cost of the run – the lowest cost)/the lowest cost. After considering the tradeoff between the average gap and average computation time, we selected the following parameter values: N
                        
                           maxGen
                        
                        =100, ∣P
                        
                           I
                        ∣=∣P
                        
                           O
                        ∣=20 and β
                        =40. In phase two, we conducted another 33 full factorial design to determine the values of α
                        =0.01, ρ
                        1
                        =0.01 and ρ
                        2
                        =0.01.

@&#RESULTS AND ANALYSIS@&#

Our results are summarized in two tables: Table 2 summarizes the computational results for the instance groups with small items, while Table 3 provides the results for big items. All columns except the first one in each table give the average values of corresponding gaps or computation times of all instances of the same group. We calculated the gap between the solution and the lower bound found by CPLEX after 1h of computation for each instance as: (CPLEX − Lower bound)/Lower bound and present the average gap of all instances in each group in the column “Gap (%)” under the block “CPLEX”. The other gaps were derived using the solutions of CPLEX as baseline, e.g., the gap for the average solution of 10 MA1 runs for some instance is calculated by: (MA1 average − CPLEX)/CPLEX, where MA1 average is the average cost of executing MA1 10 times. The column “Gap (%)” under the block “Greedy” gives the average cost of the initial solutions found using the greedy heuristic described in Section 4.2, which provides an indication of the quality of the human-generated solutions by the decision makers at the 3PL. This is followed by the results obtained by the two MA implementations. It is reasonable to assume that the values in the column “Gap (%)” under the block “CPLEX” reflect the difficulty of instance groups. Consequently, we sorted all instance groups by increasing value of “Gap (%)” of CPLEX and plotted the results in Fig. 9
                        . The detailed results for all instances can be found in the Appendix B.

From the gaps of CPLEX in both Tables 2 and 3
                        
                        , we find that the instances with big items are more difficult to be solved by CPLEX than their counterparts with small items. We can also see that for the groups with ∣S∣=20 and small items, CPLEX is able to find the optimal solutions within the time limit. The instances with ∣R∣=10 shipping routes require more computation times to be solved and have larger CPLEX gaps (and are therefore more difficult) than their counterparts with ∣R∣=5. Fig. 10
                         plots the CPLEX gaps for each instance group and is derived from these two tables; we observe an inverse relationship between the difficulty of the instances and the value of γ (the only exceptions are “50-10-0.16-1” and “50-10-0.32-1”). This implies that the problem becomes more difficult as the cost of delivery decreases relative to the container cost. Furthermore, the difficulty of instances increases with the number of shipments, which is illustrated by Fig. 11
                        .

The greedy heuristic performed better than CPLEX for only group “80-10-0.08-2”. For the rest of the groups, it produced much poorer solutions than CPLEX, which is demonstrated by the large positive values under the block “Greedy”. We can clearly see that our MA implementations are far superior to the greedy heuristic employed by human decision makers, producing solutions that cost less than half as much in certain cases. This represents a substantial cost saving, which provides dramatic evidence of the importance of having an effective solution to the FCCP. A demonstration of this fact was one of the decisive factors when the manufacturer eventually awarded the contract to the 3PL in question.

Just like CPLEX, both MA1 and MA2 also generated optimal solutions for all instances with ∣R∣=20 and small items. The positive numbers (marked in bold) in the column “Best gap (%)” under the block “MA1” or “MA2” indicate that CPLEX was superior to MA1 or MA2 for those groups, which are all “easier” groups according to Fig. 9. For the harder groups, our MA implementations exhibited their superiority and achieved better solutions than CPLEX. Moreover, our MA implementations are more likely to outperform CPLEX as the difficulty of the instance increases; this is illustrated in Fig. 12
                        , where the order of instance groups is the same as that in Fig. 9.


                        Table 3 shows that the superiority of our MA implementations over CPLEX is even greater for the instances with big items than with small items. This is because more containers are needed when the items are relatively large, which significantly increases the number of variables in the IP formulation and reduces the effectiveness of the branch-and-cut approach utilized by CPLEX. Note that our big items were randomly generated to have volumes between 2 and 6 cubic meters, and these types of items are commonly encountered by the 3PL in question.

An inspection of the columns under the blocks “MA1” and “MA2” reveals that there is not much difference in the quality of the solutions found by these two MA implementations. However, MA2 requires between approximately 2.4 and 8.1 times the amount of computation time employed by MA1 to complete.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this article, we introduced a new freight allocation and consolidation problem that involves choosing shipping routes for shipments and loading items into containers with varying sizes and costs. It models the task faced by a third-party logistics company under contract with the major children’s textiles manufacturer, where different shipments of textiles are to be consolidated so that the total cost (consisting of container and delivery costs) is minimized. Since this problem is NP-hard, we designed and implemented a memetic algorithm approach to solve it under practical settings. Extensive experimental results show that compared to CPLEX 11.1, our two MA implementations (MA1 and MA2) outperform CPLEX in terms of both solution quality and computation time when solving medium- and large-sized instances. On average, MA1 and MA2 improved on the CPLEX solutions for instances with small items by 1.04% and 0.98%, respectively. These two MA implementations showed more advantages on solving the instances with big items since the corresponding average improvements are as much as 7.15% and 7.25%. By experiments, we also compared the performance of MA1 and MA2, and find that MA1 is more time-saving while providing equivalent solution quality.

Major business enterprises looking to expand into the emerging Chinese market often require the services of 3PLs for their transportation needs. However, many companies are hesitant to venture into the region due to a prevailing impression that local 3PLs are ill-equipped to provide cost-effective logistical support. There is a need to assure foreign investors that local 3PLs can handle complex practical problems; the project upon which this study is based is a prime example.

The FCCP represents an initial investigation into a common logistical problem where the consolidation of different shipments and the packing of items into containers are simultaneously taken into account. We modeled the packing of items as a one-dimensional bin-packing problem, which is justified since the customer of the 3PL is a textile manufacturer. An obvious extension would be to consider two-dimensional or three-dimensional packing, which may be more appropriate for customers dealing in other types of products. Our MA approach can be customized for these cases by replacing our dynamic programming based VSBPPS algorithm with an appropriate sequence-based algorithm for 2D or 3D packing.

@&#ACKNOWLEDGEMENTS@&#

This research was partially supported by the Fundamental Research Funds for the Central Universities, HUST (Grant No. 2012QN213) and National Natural Science Foundation of China (Grant No. 71201065). The authors would like to thank the anonymous reviewers for their valuable comments and suggestions to improve the quality of the paper.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2013.09.015.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

