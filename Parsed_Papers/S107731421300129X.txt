@&#MAIN-TITLE@&#Using objective ground-truth labels created by multiple annotators for improved video classification: A comparative study

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a strategy to create objectively labeled ground-truth set of videos.


                        
                        
                           
                           Such a strategy mitigates the subjective biases of the annotation process.


                        
                        
                           
                           Objective labels show superior consistency than subjective labels.


                        
                        
                           
                           A classifier is trained to predict objective labels for 51K unlabeled videos.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Video classification

Large dataset analysis

Data annotation

@&#ABSTRACT@&#


               
               
                  We address the problem of predicting category labels for unlabeled videos in a large video dataset by using a ground-truth set of objectively labeled videos that we have created. Large video databases like YouTube require that a user uploading a new video assign to it a category label from a prescribed set of labels. Such category labeling is likely to be corrupted by the subjective biases of the uploader. Despite their noisy nature, these subjective labels are frequently used as gold standard in algorithms for multimedia classification and retrieval. Our goal in this paper is NOT to propose yet another algorithm that predicts labels for unseen videos based on the subjective ground-truth. On the other hand, our goal is to demonstrate that the video classification performance can be improved if instead of using subjective labels, we first create an objectively labeled ground-truth set of videos and then train a classifier based on such a ground-truth so as to predict objective labels for the set of unlabeled videos.
                  With regard to how we generate the objectively-labeled ground-truth dataset, we base it on the notion that when a video is labeled by a panel of diverse individuals, the majority opinion rendered by the panel may be taken to be the objective opinion. In this manner, using judgments provided by multiple human annotators, we have collected objective labels for a ground-truth dataset consisting of randomly-selected 1000 videos from the TinyVideos database that contains roughly 52,000 videos from YouTube (courtesy of Karpenko and Aarabi [1]).
                  Through a fourfold cross-validation experiment on the ground-truth set, we demonstrate that the objective labels have a superior consistency compared to the subjective labels when used for video classification. We show that this claim is valid for several different kinds of feature sets that one can use to compare videos and with two different types of classifiers that one can use for label prediction.
                  Subsequently, we use the ground-truth dataset of 1000 videos to predict the objective category labels of the remaining 51,000 videos. We compare the objective labels thus determined with the subjective labels provided by the video uploaders and qualitatively argue for the more informative nature of the objective labels.
               
            

@&#INTRODUCTION@&#

Massive amounts of image and video data has been and continues to be uploaded to Internet based visual content databases like Picasa, Flickr, YouTube, Archive.org, Hulu and others. The content for these databases is generally created in realistic settings from sports and news coverage; documentaries on travel, science, and technology; social events; and so on. In recent years, this type of data has fast become the experimental data of choice in computer vision research because it encompasses large inter- and intra-class variability and presents very interesting challenges for problems like object detection and tracking, face recognition, human activity analysis, and so on.

In this paper, we address the problem of consistently and objectively labeling the content in these large databases. Although applicable to all large video databases, our work focuses specifically on the videos that are uploaded to the YouTube database. YouTube requires that every video uploaded to its servers be assigned one of the 15 broad category labels listed in Table 1
                     . Karpenko and Aarabi [1] 
                     have noted that there is a significant amount of labeling noise in the categories assigned to the YouTube videos. The uploader may assign a category label based on his/her subjective judgment about the theme of the video content. Also the label assigned to a video may be motivated by a particular section of the video, and the rest of the video may be totally unrelated to the label. It may also be influenced by the motivation that led to creation of the video in the first place, or by the uploader’s opinion about the target audience. The upshot is that different uploaders may assign different category labels to videos with similar content. We obviously need a more objective and consistent way of assigning category labels to the videos.

Towards that end, we demonstrate that by first creating a ground-truth dataset of videos with objectively assigned category labels and then by using such a set to train a video classifier that can predict objective labels for new unlabeled videos, we end up with superior labeling for the unlabeled videos. By superior we mean labels that are more consistent compared to the labels that would be predicted purely on the basis of the uploader-supplied subjective labels. We demonstrate these results using the TinyVideos dataset that consists of 52,000 YouTube videos [1]. Just to give the reader a flavor of these videos, we show in Fig. 1
                      the keyframes extracted from five randomly chosen videos that correspond to five different uploader-supplied subjective labels. Looking at these key-frames, one could say that the other labels—labels other than those used by the uploaders—may also be applicable to these videos. For example, the 1st, 2nd and 5th videos could alternatively be assigned the labels Sports, News and People,respectively. As to how a video’s keyframes are selected, we will discuss that in Section 4.1.1.

Creating a ground-truth set of objectively labeled videos is obviously critical to the research reported here. For that purpose, we use a majority voting approach, which is described in detail in Section 3. Our objective labeling process involves collecting labels for every video from multiple annotators. For each video, the annotators were asked to browse through the full video and to then mark all the category labels that applied to it. Due to practical considerations of time and effort, this could only be done for a relatively small set of 1000 videos. We refer to this set of 1000 videos as our objectively labeled ground-truth dataset. With regard to this set, we are faced with the following two questions:
                        
                           1.
                           Why should we believe in the objective labels for the ground-truth dataset?

Can we propagate the objective labels from this set to the rest of the database that contains 51,000 video clips?

We supply the answer to the first question by applying a fourfold cross-validation analysis to the ground-truth dataset. And we supply the answer to the second question by claiming that the video labeling algorithm used in the cross-validation on the ground-truth dataset can be directly used for predicting the objective labels for the videos in the larger database.

In order to establish that our answers to the two questions raised above are not dependent on any particular feature set used to compare videos or on any particular classifier for assigning labels to the videos, our results in this paper are based on several different kinds of features sets and for two different types of classifiers for label prediction: the K-Nearest Neighbors (KNN) and Support Vector Machine (SVM).

With regard to the specifics of video classification used for both the cross-validation on the ground-truth dataset and for the labeling of the remaining 51,000 videos, the objective labels of the labeled videos are first propagated to the keyframes extracted from the same videos. Each keyframe extracted from a video is represented by a feature vector in the manner described in Section 4.1.1. The fourfold cross-validation on the ground-truth dataset and the label prediction for the remaining 51,000 videos is carried out in the space spanned by these feature vectors. Since it is possible for the classifier to yield different labels for the different keyframes in a target video, we pool together all such labels for all the keyframes extracted from a video by averaging and thresholding and then decide on the overall label for the video.

Although we demonstrate the robustness of using objective labels in the label prediction algorithm with a relatively small ground-truth set of 1000 randomly selected videos, it stands to reason that the larger the ground-truth dataset, the greater the accuracies that can be had by using the label prediction algorithm. As to why we have limited ourselves to a ground-truth dataset of only 1000 videos, note that the larger the ground-truth dataset, the greater the difficulty of collecting the human-annotated labels for the videos. That would certainly be the case for a typical university-based laboratory such as ours. However, large video service providers like YouTube would easily be able to scale up the methodology we present in this paper to create ground-truth datasets consisting of tens of thousands of videos by allowing the viewers (in addition to uploaders) to click on the most relevant category labels applicable to the online videos. This user feedback would be similar to the existing feedback mechanisms that allow the viewers to enter their comments and rate the videos.

The overall research reported in this paper consists of the following four steps:
                        
                           1.
                           Assuming that the opinion of a majority can be considered to be objective, we ask a panel of individuals with diverse backgrounds to label 1000 videos that are randomly selected from the collection of 52,000 videos belonging to TinyVideos dataset. We permit the individuals to give multiple category labels to a video if such is warranted by the content of the video. The labels for any particular video provided by the multiple annotators are combined through majority voting. We refer to this 1000 video set as the ground-truth dataset and the majority-voted labels as the objective labels.

We then establish through fourfold cross-validation the superiority of the objective labels vis-a-vis the subjective labels in the ground-truth dataset. Since the cross-validation analysis involves training a video classifier based on feature vectors and label data, we demonstrate the superiority of the objective labels for several different kinds of features and for two different types of video classifiers.

We predict the objective labels for the remaining 51,000 videos in the TinyVideos dataset using a classifier trained on the video keyframe feature vectors and objective labels of the ground-truth set.

We compare the predicted objective labels of the videos in this larger set with their corresponding subjective labels assigned by the uploaders.

In the rest of this paper, we start with a survey of the related work in Section 2. In Section 3, we describe the methodology for creating the objective labels for videos in the ground-truth dataset. Section 4 presents the fourfold cross-validation experiment to demonstrate the superior consistency of the objective labels in the ground-truth dataset compared to the subjective labels. In the same section, we also present the procedure to train the video classifiers for objective label prediction (Section 4.1). Subsequently, in Section 5, we use the label prediction algorithm to determine the objective labels for the unlabeled set of 51,000 videos in the TinyVideos database. We also give some qualitative arguments about their more informative nature compared to the subjective labels. Finally, in Section 6 we conclude and present our views on how this research can be extended further.

@&#RELATED WORK@&#

There is a vast amount of literature on the topic of creating and annotating datasets for addressing specific computer vision research problems like segmentation [2,3], object detection [4], people detection [5,6], human action recognition [7,8], facial pose and expression analysis [9], and so on. In recent years, as the technology has advanced, it has become increasingly common to create very large datasets for the same purposes by downloading images and videos from the Internet. Consider, for example, the 80million TinyImages dataset [10], the ImageNet database [11] and the TinyVideos dataset [1].

Large datasets obviously have the advantage of providing rich training and validation sets for developing vision algorithms. But they have the drawback that most of the data is not annotated or comes with only weak annotations based on meta-data information like user-provided tags, comments, ratings, and so on. These annotations can be heavily biased by the subjective opinions of the annotators. Several authors [12–15] have described the outsourcing of annotation tasks to human annotators on the Internet, either for pay (e.g. with Amazon’s Mechanical Turk [16]), or for entertainment (e.g. The ESP Game [15]).

That brings us to the subject of multi-annotator labeling—a relatively new paradigm in computer vision, although it is used commonly in other areas such as computer-aided diagnosis with medical images [17,18], collaborative filtering [19], and meta-analysis of diagnostic tests [20,21]. Generally in computer vision datasets, each data item is associated with a label provided by a single annotator and that label is assumed to be the gold standard. All evaluation of detection or classification algorithms is carried out based on this gold standard. Such a setup works well with annotation tasks that are unambiguous to a human annotator, such as putting a bounding box around a person, a car, or some other well defined object in an image. But there are other types of annotation tasks that do not allow for objective answers to be elicited from human annotators. Some examples of this situation include guessing the age of a person based on his/her facial image [22], deciding whether the patches/spots on the surface of Venus are volcanoes [23], predicting a suspicious region on a medical image as malignant or benign [24], or ascertaining the category of a video clip from among a set of subjective categories (Comedy, Entertainment, Drama), etc.

The YouTube video category labeling is an example of such a subjective task and hence we use multiple annotators’ responses to create the labels for videos in the ground-truth dataset. After such a ground-truthed dataset is brought into existence, the objective labels contained therein can be used to train a video classification algorithm and their performance can be evaluated vis-a-vis the subjective labels using multi-fold cross validation. Such trained classifiers can also be used to predict objective labels for the rest of the dataset that can be qualitatively compared with the subjective labels. With regards to an empirical assessment of how the variations in keyframe selection strategy, feature vector type and classifier type can influence the multi-annotator labeling of data and especially in light of our multi-fold cross-validation of the labels, we believe that the work reported here represents a novel contribution. The performance of multi-annotator labeling strategies under such variations has not been studied systematically in the past. Some recent work in machine learning community has studied the effect of noisy multi-annotator labeling on classification and regression [25,26]. In the computer vision domain, strategies have been proposed for collecting multi-annotator labels for large datasets using crowd-sourcing [12,27,13,28–31]. But these works have dealt with image multi-annotation as opposed to the video multi-annotation presented in this paper and they also have not analyzed the performance of such annotation strategies as a function of other important parameters that we have mentioned above.

Since we start out with subjectively labeled videos, the issue of any biases prevalent in the labels is important to us for obvious reasons. The existence of subjective biases and the problems that result therefrom have been addressed in several domains like medical diagnosis [24], medical image segmentation [32,33] and remote sensing [23]. To deal with this issue, it is common to obtain independent observations from multiple human annotators. The gold standard ground-truth can be treated as latent information and the annotator error rates can be estimated based on multiple diagnostic tests without the gold standard [34–36]. It has been argued in [23] that the subjective uncertainty of the data labeling needs to be taken into account in order to avoid an overly optimistic performance estimate of both the human experts and the vision algorithms. Sheng et al. [37] show that if the data labels are noisy, then the repeated labeling strategies can improve both the quality of labeled data, as well as the quality of models learned from the data. Uebersax [38] describes a latent structure model to analyze the multiple expert ratings for a medical diagnosis task, the different sources of subjective judgments by the raters and how to combine the ratings provided by multiple raters. When the labels from several annotators are available, they can either be used to just estimate the ground-truth [34,23] or they can be used to learn a classifier and the ground-truth jointly using expectation–maximization [25].

With regard to the pooling of the labels provided by different annotators, Raykar et al. [25] argue that when the labels supplied by different experts are combined, the commonly used majority voting approach assumes that all experts are equally good, which may be a restrictive assumption for some applications. If there are only a few experts in the group of annotators, with the rest being novices, then the majority voting approach would favor the novices. This is important for annotation tasks like marking regions in medical images as malignant or benign. Here, it is critical to take the expertise of an annotator into account. Therefore, more sophisticated approaches can be used like placing a prior on the skills of different annotators and performing a Bayesian inference to measure the performance of the annotators after they have labeled the data [39,25]. On the other hand, for combining the multiple annotator labels for the task in our current paper, i.e. the labeling of YouTube videos, we stick to the simple majority voting approach. The reason for this choice is that our annotation task cannot be put in the same bracket as the labeling of medical images, as far as considering the expertise levels of annotators is concerned. Due to the subjective considerations exercised by different annotators, it is acceded that their labels may be different on a particular video, but it would be unreasonable to claim that one annotator’s labels are ’better’ than another annotator’s labels.

Before formally defining what is a subjective or an objective label for a YouTube video, we introduce a common mathematical notation that can be used to describe both types of labels. Assume that there are M distinct category labels available for a video (M
                     =15 for the YouTube dataset). We associate with each video a binary vector that has M bit positions corresponding to all the allowed categories. We refer to this vector as the BCL (Binary Category Label) vector. A BCL vector for a video can be represented as 
                        
                           y
                           ∊
                           
                              
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                              
                                 M
                              
                           
                        
                      where 
                        
                           
                              
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                              
                                 M
                              
                           
                        
                      means an M-element bit vector with each element either 0 or 1. Each bit 
                        
                           y
                           [
                           m
                           ]
                        
                      indicates the presence or absence of a category in the video’s content as determined by an annotator.

With the BCL vector notation, we are ready to define a subjective and an objective label. A subjective label for a video is the one assigned by the uploader of the video. Due to the way the current YouTube upload mechanism is set up, an uploader can assign only one of the M category labels to the video. Therefore, the subjective label can be represented as a BCL vector with only one of the M bits set to 1.

On the other hand, an objective label is created from multiple BCL vectors contributed by different annotators and it allows multiple categories to be simultaneously chosen in the BCL vector. The rationale behind allowing multiple annotators to contribute towards a single video’s objective label is that it will help suppress the subjective biases of single annotators. As for allowing an annotator to choose multiple categories in a video’s BCL vector, this seems reasonable because it is a common human experience that one may consider a video as belonging to multiple visual categories. For example, it would not be unreasonable for an annotator to think of a video as belonging to both the Sports category and the Entertainment category. Fig. 2
                      shows a few examples of assigning BCLs to the videos in the visual interface that we provided to the annotators during the objective labeling process.

In a typical classification experiment, the ground-truth consists of objects with human-supplied class labels that are then used to train a classifier. Assigning meaningful category labels to videos is an inherently challenging task because these labels are not generally determined by just the physical entities found in a scene, such as objects and persons, or even activities. When an annotator labels a video, his or her judgment may transcend the objects, persons, and the activities in the video, and the label given to the video may depend on the mood and the emotions conveyed by the video. We may think of such factors that go into the human labeling of the videos as confounding factors; they are difficult to define, let alone estimate. Different people will often give different answers as to what labels a given video should have. Is a video of a basketball player sitting in the stands talking into a microphone a Sports video? It is related to sports, to be sure, but the player is not actually playing any sport. Is the video of a girl falling on her face a Comedy video? Some might think it is funny, and others tragic.

Notwithstanding such individual variations in the labeling of the videos – or, perhaps, because of such variations that could be termed noise from an engineering perspective – we desire a ground-truth database of videos with objective labels, meaning labels that a majority would consider to be the most appropriate labels. So all we need to do for creating such ground-truth is to have a panel of individuals, hopefully diverse in their personas and outlooks, label the videos and then, for each video, choose a label that the majority agrees upon.

We partitioned the TinyVideos dataset into two sets, a small set comprised of the randomly selected 1000 videos and a large set with the remaining ̃51,000 videos. We refer to the small set as the ground-truth set because objective labels are obtained for the videos in this set by the manual annotation process. For objective labeling, volunteers were recruited and each video was independently labeled by S
                        =5 annotators. In more detail, not all the 1000 videos were labeled by the same 5 volunteers. In total, 18 volunteers participated in the annotation process and each of them only provided labels for a fraction of the 1000-video set. But it was ensured that every video was annotated by 5 volunteers. The volunteers came from a diverse pool: graduate students, people working in different industries (technology, insurance, food-processing), home-makers, people of varying ages (from early twenties to late fifties) and people from different nationalities (American, Korean, Chinese and Indian).

We asked each annotator to label the videos with one or more of the M YouTube categories (M
                        =15). Every annotator was provided the visual interface shown in Fig. 2 to view the video and then select the relevant categories. The annotators were not required to watch every second of the videos, rather they had the option of browsing through a video quickly using a scrollbar. To aid in consistent labeling of the videos, we asked our annotators to determine the category labels based on short descriptive definitions and list of examples that are provided in Table 2
                        . We neither claim these descriptions to be objective category definitions nor the list of examples of be exhaustive; they are obviously based on our own understanding of these categories. We believe that these category definitions provide general criteria for labeling most videos and minimize subjective decisions. We gave the annotators these general instructions:
                           
                              •
                              Please select all the categories which are represented in each video.

If no category seems to fit, you do not need to choose any.

We refrained from giving any video examples of how the data should be labeled to avoid biasing whatever inner mechanisms the annotators may bring to bear to the problem of labeling. We did emphasize that they should select multiple labels for a video if they were all applicable.

After all our 1000 videos in the ground-truth set were labeled independently by five annotators, we collected the annotators’ BCL vectors and combined them using majority voting to define the objective label for each video, the objective-label being itself a BCL vector. We represent the individual annotator contributed labels as a three-dimensional array H of binary decisions where the element 
                           
                              
                                 
                                    H
                                 
                                 
                                    i
                                    ,
                                    s
                                 
                              
                              [
                              m
                              ]
                           
                         represents the decision of the sth human annotator on the ith video with regards to the mth video category label. If the annotator selected the mth category (
                           
                              1
                              ⩽
                              m
                              ⩽
                              M
                           
                        ), 
                           
                              
                                 
                                    H
                                 
                                 
                                    i
                                    ,
                                    s
                                 
                              
                              [
                              m
                              ]
                              =
                              1
                           
                        . Otherwise, 
                           
                              
                                 
                                    H
                                 
                                 
                                    i
                                    ,
                                    s
                                 
                              
                              [
                              m
                              ]
                              =
                              0
                           
                        . We define the objective label for the ith video as 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                           
                         and its mth category bit is determined as the majority vote over all the annotator contributed decisions for that category, that is
                           
                              (1)
                              
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 [
                                 m
                                 ]
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         s
                                                         =
                                                         1
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         i
                                                         ,
                                                         s
                                                      
                                                   
                                                   [
                                                   m
                                                   ]
                                                   ⩽
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  M
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         s
                                                         =
                                                         1
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         i
                                                         ,
                                                         s
                                                      
                                                   
                                                   [
                                                   m
                                                   ]
                                                   >
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  M
                                                               
                                                               
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Based on the BCL vectors collected from the five annotators, it is interesting to observe the histogram of the number of votes accumulated for M video categories. The number of votes correspond to the summation term in Eq. (1). For a particular video in the ground-truth set, a video category can receive anywhere from 0 to 5 votes depending on how many annotators selected that particular category to be assigned to the video. Fig. 3
                        (a) shows the histogram for all the 15 categories taken together and for all the 1000 videos. In the histogram, the high count for 0 votes is expected and it means that for most videos, most of the categories were not selected. This is reasonable because we observed during the annotation process that for almost any video, the number of category labels assigned to it ranged from 0 to 4 although there are a total of 15 categories. Very rarely a video got 5 labels and no video received 6 or more labels from any annotators. A more interesting observation is that for 2 or 3 votes, the counts are the smallest indicating that the tie-breaker decisions were the least common.

Similar histograms for some of the individual categories (Fig. 3(b)) yield further insight. We have shown the histograms for 4 categories: Sports, News, Entertainment, and Comedy. As before, 0 votes have the highest count and this means that most of the times, all the annotators agreed about that particular category not being applicable to the video. The interesting observation in these histograms is related to the degree of subjectivity that can be associated with the video categories. The Sportsand News categories are likely to have commonly acceptable definitions and hence for them, the unanimous decisions (5 votes) are more frequent that the tie-breaker decisions (2 or 3 votes). On the other hand, the Entertainment and Comedy categories can be associated with a variety of definitions by different people. Different viewers may find different things entertaining or comical. Therefore, the tie-breaker decisions become dominant as compared to the other 2 categories, i.e. Sports and News. For Entertainment and Comedy categories, the 2 and 3 votes have higher counts than 5 votes. In other words, for these categories, fewer videos achieved a unanimous vote with all five annotators selecting them to belong to the category.

We answer the following important question in this section: How do we know that the supposedly objective labels determined through a majority vote are indeed objective? We claim that this question can be answered by measuring the consistency of the multi-annotator supplied category labels in the following manner:
                        
                           •
                           In a fourfold cross-validation experiment on the ground-truth set, we use three parts as a training set and one part as a testing set.

A classifier is trained using the objective labels in the training set and then used to predict the labels for the test set.

We use ROC (Receiver Operating Characteristic) curve for the test set videos to evaluate the consistency between their predicted labels and the ground-truth objective labels obtained from the annotators.

In order to compare the performance of the objective labels with that of the subjective labels, the above steps are repeated with the subjective labels, i.e. a classifier is trained with the subjective labels of the training videos, and then the labels predicted for the test videos are compared against their original subjective labels.

With regards to comparing the classifier performance resulting due to the objective labels versus the subjective labels, an objection may be raised in the above steps that the ROC curves are being compared for two different test sets. In one case, the test set uses objective ground-truth labels to evaluate the quality of predicted labels while in the other case, the test set uses subjective ground-truth labels. Section 4.3, while acknowledging that our usage of ROC curves is different of how they are conventionally used, provides an explanation to address this concern. In the same section, we describe additional experiments that are aimed at mitigating the disparity between the two ground-truth sets.

The main step described in the bulleted points above is the training of a classifier to predict either the objective or the subjective labels for the videos of the test set. Several types of classifiers have been used in the past for the propagation of labels from a labeled to an unlabeled set. Some examples of such classifiers are Naive Bayes [40,41], Logistic Regression [42,43], K-Nearest Neighbor [44,45], Support Vector Machine [46,47], and so on. Of these, we chose to implement the two classifiers, KNN and SVM, so that a comparative analysis of the effect of the classifier type on the learning of the objective labels could be carried out. Their implementations are presented in the next subsection. The choice of these two classifiers was based on the fact that many state-of-the-art algorithms for propagating labels like Label Propagation through Linear Neighborhoods [48], Graph-based Label Propagation [49,50], Transductive SVM [51] and others use these classifiers in their implementations. Additionally, it was demonstrated by Torralba et al. [10] and Karpenko and Aarabi [1] that simple non-parametric techniques like KNN in conjunction with very large datasets can perform comparably to parametric approaches on image classification tasks. One should also note the popularity of SVM in several problem domains that involve classification and retrieval, these being computer vision, information retrieval, natural language processing, finance, computational biology, chemistry, and etc. All this attention has led to SVM implementations that are fast and scalable to large datasets.

Before describing the classifier implementations for objective label prediction, we present some notation regarding the YouTube video dataset in the box that follows. This notation will be used in the descriptions of the video classification algorithms. In these descriptions, the training set is referred to as the labeled set and the test set as the unlabeled set.
                        
                           
                              
                              
                                 
                                    
                                       
                                          
                                             •
                                             
                                                
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                : The set of training videos.
                                          
                                          
                                             •
                                             
                                                
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            test
                                                         
                                                      
                                                   
                                                : The set of videos for testing.
                                          
                                          
                                             •
                                             
                                                M is the number of YouTube categories.
                                          
                                          
                                             •
                                             
                                                
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               :
                                                               i
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     I
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                 is the ith training video, 
                                                   
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                 is the number of training videos.
                                          
                                          
                                             •
                                             The set of objective labels for videos in 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      :
                                                      
                                                         
                                                            Y
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     y
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     
                                                                        
                                                                           0
                                                                           ,
                                                                           1
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     M
                                                                  
                                                               
                                                               :
                                                               i
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     I
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                 where 
                                                   
                                                      
                                                         
                                                            y
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                 is the objective label for ith video and 
                                                   
                                                      
                                                         
                                                            {
                                                            0
                                                            ,
                                                            1
                                                            }
                                                         
                                                         
                                                            M
                                                         
                                                      
                                                   
                                                 means an M-element bit vector with each element either 0 or 1.To indicate that ith video is assigned the mth category label, we set 
                                                   
                                                      
                                                         
                                                            y
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      [
                                                      m
                                                      ]
                                                      =
                                                      1
                                                   
                                                .
                                          
                                          
                                             •
                                             The set of keyframes for videos in 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      :
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     f
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               :
                                                               i
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     I
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               ,
                                                               j
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     J
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                , where 
                                                   
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            ij
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                 is the jth keyframe in the ith training video.
                                                
                                                   
                                                      
                                                         
                                                            J
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                 is the number of keyframes for ith video.
                                          
                                          
                                             •
                                             The feature vectors of keyframes for videos in 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                   
                                                : 
                                                   
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               :
                                                               i
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     I
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                               ,
                                                               j
                                                               =
                                                               1
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     J
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                , where 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            ij
                                                         
                                                         
                                                            train
                                                         
                                                      
                                                      =
                                                      Ψ
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     f
                                                                  
                                                                  
                                                                     ij
                                                                  
                                                                  
                                                                     train
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                . Here 
                                                   
                                                      Ψ
                                                      
                                                         
                                                            
                                                               ·
                                                            
                                                         
                                                      
                                                   
                                                 corresponds to the feature extraction operator.Currently, we use 3 such operators: 
                                                   
                                                      
                                                         
                                                            Ψ
                                                         
                                                         
                                                            RP
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            Ψ
                                                         
                                                         
                                                            LH
                                                         
                                                      
                                                   
                                                 and 
                                                   
                                                      
                                                         
                                                            Ψ
                                                         
                                                         
                                                            GST
                                                         
                                                      
                                                   
                                                 corresponding to the raw pixel values, the luminance histograms, and the GIST features.
                                          
                                          
                                             •
                                             Analogous to the training set, for the test set of videos 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            test
                                                         
                                                      
                                                   
                                                , we have the keyframe set 
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            test
                                                         
                                                      
                                                   
                                                , and the feature vector set 
                                                   
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            test
                                                         
                                                      
                                                   
                                                .We want to predict their labels
                                                
                                                   
                                                      
                                                         
                                                            Y
                                                         
                                                         
                                                            test
                                                         
                                                      
                                                   
                                                using the classifier.
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

In this section, we describe the algorithm for predicting the video category labels for the unlabeled set. The essential steps of the algorithm are listed below, followed by brief descriptions of the important steps:
                           
                              •
                              For all the videos, extract their keyframes using the keyframe extraction algorithm and convert each keyframe to a PCA-compressed feature descriptor. (Section 4.1.1).

For a video from the labeled set, assign its BCL to all its keyframes. (Section 4.1.2).

Use the keyframe feature vectors and their BCLs to train the KNN or the SVM classifier. The specific details for the two classifiers are given in Algorithm 1 for KNN and in Algorithm 2 for SVM.

For a video belonging to the unlabeled set, for each of its keyframes, predict their BCLs using the learned classifier.

Finally, pool together the predicted labels for all the keyframes of the unlabeled video through averaging to obtain a soft-label BCL vector for the video. Threshold this vector to obtain the predicted objective label for the video.

In order to do any kind of classifier training and testing on the videos, we need their feature vector representation. We have chosen to base our video representation on the keyframes that can be extracted from the videos and the subsequent feature-vector based representation of the keyframes.

Keyframes are a set of image frames extracted from the video that summarize its visual content. The keyframes remove the temporal redundancy resulting from high video frame rate and, at the same time, are representative of the visual content variability. After the keyframe extraction step, we compute a feature vector for every keyframe.

For the purpose of a comparative study and in order to lend greater power to our final conclusions, we have implemented three different keyframe extraction algorithms. These are based on
                              
                                 1.
                                 Intensity-of-motion (IM).

Sufficient content change (SCC).

Mean-shift clustering (MSC).

There is a wide variety of keyframe extraction algorithms reported in the literature (see [52] for a review). It would obviously be impossible to implement them all for a comparison study. The three choices that we have implemented are representative of a large pool of such algorithms with regards to the following aspects of the keyframe extraction process: (1) the number of resulting keyframes; (2) the representation scope of the keyframes; and (3) the computational steps used for identifying the keyframes. Our three implemented algorithms have the advantage that they take the underlying visual dynamics into consideration to varying degrees and in different ways.

Our comparative study includes computing three different types of features for every keyframe:
                              
                                 1.
                                 Raw pixel intensity values (RP).

Block-wise luminance histogram (LH).

GIST features (GST) [53].

With regards to our choice of the visual features as listed above, note that these capture the global properties of the keyframes (overall pixel intensities, luminance, or the spectral properties of an image). The point-based and region-based features that we do not include in our comparative study are better suited for recognition and for finding matches for specific object categories in images. Due to the nature of the YouTube videos (keeping in mind that they are contributed by a large Internet community of users), the diversity of visual content in these videos is very large. The variability in the keyframes extracted from such videos with respect to illumination conditions, scale, viewpoints and mixed usage of natural scene content and artificially generated graphical animations would simply be much too large if we analyzed the keyframes with point-based or region-based features. A more reasonable approach is to compare the keyframes based on their overall properties such as color, texture or, for that matter, any other global feature distributions—which is what we do with the features we have listed above.
                              1
                              Despite our reservations about the usefulness of point-based and region-based features for characterizing the keyframes, one can certainly make a case for their inclusion in a comparative study through, say, bag-of-word based techniques. In our Conclusions section, we have suggested that future comparative studies of the sort we report here include such features.
                           
                           
                              1
                           
                        

The different choices of keyframe extraction algorithm and the feature type result in nine different datasets of keyframe feature vectors and labels for the video classification experiments. The same experiments are run on these nine datasets for comparing the effect of the choice of the keyframe extraction algorithm and the choice of the visual features extracted from the keyframes with regard to the performance of the classifiers. For identifying these different datasets during the reporting of our results, we have used tags that are shown in Table 3
                           .

We now present brief descriptions for the three different keyframe extraction algorithms used in our study.

In the intensity-of-motion based keyframe extraction [1,54,55], the temporal profile of motion intensity change in a video sequence is generated by considering all pairs of consecutive frames. Intensity-of-Motion is defined as the mean difference between the pixel luminance values of consecutive frames, summed over all the pixels,
                              
                                 
                                    a
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          WH
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             w
                                             ,
                                             h
                                          
                                       
                                    
                                    
                                       
                                          
                                             L
                                             
                                                
                                                   
                                                      w
                                                      ,
                                                      h
                                                      ,
                                                      t
                                                      +
                                                      1
                                                   
                                                
                                             
                                             -
                                             L
                                             
                                                
                                                   
                                                      w
                                                      ,
                                                      h
                                                      ,
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           where W and H are the image frame dimensions and 
                              
                                 L
                                 (
                                 w
                                 ,
                                 h
                                 ,
                                 t
                                 )
                              
                            are the pixel luminance values at time instant t. The extrema in this profile are the points of high motion or sudden scene changes and the keyframes are extracted at the instants of these peaks.

The second keyframe extraction technique based on sufficient content change [56,57] proceeds sequentially in time and only depends on the image frames up to the current temporal position. A frame is selected as a keyframe only if its visual content differs significantly from the previously extracted keyframes. In the mathematical form, given the most recently selected keyframe 
                              
                                 
                                    
                                       f
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                           , the next keyframe 
                              
                                 
                                    
                                       f
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                    
                                 
                              
                            is selected as follows: 
                              
                                 
                                    
                                       r
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       argmin
                                    
                                    
                                       t
                                    
                                 
                                 
                                    
                                       
                                          C
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         
                                                            
                                                               r
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                             
                                          
                                          >
                                          ε
                                          ,
                                          
                                             
                                                r
                                             
                                             
                                                i
                                             
                                          
                                          <
                                          t
                                          ⩽
                                          n
                                       
                                    
                                 
                              
                           , where n is the total number of image frames and 
                              
                                 C
                                 (
                                 .
                                 ,
                                 .
                                 )
                              
                            is the function for measuring the content change between two frames. 
                              
                                 ε
                              
                            is the sufficient content change threshold. In our implementation, the function 
                              
                                 C
                                 (
                                 .
                                 ,
                                 .
                                 )
                              
                            computes the frame content change as the summed chi-square distance measure between the luminance histograms of rectangular image blocks: 
                              
                                 C
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       b
                                       ∊
                                       B
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       
                                          
                                             χ
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                H
                                             
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                             
                                                b
                                             
                                          
                                          ,
                                          
                                             
                                                H
                                             
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             
                                                b
                                             
                                          
                                       
                                    
                                 
                              
                           . Here 
                              
                                 B
                              
                            is the grid that partitions an image frame into smaller rectangular blocks and 
                              
                                 
                                    
                                       H
                                    
                                    
                                       f
                                    
                                    
                                       b
                                    
                                 
                              
                            is the luminance histogram of the frame f over the pixels contained in the image block b.

The third keyframe extraction algorithm is based on mean-shift clustering [58,59] and it treats the video frames as points in a multi-dimensional feature space. Clustering is performed in this feature space and the representative points of the resulting clusters are taken as the keyframes of the video sequence. We have used the block-wise luminance histogram as the feature representation of the image frames used for clustering.

After the keyframes have been extracted from a video, the visual features are computed for every keyframe. The three types of features mentioned previously result in feature vectors of different lengths for the representation of the keyframes. For keyframes of size 
                              
                                 80
                                 ×
                                 60
                              
                            with 3 color channels, the raw-pixel intensity based approach gives us a feature vector of length 14,400, the block-wise luminance histogram based method a feature vector of size 64, and, finally, the GIST feature based method a feature vector of length 960. One could think of carrying out the video classifier training and testing on these feature vectors. The problem would be that the training and the testing times would be proportional to the lengths of feature vectors used. Therefore, to ensure that all computations can be carried out in a reasonable amount of time and also that the computation times for the three different types of features are roughly the same, we perform PCA dimensionality reduction on the features. For different feature sets, the number of retained principal components varied from 26 to 32 and it was based on discarding 0.1% of the energy in the lower end of eigenvalue spectrum to avoid storing spurious, numerically unstable eigenvalues.
                              Algorithm 1
                              
                                 Label prediction for the test set using KNN 
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         •
                                                         Training set is 
                                                               
                                                                  
                                                                     
                                                                        D
                                                                     
                                                                     
                                                                        train
                                                                     
                                                                  
                                                                  =
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                       ,
                                                                                       
                                                                                          
                                                                                             y
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                              
                                                                              |
                                                                              
                                                                              
                                                                              
                                                                                 
                                                                                    x
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    R
                                                                                 
                                                                                 
                                                                                    N
                                                                                 
                                                                              
                                                                              ,
                                                                              
                                                                                 
                                                                                    y
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          0
                                                                                          ,
                                                                                          1
                                                                                       
                                                                                    
                                                                                 
                                                                                 
                                                                                    M
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                            , where 
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              0
                                                                              ,
                                                                              1
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        M
                                                                     
                                                                  
                                                               
                                                             means an M-element bit vector with each element either 0 or 1. N is the dimensionality of feature vectors.
                                                      
                                                      
                                                         •
                                                         For a video belonging to the test set 
                                                               
                                                                  v
                                                                  
                                                                  ∊
                                                                  
                                                                  
                                                                     
                                                                        V
                                                                     
                                                                     
                                                                        test
                                                                     
                                                                  
                                                               
                                                            , extract its keyframes 
                                                               
                                                                  
                                                                     
                                                                        f
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                             and compute their feature vectors 
                                                               
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                            . Here R is the number of extracted keyframes for the video v.
                                                      
                                                      
                                                         •
                                                         For each keyframe feature vector 
                                                               
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                            
                                                            
                                                               
                                                                  –
                                                                  Find the K nearest neighbors in the training set, 
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          x
                                                                                       
                                                                                       
                                                                                          k
                                                                                       
                                                                                       
                                                                                          train
                                                                                       
                                                                                    
                                                                                    ,
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          k
                                                                                       
                                                                                       
                                                                                          train
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                           ,
                                                                           k
                                                                           =
                                                                           1
                                                                           ,
                                                                           …
                                                                           ,
                                                                           K
                                                                        
                                                                     .
                                                               
                                                               
                                                                  –
                                                                  Compute the label 
                                                                        
                                                                           
                                                                              
                                                                                 y
                                                                              
                                                                              
                                                                                 r
                                                                              
                                                                           
                                                                        
                                                                      for 
                                                                        
                                                                           
                                                                              
                                                                                 x
                                                                              
                                                                              
                                                                                 r
                                                                              
                                                                           
                                                                        
                                                                      using majority voting:
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    y
                                                                                 
                                                                                 
                                                                                    r
                                                                                 
                                                                              
                                                                              [
                                                                              m
                                                                              ]
                                                                              =
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          
                                                                                             
                                                                                                1
                                                                                             
                                                                                             
                                                                                                
                                                                                                   
                                                                                                      ∑
                                                                                                   
                                                                                                   
                                                                                                      k
                                                                                                      =
                                                                                                      1
                                                                                                   
                                                                                                   
                                                                                                      K
                                                                                                   
                                                                                                
                                                                                                
                                                                                                   
                                                                                                      y
                                                                                                   
                                                                                                   
                                                                                                      k
                                                                                                   
                                                                                                   
                                                                                                      train
                                                                                                   
                                                                                                
                                                                                                [
                                                                                                m
                                                                                                ]
                                                                                                >
                                                                                                K
                                                                                                /
                                                                                                2
                                                                                             
                                                                                          
                                                                                          
                                                                                             
                                                                                                0
                                                                                             
                                                                                             
                                                                                                otherwise
                                                                                             
                                                                                          
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                              ,
                                                                              
                                                                              m
                                                                              =
                                                                              1
                                                                              ,
                                                                              …
                                                                              ,
                                                                              M
                                                                           
                                                                        
                                                                     .
                                                               
                                                               
                                                                  –
                                                                  The BCL vector for the keyframe is 
                                                                        
                                                                           
                                                                              
                                                                                 y
                                                                              
                                                                              
                                                                                 r
                                                                              
                                                                           
                                                                           =
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    1
                                                                                    ]
                                                                                    ,
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    2
                                                                                    ]
                                                                                    ,
                                                                                    …
                                                                                    ,
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    M
                                                                                    ]
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     .
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         •
                                                         Compute the objective label 
                                                               
                                                                  y
                                                               
                                                             for v by averaging individual bits of the keyframe labels and then thresholding. 
                                                               
                                                                  τ
                                                               
                                                             is the thresholding constant.
                                                               
                                                                  
                                                                     y
                                                                     [
                                                                     m
                                                                     ]
                                                                     =
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       1
                                                                                    
                                                                                    
                                                                                       
                                                                                          
                                                                                             1
                                                                                          
                                                                                          
                                                                                             R
                                                                                          
                                                                                       
                                                                                       
                                                                                          
                                                                                             
                                                                                                ∑
                                                                                             
                                                                                             
                                                                                                r
                                                                                                =
                                                                                                1
                                                                                             
                                                                                             
                                                                                                R
                                                                                             
                                                                                          
                                                                                       
                                                                                       
                                                                                          
                                                                                             y
                                                                                          
                                                                                          
                                                                                             r
                                                                                          
                                                                                       
                                                                                       [
                                                                                       m
                                                                                       ]
                                                                                       ⩾
                                                                                       τ
                                                                                    
                                                                                 
                                                                                 
                                                                                    
                                                                                       0
                                                                                    
                                                                                    
                                                                                       otherwise
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Label prediction for the test set using SVM 
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         •
                                                         Training set is 
                                                               
                                                                  
                                                                     
                                                                        D
                                                                     
                                                                     
                                                                        train
                                                                     
                                                                  
                                                                  =
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                       ,
                                                                                       
                                                                                          
                                                                                             y
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                              
                                                                              |
                                                                              
                                                                              
                                                                              
                                                                                 
                                                                                    x
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    R
                                                                                 
                                                                                 
                                                                                    N
                                                                                 
                                                                              
                                                                              ,
                                                                              
                                                                                 
                                                                                    y
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          0
                                                                                          ,
                                                                                          1
                                                                                       
                                                                                    
                                                                                 
                                                                                 
                                                                                    M
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                            , where 
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              0
                                                                              ,
                                                                              1
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        M
                                                                     
                                                                  
                                                               
                                                             means an M-element bit vector with each element either 0 or 1. N is the dimensionality of feature vectors.
                                                      
                                                      
                                                         •
                                                         Train M independent binary SVM classifiers 
                                                               
                                                                  
                                                                     
                                                                        F
                                                                     
                                                                     
                                                                        m
                                                                     
                                                                  
                                                                  ,
                                                                  m
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  M
                                                               
                                                             by splitting 
                                                               
                                                                  
                                                                     
                                                                        D
                                                                     
                                                                     
                                                                        train
                                                                     
                                                                  
                                                               
                                                             into M training sets corresponding to each bit of the n BCL vectors belonging to 
                                                               
                                                                  
                                                                     
                                                                        D
                                                                     
                                                                     
                                                                        train
                                                                     
                                                                  
                                                               
                                                            : 
                                                               
                                                                  
                                                                     
                                                                        D
                                                                     
                                                                     
                                                                        m
                                                                     
                                                                     
                                                                        train
                                                                     
                                                                  
                                                                  =
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          
                                                                                             x
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                       ,
                                                                                       
                                                                                          
                                                                                             y
                                                                                          
                                                                                          
                                                                                             i
                                                                                          
                                                                                          
                                                                                             train
                                                                                          
                                                                                       
                                                                                       [
                                                                                       m
                                                                                       ]
                                                                                    
                                                                                 
                                                                              
                                                                              
                                                                              |
                                                                              
                                                                              
                                                                              
                                                                                 
                                                                                    x
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    R
                                                                                 
                                                                                 
                                                                                    N
                                                                                 
                                                                              
                                                                              ,
                                                                              
                                                                                 
                                                                                    y
                                                                                 
                                                                                 
                                                                                    i
                                                                                 
                                                                                 
                                                                                    train
                                                                                 
                                                                              
                                                                              [
                                                                              m
                                                                              ]
                                                                              
                                                                              ∊
                                                                              
                                                                                 
                                                                                    
                                                                                       0
                                                                                       ,
                                                                                       1
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        n
                                                                     
                                                                  
                                                               
                                                             .
                                                      
                                                      
                                                         •
                                                         For a video belonging to the test set 
                                                               
                                                                  v
                                                                  
                                                                  ∊
                                                                  
                                                                  
                                                                     
                                                                        V
                                                                     
                                                                     
                                                                        test
                                                                     
                                                                  
                                                               
                                                            , extract its keyframes 
                                                               
                                                                  
                                                                     
                                                                        f
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                             and compute their feature vectors 
                                                               
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                            . Here R is the number of extracted keyframes for the video v.
                                                      
                                                      
                                                         •
                                                         For each keyframe feature vector 
                                                               
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        r
                                                                     
                                                                  
                                                                  ,
                                                                  r
                                                                  =
                                                                  1
                                                                  ,
                                                                  …
                                                                  ,
                                                                  R
                                                               
                                                            ,
                                                               
                                                                  –
                                                                  Predict the mth bit of the BCL vector 
                                                                        
                                                                           
                                                                              
                                                                                 y
                                                                              
                                                                              
                                                                                 r
                                                                              
                                                                           
                                                                           [
                                                                           m
                                                                           ]
                                                                           =
                                                                           
                                                                              
                                                                                 F
                                                                              
                                                                              
                                                                                 m
                                                                              
                                                                           
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          x
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                           ,
                                                                           m
                                                                           =
                                                                           1
                                                                           ,
                                                                           …
                                                                           ,
                                                                           M
                                                                        
                                                                     .
                                                               
                                                               
                                                                  –
                                                                  The BCL vector for the keyframe is 
                                                                        
                                                                           
                                                                              
                                                                                 y
                                                                              
                                                                              
                                                                                 r
                                                                              
                                                                           
                                                                           =
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    1
                                                                                    ]
                                                                                    ,
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    2
                                                                                    ]
                                                                                    ,
                                                                                    …
                                                                                    ,
                                                                                    
                                                                                       
                                                                                          y
                                                                                       
                                                                                       
                                                                                          r
                                                                                       
                                                                                    
                                                                                    [
                                                                                    M
                                                                                    ]
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     .
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         •
                                                         Compute the objective label 
                                                               
                                                                  y
                                                               
                                                             for v by averaging the individual bits of the keyframe labels and then thresholding. 
                                                               
                                                                  τ
                                                               
                                                             is the thresholding constant.
                                                               
                                                                  
                                                                     y
                                                                     [
                                                                     m
                                                                     ]
                                                                     =
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       1
                                                                                    
                                                                                    
                                                                                       
                                                                                          
                                                                                             1
                                                                                          
                                                                                          
                                                                                             R
                                                                                          
                                                                                       
                                                                                       
                                                                                          
                                                                                             
                                                                                                ∑
                                                                                             
                                                                                             
                                                                                                r
                                                                                                =
                                                                                                1
                                                                                             
                                                                                             
                                                                                                R
                                                                                             
                                                                                          
                                                                                       
                                                                                       
                                                                                          
                                                                                             y
                                                                                          
                                                                                          
                                                                                             r
                                                                                          
                                                                                       
                                                                                       [
                                                                                       m
                                                                                       ]
                                                                                       ⩾
                                                                                       τ
                                                                                    
                                                                                 
                                                                                 
                                                                                    
                                                                                       0
                                                                                    
                                                                                    
                                                                                       otherwise
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

During the label creation process discussed in Section 3, the objective label is assigned to a video as a single entity. But for the classifier training, we use feature vectors corresponding to the individual keyframes of the videos. Therefore when the keyframes are extracted from a video, some way of inferring the keyframe’s objective labels from the video objective label is required so that the (feature-vector, label) pairs can be fed to the classifier. A principled way to do this would be to examine the semantic content of the video and its component keyframes and decide as to which subsets of visual categories from the video objective label should be assigned to the different keyframes. This can be an extremely challenging process considering the degree of complexity involved in understanding the visual semantics of an image or a video. We do not attempt to address this difficult problem in this paper. Rather, we opt for a simple strategy where the objective label of the video is assigned to each of its keyframes.

Assigning a video’s label to its keyframes needs to be commented on. An objective label for a video must capture the visual diversity of the entire video. For example, if a News video includes a prominent portion that is focused primarily on automobiles, it would be reasonable to expect that the video’s objective label should have the News and Autos bits set in its BCL vector. The keyframes that are extracted from the automobiles portion of the video obviously carry some association with the News category because they are being shown as part of a news coverage. So it seems reasonable that those keyframes would carry both the labels, News and Autos. However, it may be questionable to assign the label Autos to the keyframes extracted from the non-automobile portions of a news video. That is evidently a weak point in our admittedly simpleminded algorithmic step of assigning a video’s objective label to all its keyframes. However, since the alternative of having human annotators label the keyframes individually is completely impractical, we must accept the consequences of our simpleminded approach and demonstrate that our overall method for the objective labeling works despite the shortcomings introduced by this step.
                              2
                              In support of assigning a video’s label to all its keyframes, one could argue that even if a small fraction of the keyframes get a few irrelevant categories included in their objective labels, in general it is likely that the irrelevant labels would get averaged out when the objective labels are pooled together and by the final step of thresholding the BCL vector.
                           
                           
                              2
                           
                        

A valid question may be posed about the motivation for creating objective labels: How do the subjective category labels provided by the video uploaders compare with the majority-voted objective labels supplied by the panel of human annotators? In other words, what is the justification for creating these new objective labels for the videos when the subjective labels might have served the purpose of ground-truth for video classification? Our whole premise in the paper is that the labels supplied by the video uploaders, because of their subjective nature, do not constitute a high quality ground-truth for the video categorization task. We now establish this through the fourfold cross validation experiment performed on the ground-truth set of 1000 videos. In every round of the experiment, 750 videos were used as the labeled set for training the classifier and the rest 250 were used as the unlabeled set for which the labels were predicted.


                        Fig. 4
                         shows the ROC curves to compare the consistency of the objective and the subjective labels. The consistency of a labels was measured by comparing the individual bits of the ground-truth BCL vector of a video and its predicted BCL vector returned by the classifier. In each plot, we show four ROC curves, two for the objective labels resulting from the KNN and SVM classifiers, and the other two for the subjective labels. In the figure, we have shown these curves for two of the nine datasets mentioned earlier: IM_GST and SCC_RP. The following observations can readily be made from both the plots:
                           
                              •
                              The objective labels result in better classification performance, or in other words, are more consistent than the subjective labels for both the classifiers.

The SVM classifier gives a superior performance both with objective and subjective labels compared to the KNN classifier.

It is also an interesting exercise to compare the performance of the objective labels with the labels provided by the individual annotators. This is shown in Fig. 5
                        . The top row shows the ROC curves for objective labels, uploader-supplied subjective labels and the annotator-supplied labels for each of the 5 annotators. The results are shown for the KNN and SVM classifier on the IM_GST dataset. In the bottom row, the ROC curves from the individual annotators were averaged and the sub-figures show the mean 
                           
                              ±
                           
                         one standard deviation ROC curves. From the results, it is evident that the objective labels perform better than the individual annotator subjective labels and this strengthens the claim that just multilabels are not sufficient to get advantage over the uploader-supplied subjective labels. The extra step of aggregating the annotator labels to get the objective labels is necessary to the boost in classification performance.

Similar conclusions can be drawn for the other datasets. Due to space constraints, we do not show the ROC curves for all the datasets. Instead, we summarize their results in the form of two bar plots for the KNN and SVM classifiers in Fig. 6
                        . In these plots, we could have used area under the ROC curve as the numerical measure of label consistency. Instead, we have used the g-means metric [60] because it is a better measure for datasets having unbalanced positive and negative sample populations (which is the case for some of our YouTube categories). This metric separately includes the classification accuracies of the positively and negatively labeled data. It is defined as the geometric mean of the true positive and the true negative rates, 
                           
                              gmeans
                              =
                              
                                 
                                    tp
                                    ·
                                    tn
                                 
                              
                           
                        . Here, tp and tn are defined as: 
                           
                              tp
                              =
                              
                                 
                                    TP
                                 
                                 
                                    TP
                                    +
                                    FN
                                 
                              
                           
                         and 
                           
                              tn
                              =
                              
                                 
                                    TN
                                 
                                 
                                    TN
                                    +
                                    FP
                                 
                              
                           
                        . Higher values of the g-means metric imply better label consistency and better classifier performance.

It is also instructive to compare the relative classification performance using objective labels on all the datasets. We want to draw some general conclusions regarding which keyframe extraction algorithm and which visual features for representing the keyframes work best with the objective labels. This can be accomplished by comparing the ROC curves for all nine datasets.

In Fig. 7
                        , we show such plots separately for the KNN and the SVM classifiers. The plots show that the keyframes extracted using the intensity-of-motion and sufficient-content-change algorithms lead to better classifier performance compared to the keyframes extracted with the mean-shift clustering approach. A plausible reason for this is that mean-shift clustering generally results in significantly smaller number of keyframes for a video, compared to the other two algorithms. This may lead to excessively coarser temporal sampling of the visual information for the video to be adequately summarized with the keyframes when they are extracted with the mean-shift-clustering algorithm.

With regard to the visual features used to represent the keyframes, the GIST features result in superior label consistency compared to the luminance histogram based features and the raw pixel features for both the classifiers.

Among all the nine datasets, the one corresponding to the combination of the intensity-of-motion based algorithm for keyframe extraction and the GIST features for the representation of the keyframes resulted in the best classification performance using the objective labels.

In our cross-validation experiments, we compared two scenarios:
                           
                              1.
                              Objective labels are used during the training stage and the predicted labels of the test instances are validated against their objective ground-truth labels.

Subjective labels are used during the training stage and predicted labels of the test instances are validated against their subjective ground-truth labels.

The ROC curves are used to compare the performance between these two scenarios. A valid objection may be raised that in drawing the ROC curves, in the former scenario, objective ground-truth labels for the test set are being used while for the latter scenario, subjective ground-truth labels are being used. This is different from the usual manner in which the ROC curves are used, i.e. to compare the performance of different algorithms while keeping the dataset fixed. Conventionally, the competing algorithms are trained separately using the same training set and then their predicted labels for the test instances are validated against the same ground-truth labels.

In contrast, in our present situation, the multiple ROC curves are drawn by keeping the classification algorithm fixed (e.g. either KNN or SVM) and changing the types of labels employed for training and testing. There is no way to avoid the fact that the test sets would be different when the label type is changed. Therefore, strictly speaking, the method of point-by-point comparing the ROC curves at all the false positive rates cannot be used to compare between the two label types. Nevertheless, this limitation should not lead us away from the validity and importance of the research question that which among the multiple labeling strategies is best, in some sense, to label the data instances.

Through the following simple example, we first of all establish the point that one labeling strategy may be superior to another for better partitioning the feature space in which the data instances are situated. And then we discuss what information do the ROC curves give about the two labeling strategies. Consider an experiment where we have the face images of several people and for each face image, we have two different types of labels: (1) the nationality of the person, and (2) the race of the person. Both types of labels are multiclass labels. As is evident from Fig. 8
                        , for the same data points in the feature space, training procedure based on nationality labels leads to a simpler and more accurate classifier as compared to training with race labels. Of course, a classifier trained with nationality labels has to be evaluated with nationality label ground-truth for the test instances and similarly, a classifier trained with race labels has to be evaluated with race label ground-truth, and so technically speaking, the two classifiers cannot be compared. Nevertheless, as the illustration in Fig. 8 shows, for the same data instances, nationality labeling leads to a better partitioning of the feature space compared to race labeling.

Even though the ROC curves for the above two cases cannot be compared, we refer to the definition of AUC (Area Under the Curve) from a paper on ROC analysis by Fawcett [61]: the AUC of a classifier is equivalent to the probability that the classifier will rank a randomly chosen positive instance higher than a randomly chosen negative instance. So even if two ROC curves cannot be compared point-by-point at all the false positive rates, their AUCs can give us an idea as to which classifier has the higher probability of ranking a randomly chosen positive instance higher than a randomly chosen negative instance. Note that nowhere in comparing such probabilities, we need to make use of the fact that they be computed based on the same ground-truth set. The same analogy and explanation can be carried over to our case of objective and subjective labels.

Still, we can take some steps to alleviate this concern regarding the disparity between the testing sets originating from different label types. The disparity between the ground-truth sets is mainly coming from the fact that an uploader-supplied subjective label for a video allows only one of the 15 labels to be assigned while on the other hand, the objective label is intrinsically multilabel, i.e. it allows any number of labels from among the 15 categories to be assigned to a video. Therefore the two label types have different distributions. Fig. 9
                         shows the label distributions for the different types of labels: the objective labels, the uploader-supplied subjective labels and the subjective labels from individual annotators. Note that we are making a distinction between the subjective labels provided by the uploaders of the videos and the ones provided by each of the 5 annotators. The annotator labels are still considered subjective because they are coming from a single person. In computing the label distributions in Fig. 9, we considered each category (e.g. Sports, News, etc.) as an independent Bernoulli random variable with binary values 0/1 and computed its probability of being 1. In this way, for each label type, we get a vector of 15 probabilities which is shown as a bar graph in the figure. Whether two label types have similar or dissimilar label distributions can be ascertained by computing the symmetric KL divergence between their corresponding probability vectors. Table 4
                         shows these values between the probability vector of the objective labels and those of each of the other type of labels. The numbers in the table clearly indicate that annotator-supplied subjective labels are closer in distribution to the objective labels than the uploader-supplied labels.

In the ROC results presented thus far, we had to train and test with the same label type. For example, a classifier trained with the uploader-supplied subjective labels could not be evaluated against the objective ground-truth labels due to the different label distributions of the two label types. But such a thing would become possible if want to compare the performance of objective labels with the annotator-supplied subjective labels. Because of the fact that the annotator-supplied label distribution is similar to objective label distribution (as is seen from Fig. 9 and Table 4), we can train a classifier with annotator-supplied labels and then evaluate the predicted labels against the objective ground-truth labels at the testing stage. Now, this situation is closer to the way ROC curves are conventionally used. During the training stage, we train using either the objective labels or the annotator supplied labels but during the testing stage, we keep the test set fixed by comparing the predicted labels from different classifiers with the same ground-truth labels, i.e the objective labels of the test instances. The results for this experiment are shown in Fig. 10
                        . The top row shows the ROC curves for the objective labels and the annotator-supplied labels for each of the 5 annotators. The results are shown for the KNN and SVM classifier on the IM_GST dataset. In the bottom row, the ROC curves from the individual annotators were averaged and the mean 
                           
                              ±
                           
                         one standard deviation ROC curves are shown. These ROC curves give further support to the fact that the classifier performance is superior for objective labels than with the subjective labels from an individual annotator. This experiment was not performed with uploader-supplied subjective labels due to their different label distribution from the objective labels.

In the previous section, we quantitatively measured the consistency of the objective labels on the ground-truth video dataset. The objective labels were available for the 1000 videos in the ground-truth set and therefore, we could train a classifier with objective labels using a training set of 750 videos and then predict the labels for the rest 250 videos in a cross-validation experiment. The predicted labels could then be compared with the videos’ ground-truth objective labels.

In contrast, in this section, we predict the objective labels for the remaining ̃51,000 videos of the large-scale dataset by training a classifier with all the 1000 videos of the ground-truth set. Based on the observations made in the last section, we performed the large-scale prediction using only the IM_GST features and the SVM classifier because, in the cross-validation experiments, these resulted in the best prediction performance among the nine feature sets and among the two different classifiers.

One thing to note is that because there are no ground-truth objective labels available for the large-scale dataset, it is not possible to quantitatively estimate the accuracy of the predicted objective labels. Instead, we can make a qualitative projection about the performance of the objective labels by alluding to how the subjective labels would compare in their performance on the small ground-truth set and on the large-scale set. We expect that the label predicting classifier behaves similarly on the large dataset as on the ground-truth set. Hence the consistency of the predicted labels with the ground-truth labels for the two scenarios should be about the same. This can actually be verified for the subjective labels because ground-truth subjective labels are available both for the small video set as well as the large set.


                     Fig. 11
                      shows that the classifier trained with subjectively-labeled data will give similar performance in terms of label consistency when making predictions on the small-scale and the large-scale datasets. This is indicated by the closely following red solid and dashed ROC curves. Therefore, we can project that the ROC curve corresponding to the predicted objective labels on the large dataset will also closely match the blue solid curve that corresponds to the objective label consistency on the small dataset. This would in turn indicate that the performance of the objective labels is superior to that of subjective labels on the large video dataset even if the classifier learning is performed with a very small sized training set.

Because we allow for multiple categories to be present in a video’s BCL vector, this makes it possible for us to determine which set of categories tend to co-occur in a video’s content. If the co-occurring labels have closely related semantic meanings, then it can be inferred that the objective labels are effectively clubbing together the categories that different labelers would tend to assign to the same video based on their subjective judgment. For example, consider the Sports category in Table 5
                     . Using the predicted objective labels of the large dataset, we considered all the videos whose Sports bit was turned on. For such videos, we determined the other five most frequently occurring categories in their objective labels. These are shown in the right column of the Sports row. Most of these categories (e.g. People, Games, Autos, Entertainment) are the ones that the annotators would also try to assign to a video based largely on sports content because:
                        
                           1.
                           Most sports videos contain people.


                              Games and Sports can be considered synonymous for certain videos.

Motor sport videos show autos predominantly.

Many people may find the Sports videos as entertaining.

Another example can be given about the Entertainmentcategory where the top 5 co-occurring categories are People, Film, Comedy, Travel and Music. It is not a difficult exercise to argue that the content in an Entertainment video can be associated with one or more of these other categories. Similar inferences can be made about the rest of the YouTube categories shown in the table. Such information would be completely suppressed by the subjective labels because the annotator is forced to assign only one category label to the video.

@&#CONCLUSIONS@&#

The human uploaders deciding for themselves as to what label to assign to a video creates a large degree of label noise in a large database such as the one made available by YouTube. There are legitimate practical reasons for wanting to see a greater consistency in these category labels.

With the methodology we provide in this paper, a video service like YouTube could still allow for subjective labeling of the videos, as is currently the practice, but now the viewers could also be given a choice of accessing videos through the more consistent objective labels.

Our work has demonstrated that for three different types of visual features and for two different types of video classifiers, the objective labels result in superior label consistency on the unlabeled set as compared to the subjective labels. We also showed that it is possible to predict objective labels for the videos in a large database of 51,000 videos by training a video classifier based on the objective labels created originally for a more manageable subset of the database.

With regard to how the work reported here can be extended, obviously our work represents just one approach to the problem of labeling large video databases in a consistent manner. We can surely expect that future work in this area would include other algorithms for keyframe extraction, other visual features for the representation of the keyframes, and, possibly, also other classifiers. Future approaches may also experiment with different logic for the pooling of multiple labels for a video when more than one label is available for a video. Yet another expansion on our work would be the use of a larger ground-truth set – larger than the 1000 videos used in our work here.

@&#ACKNOWLEDGMENTS@&#

This work was supported by Olympus Corporation. We would like to thank Alex Karpenko and Parham Aarabi for sharing their TinyVideos dataset with us. Finally, our thanks are due to the panel of human annotators who provided objective labels for the videos in the ground-truth set.

@&#REFERENCES@&#

