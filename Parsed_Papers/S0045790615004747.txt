@&#MAIN-TITLE@&#Survey on state scheduling-based topology control in unattended wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We survey the state scheduling-based topology control protocols suitable for unattended wireless sensor networks.


                        
                        
                           
                           We categorize the protocols based on the parameters used for state scheduling.


                        
                        
                           
                           Advantages, drawbacks, and results of existing methods are tabulated.


                        
                        
                           
                           We delineate future research issues in design of state scheduling-based topology control protocols.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Unattended wireless sensor networks

Topology control

State scheduling

Connectivity

Coverage

Sleep–wakeup scheduling

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           Image, graphical abstract
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

Wireless sensor networks (WSNs) consist of large numbers of sensor nodes that are densely deployed to monitor physical or environmental conditions and report the monitored information to the base station for further processing. WSNs have been used in applications such as environmental monitoring, habitat monitoring, structural health monitoring, medical sensor networks, internet of things, and delay tolerant networks.

Nodes in unattended WSNs (UWSNs) are subject to harsh environmental conditions in applications where human access is difficult once nodes are deployed [1]. In these networks, the nodes have to adapt to the dynamic change in the environment. The network's topology changes frequently because of node failure, new node addition, channel fading, and network partitioning. If all the nodes deployed on a terrain are used simultaneously, the nodes expend surplus energy. The data transmitted by a node interferes with data of the other nodes causing congestion. To deal with the adaptiveness of working of energy-constrained nodes in UWSNs, the topology control algorithm is executed at regular intervals in order for the application fidelity to not be affected.

In [2], an overview of topology control techniques, which are based on network coverage and connectivity, is provided. Coverage intensity near the boundary facilitates in avoiding certain areas with poor accessibility by varying the transmission range of nodes. A temporal domain in network connectivity deals with energy savings of sensor nodes by switching between the active and sleep states of the nodes. Three types of medium access control (MAC) protocols, synchronous, asynchronous, and hybrid protocols, are discussed. This paper provides a detailed survey of state scheduling approaches in both flat and hierarchical networks, in which the scheduling decisions are taken according to a network layer protocol or a supporting module of the network layer protocol, and not according to the MAC protocol alone as in [2].

Topology control protocols provided in this paper deal with extensive state scheduling approaches for flat and hierarchical networks to achieve reduced energy consumption, increased lifetime, and improved connectivity and coverage. Specific applications suitable for the topology control algorithms are highlighted. In contrast, the authors in [3] have discussed topology control approaches for two-dimensional (2D) and three-dimensional WSNs. In 2D WSNs, four categories of topology control algorithms are discussed: power adjustment, power mode, cluster, and hybrid. In the power mode approach, state scheduling topology control algorithms that consider reducing energy consumption are discussed. In the power adjustment approach, the nodes vary in their transmission power in accordance with distance, to conserve energy. In the cluster approach, cluster heads are elected to form a hierarchical structure to construct efficient topology. The hybrid approach, which helps to achieve less energy consumption, is the combination of all these approaches.

The nature of multihop and unregulated communication of nodes in WSNs (Fig. 1
                         (a)) face interference from neighboring nodes, which leads to collision and high energy consumption. Topology control is an important technique used in wireless ad hoc and sensor networks to reduce energy consumption, contention to wireless channels, and radio interference. As shown in Fig. 1 (b), the basic idea of a topology control protocol is to regulate the communication among nodes. The goals of topology control protocols in WSNs are [4]: (a) to prolong the network lifetime; (b) to limit congestion; (c) to increase the efficiency of MAC and routing protocols; (d) to ensure good coverage and connectivity; and (e) to improve network performance, such as less delay and high packet delivery ratio.

Topology control protocols for WSNs are broadly classified into power control and state scheduling protocols (Fig. 2
                        ) [4]. In power control-based protocols, the transmission power of nodes is adjusted in accordance with distance. The working of state scheduling protocols is similar to duty-cycle WSNs in which nodes usually switch between active and dormant states periodically to achieve balanced energy consumption and increased network lifetime. Transition from one state to another depends on parameters illustrated in Fig. 3.
                        
                     

Other topology control options for regulating communication among nodes in WSNs are as follows:

                           
                              •
                              Graph model: The network is modeled as a graph with vertices representing nodes and edges representing connectivity among nodes. The graph models are used to determine cut vertices, node placement, and path calculation.

Backbone model: The backbone nodes are responsible for relaying traffic and maintaining connectivity in the network. Theoretical evaluation of topology control focuses on connected dominating set (CDS) [5] to construct an active backbone route to the sink. On detecting an event, nodes connect to backbone nodes to forward data.

The remainder of this paper is organized as follows: Section 2 specifies the need for state scheduling. Sections 3 and 4 review the state scheduling topology control protocols for flat and hierarchical networks. Section 5 specifies points to consider in designing state scheduling-based topology control protocols. Finally, Section 6 concludes the paper.

Topology control solutions have to guarantee certain requirements, such as connectivity, coverage, and lifetime.

                        
                           •
                           Connectivity: It ensures reliable and robust routing. A network is said to be fully connected if there exists a path between the source and destination. The path could be direct or established via intermediate nodes. Topology control must ensure the minimum number of active nodes required to achieve connectivity.

Network lifetime: Network lifetime indicates the time in which the network is operational. It depends on the battery power capacity of the sensor nodes. Topology control must ensure that the state scheduling of nodes leads to improved lifetime.

Coverage: Each sensor node has a certain coverage area. It reports with higher confidence on the occurrence of events in the monitored region. Topology control must ensure that all parts of the monitored region are covered by an observing node or by a group of nodes.

The multistate system reads input and generates appropriate output for each of its states [6]. The common characteristics of such systems are as follows: (a) it involves a series of system states; (b) in each state, one or more functions are carried out; (c) there are rules defining the transitions between states. At a specific period of time, only a certain number of nodes operate so as to have a distributed workload and avoid congestion. The use of global positioning system (GPS) by nodes to obtain location information results in high energy consumption. To make the nodes to work without geographical information is challenging [7]. Turning off nodes may generate blind points if none of the nodes are monitoring the region of interest. Therefore, providing good scheduling algorithms to turn off nodes without degrading coverage and connectivity is crucial.

The parameters used for categorizing state scheduling topology control techniques for flat and hierarchical networks are summarized in Fig. 3. A flat network comprises source and sink nodes. If an event is observed, the source nodes flood the data toward the sink node. In a hierarchical network, nodes are grouped into clusters, and cluster heads are elected for each cluster to form a backbone network. The role of a cluster head is to aggregate data from the cluster members before sending it toward the sink node.
                  

In a flat network, data is collected using data-centric routing [8]. The sink transmits a query to all nodes through flooding, and the source nodes check for events matching the query and respond accordingly. This section highlights the state scheduling-based topology control protocols meant for flat network. The advantages, disadvantages, and results for few topology control protocols have been summarized in Table 1.

Probing environment and adaptive sleeping (PEAS) is a fault tolerant protocol, which uses a randomized wakeup algorithm to extend network lifetime and adapt to node failures [9]. The operation states of PEAS are sleeping, probing, and working (Fig. 4
                        ). The nodes are initially in sleeping state, and each node sleeps for an exponentially distributed duration generated according to the probability density function (PDF).

                           
                              (1)
                              
                                 
                                    f
                                    
                                       (
                                       
                                          t
                                          s
                                       
                                       )
                                    
                                    =
                                    λ
                                    
                                       e
                                       
                                          −
                                          λ
                                          
                                             t
                                             s
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where λ is the probing rate and ts
                         represents the sleeping duration. After ts
                         expires, the node wakes up and enters probing state. A probing node broadcasts PROBE control message. The node switches to sleep state for a duration ts
                         if it receives a reply from the working neighbor node. If the node does not receive a REPLY message (due to failure), it switches to working state and starts functioning until it fails or consumes all its energy. The probing rate λ is adjusted dynamically according to neighbor count. Each working node maintains a counter N, which records the PROBE messages received and the associated timestamps. The counter value, set as 0, is incremented by one for every new PROBE message received.

The aggregate probing rate 
                           
                              λ
                              ¯
                           
                         is calculated as

                           
                              (2)
                              
                                 
                                    
                                       λ
                                       ¯
                                    
                                    =
                                    
                                       k
                                       
                                          t
                                          −
                                          
                                             t
                                             o
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where k denotes the threshold value of the counter, t denotes the current time, and t0
                         represents the most recent time when N was set to 0. The reception of REPLY message from a working node updates the probing value from 
                           
                              λ
                              ¯
                           
                         to λ.

                           
                              (3)
                              
                                 
                                    
                                       λ
                                       
                                          n
                                          e
                                          w
                                       
                                    
                                    =
                                    λ
                                    
                                       
                                          λ
                                          d
                                       
                                       
                                          λ
                                          ¯
                                       
                                    
                                    ,
                                 
                              
                           
                        where λd
                         is the desired rate and λnew
                         is the new probing rate. The sleeping period ts
                         is adjusted according to PDF

                           
                              (4)
                              
                                 
                                    f
                                    
                                       (
                                       
                                          t
                                          s
                                       
                                       )
                                    
                                    =
                                    
                                       λ
                                       
                                          n
                                          e
                                          w
                                       
                                    
                                    
                                       e
                                       
                                          −
                                          
                                             λ
                                             
                                                n
                                                e
                                                w
                                             
                                          
                                          
                                             t
                                             s
                                          
                                       
                                    
                                 
                              
                           
                        
                     

PEAS is suitable for densely deployed nodes with sufficient sleeping neighbor nodes and scenarios in which sensor nodes can be destroyed by enemy bombs and vehicles on the battlefield.

Lightweight deployment-aware scheduling (LDAS) turns off redundant sensor nodes without using accurate location information to increase the network lifetime and coverage area [7]. LDAS consists of three states, namely, on-duty, ready-to-off, and off-duty. A node in on-duty state performs sensing and communication tasks. It periodically checks the working neighbor's count on the basis of predefined requirements. As shown in Fig. 5
                        , a node enters ready-to-off state when the ticket count exceeds the threshold value and wakes up after a certain duration, called as random backoff time between 0 and Wmax. After wakeup, if the neighbor count is more than estimated, the node goes into the off-duty (sleep) state for a particular sleeping time (ST). After ST expires, the node erases previously received tickets and enters on-duty state. LDAS uses the weighted random voting method to decide an eligible node to set into sleep mode. The voting mechanism adds more weights to the neighbors with high density. The LDAS approach is suitable for applications in which small blind points are acceptable in the deployment area. For example, a building temperature control system is effective only if it can acquire temperature information for every room. In an ecosystem monitoring system, obtaining environmental information for closely located areas is not necessary.

The coverage configuration protocol (CCP) achieves varying degrees of coverage according to application requirements [10]. CCP has three main states, namely, ACTIVE, SLEEP, and LISTEN. In addition, CCP has two transient states, JOIN and WITHDRAW, to avoid contention. Fig. 6
                         illustrates the state transition diagram of CCP. The initial state of nodes is ACTIVE, from which the redundant neighbors switch to the SLEEP state. The nodes then enter the LISTEN state once the sleep timer Ts
                         expires. When a beacon (HELLO, WITHDRAW, or JOIN message) is received, a node evaluates its eligibility. If it is eligible, it initiates a join timer Tj
                         and switches to the JOIN state. Otherwise, it sets Ts
                         and switches to the SLEEP state when the listen timer Tl
                         expires. In the JOIN state, if a node becomes ineligible before Tj
                         expires (e.g., due to the reception of a JOIN message), it cancels Tj
                         and reverts to the SLEEP state. If Tj
                         expires, it broadcasts the JOIN message and enters the ACTIVE state. In the ACTIVE state, when a node receives a HELLO message, it executes the coverage eligibility algorithm to determine its eligibility to remain active. If it is ineligible, it starts the withdraw timer Tw
                         and enters the WITHDRAW state. In the WITHDRAW state, if a node becomes eligible (due to the reception of a WITHDRAW or HELLO message) before Tw
                         expires, it cancels Tw
                         and switches to the ACTIVE state. If Tw
                         expires, it broadcasts the WITHDRAW message and reverts to the SLEEP state. CCP is suitable in surveillance applications, in which the sensor nodes initially maintain a low degree of coverage required for distributed detection. After an intruder is detected, the region in the vicinity of the intruder must reconfigure itself to achieve a higher degree of coverage required for distributed tracking.

The process of energy saving by scheduling sleep intervals for redundant nodes is discussed in [11]. It uses two-hop neighborhood information for selecting a subset of nodes to be active. A node can be in one of the three states: sleep, listen and active. Fig. 7
                         illustrates the state transition diagram of this approach in which initially the nodes are in the listen state. Nodes exchange HELLO messages to gather information about their neighbors. If a node does not receive an announcement message from its neighbor before the expiration of Tl
                        , the node enters the active state. If the node receives a WITHDRAWAL message before Tl
                         expires (i.e., its node ID is not found in the sender's active list) from its neighbors, the node switches to the sleep state, or if the node receives a JOIN message (i.e., its node ID is found in the sender active list), the node enters the active state and broadcasts its own active set. A node in the active state periodically checks if it should turn its radio off, and switch to sleep state. This decision is based on the eligibility rule, every pair of neighbor nodes can reach each other by two hops. The node in the active state switches to listen state for every Ta
                         time duration. The nodes in the sleep state switch to listen state for every Ts
                         time interval. It is suitable for networks with densely deployed nodes for continuous monitoring of a hostile environment.

Adaptive self-configuring sensor network topologies (ASCENT) are constructed using a minimal number of active nodes to maintain connectivity and adaptive activation of nodes on the basis of neighbor and data loss threshold [12]. ASCENT consists of four states, namely, sleep, passive, test, and active. 
                        Fig. 8
                         shows the state transition diagram of ASCENT. The nodes are initially in the test state. A time interval Tt
                         is set and neighbors are sent announcement messages. When Tt
                         expires, the node enters the active state. Before the expiration of Tt
                        , if the active neighbor count is above the neighbor threshold (NT), or if the average data loss rate (DL) is higher than the average loss (To
                        ), the node switches to the passive state. When a node enters the passive state, it sets up a timer Tp
                         and informs the active nodes, thus facilitating the active nodes in estimating the node density. Before Tp
                         expires, if the number of neighbors is found below NT or the node receives help messages from an active neighbor or data loss is more than the loss threshold (LT), the node transitions to the test state. Nodes in passive and test states continuously update the number of active neighbors and DL values. The expiration of timer Tp
                         switches a node to sleep state. A node in the sleep state turns the radio off and sets a timer Ts
                        . When Ts
                         expires, the node reverts to the passive state. A node in active state continues forwarding the data and routing packets until it runs out of energy. If DL is greater than LT, then the active node sends help messages to activate more nodes. The final packet loss from each neighbor node is calculated using an exponentially weighted moving average (EWMA) of the form

                           
                              (5)
                              
                                 
                                    E
                                    W
                                    M
                                    
                                       A
                                       
                                          c
                                          u
                                          r
                                          r
                                          e
                                          n
                                          t
                                       
                                    
                                    =
                                    ρ
                                    .
                                    C
                                    W
                                    +
                                    
                                       (
                                       1
                                       −
                                       ρ
                                       )
                                    
                                    E
                                    W
                                    M
                                    
                                       A
                                       
                                          p
                                          r
                                          e
                                          v
                                          i
                                          o
                                          u
                                          s
                                       
                                    
                                    ,
                                 
                              
                           
                        where CW is the contention window, which keeps track of the packets received from the neighbor node and ρ is the filter constant set to 0.3. The neighbor loss threshold (NLS) is determined by

                           
                              (6)
                              
                                 
                                    N
                                    L
                                    S
                                    =
                                    1
                                    
                                    −
                                    1
                                    /
                                    N
                                    ,
                                 
                              
                           
                        where N is the number of neighbors calculated in the previous cycle. ASCENT is used for habitat monitoring.

Easy quality of service (QoS)-based topology control in WSNs (EasiTPQ) [13] focuses on extending QoS to a network with a subset of active nodes. Fig. 9
                         depicts the state transition diagram of EasiTPQ, which consists of four states, namely, R_Test, R_Active, R_Passive, and R_Sleep. Initially, all the nodes, except “sink,” are in R_Passive state. The sink node transmits Topo_Initial control message. Nodes receiving Topo_Initial message switch to R_Test state and exchange control and data messages. If a node finds that the average data loss rate (PL) is higher than average loss (P0
                        ) before entering the R_Test state, or if the neighbor count δ(N) is larger than average neighbors count (N), the node reverts to the R_Passive state. The node in the R_Passive state switches to the R_Test state, if δ(N) is greater than N or PL
                         is greater than data loss threshold (PT
                        ). The node enters the R_Active after the expiration of Tt
                        . The node enters the R_Sleep state from the R_Passive state after Tp
                         expires. The node reverts to the R_Passive state when the timer Ts
                         expires. Nodes in the R_Active state switch to the R_Test state for every Ta
                         period to detect whether they should transition to low power consuming states, such as R_Passive and R_Sleep states. EasiTPQ is applied in hybrid WSNs for real time imaging and video transmissions.

A distributed lifetime optimization algorithm is used for minimizing a node's energy by using smart monitoring schedules [14]. The node can be in one of the following states: active, idle, vulnerable, permanent, or terminated (Fig. 10
                        ). The rules for state transition are as follows: (1) A node in the vulnerable state monitors the region and switches to the active state (transition A) if a region or face is not covered by any other node; (2) A node in the vulnerable state switches to the idle state if all its faces are covered by one or two nodes (transition B); (3) Transition E is a variation of transition A, in which a node in the active state is the only one covering certain face, transitions F and G are used by nodes to switch to the terminated state when their power supply has been exhausted; (4) Nodes in active or idle states switch to the vulnerable state if any neighboring node becomes vulnerable (transitions C and D); (5) Once a node becomes permanent, it stays so until its energy exhausts below the threshold value. This topology control approach finds application in battlefield monitoring, natural calamities, and other similar situations, in which a large area must be monitored.

The authors in [15] implemented a topology control protocol that achieves full connectivity and sensing coverage over an entire network field. Fig. 11
                         illustrates that a node can be in any of the four states, namely, Active, Listen, Sleep, and Relay states. The nodes are initially maintained in the listen state. The sink selects the farthest node within its one-hop sensing radius r to be active. It selects two more nodes located vertically and one node located horizontally against the line connecting the sink and farthest node and activates them. The sleeping nodes revert to the initial listen state after a period Ts
                        . A node in the listen state switches to the active state if it receives a designation message from active nodes. If the time limit TL
                         (time at listen state) expires, the node reverts to the sleep state. When the active node receives an advertisement message more than three times, it switches to the relay state, which provides interconnection among the active nodes. If the residual energy of nodes in the active and relay states falls below the threshold energy TE
                        , the nodes switch to the sleep state. This topology control approach is suitable for target tracking applications, where the location of an object is detected by a group of nodes.

The three-phase single initiator (TPSI) algorithm [16] is used for the formation of the backbone nodes that are responsible for relaying traffic throughout the network and maintaining connectivity. The remaining nodes in the network are activated to transmit their sensor readings to the closer backbone node. The algorithm works by constructing a maximal independent set (MIS) and joins nonMIS nodes to generate CDS. In the second stage of the algorithm, CDS is generated, and the final stage deals with the pruning of CDS. The CDS nodes are selected based on a metric called key. The key of a node u is determined by

                           
                              (7)
                              
                                 
                                    k
                                    e
                                    y
                                    
                                       (
                                       u
                                       )
                                    
                                    =
                                    f
                                    a
                                    i
                                    r
                                    n
                                    e
                                    s
                                    s
                                    
                                       (
                                       u
                                       )
                                    
                                    +
                                    n
                                    o
                                    d
                                    e
                                    D
                                    e
                                    g
                                    r
                                    e
                                    e
                                    
                                       (
                                       u
                                       )
                                    
                                    ,
                                 
                              
                           
                        where nodeDegree(u) is the number of neighbors of node u and fairness is determined by

                           
                              (8)
                              
                                 
                                    f
                                    a
                                    i
                                    r
                                    n
                                    e
                                    s
                                    s
                                    
                                       (
                                       u
                                       )
                                    
                                    =
                                    
                                       (
                                       
                                          
                                             d
                                             n
                                          
                                          
                                             
                                                d
                                                n
                                             
                                             +
                                             n
                                             −
                                             1
                                          
                                       
                                       )
                                    
                                    
                                       (
                                       
                                          
                                             E
                                             r
                                          
                                          
                                             E
                                             i
                                          
                                       
                                       )
                                    
                                    ,
                                 
                              
                           
                        where d is the distance between the pair of nodes, Er
                         is the residual energy, Ei
                         is the initial energy, and n is the path loss exponent. Fig. 12
                         depicts the state transition diagram of the TPSI algorithm, in which all the nodes initially remain in the Uncovered state. The MIS construction starts with a node volunteering to be an initiator. It switches to the Dominator state and broadcasts a dominator message. Upon receiving the message, the nodes change to the Dominatee state, and this process continues until all Uncovered nodes have changed the state. A Dominatee receiving the CDS message sends a Volunteer Connector message to its neighbors and waits Tdom
                         time interval for an invitation to become CDS. The timer Tdom
                         is computed as follows:

                           
                              (9)
                              
                                 
                                    
                                       T
                                       
                                          d
                                          o
                                          m
                                       
                                    
                                    =
                                    
                                       T
                                       max
                                    
                                    
                                       (
                                       
                                          
                                             1
                                             
                                                n
                                                o
                                                d
                                                e
                                                D
                                                e
                                                g
                                                r
                                                e
                                                e
                                                (
                                                u
                                                )
                                             
                                          
                                          X
                                          
                                             1
                                             
                                                E
                                                
                                                   
                                                      (
                                                      u
                                                      )
                                                   
                                                   r
                                                
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where Tmax
                         is the predefined time value and E(u)r
                         is the residual energy of node u. A node switches to Dominatee state, if it and its one-hop neighbor are in the CDS state. The flexibility of this approach is appealing to environmental monitoring applications, in which replacing or recharging the battery of nodes once deployed on a terrain may not be practical.

Policy-controlled self-configuration for UWSN (PCSSN) [1] uses the markov decision process (MDP) for dynamic optimal activation of nodes. In PCSSN, nodes are in any of the five states, namely, Active, Passive, Discovery, Emergency, and Sleep states (Fig. 13
                        ). Initially, all nodes are in the discovery state, during which they send HELLO messages to their one-hop neighbors. After a duration of Tlearn
                        , the initiator (no
                        ) and sink (nN
                        ) switch to the active state and the remaining nodes switch to the passive state, in which no sensing is performed. The nodes in the passive state switch to active, sleep, and emergency states if they receive PTOAN_message, PTOS_message, and PTOE_message, respectively. The nodes switch to passive state for every Ts
                         interval from their current states. The nodes receiving the PTOE_message switch to the emergency state and respond in case of node failures. For every Treo
                         interval, the network is reorganized, and the nodes transition back to the passive state, except the initiator and sink nodes. The values of Ts
                         and num are determined as follows:

                           
                              (10)
                              
                                 
                                    T
                                    s
                                    =
                                    
                                       
                                          (
                                          n
                                          u
                                          m
                                          +
                                          1
                                          )
                                       
                                       *
                                    
                                    
                                       T
                                       
                                          r
                                          e
                                          o
                                       
                                    
                                    −
                                    
                                       T
                                       
                                          n
                                          o
                                          w
                                       
                                    
                                    ,
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    n
                                    u
                                    m
                                    =
                                    
                                       |
                                       
                                          T
                                          S
                                          /
                                          
                                             T
                                             
                                                r
                                                e
                                                o
                                             
                                          
                                       
                                       |
                                    
                                    ,
                                 
                              
                           
                        where Tnow
                         is the current time, num is the number of reorganizations that have already occurred, and Timestamp TS is obtained from the routing table. A node has m number of active nodes that are chosen on the basis of the distance between neighbors and residual energy of nodes. PCSSN is suitable for military operations in hostile environment and target tracking applications.

The aim of the secure topology maintenance protocol (Sec-TMP) [17] is to enforce event delivery to the base station (BS) while providing a standard topology maintenance service to WSNs. In Sec-TMP, each node has three operating states, namely, working, sleeping, and probing (Fig. 14
                        ). Once a node is deployed, it starts in the sleeping state with an initial sleeping timeout Ts
                        , randomly selected over a given interval. After the timeout Ts
                        , the node switches to the probing state, in which it broadcasts PROBE control messages. On the basis of the PROBE-REPLY (P-REPLY), the node switches to the working or sleeping state. In particular, if less than the desired P-REPLYs are received, the executing node transitions to the working state from the probing state. Otherwise, it reverts to the sleeping state. The node sets the sleeping time according to an exponential distribution as in PEAS [9]. If the node in the working state is able to contact BS after authentication by using the symmetric key, it transmits data and receives proof from BS, then transitions to the probing state. Sec-TMP is suitable in harsh environmental monitoring applications.

The aim of hop-based disjoint wakeup scheduling algorithm is to achieve full connectivity, coverage, and less energy consumption [18]. The state transition diagram of a sensor node is shown in Fig. 15
                        . Nodes are initially in the sleep state. At every periodical interval ts
                        , nodes switch to the listen state. The nodes in the listen state switch to active state after a time period tL
                        , if none of its neighbors are active. The node reverts to sleep state, if one of their neighbors is active. If several nodes compete to become active, then the contention is resolved by a randomized backoff delay as

                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             
                                                delay
                                             
                                             =
                                             
                                                (
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      Er
                                                      Em
                                                   
                                                   )
                                                
                                                +
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      
                                                         C
                                                         i
                                                      
                                                      
                                                         N
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                +
                                                V
                                                )
                                             
                                             *
                                             
                                                N
                                                i
                                             
                                             *
                                             T
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where Er is the residual energy of a node and Em denotes the maximum energy available. Ci
                         denotes the number of active neighbors with smaller hop count and Ni
                         is the number of neighbors for the sensor node i. The variable T denotes the round trip delay and V is a random variable whose value lies between 0 and 1. Every active node periodically broadcasts HELLO_MSG to determine its neighbors. In the listen state, a node receiving SELECT_MSG switches to Additional_Active. The node transitions to active or withdrawal state depends on the active neighbors count. At every periodical interval tw, a node switches to the active state from withdrawal state. To give each node a fair chance of being active, each node remains in the active state for a certain time period tA
                        . The time period tA
                         is determined depending on the residual energy at each node. An active sensor node periodically checks its residual energy and switches to the withdrawal state when its residual energy reaches a threshold value. Nodes transition to the sleep state from the withdrawal state after an interval tL, if one of their neighbors is active. It is suitable for applications such as battlefield surveillance and inventory tracking.

In hierarchical network, the sensor nodes are organized into clusters, in which cluster members send data to sink via a cluster head. A cluster head acts as a relay in transmitting data toward the sink. Clustering distributes the management responsibility from the base station to cluster heads. As pointed in [19], such distributed management provides a convenient framework for data fusion, local decision making, local control, and energy savings. This section highlights the state scheduling-based topology control protocols for hierarchical WSNs. The advantages, disadvantages, and results for some of the topology control protocols have been summarized in Table 2.
                     
                  

Geographical adaptive fidelity (GAF) [20] uses location information and virtual grids to determine neighbors. The size of a virtual grid depends on the radio range R, and is considered as a square of size r. The nodes in adjacent grids communicate with each other. The distance between two farthest nodes in adjacent grids should not be larger than R, that is,

                           
                              (13)
                              
                                 
                                    
                                       r
                                       2
                                    
                                    +
                                    
                                    
                                       
                                          (
                                          
                                             2
                                             r
                                          
                                          )
                                       
                                       2
                                    
                                    ≤
                                    
                                       R
                                       2
                                    
                                 
                              
                           
                        
                     

The nodes in GAF have three states: sleeping, discovery, and active states (Fig. 16
                        ). Initially, nodes are in the discovery state and become active after time Td
                        . After a certain time Ta
                         the node reverts to the discovery state. A node in the active or discovery state switches to the sleeping state when its neighbors handle routing. Nodes use rank as a metric to decide which node should be involved in routing. The nodes in the active state have a higher rank than those in the discovery state. One active node is maintained in each grid. Each active node estimates the time it expects to leave its gird, and includes this information in the discovery message. The nodes receiving the discovery message adjust their sleep time interval. An active node estimates its time of leaving the grid by using the following formula

                           
                              (14)
                              
                                 
                                    e
                                    n
                                    g
                                    t
                                    =
                                    
                                    r
                                    /
                                    s
                                 
                              
                           
                        where engt is the expected node grid time, s denotes the current speed, and r is the grid size. A node in the sleeping state, after an interval Ts
                        , switches to the discovery state to find neighbors. GAF is suitable for applications such as habitat monitoring and target tracking.

In [21], an extension of GAF, called optimally rigid geographical adaptive fidelity (ORGAF), was proposed for heterogeneous networks to decrease the communication complexity and energy dissipation. GAF offers a four-connected backbone network for large-scale sensor networks. High degree nodes cause interference and high energy consumption. ORGAF is two-connected and the node states are the same as in GAF. The selection of an active node is based on high residual energies in all distributed virtual grids. The active nodes broadcast HELLO messages and determine the neighbors based on HELLO-ACK. To reduce the degree of nodes, some edges are removed, which do not belong to the global optimally rigid graph [22]. The resultant topology is infinitesimally rigid and the total weight of the edges is minimal for the entire rigid graph with same vertices.

Linear distance-based scheduling (LDS) [23] selects a sensor node with a higher probability to sleep when it is distant from the cluster head. All nodes communicate with the cluster head in a single-hop, maintaining a star topology. At each cycle, the cluster head chooses active nodes to transition to the sleep state. The probability with which a sensor node switches to the sleep state depends on the distance between the sensor node and the cluster head (x). The probability p(x) is defined as

                           
                              (15)
                              
                                 
                                    p
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   C
                                                   f
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             
                                                for
                                             
                                             
                                                
                                                   0
                                                   ≤
                                                   x
                                                   ≤
                                                   
                                                      x
                                                      s
                                                   
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                for
                                             
                                             
                                                
                                                   
                                                      x
                                                      s
                                                   
                                                   <
                                                   x
                                                   ≤
                                                   R
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where C is a constant, f(x) is the PDF, R is the maximum transmission range of the cluster head, and xs
                         is defined as

                           
                              (16)
                              
                                 
                                    
                                       x
                                       s
                                    
                                    ≤
                                    R
                                    
                                       
                                          3
                                          (
                                          1
                                          −
                                          
                                             β
                                             s
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        where βs
                         is the fraction of sensor nodes that are allowed to sleep. LDS is suitable for monitoring temperature, humidity, and mechanical stress levels of a building.

In [24], the authors proposed a topology control protocol, in which each node executes the shortest path algorithm until k-shortest disjoint paths are obtained from each node to all their respective neighbor nodes. The k-paths to destination are formed and weights are associated for each path. These weights are based on the eligibility factor (EFpath
                        ) of each path to be selected. A cluster head monitors all existing paths between a sensor and BS within its cluster. At a certain interval, the cluster head activates one of the k-paths and deactivates (sleep mode) the remaining (k−1)-paths. Sorting k-paths in an ascending order between nodes and BS is based on the eligibility factor as follows:

                           
                              (17)
                              
                                 
                                    E
                                    F
                                    p
                                    a
                                    t
                                    
                                       h
                                       k
                                    
                                    
                                       (
                                       
                                          I
                                          ,
                                          
                                          j
                                       
                                       )
                                    
                                    
                                    =
                                    
                                    
                                       
                                          (
                                          
                                             T
                                             o
                                             t
                                             a
                                             l
                                             
                                             
                                             P
                                             a
                                             t
                                             h
                                             
                                             
                                             C
                                             o
                                             s
                                             t
                                             
                                             ×
                                             
                                             M
                                             a
                                             x
                                             i
                                             m
                                             u
                                             m
                                             
                                             
                                             E
                                             d
                                             g
                                             e
                                             
                                             
                                             C
                                             o
                                             s
                                             t
                                             
                                             ×
                                             
                                             H
                                             o
                                             p
                                             
                                             
                                             C
                                             o
                                             u
                                             n
                                             t
                                             
                                             ×
                                             
                                             A
                                             v
                                             a
                                             i
                                             l
                                             a
                                             b
                                             i
                                             l
                                             i
                                             t
                                             y
                                             
                                             
                                             o
                                             f
                                             
                                             
                                             n
                                             o
                                             d
                                             e
                                             s
                                             
                                             
                                             i
                                             n
                                             
                                             
                                             p
                                             a
                                             t
                                             
                                                h
                                                k
                                             
                                          
                                          )
                                       
                                       
                                          −
                                          1
                                       
                                    
                                 
                              
                           
                        
                     

In (17), the first two parameters determine the energy consumption in the path and the last two parameters determine the QoS supporting rate in the path. This topology control approach is suitable for fault tolerant environmental monitoring applications, in which multiple paths to the cluster head are available.

In the connectivity-based partition approach (CPA) [25], the sensor nodes are divided into groups and one node from each group is activated, and other nodes are deactivated (sleep mode). CPA comprises two node types in each group, ordinary and head nodes. Head nodes with high residual energy are selected from each group. CPA undergoes a group merging process, iteratively, before it reaches the final partition. The state transition diagram of a head node is shown in Fig. 17
                        . At the operation's initiation, nodes broadcast UPDATE_MSG, containing their group information, to their neighbors. In the decision state, the head calculates the priority to merge with an adjacent group. If two adjacent groups are in the merging or holding state, then the head node of a group switches to the waiting state to avoid collision. If there is no competition, the head node switches to the contending state and sends MERGE_REQ expressing its willingness to merge with the group. Once merging is completed, it broadcasts UPDATE_MSG, which contains the information of the newly merged group, to its neighbors. A node switches to the holding state if it receives HOLD_MSG from its neighboring groups. CPA is suitable for applications such as perimeter monitoring and target tracking.

Rank-based sleep scheduling (RBSS) [26] controls active and sleep schedules according to the node rank. A sensor node with high residual energy (rank) from each grid is activated. RBSS has four states, namely, Time Synchronization, Discovery, Sleep, and Active states. The state transition diagram of a node is shown in Fig. 18
                        . Initially, nodes are in the Time Synchronization state and transition to the Discovery state after receiving the beacon from BS. From the Discovery state, the node transitions to the Sleep or Active state, depending on the rank of its neighbor and reception of discovery message or the expiration of timer Td
                        . From the Active state, the node reverts to the Discovery or Sleep state, depending on the discovery message that it receives from its partner node and rank or the expiration of timer Ta
                        . From the Sleep state, the node transitions to the Discovery state when the timer Ts expires. RBSS is suitable for applications such as home automation and parking lot monitoring.

Group-based scheduling protocol (GSP) [27] exploits the network density by dividing the nodes into groups. GSP has two phases, namely, group forming and leader's election phases. In the first phase, nodes sharing the same neighbors are grouped together. The second stage of the group forming phase includes the reduction in the number of groups, with the joining of other groups, as in CPA [25]. In the leader's election phase, one node of each group is activated, while others turn their radios off. The active nodes are chosen on the basis of their energy level. If multiple nodes contend for leader election, the node with high residual energy is elected as leader for Ta
                         duration. The remaining nodes involved in the competition transition to the sleep state for Ts
                         duration. After the expiration of Ts
                        , the leader election process starts again. GSP is suitable for target tracking applications.

Energy efficient topology control (ECTC) [28] uses two-hop neighborhood information to switch off redundant nodes, to reduce energy consumption in the network. A node can be in one of the four states: sleep, listen, cluster head, and bridge. Initially, nodes are in the listen state and exchange HELLO messages to determine neighbor nodes. If the node in the listen state does not receive any message within an interval Tl
                        , it switches to the cluster head state and sets a timer TCH.
                         Before expiration of Tl, a node receiving a WITHDRAW message switches to the sleep state and that receiving a JOIN message transitions to the bridge state. The node in the bridge state provides connectivity between two or more clusters. The node in the bridge state transitions to the listen state after an interval Tb
                         or reverts to the sleep state, if every pair of its neighbors can reach each other within three hops. ECTC is suitable for temperature monitoring applications.

In this section, we have highlighted some of the issues to be addressed in designing state scheduling-based topology control protocols.

                        
                           1.
                           As the monitoring environment is prone to extreme environmental conditions, interference and presence of obstacles lead to change in the link quality. It is efficient to consider the effect of interference to check the robustness of the nodes.

In contrast to omnidirectional antennas, use of directional antennas enhances the coverage range, minimizes cochannel interference, and reduces multipath components. The effect of directional antenna in a state scheduling topology control to address interference is yet to be studied.

Most of the existing state scheduling topology control designs focus on either connectivity or coverage. To achieve better QoS, both should be considered. The problem of coverage holes due to node damage, energy exhaustion, or active node count dropping below threshold must be addressed to achieve better connectivity. One such approach is the deployment of relay nodes. Relay nodes have higher energy reserve and long range of communication. These nodes are maintained in a low-energy mode, and are activated when the network experiences the coverage hole problem to achieve lossless data transmission. The other approach is to move the relay nodes to the region facing the coverage hole.

The control messages involved in multistate transition impose additional overhead to determine the sink and to change the node state. Mobile sink is used for reducing the control message involved.

Formation of hotspots around the cluster head or sink can be avoided. Nodes near the cluster head or sink are used frequently in relaying data, which makes the node busy and leads to packet loss and increase in the node temperature. This overheating disrupts the working of nodes. For example, consider a temperature monitoring application in forest environment; the rise in node temperature due to frequent message processing and environmental temperature may create erroneous values. In state scheduling, node temperature could be considered and if the node temperature exceeds the threshold value, the node state could be changed to a low-energy consuming state, such as sleep or idle.

Cross-layer techniques for state transition must be explored. Topology control protocols could make use of other layers in association with network and data link layers in the formation and maintenance of a topology. This facilitates in reducing the delay in neighbor node selection and switching the radio on and off. The cross-layer-based state scheduling topology control protocols have to support application-specific requirements. They must deal with balanced QoS metrics, such as packet delivery ratio, delay, and lifetime.

Most of the existing state scheduling topology control protocols deal with simulation, having unrealistic energy models. The effectiveness of the algorithms must be tested with emulators or testbeds for accurate results.

Node failure, node death, or high traffic conditions cause change in the network topology. In a state scheduling approach, nodes use more time to determine the changes as they are in different states. Therefore, route invalidation may occur in such networks more often. Machine learning techniques [30] could be considered in state scheduling to achieve the objectives (increased packet delivery ratio, reduced delay, and increased throughput) as per the application requirements.

An adversary can easily compromise the functioning of nodes if the availability of sink is intermittent. Hence, data transmission to sink must be performed securely. Implementation of a light weight security algorithm is challenging in resource constrained nodes, for effective data dissemination to sink, while still maintaining integrity, confidentiality, and authentication.

@&#CONCLUSION@&#

Most of the UWSNs involve risky environmental conditions in applications such as volcano monitoring, forest fire monitoring, sand storm monitoring, and battlefield surveillance, where human intervention is minimal. Nodes in these networks have to react to the dynamic change in the environment. This paper reviewed most of the recently proposed state transition-based topology control mechanisms, which were determined to be suitable for UWSNs. In addition, this paper discussed the influence of different parameters involved in these topology control mechanisms for flat and hierarchical networks. To improve the performance according to the changing trend of UWSNs, design of a state scheduling-based topology control algorithm by considering or extending the research areas, which include interference minimization, mobile node or sink, security, QoS, temperature effect, and use of machine learning algorithms are promising for the future.

@&#REFERENCES@&#

