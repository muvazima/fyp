@&#MAIN-TITLE@&#Mobility and QoS aware anycast routing in Mobile ad hoc Networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Anycast routing is important in terms of resources, robustness and efficiency.


                        
                        
                           
                           The proposed model is based on node stability, congestion and link/route expiry time.


                        
                        
                           
                           Performs better in terms of control overheads, PDR and end-to-end delay.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mobile ad hoc Network

Congestion

Anycast

Stability

Routing

QoS

@&#ABSTRACT@&#


               
               
                  Anycast is an important way of communication for Mobile Ad hoc Networks (MANETs) in terms of resources, robustness and efficiency for replicated service applications. Most of the anycast routing protocols select unstable and congested intermediate nodes, thereby causing frequent path failures and packet losses. We propose a mobility and quality of service aware anycast routing scheme in MANETs (MQAR) that employs three models: (1) node movement stability, (2) channel congestion, and (3) link/route expiry time. These models coupled with Dynamic Source Routing (DSR) protocol are used in the route discovery process to select nearest k-servers. A server among k-servers is selected based on less congestion, route expiry time, number of hops, and better stability. The simulation results indicate that proposed MQAR demonstrates, reduction in control overheads, path delays and improved packet delivery ratio compared to existing methods such as flooding, DSR and load balanced service discovery.
               
            

@&#INTRODUCTION@&#

Mobile Ad hoc Networks (MANETs) consists of a set of wireless mobile nodes communicating to each other without any centralized control or fixed network infrastructure and can be deployed quickly [1,2]. The potential applications include emergency disaster relief, battlefield situations, mine site operations, and wireless classrooms or meeting rooms in which participants wish to share information or to acquire data.

Anycast is an important way of communication for replicated service applications in terms of resources, robustness and efficiency, when mobility and link disconnections are frequent. Anycast allows a source node to transmit packets to a single destination node out of set of several destination nodes. The idea behind anycast is that a client wants to send packets to any one of the nearest possible servers offering a particular service or application. The set of destination nodes is identified by anycast address [3]. As compared to unicast and multicast, anycast is a new type of communication defined in IPv6 that provides a service mainly in client server environment [4].

Constructing and maintaining anycast communication should be simple so as to keep minimum control overheads. It is a common practice in most of the anycast routing protocols, where in packets are sent along the shortest path [5]. This is because, fewer nodes involved in transmission may save the power, network bandwidth and collisions during the message transmission.

One of the most important issue in MANETs is to find an efficient and reliable anycast route. The current research on MANETs mainly focuses on ad-hoc routing protocols with minimum hop count, energy efficiency, low server load, and low congestion, as the route selection criterion. Although there are many proposed routing protocols for MANETs, most of them consider the shortest-path with minimum hop count as the route selection criterion. Even though hop metric is easy to implement and reliable in dynamic environments, the queuing delay and the contention delay at the intermediate nodes are not taken into account for route selection. Thus, a minimum hop path may sometimes incur a higher end-to-end delay than some alternate paths. Moreover, routing protocols based on minimum number of hops some times cannot fairly distribute the routing load among mobile hosts. An unbalanced distribution of traffic may lead to higher packet dropping rate and faster battery power depletion on certain mobile nodes.

The objective of this paper is to design and analyze a stability and QoS based anycast routing scheme in MANET to improve the performance and enhance the service availability through the method of evenly distributed traffic load. The scheme uses Dynamic Source Routing (DSR) [6] as basic route finding protocol along with stability and QoS models. Our contributions as compared to existing works are as follows. (1) Designing a mathematical model for selecting stable nodes (with respect to position) based on node’s own stability, i.e., self stability, and neighbor nodes stability. (2) Designing a mathematical model for selecting noncongested nodes based on channel load and node buffer occupancy. (3) Designing a mathematical model for finding link expiry time between pair of nodes. (4) Design of route discovery process, which includes request phase to find routes to anycast servers through forwarding intermediate nodes which satisfy stability, congestion criteria and also meet the route expiry deadline; and reply phase to update routing cache and confirm the routes found in request phase, and (5) designing route maintenance procedure to handle node and link failures.

The rest of the paper is organized as follows. Section 2 presents an overview of existing MANET anycast routing protocols, Section 3 discusses the proposed work. Simulation and result analysis are presented in Section 4, and conclusions are given in Section 5.

@&#RELATED WORK@&#

Related works done in the field of anycast routing are presented in this section. Anycast service discovery in MANETs usually relies on network-layer message broadcasting, which leads to large traffic overhead for the scarce bandwidth of MANETs. In Design and implementation of an anycast services discovery (DIASD) [7], traffic-control mechanism is used to balance the load in anycast service discovery, and also supports k-anycast service. With k-anycast service, the fault tolerance and service flexibility is improved. DIASD scheme is used for comparison with our scheme to overcome some of its drawbacks as follows.

DIASD is basically a hierarchical routing protocol, where in prior to the construction of anycast tree, node clustering and virtual backbone are required to organize the nodes in a MANET. Route computation is carried out at the cluster head nodes only; the movement of the cluster nodes adversely affects the performance of the protocol. Also, the cluster node update information could cause a significant amount of control overhead. Thus the main drawback of the tree based protocols is that they are not robust enough to operate in highly mobile environments.

The work presented in [8] introduces anycast method and theory into challenged communication processes in opportunistic network. In [9], IPv6 uses anycast concept and proposes a k-anycast communication model which can route k-anycast service request messages to the nearest k-anycast tree node to provide the requested service, and can evenly distribute across the k-anycast tree nodes.

In [10], authors consider the density of nodes through count of routes to the anycast group member as a routing metric. In [11], a QoS anycast routing algorithm based on ant colony optimization is proposed, which regulates the pheromone on the best path and adopts resetting method and candidate set strategy to avoid falling into local optimal path and expand searching space of ant colony. In [12], Zone Routing Protocol (ZRP) and anycast addressing is presented assuming the destination as a member of anycast address.

The work presented in [13] proposes an Adaptive Neuro-Fuzzy Inference System (ANFIS) based multiple QoS constrained anycast routing by using a set of static and mobile agents. The work given in [14] provides load balancing and failover services in a way that other IT organization teams can use without having to manage the underlying technology.

A Petri-net-based simulation model of a MANET is developed and studied in [15]. The model enables representation of reliability aspects of wireless communication such as fading effects, interferences, presence of obstacles and weather conditions in a general and rather easy way.

The work proposed in [16] is an adaptive congestion aware protocol that detects and reacts to congested nodes and congested parts of the network by using implicit hybrid contact and resources congestion heuristic in delay tolerant networks. In [17], a framework to evaluate network dependability and performability is presented.

In [18], various schemes to improve routing protocol performance by using mobility prediction is presented. To avoid congestion in IP, a backup topology design method is used in [19]. This backup topology design method splits the traffic on high load links to other links by considering network conditions, such as the traffic matrix or topology.

The work given in [20] explores an end-to-end threshold-based algorithm which enhances congestion control to address link failure loss in MANET by using link failures, round trip time and retransmission time out estimation. The work presented in [21] for Limiting Greedy Connections (LGC) uses an active congestion control mechanism for minimizing the degradation in network performance caused by bandwidth greedy applications on a congested node. The work presented in [22] proposes an early congestion detection and adaptive routing which constructs a NHN (non-congested neighbors) list and finds a route to a destination through NHN nodes.

The work given in [23] considers finding QoS anycast path from client (source) to any one of the server by using software agents. Protocol uses integration of static and mobile agents for inferring the QoS path from a set of multiple paths by using Fuzzy Inference System (FIS). The work given in [24] proposes a QoS-Oriented Distributed routing protocol (QOD) to enhance the QoS support capability of hybrid networks. Taking advantage of fewer transmission hops and anycast transmission features of the hybrid networks, QOD transforms the packet routing problem to a resource scheduling problem.

In [25], k-anycast members are selected from a set of servers by three different schemes. The three schemes discuss about how to select k servers depending on the radius of flooding, by selecting at least k members and members less than k members. The Adaptive On-demand Distance Vector (AODV) routing protocol extended to support anycast routing is presented in [26]. Route request and route reply are used to identify anycast server. A node communicates simultaneously with only one anycast member.

The work given in [27] describes the probability of connected route to anycast member as a function of dynamicity and density of the network. Anycast routing scheme chooses the shortest path routing as well as considers node degree density of hosts in the network through count of routes to the anycast group member.

There are some works on smart packet based routing, hybrid routing and DSR security enhancement which may be helpful in anycast routing. The work in [28] presents a new infrastructure where smart data packets are used to guide through best available route in the network and minimizes convergence time. The work given in [29] proposes a routing protocol that divides the Spatial Wireless Ad Hoc networks (SWAH) into backbone and non-backbone networks to perform static routing and dynamic routing, respectively. It provides load balancing adaptively by establishing and maintaining multiple node-disjoint routes. Authors in [30] present a security enhancement to DSR protocol against wormhole attacks in ad hoc networks for multirate transmissions which relies on calculation of round trip time (RTT). It uses the processing and queuing delays of each participating node in the calculation of RTTs between neighbors.

According to the literature survey, it has been observed that there is scope for improving anycast routing schemes in MANETs in terms of control overheads, load balancing, stable routes, and QoS. Thus there is a need to develop a robust and an efficient movement stability and QoS based congestion aware anycast routing scheme in MANET. We have designed three major models in our approach to anycast routing discovery problem. (1) Stability model to identify stable nodes, (2) congestion model to take QoS into consideration by checking congestion aware parameters like channel load, and buffer occupancy, and (3) link expiry time model to make sure the link duration will fall within an acceptable range.

This section presents, background of DSR, node movement stability model, congestion model, link expiration time model, route establishment, route discovery and maintenance.

Dynamic source routing (DSR) is an on-demand reactive routing protocol designed to restrict the bandwidth consumed by control packets, by eliminating the periodic table update messages required in the table driven proactive approach.

It uses source routing instead of relying on the routing table at each intermediate node. DSR is beaconless and hence does not require periodic hello packet transmissions. Route construction phase establishes a route by flooding route request (RR) packets in the network. An intermediate node, upon receiving a RR packet, checks the sequence number on the packet before forwarding it. The packet is forwarded only if it is not duplicate RR. The sequence number on the packet is used to prevent loop formation. RR packet updates itself with traversed nodes address, which will facilitate in path construction. The destination node, on receiving a RR packet, responds by sending a route reply (RP) packet to the source by using traversed addresses. Thus source will have the address to destination through intermediate nodes.

Even though DSR protocol performs well in static and low mobility environment, the performance degrades rapidly with increasing mobility. To enhance the performance, we use modified DSR and call it as Mobility and QoS aware Anycast Routing in Mobile ad hoc Networks (MQAR). Our protocol (MQAR) works better under dynamic and high mobility environment, since we include stability model to identify more stable nodes, congestion model to check traffic on the channel dynamically and link expiry model to check duration of the link, so that selected path will stay for longer duration in anycast routing.

The stable nodes are necessary in forwarding group to provide better packet delivery services. Node stability in terms of movement around its current position gives us an idea of stationary property of node. Node stability metrics are used to identify stable nodes in a path for forwarding packets from a source to anycast node.

Two metrics are identified to represent node movement stability as the quality of connectivity: self stability, and neighbor nodes stability. The steps in finding the stability of a node are as follows. (1) All the nodes in MANET find the self movement stability, i.e, node movement relative to its previous position, and (2) find neighbor node movement stability of all the nodes in MANET by considering the neighbors self stability. Each node in a MANET will compute the node movement stability factor based on self and neighbor nodes movement stability.


                        Self movement stability 
                        
                           
                              
                                 
                                    S
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                        : It can be defined as the node’s movement with respect to its previous position. A node is said to be stable if its movement is within given fraction of its transmission range. Consider the scenario as shown in Fig. 1
                        , where a node with transmission range ‘r’ moves from position (
                           
                              
                                 
                                    x
                                 
                                 
                                    r
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    r
                                 
                              
                           
                        ) to (
                           
                              
                                 
                                    x
                                 
                                 
                                    n
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    n
                                 
                              
                           
                        ) in a given time window by a distance ‘d’.

When a node moves from its previous position, its movement stability relative to previous position keeps varying, and the distance of movement of a node (
                           
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                           
                        ) in a time window ‘t’ can be measured by using Eq. (1).
                           
                              (1)
                              
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   n
                                                
                                             
                                             -
                                             
                                                
                                                   x
                                                
                                                
                                                   r
                                                
                                             
                                             )
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             (
                                             
                                                
                                                   y
                                                
                                                
                                                   n
                                                
                                             
                                             -
                                             
                                                
                                                   y
                                                
                                                
                                                   r
                                                
                                             
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Based on the movement of the distance at every time window, the self stability metric (
                           
                              
                                 
                                    S
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                        ) can be estimated as given in Eq. (2). 
                           
                              
                                 
                                    S
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                         varies between 0 and 1. When the movement distance (
                           
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                           
                        ) of a node increases, the self stability value will decrease. For the requirement of the higher degree of movement stability, ‘r’ can be replaced by ‘r/2’ or ‘r/4’ or ‘r/8’ etc.
                           
                              (2)
                              
                                 
                                    
                                       S
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                   -
                                                   
                                                      
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               t
                                                            
                                                         
                                                      
                                                      
                                                         r
                                                         /
                                                         2
                                                      
                                                   
                                                
                                                
                                                   if
                                                   
                                                   0
                                                   ⩽
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   <
                                                   r
                                                   /
                                                   2
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   Otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

There are some limitations in calculation of self stability due to the influence of GPS accuracy and resolution. Better results can be estimated with higher accuracy and resolution in GPS. This work assumes that GPS accuracy and resolution is limited to 95% and 7.8m, respectively [31].


                        Neighbor node movement stability (
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                        ): It can be defined as a node’s connectivity to its neighbor in terms of neighbor’s self movement stability. Each node accumulates connectivity information and signal stability of one hop neighbors, and maintains a neighbor list.

The degree of a node ‘n’ is represented as number of links (or nodes) connected to it, and is denoted as ‘ND’. The neighbor node stability of a node (
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                        ) with respect to neighbors at time ‘t’ can be expressed as in Eq. (3).
                           
                              (3)
                              
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                                 =
                                 α
                                 ×
                                 
                                    
                                       1
                                    
                                    
                                       ND
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          ND
                                       
                                    
                                 
                                 
                                    
                                       S
                                    
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                                 (
                                 t
                                 )
                                 +
                                 (
                                 1
                                 -
                                 α
                                 )
                                 ×
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 -
                                 1
                                 )
                              
                           
                        where 
                           
                              α
                           
                         is the weightage factor (lies between 0 and 1), 
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              -
                              1
                              )
                           
                         is the recent neighbor node stability, and 
                           
                              
                                 
                                    S
                                 
                                 
                                    s
                                    ,
                                    i
                                 
                              
                              (
                              t
                              )
                           
                         is the self stability of neighbor node ‘i’. We are using the stability model to select nodes with higher self and neighbor stability values such that the selected path through such stable nodes stays for a longer duration.


                        Node movement stability factor 
                        
                           
                              Nsf
                              (
                              t
                              )
                           
                        : It defines the stability of a node associated with self and neighbor node movement stability in a given time interval ‘t’. This can be expressed as in Eq. (4). Higher the value of 
                           
                              Nsf
                              (
                              t
                              )
                           
                         indicates better stability.
                           
                              (4)
                              
                                 Nsf
                                 (
                                 t
                                 )
                                 =
                                 f
                                 (
                                 
                                    
                                       S
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                                 ,
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                                 )
                                 =
                                 β
                                 
                                    
                                       S
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                                 +
                                 (
                                 1
                                 -
                                 β
                                 )
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                                 (
                                 t
                                 )
                              
                           
                        The weight factor 
                           
                              β
                           
                         denotes the relative importance of the quantities 
                           
                              
                                 
                                    S
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                         and 
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                         which lies between 0 and 1.


                        
                           
                              α
                           
                         and 
                           
                              β
                           
                         in Eqs. (3) and (4) indicate the weightage given to the terms in 
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                         and 
                           
                              Nsf
                              (
                              t
                              )
                           
                        , respectively. The values chosen for them is between 0.6 and 0.7, since they have yielded better results in extensive simulations. In 
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                              (
                              t
                              )
                           
                        , higher weightage is given to the first term, considering the fact that nodes are mobile and it is likely for a node to move with respect to its earlier position. Similarly, in 
                           
                              Nsf
                              (
                              t
                              )
                           
                        , higher weightage is given to first term.

Stability factor of a node is computed only if self stability and neighbor stability is greater than zero. Thus our scheme extracts the highly stable nodes and adjusts the network topology for routing restricted to stable nodes so as to reduce the probability of link failure.

To address the congestion problem in MANET, following two models are proposed: channel load model and buffer occupancy model.


                        Channel load Model: Congestion in a network is measured based on rate of change in channel load (CL). This can be represented in Eq. (5), where 
                           
                              
                                 
                                    T
                                 
                                 
                                    busy
                                 
                              
                           
                         and 
                           
                              
                                 
                                    T
                                 
                                 
                                    idle
                                 
                              
                           
                         are busy and idle times of the channel measured in seconds in a given time window.
                           
                              (5)
                              
                                 CL
                                 =
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             busy
                                          
                                       
                                    
                                    
                                       
                                          
                                             T
                                          
                                          
                                             busy
                                          
                                       
                                       +
                                       
                                          
                                             T
                                          
                                          
                                             idle
                                          
                                       
                                    
                                 
                              
                           
                        As channel load increases, congestion in the network increases. Thus change in rate of channel load in a particular time window indicates change in congestion level. The change in channel load with respect to time can be represented by means of slope as m indicating either rise or fall in the congestion level.

Changes in channel (link) load are measured in consecutive windows (normally 5 to 10s) for a given observed period t (normally at regular intervals of 30s), and average change in load (considering ‘n’ links) at a node, 
                           
                              Ave_m
                           
                        , is calculated as given in Eq. (6).
                           
                              (6)
                              
                                 Ave_m
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       
                                          
                                             m
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                              
                           
                        Based on the 
                           
                              Ave_m
                           
                        , Channel Congestion Factor (CCF) in a time window t can be interpreted by comparing it with allowed threshold value as decided by the administrator as given in Eq. (7). The value of the CCF(t) varies between 0 (no congestion) and 1 (high congestion).
                           
                              (7)
                              
                                 CCF
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         Ave_m
                                                         (
                                                         t
                                                         )
                                                      
                                                      
                                                         Threshold
                                                      
                                                   
                                                
                                                
                                                   if
                                                   
                                                   0
                                                   <
                                                   Ave_m
                                                   (
                                                   t
                                                   )
                                                   <
                                                   Threshold
                                                
                                             
                                             
                                                
                                                   1
                                                
                                                
                                                   if
                                                   
                                                   Ave_m
                                                   (
                                                   t
                                                   )
                                                   ⩾
                                                   Threshold
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   if
                                                   
                                                   Ave_m
                                                   (
                                                   t
                                                   )
                                                   ⩽
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Link Buffer Occupancy (LBO) Model: A node should maintain an average buffer level to avoid congestion and frequent link failures. LBO is defined as the ratio of queue occupancy (QOCC) by a link to maximum queue size (QSIZE) of the buffer in a given time window at intermediate node as represented by Eq. (8).
                           
                              (8)
                              
                                 LBO
                                 =
                                 
                                    
                                       QOCC
                                    
                                    
                                       QSIZE
                                    
                                 
                              
                           
                        
                     

The average of intermediate node’s buffer occupancy (
                           
                              Ave_LBO
                           
                        ) by all associated direct links of a node is given by Eq. (9) (considered for ‘n’ links).
                           
                              (9)
                              
                                 Ave_LBO
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       
                                          
                                             LBO
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                              
                           
                        As similar to CCF(t), we estimate the Buffer Congestion Factor (BCF(t)) based on buffer occupancy in a given time window t. Our routing scheme uses CCF(t) and BCF(t) and computes link congestion factor (LCF) for QoS based applications to find route from a client to the server. It indicates the congestion of the direct link between intermediate nodes. LCF(t) (a normalized value) given in Eq. (10) helps in selecting noncongested nodes with sufficient buffer capacity for routing in anycast networks. The smoothed value of LCF(t) denoted as CF(t) is given in Eq. (11). The weight factors w and 
                           
                              (
                              1
                              -
                              w
                              )
                           
                         denote the relative importance of the quantities of LCF in current and previous time windows.
                           
                              (10)
                              
                                 LCF
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       CCF
                                       (
                                       t
                                       )
                                       +
                                       BCF
                                       (
                                       t
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 CF
                                 (
                                 t
                                 )
                                 =
                                 LCF
                                 (
                                 t
                                 -
                                 1
                                 )
                                 ×
                                 w
                                 +
                                 (
                                 1
                                 -
                                 w
                                 )
                                 ×
                                 LCF
                                 (
                                 t
                                 )
                              
                           
                        Lower value of CF(t) denotes lesser congestion at a node.

We propose the Link Expiration Time (LET) Model to reduce the data packets loss due to link failures. LET defines the life time of a link between intermediate nodes. In most existing protocols, a mobile host will keep using the route until the link is broken. In this model, we use a proactive method of finding the duration of time that two neighbors remain connected if the speed, direction, and radio propagation range are known.

Predicting the LET along each hop on the route will facilitate the prediction of Route Expiration Time (RET). RET is defined as life time of route between client and server.

The Eq. (12) gives the LET formed by nodes 
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                           
                         and 
                           
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                           
                         having the coordinates 
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         and 
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        , speeds 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    j
                                 
                              
                           
                        , and the directions 
                           
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                           
                         and 
                           
                              
                                 
                                    θ
                                 
                                 
                                    j
                                 
                              
                           
                         
                        
                           
                              (
                              0
                              <
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    θ
                                 
                                 
                                    j
                                 
                              
                              <
                              2
                              ×
                              π
                              )
                           
                        , respectively.
                           
                              (12)
                              
                                 LET
                                 =
                                 
                                    
                                       -
                                       (
                                       a
                                       ×
                                       b
                                       +
                                       c
                                       ×
                                       d
                                       )
                                       +
                                       
                                          
                                             (
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                
                                             
                                             +
                                             
                                                
                                                   c
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             ×
                                             
                                                
                                                   r
                                                
                                                
                                                   2
                                                
                                             
                                             -
                                             
                                                
                                                   (
                                                   a
                                                   ×
                                                   d
                                                   -
                                                   b
                                                   ×
                                                   c
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             a
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              a
                              =
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              cos
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    S
                                 
                                 
                                    j
                                 
                              
                              cos
                              
                                 
                                    θ
                                 
                                 
                                    j
                                 
                              
                              ,
                              c
                              =
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              sin
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    S
                                 
                                 
                                    j
                                 
                              
                              sin
                              
                                 
                                    θ
                                 
                                 
                                    j
                                 
                              
                              ,
                              b
                              =
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ,
                              d
                              =
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                           
                        , and r
                        =transmission range of each node.

Route Expiry Time (RET) is estimated based on the minimum of LET of intermediate nodes through which paths are established between client and servers. It is given as in Eq. (13)
                        
                           
                              (13)
                              
                                 RET
                                 =
                                 min
                                 (
                                 
                                    
                                       LET
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ;
                                 
                                 ∀
                                 i
                                 =
                                 1
                                 …
                                 n
                              
                           
                        
                     

We modify Dynamic Source routing (DSR) by applying parameters supported by stability, congestion and route expiry models in route establishment phase. Routing considers the parameters at each node for route request propagation and path(s) finding between client and servers. It also uses routing information cache (RIC) at each node that facilitates route finding by providing path information from the existing database. RIC will reduce route request propagation overheads. This section presents databases, route request (RR) packets, route reply (RP) packets, route error (RE) packets, and RIC.

Each node maintains a link data base which contains destination servers id, next hop node id, distance from the node to anycast servers, 
                           
                              Nsf
                              (
                              t
                              )
                              ,CF
                              (
                              t
                              )
                           
                         and LET. To explain the fields of the link data base, we consider the network topology given in Fig. 2
                        .

Where C1,C2 and C3 are client machines that generate anycast packets. I1 to I9 are the intermediate nodes and S1 to S3 are server machines that have the same anycast address A1. Connectivity of the network indicates distance on each link. The information in the link data base table at the intermediate node say I1 is given in Table 1
                        .

To create an anycast shortest route in a MANET from client to server, various control packets such as route request (RR), route reply (RP) and route error (RE) packets are used. In this section, we describe some of the control packet components required to create stable and non congestion paths. Some important fields of RR packet are as follows.
                              
                                 •
                                 Client address: It is the address of the client from where the path needs to be established to one of nearest servers in the network.

Server address: It is the address of the server where packet has to be forwarded. It helps in accommodating the routes created by RR packets and RP packets.

Next hop address: It is the address of the neighbor connected with in the transmission range for propagating RR. The field is updated at every hop.

Sequence number: The sequence number assigned to every packet delivered by the client uniquely identifies the packet. It is used to avoid multiple transmission of the same RR packet.

Route record: It has the addresses of the visited previous nodes recorded in visiting sequence. This information will be used during the return journey to RR packet originator by corresponding RP packet.

Number of hops: It is the number of hops travelled by RR packet to reach the destination server, which is updated by one at every hop.

Time to live: It is the number of hops RR packet can travel. The field is decremented by one after every hop.

RP packet format for anycast routing is almost similar to RR packet with few changes in RR packet. The changes in RR packet to convert it into RP packet are as follows: When RR packet reaches the server from the designated client, client address and server address are interchanged, RR packet contains the list of nodes along the route it has travelled (route record is reversed). RP packet from the server is sent to client on a route given in its route record. Next hop address will be picked from the route record at every hop.

RE packet is generated when a node is unable to send the packets either due to link failure or congestion. Some of the fields of this packet are client address, server address, route record and sequence number. Whenever a node identifies link failure, it generates RE packet to either client or server. If link failure occurs in forward journey of a RR packet (from client to server), RE packet is sent to the client. On the other hand if link failure occurs during journey of the RP packet (from server to the client), RE packet is sent to the server. Intermediate nodes receiving RE packet updates their route information cache by removing paths having failed links and also examine its route cache for an alternate path. If an alternate path is found, it modifies the route, otherwise forwards RE packet to server.

RIC is used to store the latest routes to servers learned through RR and RP packets. This avoids unnecessary route discovery operation each time when a data packet is to be transmitted. This reduces delay, bandwidth consumption, and route discovery overhead. A single route discovery may yield many routes to anycast server, due to intermediate nodes replying from local caches. When client node learns that a route to server node is broken, it can use another route from its local cache, if such a route to server exists in its cache. Otherwise, client node initiates route discovery by sending a route request. Use of RIC can speed up route discovery and it can reduce propagation of route requests. The contents of RIC will be removed at every periodic interval.

Each node in the network maintains its own RIC that aids in forwarding packets to neighbors. For every visited RP packet at a node, RIC is updated by using some of the fields in RP packet required for establishing stable and noncongested paths. Table 2
                            presents a typical RIC at client node C1 for topology given in Fig. 2. Various fields in the table are explained as follows.
                              
                                 •
                                 Anycast address: It is the anycast group address attached to different servers where packet has to be forwarded from required client (extracted from RP packet server address and route record). It helps in accommodating the routes for RR packets.

Path information: It represents a complete path (a sequence of links).

RET: It is the minimum value of LET of all intermediate nodes selected from client to the server.

Hops: It is number the of hops required to reach the server via the path.

Recorded Timestamp: It contains the time at which RIC is updated by using RP packet.

Anycast QoS based path creation involves two phases; a request phase and a reply phase. Request phase invokes route discovery process to find routes to anycast servers through stable and noncongestion intermediate nodes. Reply phase involves updating of RIC and conforming the routes found in request phase. Stable nodes are the one who satisfy stability criteria and noncongestion requirement of an application, based on our stability and congestion models. These stable and noncongestion nodes act as intermediate nodes and help to create anycast routes from client to server.

In the following section, we present the process of request phase, reply phase, and route maintenance phase.

A client node finds the route to its anycast server by using RR packets. The sequence of operations that occur are as follows. (1) Client node prepares a RR packet. (2) Selective forwarding of RR packet to neighbors who satisfy stability and congestion criteria as set by the network administrator. From simulation experiments, we have observed better results with congestion factor (CF) threshold varying between 0.1 and 0.3, and node movement stability factor (Nsf) threshold varying between 0.6 and 0.8. Neighbors with Nsf greater than Nsf threshold and CF less than CF threshold are selected for forwarding of RR packet. (3) A node receiving RR packet will discard it, if it is already received (by using sequence number and client address), and stop forwarding of RR packet. (4) If RR packet is not a duplicate, checks RIC for availability of route; if available, RP packet will be generated, and starts reply propagation to client. (5) If route is not available in RIC, forwards the RR packet by updating its fields (route record, stability value, congestion factor, LET and nexthop address) to its neighbors as in step 2. (6) Perform steps 3 to 5 until anycast server is reached, and (8) If server is not reached within certain hops, send RE packet to the client node.

Server initiates the reply phase. When RR packet reaches the server, following operations are performed in the reply phase. (1) Server computes RET for all the received RR packets. (2) Among the multiple paths, server selects a path with higher RET. (3) RP packet is generated for RR packet which has higher RET. Server forwards RP packet to neighbor address as present in route record by updating RIC at server. Updates RIC with server id/anycast address, path information, RET, hops, and recorded time stamp. (4) Node receiving RP packet updates RIC by using contents of RP packet, and forwards to next neighbor. Updates will happen only if current time is greater than the time recorded in RIC. If next neighbor or link is failed, sends RE packet to server and visited intermediate nodes and stops RP packet propagation. (5) Perform step 3 until client is reached without link/node failures. (6) If client is not found due to link breaks, send RE packet to the server. (7) Once all RP packets reach the client, the client node chooses a server based on path with higher RET. (8) For the chosen server, select a path with lesser hops, and keep other paths to the server as backup paths. Chosen path to the server will be used by the client as a source route for data transmission.

Route maintenance is required in case of link failures. There are three cases of link failures; link failure between stable intermediate nodes, link failure between source and stable intermediate node, and link failure between destination and stable intermediate node. We can tackle the problem in following ways. (1) In case of link failure between two stable intermediate nodes, the node detecting failure condition will use RR and RP packets to find stable and less congested path between itself and the destination. The new path from intermediate node to destination will be informed to client. If a new path is not found, the node sends RE packet to client to rediscover the paths. (2) In case of link failure between client and stable intermediate node, client node will probe backup path, if it is working, it will use backup path. Routes will be rediscovered if backup path does not exist. (3) In case of link failure between destination and stable intermediate node, the intermediate node will use RR and RP packets to discover paths to destination from itself and informs the client about the path. If route is not discovered, the node sends RE packet to client to initiate route rediscovery. The client constructs a new path in all the cases for further routing of packets.

Additional costs are involved in the proposed routing protocol to maintain the state of the connections to neighbors. Link data base table comprising of node stability factor, congestion factor, and link expiry time has to be maintained at all intermediate nodes as shown in Table 1. The table maintenance has advantage, as it provides stable routes, reduces route failures, and reduces control overheads. The proposed protocol uses the packet forwarding mechanism through only stable and non-congestion nodes; hence the number of request/reply packets used are reduced. In addition to that, we use link expiry time model, which can predict the future state of network topology and perform route construction proactively in a timely manner.

Apart from maintaining table, it employs k anycast servers. Employment of k anycast servers improves the fault tolerance and service flexibility because of strong connection established among k-anycast group servers through stable and non congestion nodes. Furthermore, packet delivery ratio increases as number of servers increase because client can get connected to any other server even when the connected server has mobility. This also reduces congestion at the servers by balancing load across all servers. The end-to-end delay will be reduced since the routes are stable and are through non-congested links.

In this section, we compare the performance of our proposed protocol with DIASD, DSR and traditional flooding. The protocols are compared in terms of control overhead, packet delivery ratio, and average end-to-end delay. We run the simulation with 95% confidence interval to analyze the performance parameters.

We have simulated proposed scheme for various network scenarios using C programming language. Simulation environment for the proposed work consists of four models: (1) Network model, (2) Channel model, (3) Mobility model, and (4) Traffic model.

Network Model: An ad hoc network is generated in a given area. It consists of several number of mobile nodes that are placed randomly within a given area. The coverage area around each node has a limited bandwidth that is shared among it’s neighbor. It is assumed that, the operating range of transmitted power and communication range are constant.

Channel Model: It assumes the free space propagation model and error free channel. To access the channel, ad hoc nodes use CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) media access protocol to avoid possible collisions and subsequent packet drops.

Mobility Model: We use a random way-point (RWP) mobility model based upon three parameters; speed of movement, direction for mobility and time of mobility. In RWP, each node picks a random destination uniformly within an underlying physical space, and travels with a given speed. After reaching the destination, the node pauses for certain time period, and the process repeats itself.

Traffic Model: It is a constant bit rate model that transmits a certain number of fixed size packets in a flow.

Following metrics have been used to analyze the performance. (1) Packet Delivery Ratio (PDR): It is the ratio of number of average data packets received at anycast server to the number of data packets sent by the client. (2) Packet Overhead: It measures the ratio of control packets (RR, RP and hello packets) sent to the network to the total number of average data packets delivered to the server, and (3) Average end-to-end delay: It is the average delay experienced by the successfully delivered packets in reaching the server.

Simulation parameters used are summarized in Table 3
                     .

Simulation procedure for the proposed scheme is as follows. (1) Generate ad hoc network with given number of nodes. (2) Estimate neighbor stability based on self node movement stability and neighbor node movement stability. (3) Compute link congestion factor based on channel congestion and buffer congestion factors. (4) Compute LET. (5) Update link data base at each node considering their neighbors. (6) Initiate Route Discovery Process using RR, RP and RE, and accordingly update RIC. (7) Establish the path(s) from client to servers, and send the data packets, and (8) Compute performance parameters of the system.

In Figs. 3 and 4
                        
                        , we show the variation of control overhead with respect to different number of servers and client nodes. The overhead takes into account of request and reply messages. The control overhead of our scheme MQAR is reduced compared to traditional flooding, DSR and DIASD schemes. This is because, as number of servers increase, possibility of getting more connections to any other server is high (Fig. 3). MQAR uses only paths which satisfy the node stability, QoS and congestion levels and RET, hence breakage of paths as well as failure of nodes is less. The selected path to a server will be robust and stays for a longer duration without packet loss.

Impact of varying number of clients from 1 to 15 is shown in Fig. 4. When the number of clients increase, control overhead of three approaches increase. MQAR performs better compared to other schemes because it uses the forwarding control mechanism through only stable and non-congestion nodes. Hence the number of request/reply packets used are reduced. In addition to that, we use LET model, which can predict the future state of network topology and perform route construction proactively in a timely manner.

We evaluate schemes for k-anycast servers connected in sparse and dense mode. For both sparse and dense service providers, it is observed that the control overhead is reduced in MQAR scheme (Figs. 5 and 6
                        
                        ). For the sparse case, we evaluate the control overhead by varying the k values from 1 to 10, where as we evaluate overhead for the dense case by varying the k values from 11 to 50. With k-anycast service, the fault tolerance and service flexibility is improved because of strong connection established among k-anycast group servers through stable and noncongestion nodes.

The effect of PDR is studied by varying the number of nodes, mobility of the nodes, and number of clients as in Figs. 7–9
                        
                        
                        . The scalability of the system is tested by finding the PDR with increase in number of nodes from 50 to 250 with fixed mobility of the node as 5m/s. From test results, it has been observed that the PDR increases consistently with increase in number of nodes and increase in number of servers from 10 to 15. This makes PDR in MQAR significantly better than flooding, DSR and DIASD as the number of nodes increase. PDR increases as number of servers increase because client can get connected to any other server even when the connected server has mobility. MQAR uses only those paths which satisfy the node stability, QoS aware congestion and route expiry time, hence breakage of paths as well as failure of nodes is less. The selected path to a server will be robust and stay for a longer duration without packet loss.

The effect of variation in mobility of the nodes on PDR for number of servers 10 and 15 is shown in Fig. 8. Comparing PDR of MQAR with flooding, DSR and DIASD, there is a significant difference when the mobility increases. As the speed of the node increases new paths discovery is performed in flooding, DSR and DIASD, which causes loss of packets. Whereas in our MQAR scheme, it rebuilds the transmission path based on three models namely stability, congestion and route expiry models, make the packets to be transferred to maximum extent whenever either node/link fails or nodes move out of range. Hence MQAR has higher PDR than other schemes.


                        Fig. 9 shows the performance of PDR with different mobility speeds 5 and 8m/s, with the variation in number of clients. PDR is more in MQAR compared to flooding, DSR and DIASD. However it decreases in all schemes as the mobility of the nodes increase. MQAR selects the QoS path depending on the optimized route expiry time. The path which meets the route expiry deadline is selected based on link expiry time through neighbor nodes.

End-to-end delay for varying mobility of nodes and number of nodes is depicted in Fig. 10
                        . As mobility speed of the nodes increase, end-to-end delay also increases. This delay is higher in flooding, DSR and DIASD as compared to MQAR. Some of the reasons for MQAR to perform better compared to other schemes are as follows: (1) MQAR selects the paths containing intermediate nodes which fulfills the stability criteria, hence path established through stable nodes are robust, (2) anycast traffic is initiated through non-congested nodes, hence there is less packet loss, (3) lastly, the selected paths are satisfying route expiry deadline, and delay requirement is met.

End-to-end delay for varying number of clients with different mobility speed is depicted in Fig. 11
                        . As the mobility values increase, end-to-end delay also increases with increase in number of clients because more number of packets are generated by each of the client to the server, but MQAR performs better compared to other schemes.

@&#CONCLUSIONS@&#

Node’s movement stability, channel load, node congestion level and route expiry time are the important QoS metrics among several QoS parameters for providing an efficient, low overhead QoS support for anycast routing in MANETs. we proposed mobility and QoS based anycast routing in MANETs. The proposed work is simulated for various MANET network environments to validate its performance. From the simulations, we observed that the proposed scheme performs better than traditional flooding, DSR and DIASD scheme in terms of control overhead, packet delivery ratio and end-to-end delay.

In our future work, we would like to work on anycast routing protocols to check the efficiency under high throughput applications, e.g. multimedia applications by employing negotiation parameters in route request packet in finding nearest server through non congestion paths.

@&#REFERENCES@&#

