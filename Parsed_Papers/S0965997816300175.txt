@&#MAIN-TITLE@&#Multi-dimensional visualization of large-scale marine hydrological environmental data

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper develops large scale marine hydrological environmental data-oriented visualization software and realizes oceanographic planar graph, contour line rendering, isosurface rendering, factor field volume rendering and dynamic simulation of current field.


                        
                        
                           
                           This study establishes nodes in the scene for the management of geometric objects to realize high-performance dynamic rendering of massive marine hydrological environmental data.


                        
                        
                           
                           The system employs CUDA parallel computing to improve the computation rate of volume rendering of marine water environmental factors based on NetCDF (Network Common Data Form) format.


                        
                        
                           
                           The visualization software of marine hydrological environment developed can simulate and show properties and change process of marine water environmental factors efficiently and intuitively.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Marine environment

GPU

3D data

OSG

NetCDF

Multi-dimensional visualization

@&#ABSTRACT@&#


               
               
                  With the constant deepening of research on marine environment simulation and information expression, there are higher and higher requirements for the sense of reality of ocean data visualization results and the real-time interaction in the visualization process. This paper tackle the challenge of key technology of three-dimensional interaction and volume rendering technology based on GPU technology, develops large scale marine hydrological environmental data-oriented visualization software and realizes oceanographic planar graph, contour line rendering, isosurface rendering, factor field volume rendering and dynamic simulation of current field. To express the spatial characteristics and real-time update of massive marine hydrological environmental data better, this study establishes nodes in the scene for the management of geometric objects to realize high-performance dynamic rendering. The system employs CUDA (Computing Unified Device Architecture) parallel computing for the improvement of computation rate, uses NetCDF (Network Common Data Form) file format for data access and applies GPU programming technology to realize fast volume rendering of marine water environmental factors. The visualization software of marine hydrological environment developed can simulate and show properties and change process of marine water environmental factors efficiently and intuitively.
               
            

@&#INTRODUCTION@&#

Currently, ocean has been closely linked with the life of people. With the rapid development and utilization of marine resources, The research on visualization of marine information plays a more and more important role. Meanwhile, multi-dimensional dynamic visualization of large-scale marine hydrological environmental data has become a hot topic of ocean research with the development of marine information technology. Digital Ocean, as a hotspot of the marine information technology, is the best way to represent its information to participants, which can convey and perform marine scenes in an intuitive way [1]. The features of 3D visualization include intuitiveness, time sharing, and regularity. Besides, it is good for displaying internal laws and different relationships in the data. It is really a challenge to integrate the visualization of massive marine data into the virtual environment organically. Beside spatial data integration, new user interfaces for interactive marine data visualization geo-database are also expected [2].

The applications of virtual and mixed-reality environments, in fields like simulation, games and education, bring in billions of dollars every year [3]. The utilization of these virtual and mixed-reality environments is under exploration for various industrial tools. Besides, with the development of marine information technology, multi-dimensional dynamic visualization of the water environment data becomes a hotpot in marine research, which is mainly reflected in simulation and emulation of the information on water environmental elements including sea temperature, ocean current salinity and seawater density. An exploratory research about 3D ocean current model rendering and multi-touch interaction [4] was conducted early. Another work visualized ocean current and airflow through Streamline Splatting algorithm [5]. The visualized analysis based on the time-space characteristic of marine environment data has been already implemented on web context [6]. The integrated virtual reality system of marine environment has been utilized for geospatial analysis on high performance computer [7–9]. Thomas Butkiewicz and Colin Ware have conducted 3D exploratory analysis on multi-point touch screen of ocean current model [10]. Sun and Ess et al. have visualized ocean current and atmospheric flow through Streamline Splatting algorithm [11]. Yawen [12] et al. have realized visualization analysis on time-space characteristics of marine environmental data. In order to meet the requirement of marine research and development, several marine environmental visualization softwares have been developed and applied successively. Google Ocean can realize three-dimensional show of global submarine topography, but has deficiencies in three-dimensional visualization of marine water factors. IDV mainly shows value information through two-dimensional plane, section and profile in allusion to the processing of marine water factors. Vapor of USA Atmospheric Meteorological Bureau realizes three-dimensional visualization of data, but the software is mainly used for meteorological data and has its own file format. Chinese digital ocean system developed by National Marine Information Center of China, realizes visualization of ocean phenomena and their change process [13], but it mainly relies on digital sphere platform for 2D and 2.5D show of marine environmental information and lacks the analysis and display of marine environmental factors in stereo environment.

The features of marine environment can be reflected from many kinds of factors such as sea temperature, sea salinity, sea density, ocean current and so on. These data are time series, multi-dimensional, heterogeneous in structure and huge amount. The complexity of marine data and the requirements of scientific research necessitate a specific tool that can provide dynamic visualization and analysis of marine information interactively and intuitively in 3D environment. It should be generic for marine data sets and have high efficiency for mass data. This paper researches key technologies such as contour line tracing, isosurface generation, section rendering and volume rendering through point, line, surface and volume mode analysis based on features of large-scale marine hydrological environmental data, and develops a tool to realize three-dimensional simulation of large-scale marine hydrological environmental data and improves its rendering efficiency based on the application of GPU rendering technologies and NetCDF data storage technologies.

System framework is mainly composed of data management, data rendering and application display. Fig. 1
                      shows the system framework.

Data management module mainly realizes the interpretation, access and management of marine hydrological environmental data with NetCDF data access way. As a commonly used data access way, NetCDF can store, manage, obtain and distribute grid data efficiently. Due to such advantages as small memory space, fast reading data, self-description and flexible reading way, it is widely used as data storage standard in fields such as atmospheric sciences, hydrology and oceanology [14]. NetCDF provides a common C programming interface for application and supports basic data types, mainly including byte, char, short, long, float and double [15]. According to features of marine data such as dynamic and multi-dimensional nature and massive amount, target data can be obtained conveniently and rapidly according to the requirement of three-dimensional marine scene rendering with the use of NetCDF data format storage. NetCDF uses variable, dimension and property to form data storage and provides inquiry function. Therefore, it can realize unified management and share of marine data and the dynamic expression and analysis of marine water factor data.

Data rendering module uses multi-threading, integrated UI, e.g. MFC, and rendering engine to complete visualization rendering and analysis of multi-dimensional marine water factor data. 3D rendering engine is composed of a series of modules including line rendering, surface rendering and volume rendering. The modules are mainly developed with API of OpenGL underlying rendering which has become an industrial standard [16]. GLSL and CUDA are also used to improve the calculation and rendering efficiency. Detail optimizations of the rendering engine are described in Section 3.

Application display mainly responds to different operations of users, like roaming in the scene, configuring scene properties, assigning elements for analysis and display, etc., in order to realize free interaction along with data rendering module and shows visualization results.

The rendering of planar graph of marine hydrological environmental data is mainly realized with the use of 3D geometric rendering [17] technology and Delaunay algorithm [18]. The corresponding data value is obtained through NetCDF file operation (environmental factor value is peak elevation value). Delaunay algorithm is used to obtain triangular array and remove noneffective triangles through traversal and optimization. Vertex index mechanism is utilized to analyze data efficiently and uses drawing element to establish triangular surface object. The color of triangular vertex is interpolated according to elevation value and configurable color legend [19].

The rendering of planar graph is realized with triangular mesh method of 3D geometric rendering. Meanwhile, the effective differentiation between sea surface and land is achieved through gradient correspondence of element value and color value and the transparency of invalid value. Gradient color change algorithm is as below:

Known: minimum element value min, maximum element value max, numerical value outside data segment is an invalid value; assuming that values between the minimum value A and the maximum value B are divided into four color sections on average (step 
                           =
                         4), what is the numerical value (valueN) in each section?

                           
                              (1)
                              
                                 
                                    G
                                    r
                                    a
                                    d
                                    i
                                    e
                                    n
                                    t
                                    =
                                    m
                                    i
                                    n
                                    +
                                    
                                       (
                                       
                                          m
                                          a
                                          x
                                          −
                                          m
                                          i
                                          n
                                       
                                       )
                                    
                                    *
                                    N
                                    /
                                    S
                                    t
                                    e
                                    p
                                 
                              
                           
                        
                     

It can be obtained according to formula as followed.

                           
                              (2)
                              
                                 
                                    {
                                    
                                       
                                          
                                             
                                                value
                                                1
                                                =
                                                min
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   value
                                                   2
                                                
                                                =
                                                m
                                                i
                                                n
                                                +
                                                
                                                   (
                                                   
                                                      m
                                                      a
                                                      x
                                                      −
                                                      m
                                                      i
                                                      n
                                                   
                                                   )
                                                
                                                /
                                                3
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   value
                                                   3
                                                
                                                =
                                                m
                                                i
                                                n
                                                +
                                                
                                                   
                                                      
                                                         m
                                                         a
                                                         x
                                                         −
                                                         m
                                                         i
                                                         n
                                                      
                                                      a
                                                   
                                                
                                                *
                                                2
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   value
                                                   4
                                                
                                                =
                                                m
                                                a
                                                x
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In this way, we can set four color values value1, value2, value3 and value4 to realize gradient change of the graph. In order to improve the planar rendering efficiency, GLSL is used to calculate the gradient color of each vertex in fragment shader according to the algorithm. Fig. 2
                         shows the rendering effect. Sea water temperature is rendered in planar graph with four color stages.

Contour line is a smooth curve after connecting nodes. The contour line can help customers to understand the distribution of values briefly, so that it can help analysis on value characteristics. Contour line is widely applied in visualization area.

Suppose there are two points denoted as p1 and p2 with their value p1.value and p2.value respectively, while the attribute value of contour line is value. Calculate the value of flag according to Formula 3.

                              
                                 (3)
                                 
                                    
                                       f
                                       l
                                       a
                                       g
                                       =
                                       (
                                       p
                                       1
                                       .
                                       v
                                       a
                                       l
                                       u
                                       e
                                       −
                                       v
                                       a
                                       l
                                       u
                                       e
                                       )
                                       ×
                                       (
                                       p
                                       2
                                       .
                                       v
                                       a
                                       l
                                       u
                                       e
                                       −
                                       v
                                       a
                                       l
                                       u
                                       e
                                       )
                                    
                                 
                              
                           
                           
                              
                                 a.
                                 If flag < 0, there exist equivalent values between the two points. And the coordinates of desired equivalent values is as in Formulas 4 and 5:

                                       
                                          (4)
                                          
                                             
                                                x
                                                =
                                                p
                                                1
                                                .
                                                x
                                                +
                                                
                                                   (
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   −
                                                   p
                                                   1
                                                   .
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   )
                                                
                                                ×
                                                
                                                   
                                                      p
                                                      2
                                                      .
                                                      x
                                                      −
                                                      p
                                                      1
                                                      .
                                                      x
                                                   
                                                   
                                                      p
                                                      2
                                                      .
                                                      v
                                                      a
                                                      l
                                                      u
                                                      e
                                                      −
                                                      p
                                                      1
                                                      .
                                                      v
                                                      a
                                                      l
                                                      u
                                                      e
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          (5)
                                          
                                             
                                                y
                                                =
                                                p
                                                1
                                                .
                                                y
                                                +
                                                
                                                   (
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   −
                                                   p
                                                   1
                                                   .
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   )
                                                
                                                ×
                                                
                                                   
                                                      p
                                                      2
                                                      .
                                                      y
                                                      −
                                                      p
                                                      1
                                                      .
                                                      y
                                                   
                                                   
                                                      p
                                                      2
                                                      .
                                                      v
                                                      a
                                                      l
                                                      u
                                                      e
                                                      −
                                                      p
                                                      1
                                                      .
                                                      v
                                                      a
                                                      l
                                                      u
                                                      e
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

If flag > 0, there exists no equivalent values between the two points.

If 
                                       
                                          f
                                          l
                                          a
                                          g
                                          =
                                          0
                                          ,
                                       
                                     it indicates there exists points between p1 and p2 with the same attribute value with contour line, and such points are denoted as singular points. The existence of singular points will increase the calculation difficulty of program, so that in this paper, we give a very small offset value 0.0001 to the singular points. In this case, the singular points will neither influence the program calculation, nor influence the curve drawing.

According to the contour interpolation algorithm, the number of equivalent points in a mesh can be considered as the following three situations and consequent determinations will be proposed accordingly:

                              
                                 a.
                                 The number of equivalent points is 0; don’t draw contour line;

The number of equivalent points is 2; connect the two points directly (as in the Fig. 3
                                    );

The number of equivalent points is 4; in this case, there are two ways to draw the contour line, as shown in the Fig. 4
                                    . The reason for such ambiguity is the existence of saddle point in this unit. We can perform analysis of dual linear interpolation function from inside of the unit. As the linear interpolation is used at the margin of the unit, the value change of function which determines the surface of the unit is in dual linear property, which indicates the contour line in the unit is a hyperbolic curve rather than a straight line as in Formula 6.

                                       
                                          (6)
                                          
                                             
                                                F
                                                
                                                   (
                                                   x
                                                   ,
                                                   y
                                                   )
                                                
                                                =
                                                
                                                   a
                                                   0
                                                
                                                +
                                                
                                                   a
                                                   1
                                                
                                                x
                                                +
                                                
                                                   a
                                                   2
                                                
                                                y
                                                +
                                                
                                                   a
                                                   3
                                                
                                                x
                                                y
                                             
                                          
                                       
                                    
                                 

In Fig. 3, The symbol of 
                              
                                 
                                    
                                    ′
                                 
                                 
                                    +
                                    ′
                                 
                              
                            denotes the attribute value of this point is larger than that of the contour line, while the symbol of” denotes the attribute value of this point is smaller than that of the contour line. The ambiguous connection can be determined by the function value according to the cross point of the two asymptotic lines of the hyperbolic curve. This is because the cross point of the two asymptotic lines is always located at the same area with one of the pairs of vertices. Therefore, use the first connection approach if the cross point is 
                              
                                 
                                    
                                    ′
                                 
                                 
                                    +
                                    ′
                                 
                              
                           ; use the second connection approach if the cross point is 
                              
                                 
                                    
                                    ′
                                 
                                 
                                    −
                                    ′
                                 
                              
                           . In this paper, for simplification, we use unit diagonal cross point to replace the calculation of asymptotic lines cross point.

In this paper the contour line is drawn using a parallel rendering algorithm based on GLSL. As shown in Fig. 5
                           , firstly, system stores the mesh attribution and mesh coordinate information via texture. Among this, elements of R, G are used to store coordinate value, and elements of B, A are used to store mesh point attribute value. According to vertices attribute value i, j, we generate the texture coordinate accordingly and we obtain the coordinate and attribute values of 4 vertices of this unit in the texture index. Based on these values, we can calculate the coordinate values of the equivalent points. For each mesh we can obtain the coordinates of 4 equivalent points in maximum; store the coordinate of equivalent points in matrix according to its connecting order. In case that there exist no equivalent points, we set the same value for 4 vertices coordinates and in this paper we give (0.0, 0.0, 0.0, 1.0) (while in GLSL, it returns blank when trying to connect two points in the same place); in case that there are two equivalent points, we store the equivalent points in the position of 0 and 1 in the matrix, and store (0.0, 0.0, 0.0, 1.0) in the position of 2, 3. According to value of vertexFlag (the attribute values of vertices including i, j, vertexFlag, where i, j are used for texture index while vertexFlag is used to mark vertices), we obtain the relative position of vertices. Vertex shaders will perform rasterization according to the preset connection approach (
                              
                                 0
                                 −
                                 1
                                 ,
                              
                            or 
                              
                                 2
                                 −
                                 3
                              
                            connection) firstly, and then fill the color value in the fragment shader; the drawing results are shown in Fig. 6
                           .

Isosurface can be regarded as an extension of three-dimensional space of contour line, i.e. all point sets meeting 
                           
                              F
                              (
                              x
                              ,
                              y
                              ,
                              z
                              )
                              =
                              c
                           
                         in three-dimensional space data field. There are many relevant algorithms of isosurface rendering. Isosurface extraction algorithms specific to large-scale data include Branch-On-Need Octree (BONO) with subdivision on demand and Near-Optimal Isosurface Extraction (NOISE) etc. [15] This paper mainly improves the rendering efficiency and quality of isosurface based on MC (Marching Cubes) [20,27] algorithm and implementation. As ocean and land are crossed, there are a lot of invalid values in rule data of marine hydrological environment. For the rendering efficiency, MC algorithm is improved and triangular meshes with invalid data are eliminated through identification bit. Frame rate is improved through the setting of vertex coordinate array, color array, normal array, binding mode and data analysis [16]. To improve the rendering quality, vertex normal vector of triangular mesh in isosurface is obtained with the estimation method of gradient normal vector for realizing smooth isosurface. The computational formula of normal vector of equivalent point is as below:

                           
                              (I)
                              Gray scale gradient g on voxel vertext (i, j, k)

                                    
                                       (7)
                                       
                                          
                                             g
                                             =
                                             
                                                1
                                                2
                                             
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  f
                                                                  
                                                                     (
                                                                     i
                                                                     −
                                                                     1
                                                                     ,
                                                                     j
                                                                     ,
                                                                     k
                                                                     )
                                                                  
                                                                  −
                                                                  f
                                                                  
                                                                     (
                                                                     
                                                                        i
                                                                        +
                                                                        1
                                                                        ,
                                                                        j
                                                                        ,
                                                                        k
                                                                     
                                                                     )
                                                                  
                                                               
                                                               
                                                                  X
                                                                  f
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  f
                                                                  
                                                                     (
                                                                     i
                                                                     ,
                                                                     j
                                                                     −
                                                                     1
                                                                     ,
                                                                     k
                                                                     )
                                                                  
                                                                  −
                                                                  f
                                                                  
                                                                     (
                                                                     
                                                                        i
                                                                        ,
                                                                        j
                                                                        +
                                                                        1
                                                                        ,
                                                                        k
                                                                     
                                                                     )
                                                                  
                                                               
                                                               
                                                                  Y
                                                                  f
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  f
                                                                  
                                                                     (
                                                                     i
                                                                     ,
                                                                     j
                                                                     ,
                                                                     k
                                                                     −
                                                                     1
                                                                     )
                                                                  
                                                                  −
                                                                  f
                                                                  
                                                                     (
                                                                     
                                                                        i
                                                                        ,
                                                                        j
                                                                        ,
                                                                        k
                                                                        +
                                                                        1
                                                                     
                                                                     )
                                                                  
                                                               
                                                               
                                                                  Z
                                                                  f
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Calculation of normal vector of isosurface

                                    
                                       (8)
                                       
                                          
                                             
                                                v
                                                0
                                             
                                             =
                                             
                                                g
                                                1
                                             
                                             +
                                             
                                                (
                                                i
                                                s
                                                o
                                                v
                                                a
                                                l
                                                u
                                                e
                                                −
                                                
                                                   v
                                                   1
                                                
                                                )
                                             
                                             
                                                (
                                                
                                                   g
                                                   2
                                                
                                                −
                                                
                                                   g
                                                   1
                                                
                                                )
                                             
                                             /
                                             
                                                (
                                                
                                                   
                                                      v
                                                      2
                                                   
                                                   −
                                                   
                                                      v
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 where, v
                                 0 refers to normal vector of equivalent point, v
                                 1, v
                                 2 represents the normal vector of two endpoints, g
                                 1, g
                                 2 refers to gray value of two endpoints and isovalue refers to threshold value.

Finally, threshold variable is colored with color mapping visualization method. The left part in Fig. 7
                                  shows the rendering effect.

In order to improve the rendering efficiency of isosurface, this paper implements the parallel computing of Marching Cube based on CUDA. The specific implementation can refer to the examples of CUDA provided on official website.

The main problem of the real-time rendering of sea flow field lies in the improvement of calculation and rendering speed of flow field vector of massive data. As our rendering engine manages each node in the scene mainly through scene graph, it is efficient for constant nodes. However, the long time spent on the calculation and rendering of each node becomes a major problem of real-time flow field rendering for dynamic nodes of ocean current in the flow field which change with time. There are two different technologies for the rendering of dynamic ocean current: first, establish geometric nodes through leaf node, realize dynamic display with VBO rendering method and node callback, specify drawing element as LINES in its self-defined drawing technique and determine the size and direction of arrow according to the vector value of longitude and latitude of lattice current; second, realize the rendering through parallel computing of the third-party library CUDA [21,22].

In order to improve the efficiency of rendering, parallel computation using CUDA is adopted in this paper. Computation Node is added in the scene as the vessel of My Module and My Resource. Parallel computing is conducted with the module. Vertex array resources are mapped to the device memory through ‘map’ function. ‘cudaMemcpy’ is invoked in ‘Launch’ and ocean current data are transferred to GPU for parallel computing through ‘cudaMemcpy HostToDevice’. Mapped vertex array is updated.


                        Table 1
                         shows the comparison of rendering efficiency with both methods. The result shows that the second method is better than the first one.

Volume rendering is always the research front in the field of three-dimensional simulation. This paper applies Ray Casting algorithm [28] realized based on GPGPU to volume rendering of large-scale marine hydrological environmental data. The following are considered in the use of Ray Casting algorithm: first, this algorithm is based on ray scanning process in solution and meets the common sense of life, which is easy to understand. Second, this algorithm can achieve the highest rendering precision and the best image quality [23,29]. Third, this algorithm can realize easy transplantation to GPU and meet the requirement of real-time rendering. Fig. 9
                        
                        
                         shows the flow chart of realization method of Ray Casting volume rendering based on GPU.

The rendering process mainly has three parts: (1) combine three-dimensional volume texture and space volume mode (regular cube) and determine volume texture coordinates of 8 vertexes of the cube; (2) Render the scene to two-dimensional texture through FBO backward depth. The color value of each pixel on two-dimensional texture represents the distance of the point most far away from the viewpoint in a direction; (3) realize Ray Casting algorithm in fragment shader in the main rendering scene [24,25], mainly include synthesis of transparency and sampling along the ray. The rendering of transparent object is the mixing of its color and the color of its post objects in essence. It is called as alpha blending technology. The formula of alpha blending technology is as below:

                           
                              (9)
                              
                                 
                                    
                                       c
                                       0
                                    
                                    =
                                    
                                       a
                                       s
                                    
                                    
                                       c
                                       s
                                    
                                    +
                                    
                                       (
                                       
                                          1
                                          −
                                          
                                             c
                                             s
                                          
                                       
                                       )
                                    
                                    
                                       c
                                       d
                                    
                                 
                              
                           
                        where, as
                         refers to the transparency of the transparent object, cs
                         refers to the original color of the transparent object, cd
                         represents the original color of the target object, and c
                        0 refers to the color value obtained by observing the target object through the transparent object.

In Ray Casting algorithm, the process when the ray passes through volume texture is the ordering process of transparency. Therefore, a synthetic sequence problem exists here. The process when the ray passes through volume texture can also be used as sampling synthesis process. This paper uses the ordering from front to back. The ordering formula is as below:

                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             C
                                             
                                                i
                                             
                                             Δ
                                          
                                       
                                       
                                          
                                             =
                                             
                                                (
                                                
                                                   1
                                                   −
                                                   
                                                      A
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                      Δ
                                                   
                                                
                                                )
                                             
                                             
                                                C
                                                i
                                             
                                             +
                                             
                                                C
                                                
                                                   i
                                                   −
                                                   1
                                                
                                                Δ
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             A
                                             
                                                i
                                             
                                             Δ
                                          
                                       
                                       
                                          
                                             =
                                             
                                                (
                                                
                                                   1
                                                   −
                                                   
                                                      A
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                      Δ
                                                   
                                                
                                                )
                                             
                                             
                                                A
                                                i
                                             
                                             +
                                             
                                                A
                                                
                                                   i
                                                   −
                                                   1
                                                
                                                Δ
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where, Ci
                         and Ai
                         are respectively color value and non-transparency obtained by sampling on volume texture, i.e., data contained in voxel; 
                           
                              C
                              
                                 i
                              
                              Δ
                           
                         and 
                           
                              A
                              
                                 i
                              
                              Δ
                           
                         refer to cumulative color value and non-transparency. The sampling formula is as below:

                           
                              (12)
                              
                                 
                                    t
                                    =
                                    
                                       t
                                       
                                          s
                                          t
                                          a
                                          r
                                          t
                                       
                                    
                                    +
                                    d
                                    *
                                    d
                                    e
                                    l
                                    t
                                    a
                                 
                              
                           
                        where, tstart
                         refers to volume texture coordinates of projected point on the surface of cube, d refers to projection direction, delta refers to sampling interval and t refers to the sampling texture coordinates obtained.

To achieve better rendering effect, the filter type of texture is set as linear type. For invalid data point, its transparency is set as 0 through the addition of judgment mark. To achieve dynamic rendering, data in three-dimensional texture can be updated in real time. Volume rendering is conducted with the method above through experiment. The rendering of millions and millions of data can be realized without influencing the rendering efficiency. The left part of Fig. 10 shows the rendering effect. To obtain more accurate internal information of data volume, users can draw the internal profile of volume by setting volume rendering parameters.

Multi-dimensional dynamic visualization software of marine hydrological environment is developed with Visual Studio 2008 development environment and Open Scene Graph 3.0 [16] is adopted to manage the spatial objects in 3D scene. Rendering engine as shown in Fig. 1 is implemented with glsl and CUDA to realize efficient rendering of marine hydrological features [26,31]. The software mainly includes data initialization, two-dimensional scalar rendering, analysis, two-dimensional vector rendering, three-dimensional scalar rendering, image/video output and configuration tools. The interface uses Microsoft Office 2007 pattern.

Data initialization mainly completes the selection of marine environmental data for rendering; element display mainly completes the display of sea water temperature, salinity, density and ocean current. Scalar rendering mainly completes the setting of color graph on depth plane, longitude and latitude profile, the setting of contour line on horizontal profile, setting of visibility of longitudinal vertical section and latitudinal vertical section under 2D, and isosurface rendering and volume rendering under 3D. Vector rendering mainly completes the dynamic display of vectors such as ocean current under 2D. Because we optimized the efficiency of rendering engine, the rendering efficiency is improved. Analysis function is a novel aspect of the software. With analysis function, user can assign a point or line interactively and a profile of the assigned point or a section of the assigned line can be analyzed and rendered in the scene, which can provide much more comprehensive understanding of internal phenomena of marine. Image/video output function is provided for the output of 3D scene contents in the window to static image file or AVI animate file, including image storage, recording start, recording suspension and recording stop. Configuration tools mainly include background color setting, toolbar control, window control function, establishment of coordinate system and legend display etc., which makes users change configuration conveniently during rendering.


                     Fig. 11 shows the main user interface of the system developed. The interface of the software can be divided into two parts. The left part is function panel, which controls the display elements. With the function panel, users can conveniently operate the software, such as choosing the element to display, assigning point or section to analysis, configuring properties to render, and so on. The right part is the main window, which rendering the objects in 3D scene responding to the users operation. Through the comprehensive display of data in different dimensions and in cooperation with the time sequence dynamic update module, the distribution characteristics and change condition of seawater temperature elements under 3D environment can be expressed intuitively. This software also provides the real-time processing and display function of customized isoline, profile curve and time sequence change curve, so that the users can comprehensively compare and analyze the local characteristics while observing the environmental element distribution and change of the whole water body environment, so as to improve the users understanding and identification ability to the multi-dimensional ocean environment data.

The existing internationally popular ocean platform and software provide the user with an interactive three-dimensional visual interface, so that the user can model and simulate the ocean surface water and three-dimensional submarine topography, simulate the seabed, water, sea surface, island, coastal zone and other natural marine elements and natural phenomena in global or partial sea areas as well as the digital representation and prediction of the changing process.

Functionally, the four types of software (i.e. Paraview, Vapor, VisIt, Our Software) realize the basic scene display and data loading, and can continue excavating the information required in scientific research and practical application in a scene, such as the multimode dynamic visualization of sea level altitude, sea water temperature, salinity, three-dimensional flow field and other invisible sea water features. The thorough comparison shows that our software has the following advantages:

                        
                           1.
                           With concise and convenient human-computer interaction interface, it is convenient for practical operations. With various and complicated contents on the interface, neither ParaView nor Vapor is convenient for the user to find the required function modules rapidly; the two interface windows after VisIt is started are likely to cause the users misoperation. Compared with the operating interfaces of the above-mentioned three types of software, our more visual and concise software can help the user to learn it more quickly. Before data loading, none of our softwares functional modules is activated so that the user wont operate it incorrectly. It is shown in the figure below.

In addition, because VisIt software must load the preprocessing file when it is started, the user needs to wait for a rather long time. However, our software, which can be started quickly, not only offers a better user experience but also saves time.

The application of GPU enhances the real-time rendering efficiency of big data. The three kinds of software mentioned above have a low rendering efficiency for mass data and the rendering quality is also unsatisfactory. The efficiency of VisIt is clearly lower than that of our software. Our software realizes the real-time dynamic high-efficiency visual display of two-dimensional color-filling graph via the GPU programming rendering technology and shading language GLSL, realizes the dynamic simulation of isoline as well as the fast rendering of isosurface, and greatly enhances the computing efficiency. Besides, with the application of GPGPU programming rendering technology, the software can realize the dynamic visual display of sea water elements and can realize the data volume render of ten million level (10,000,000 points data) at present. As for the rendering effect, if the rendering is too dark, the insufficient contrast ratio will influence the observation details; if the rendering is darker than others, the more gentle hue is suitable for observation with eyes for a long time. After comprehensively considering the fineness of details and human-body fatigue problem during observation work, this software platform adjusts the contrast ration and hue weight in the best way.

It is convenient for adding new functions and special effects. It designs and realizes the visualization of three-dimensional marine graph and realizes the packing of interface, interaction, function and special effect. The weakened association among the above-mentioned four parts achieves the relationship of weak coupling so as to add new data, functions and special effects. Since it is difficult to largely change the bottom frame based on the natural mode in other systems, so such systems are not flexible and no latest technologies have been applied for them. Furthermore, a commercial platform often doesn’t offer open source code and doesn’t certainly SDK for secondary development. However, there are many extensible possibilities in the software platform researched and developed independently by us, so some relevant but incompletely similar data and needs can be easily fit via simple development, such as the oceanographic hydrological data to lake hydrologic data. Besides, this software also has the adaption of a mobile platform. It can be demonstrated from our previous paper [30] [31] about three-dimensional seabed on mobile platform that this platform also has the potential to be transplanted to a mobile device. However, other platforms haven’t provides this function.

@&#CONCLUSION@&#

The implementation of multi-dimensional dynamic visualization software of marine hydrological environment provides a real-time, dynamic and interactive three-dimensional visualization simulation tool of marine hydrological environment for users. It can realize efficient geometric analysis and dynamic rendering of large-scale marine water environmental data and display features and dynamic analysis of marine water environment intuitively. The rendering efficiency is improved evidently by several ten times compared with traditional serial algorithm. Because parallel calculation and rendering are mainly implemented in graphic card, so the efficiency and data amount can be affected by the graphic memory. By our practical test, massive data with several million points can be rendered dynamically with no evident time delay using popular graphic cards. The interactive framework of the system can allow users to realize stereo real-time dynamic observation of marine water information through plane, contour line, isosurface and volume information, display single spatial point of ocean consecutively and realize stereo display of spatial scope region extended from single spatial point or section line of ocean. It provides intuitive and comprehensive for the research on marine water environment. Compared with other similar tool, rendering effect, such as light, smoothness, shade, color, etc., need to be improved in the future. Especially for vector data rendering, stream line should be used to enhance the rendering effect of ocean current and wave.

@&#REFERENCES@&#

