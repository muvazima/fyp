@&#MAIN-TITLE@&#Pull-based recommendations in mobile environments

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We have designed a framework to support mobile context-aware recommendations.


                        
                        
                           
                           We have described in detail the pull-based recommendation module.


                        
                        
                           
                           We have performed an extensive study of the state of the art.


                        
                        
                           
                           We have performed an experimental evaluation that compares different paradigms.


                        
                        
                           
                           The proposed architecture is generic, extensible, and adaptable to the requirements.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Context-awareness

Recommendation systems

Mobile computing

@&#ABSTRACT@&#


               
               
                  In the field of Context-Aware Recommendation Systems (CARS), only static contextual information is usually considered. However, the dynamic contextual information would very helpful in mobile computing scenarios. Despite this interest, the design and implementation of flexible and generic frameworks to support an easy development of context-aware mobile recommendation systems have been relatively unexplored. In this paper, we describe a framework that facilitates the development of CARS for mobile environments. We mainly focus on the development of the elements needed to support pull-based recommendations and the experimental evaluation of the proposed system.
               
            

@&#INTRODUCTION@&#

Recommendation systems [1–3] have become an important research area since their emergence in the last decade of the 20th century. Netflix, MovieLens, Amazon, YouTube, Yahoo, Tripadvisor, Last.fm and IMDb are examples of popular recommendation applications that currently play an important role in the Internet.

In general, a recommendation system is an application that, using certain techniques and algorithms, is able to suggest relevant items to users (e.g., movies, songs, books, jokes, applications, websites, travel destinations, e-learning material, and even friends in social networks). It tries to adapt its proposals to each user in a personalized way, based on his/her preferences and current interests. These recommendations can be seen as a suggestion about items that are considered of potential interest to a particular user. For example, in a scenario of books the recommendations would be books that are expected to be relevant to the user (and so they should be read before others), in a scenario of travel destinations the recommendations would be places that according to the user preferences will be more attractive for the user, in the context of a digital newspaper the recommendations would be the news that the user could find interesting, in the context of movies the recommendations would be movies that the user would probably like, etc.

Traditional recommendation systems ignore the context when providing relevant items to the user. However, the context should play a key role when providing recommendations. Thus, the relevance of an item depends on the context, which notably involves spatio-temporal criteria (e.g., see [4]) but may also include other contextual factors. Moreover, the context of a user in a mobile computing scenario is highly dynamic (e.g., the location of the user usually changes constantly). Therefore, recommendation algorithms should be able to effectively and efficiently exploit the dynamic context of the user in order to offer him/her suitable recommendations.

Our current work is focused on solving the following scientific problem: how could we facilitate the development of Context-Aware Recommendation Systems (CARS) in mobile environments, to provide users with relevant recommendations? It is motivated by the lack of generic CARS frameworks that consider aspects related to mobile users and mobile computing. So, the goal of our research is to contribute to bridge the gap not only between recommendation systems and context-aware computing, but also between CARS and mobile computing.

In this paper, we describe a framework that facilitates the development of context-aware recommendation systems for mobile users, focusing particularly on pull-based recommendations. The rest of the paper is organized as follows. Section 2 describes the technological context of this work, emphasizing the role of context-aware recommendation systems and mobility, as well as presenting a motivating scenario where a context-aware mobile recommendation framework like the one proposed in this paper would be useful. In Section 3, we overview the context-aware mobile recommendation framework proposed. In Section 4 we focus on the process of pull-based recommendation, which is the main module that we have analyzed and studied in detail in this work. In Section 5, we describe an experimental evaluation that we have performed and the results obtained. In Section 6, we review the related work. Finally, we present our conclusions and point out some directions for future work in Section 7.

In this section, we provide an overview of the technological context of our research. First, we introduce some basic ideas about recommendation systems. Then, we focus on context-aware recommendation systems. Afterwards, we consider the introduction of mobility aspects in the recommendations. Finally, we illustrate the interest of mobile context-aware recommendation systems with an example scenario. The goal of this section is to provide background knowledge, rather than the state of the art of research in the area, which is described in Section 6.

Depending on how the recommendations are obtained, classical Recommendation Systems (RS) can be classified into the following categories [5]:
                           
                              •
                              
                                 Collaborative filtering: the user receives recommendations of items that people with similar tastes and preferences liked in the past.


                                 Content-based recommendation: the user receives recommendations of items similar to the ones that the user preferred in the past.


                                 Hybrid recommendation approaches: these approaches combine collaborative filtering and content-based recommendation.

Many studies have been performed in the area of recommendation systems. Despite this, the researcher community still continues to develop new approaches, as many interesting problems remain unsolved (e.g., how to obtain suitable recommendations in the absence of previous information about the user, how to ensure enough variability in the items recommended, how to combine and exploit information from other sources such as social networks, etc.). The development of recommendation systems is supported by increasingly-important motivations, especially in the area of businesses (e.g., the need to better understand what the user needs, increase the sales of diverse items, improve the user satisfaction and the user fidelity, etc.) [1].

Most RS operate in a two-dimensional (2D) User
                        ×
                        Item space. However, considering only information about the users and items is not enough in applications such as the recommendation of vacation packages. In this case it is important to not only determine which items should be recommended, but also when these recommendations should be provided and how to combine them in a ranked list. Moreover, traditional collaborative filtering techniques generally take into account all the collected ratings of the items to generate the recommendation models; these techniques assume that the context is homogeneous, but actually a user can assign different ratings to the same item in diverse contexts, as the relevance and interest of a specific item for a user may depend on his/her current context. Therefore, additional contextual information should be considered in the recommendation process.

We agree with the context definition provided in [6], which considers the context as “any information that can be used to characterize the situation of an entity”, where an entity could be “a person, place, or object that is considered relevant to the interaction between a user and an application, including the user and applications themselves”. Other definitions of context have been introduced in the literature related to the context-aware computing field (e.g., [7]). Examples of elements defining the context could be the location, time, weather, mood, activity, and companion of the user. There are certain types of context elements that, according to the circumstances, could be more important than others; for example, if it is raining a person could prefer to stay at home watching a movie rather than to go to run (i.e., the weather element in this case is more important than others).

With advances in the fields of ubiquitous and mobile computing, the lack of analysis of contextual information in recommendation systems has been strongly criticized. So, researchers and developers had mainly focused on solving classic problems of recommendation systems, such as the cold start problem, spam vulnerability, high dimensionality, and many others. Recently, researchers working on recommendation systems have recognized the need to investigate them in domains where the contextual information is particularly relevant, such as in the case of mobile computing scenarios.

The integration of recommendation systems and context-aware computing has given rise to the so-called Context-Aware Recommendation System (CARS). The meaning of context-aware was defined in [6] by indicating that “a system is context-aware if it uses context to provide relevant information and/or services to the user, where relevancy depends on the user's task”.

A pioneer proposal in the field of context-aware recommendation systems is [8,9]. In order to improve the recommendations based on contextual information, the authors of that work extend the classical 2D paradigm to a multidimensional recommendation model (MD model) that provides recommendations based on multiple dimensions: User
                        ×
                        Item
                        ×
                        Context. They introduced three different context-aware recommendation paradigms, which use the contextual information in the recommendation process:
                           
                              •
                              
                                 Pre-filtering, where the contextual information is used to filter the data set before applying traditional recommendation algorithms.


                                 Post-filtering, where the contextual information is considered only in the final step of the process. So, contextual information is initially ignored and the ratings are predicted using any conventional 2D recommendation system, taking all the input data available (potential items to recommend) into account. Afterwards, the resulting set of recommendations is adjusted (contextualized) for each user by using contextual information.


                                 Contextual modeling, where the contextual information is used directly in the modeling technique.

So, the pre-filtering and post-filtering methods consider the context as an additional filtering step that can be applied to any traditional recommendation algorithm, either to restrict its input (pre-filtering) or its output (post-filtering). On the other hand, contextual modeling recommendation systems imply a radically different approach, as the contextual information directly affects the generation of the recommendation models.

In Section 6.1 we describe some relevant works performed in the field of CARS. However, we would like to emphasize that, despite the existing efforts, the design of flexible and generic architectures and frameworks to support an easy development of CARS has been relatively unexplored.

The widespread availability of mobile devices, such as smartphones and portable computers, implies that the relevance of mobile computing scenarios is nowadays undeniable. This, in turn, demands new approaches for the development of recommendation systems that can handle and effectively exploit the data available in those environments. Thus, a recommendation system in a mobile computing scenario should rapidly obtain contextual information of the user, by using multiple sensors [10,11], accessing resources available in the Internet, etc.

Some context-aware mobile applications have already been developed, but they focus mostly on specific domains (e.g., restaurants, museums, gas stations, supermarkets, foods, etc.) [12–16]. Section 6.2 provides an in-depth study of existing approaches for mobile CARS. Despite these efforts, more research is needed to enable the potential definition of flexible and generic frameworks to support an easy development of mobile CARS.

This section describes a sample scenario to illustrate the interest of a context-aware mobile recommendation architecture. The scenario shows some of the main benefits provided by the architecture that we propose in this paper, as well as the interest of having a flexible and global CARS framework for mobile users. We follow a story-like style to describe the motivating scenario, which consists of two parts: shopping (see Section 2.4.1), which is illustrated in Fig. 1
                        , and leisure after shopping (see Section 2.4.2).

Throughout the description of the scenario, we assume the existence of an application MOcCARSin (MObile Context-Aware Recommendation System), which can be installed in mid-range smartphones. This application recommends (proactively or through explicit queries) products of interest to the user, considering an enriched user profile built based on opinions issued in the past about products in different contexts as well as exploiting additional contextual information obtained from the environment (via different types of sensors).

The example provided in the rest of this section illustrates the benefits of a context-aware mobile recommendation framework to provide useful recommendations in a variety of scenarios. Several mobile computing applications for different scenarios could be developed based on the generic framework proposed. Although the fictitious application MOcCARSin named in the example still does not exist, it shows the ultimate goals pursued in our research.

Alice gets up at 7:30 am. It is Saturday and raining. She needs to buy some food for the week, but she does not know exactly what she should buy and where she could go. So, Alice decides to use MOcCARSin in order to receive recommendations of supermarkets where she can go, given her current circumstances. First, she introduces the keyword “food” as the query. Automatically, MOcCARSin enriches this input with additional contextual information that is relevant in her context, such as the hour and day of the week, the weather conditions, her current location, and even information about the persons that are with Alice at the moment. MOcCARSin infers that Alice is probably interested in buying food, as her potential desire to have lunch or dinner at that time of the day is considered unlikely; taking breakfast outside does not seem a plausible option either because Alice's coffee machine broadcasted a “coffee ready” message a few minutes ago (by using M2M, or Machine to Machine, communications). So, MOcCARSin asks Alice “Do you need to buy food?” and she confirms.

Then, MOcCARSin evaluates the different context parameters and Alice's preferences to suggest her a place where she can buy food. It knows that Alice prefers medium-price supermarkets rather than more expensive high-quality malls, small stores, or gourmet food stores specialized in specific types of products. However, in this case the closest supermarket is quite far, so going by foot there is not a good option given that it is raining. Moreover, Alice does not have a car, the public transportation system is not working yet at this time, and Alice's brother (who could drive her to the supermarket) is not with her at the moment. So, MOcCARSin considers interesting to include a small food store, located a few blocks from her home, in the list of suggestions provided. Alice finally selects a supermarket, and so MOcCARSin suggests her to take a taxi or wait until 9:00 when the bus service starts. Alice decides to take a taxi, and therefore MOcCARSin recommends her several taxi companies (ranked based on ratings from other users), continuously showing on a map the up-to-date locations of taxis nearby along with contact information of the corresponding taxi companies.

Once in the supermarket, MOcCARSin automatically suggests products that she usually buys, products whose stock in her fridge is decreasing (this information was provided by her fridge before leaving home), as well as other products that she has never purchased but she might like. For each product suggested, MOcCARSin provides optional information such as its name, price, and appropriate routes to reach the supermarket's section where the product is located. If Alice selects a set of products at the same time, then MOcCARSin is able to suggest Alice a route that optimizes the retrieval of all those products. As the supermarket may include several floors, MOcCARSin exploits a hierarchical indoor map to obtain the appropriate walking directions, including (if necessary) taking the stairs or an elevator. Information about products is obtained from a web service provided by the supermarket, as well as from other customers that may disseminate and share dynamically (through a mobile peer-to-peer network) information about specific offers that they have seen. Moreover, Alice has accepted to share information about her current shopping cart with the supermarket, which the marketing department exploits to offer her customized offers and related products (e.g., since Alice has bought strawberries, she can be offered whipped cream at a special price).

By using NFC (Near Field Communication), MOcCARSin is able to provide Alice with information about products that she is currently observing, as the supermarket has deployed an appropriate mechanism to query this information (such as RFID –Radio Frequency IDentification– tags). For example, MOcCARSin can identify product features including its ingredients or caloric content, its price, and its expiry date. Alice is in a gluten-free diet, and so MOcCARSin warns her if she tries to pick up products that contain gluten. It also prevents Alice from choosing specific products whose expiry date is too close in time, taking into account her consumer habits (e.g., Alice may leave products in the fridge for a long time).

When Alice considers that the shopping is finished, MOcCARSin alerts Alice that she is just three euros below the threshold that would entitle her to a free delivery at home. As she does not have a car, she decides to buy also a couple of chewing gum packets and ask for home delivery during the afternoon.

After leaving the supermarket, the weather has improved considerably. Alice starts walking home and she receives a recommendation to have lunch in a restaurant located nearby. It is a good time to eat and she is hungry. Besides, the restaurant offers Chinese food, which is Alice's preferred meal. So, she decides to accept the recommendation. MOcCARSin suggests Alice to ask Bob, Alice's best friend, to join her, as he also loves Chinese food. Alice contacts Bob and he accepts, but he is not nearby, so he takes his own car to go there. Bob types “parking car” in his MOcCARSin application along with the address of the restaurant, to try to find available parking spaces near the restaurant. MOcCARSin collects and offers him information about available parking spaces that may be relevant (obtained from repositories with information about parking lots and garages, data collected from parking sensors, etc.). Some of the private parking spots suggested support booking and electronic payment, which Bob finds convenient.

In the meanwhile, Alice decides to buy a present for Bob. He loves books, so she asks for appropriate book recommendations. As Bob is sharing with Alice information about his preferences and the books that he has already read, the MOcCARSin application in Alice's device uses those data to suggest Alice an appropriate book for Bob.

At the restaurant, Bob invites Alice to go to the cinema after lunch. Alice accepts, but she has the responsibility to choose the movie. By simply introducing the keywords “cinema movies”, MOcCARSin is able to provide recommendations about interesting movies being shown in cinemas in the vicinity. User preferences related to the price, type of cinema (preferred size, audio and video capabilities offered, comfort and additional services, etc.), and movie genres, are automatically analyzed during the recommendation process. For example, MOcCARSin excludes 3D movies, as they usually give Alice a headache. Moreover, as Alice shares many interests with her friends, she trusts particularly the opinions (ratings) provided by people in her social network, which is also taken into account by MOcCARSin when assessing the reliability and relevance of the available ratings.

In our preliminary work [17], we proposed basic ideas regarding the design of a context-aware mobile recommendation architecture, which facilitates the creation of CARS for mobile computing environments. In this section, we provide an overview of the proposed framework and some fundamental ideas regarding the management of contextual information.

The proposed framework (see Fig. 2
                        ) accommodates several traditional recommendation algorithms, such as collaborative filtering based on users/items, Singular Value Decomposition (SVD), and content-based filtering, as well as combinations of traditional recommendation algorithms. In addition, it supports different context-aware recommendation paradigms (pre-filtering, post-filtering, and contextual modeling), based on adaptations of traditional (i.e., non-contextual) algorithms adapted to mobile environments. The architecture designed is composed of the following layers:
                           
                              •
                              
                                 View layer. It reflects the main components of the Graphical User Interface (GUI).


                                 Logic layer. It contains the main modules of the system, such as a sentiment analyzer, a sensing engine, a user reliability analyzer, a user profile and context manager, a push-based recommendation module, a pull-based recommendation module, a rating reliability analyzer, a repository manager, and a data sharing manager.


                                 Data layer. It provides access to data relevant for context-aware recommendations in mobile environments.

As can be seen in the figure, this architecture comprises a number of modules. For instance, the User Profile and Context Manager is responsible for managing (inserting, modifying, and removing) information about the user profile and context. The information from this module is stored in a local database through the module Repository Manager, which allows the access to a local database storing those data, offering an object-relational mapping. The proposed architecture reflects an ambitious goal with many challenges, which have to be tackled gradually. In this contribution, we mainly focus on the development of some of the modules of the logic layer, with a special emphasis on the Pull-Based Recommendation module. Thus, the detailed design of some elements of the architecture is considered to be out of the scope of this paper, for example:
                           
                              •
                              The sentiment analyzer is able to interpret an opinion in natural language (e.g., an opinion expressed using free text) and determine if the opinion is positive, negative or neutral, to assign it a numeric and/or qualitative rating automatically. In our current work, we assume that the user will always express his/her preferences by using numeric ratings (e.g., using a scale between 1 and 5, or between 1 and 10, etc.).

The rating reliability analyzer module protects against profile injection attacks (attacks that try to artificially increase or decrease the relevance of some items by injecting fake ratings). This module will be implemented by applying different attack detection methods [18], and its filtered output will be used to update the corresponding local knowledge base by using the Repository Manager. Moreover, we plan to perform a reliability analysis to assign more confidence to the information provided by the user's friends [19].

Finally, the philosophy of storing information in the knowledge base locally will be extended to also allow access to external knowledge bases, as well as to support sharing data with other users in a Peer to Peer (P2P) way. To achieve this, we plan to implement a Data Sharing Manager module.

Currently, one of the biggest problems in the field of CARS is how to obtain the contextual information. In many cases, this information is obtained explicitly based on questions asked to the user by the system. For example, the system could provide the user a template to fill context fields by using free text or selecting an option from a drop-down menu. However, this is inconvenient for users, which may be too lazy to fill all the fields or carefully answer all the questions provided, leading in the end to an incomplete or inaccurate identification of the context of the user. So, the use of unobtrusive techniques able to infer the context without the user intervention (e.g., [20–23]), by using several sources (e.g., sensors, geospatial information services, social networks, web services, etc.), is desired. Observing the behavior of users and using data mining techniques, for example to learn user preferences and user needs, could also be beneficial (e.g., see [24,25]).

In our framework we implemented the Sensing Engine module to exploit implicitly the information from sensors. Dynamic context values, such as the transport way, mobility (e.g., sensed by accelerometers), temperature (e.g., sensed by temperature sensors), and time of the day (e.g., sensed by optical sensors), as well as the location (e.g., sensed by GPS) of the current user or item may be captured from sensors of the mobile devices. Thus, today's mobile devices (e.g., smart phones) come equipped with a large number of sensors, which would be useful to obtain contextual information of the user or item environment (e.g., timer, humidity, ambient noise, compass, gyroscope, camera, etc.) [10,26]. Moreover, a supporting infrastructure of sensors may be in place (e.g., to obtain temperature information from sensors deployed in a specified area).

We have performed an in-depth study of the state of the art of mobile context-aware recommendation systems (see Section 6 and particularly Table 7). Based on this study and also on the contextual model presented in [27], we have identified a set of relevant context dimensions and their possible values:
                           
                              •
                              
                                 User context: transport way (walking, bicycle, car, public), mobility (stopped, moving), weekday (week, weekend), mood (happy, sad, active, lazy), companion (alone, friends, family, girlfriend, children).


                                 POI (Point of Interest) context: price ($, $$, $$$, $$$$, free). Obviously, the higher the number of dollar signs used the higher the price.


                                 Environment context: season (spring, summer, autumn, winter), temperature (warm, hot, cold), time of the day (morning, night, afternoon), and weather (cloudy, snowing, sunny, rainy).


                                 System context: mode (off, on, flight), network (adequate, excellent, poor), and battery level (low, medium, high).

This analysis was important in supporting our goal of designing an architecture in a flexible and generic way, to enable its adaptation to any domain.

In this work, we focus mainly on the description and evaluation of the Pull-Based Recommendation module. This module provides explicit (or reactive) recommendations, obtained as an answer to a query explicitly submitted by the user and evaluated by the system as a continuous query [28].


                        Fig. 3
                         shows a high-level view of this process. First, the user introduces the item type (as the query) and context constraints (hard and/or soft constraints can be considered, as explained later) in the GUI. Afterwards, the user might (optionally) specify hints regarding the importance of the different context criteria that should be taken into account during the recommendation process. Finally, a certain context-aware recommendation paradigm (pre-filtering, post-filtering, or contextual modeling) is applied to obtain appropriate recommendations for the current user. The type of paradigm executed depends of the choice of the system developer and/or the type of items to recommend. As the context will continuously change (e.g., imagine a scenario where both the user and the items to recommend move, such as a taxi recommendation scenario), the recommendation system must automatically update the contextual information (context of the user and context of the items) and evaluate the query in a continuous way. This continuous revaluation process will be performed until the user decides to cancel the query (i.e., when he/she is not interested in recommendations about that type of item anymore).


                        Algorithm 1 shows the pull-based recommendation process in more detail. It receives as input: the contextual information of the current user, which is obtained from mobile sensors and/or the user himself/herself; the kind of items required; optionally a maximum number of items k to recommend; the minimum score required for two contexts to be considered similar (called the similarity threshold); and the time interval between two consecutive recomputations of the recommendation (the refreshment period). The sub-algorithm contextAwareMobileRecommendationParadigm(), can be implemented following any context-aware recommendation paradigm: pre-filtering, post-filtering, and contextual modeling; the details of these paradigms are provided later in this section. Such a sub-algorithm contextAwareMobileRecommendationParadigm() is executed with the required refreshment frequency until the query is explicitly canceled by the user. For this purpose, the values of the dynamic context variables are updated in each refreshment.

Both the pre-filtering and the post-filtering paradigms require determining the similarity between contexts, as the recommendation model will need to identify past votes/ratings (from the same user or from other users) that have a context similar to the current context of the user. In this section, we first describe the representation of contexts using context variables and then introduce a context similarity metric.
                           Algorithm 1
                           Pull-based recommendation algorithm


                           
                              
                                 
                                    
                                 
                              
                           

When comparing two contexts, the different context variables composing them have to be compared. In principle, all the context variables can be considered as equally important; so, we could assume that each context variable has a weight that is obtained by dividing one between the number of context variables. However, there are circumstances where some variables are more important than others, which should be considered during the recommendation process. Hence, for each domain (i.e., type of items) the system by default considers a higher importance weight to the context variables that are usually considered most relevant and a value of zero for those that are irrelevant in that domain. Moreover, the user can optionally modify his/her context criteria, by adjusting one or all the weights of the variables (e.g., see an example in Section 4.2.1). For example, the user could consider some context variables as irrelevant, assigning them a weight of zero. Alternatively, he/she could highlight the importance of some context variables over others, assigning them higher weights. If the user modifies only one or a few weights, then the values of the remaining weights will be automatically adjusted (to keep their desired relative importance and still ensure that the sum of all the weights is equal to one). These weights are considered during the recommendation process.
                              Example
                              Let us suppose that a restaurant recommendation system considers that the variables more relevant in that domain are: companion, weekday, transport way, mobility, time of the day, mood, temperature, weather, and price. For these variables, the system automatically assigns default relevance weights that are assumed to be generally suitable for that type of items, ensuring that the sum of all weights is 1 (see Table 1
                                 ). However, the user U
                                 1 considers that the variables relevant to him/her are: transport way, companion, price, time of the day, and weather; hence, he/she modifies all the initial weights. On the other hand, the user U
                                 2 considers that the most important context variables are others (transport way, price, and time of the day), and so decides to assign other weights.

Context variables whose weights are different from zero represent soft constraints, as they embed preferences of the user regarding the impact of the different context variables. Moreover, the user could also formulate hard constraints, which are specific conditions on the values of certain context variables that need to be satisfied (e.g., the price of an item should be below a certain threshold, the item should not be located further than a certain distance, etc.).

In Algorithm 2, we present the strategy used to calculate the similarity between context variable vectors Cx
                            (i.e., the context of the current user) and Cy
                            (i.e., the context of another user or the context of an item), by using Eq. (1). As shown in the equation, the similarity between contexts is computed based on the similarity between the values for each of the context variables (e.g., transport way, mobility, weekday, mood, companion, price, season, temperature, time of day, or weather). Specifically, the similarity sim(cx, cy
                           ) computed between each pair of values 
                              
                                 c
                                 
                                    x
                                    i
                                 
                              
                            and 
                              
                                 c
                                 
                                    y
                                    i
                                 
                              
                            (of the context variable i of the contexts cx
                            and cy
                           ) is multiplied by the relevance weight wi
                            corresponding to that context variable. If the overall similarity is greater than a certain similarity threshold, then the contexts Cx
                            and Cy
                            are considered to be similar. The proposed equation is analogous to the one used in [29]. However, in that work only the similarity between the context of a current user (Cx
                           ) and an item context (Cphoto
                           ) was considered, whereas we consider also the possibility to compare two user contexts.
                              
                                 (1)
                                 
                                    similarity
                                    
                                       
                                          C
                                          x
                                       
                                       
                                          C
                                          y
                                       
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          s
                                          i
                                          m
                                          
                                             
                                                c
                                                
                                                   x
                                                   i
                                                
                                             
                                             
                                                c
                                                
                                                   y
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    ∗
                                    
                                       w
                                       i
                                    
                                 
                              
                           
                        

To determine the similarity 
                              s
                              i
                              m
                              
                                 
                                    c
                                    
                                       x
                                       i
                                    
                                 
                                 
                                    c
                                    
                                       y
                                       i
                                    
                                 
                              
                            between the values of a context variable i in two contexts, we consider the following specific cases:
                              
                                 •
                                 If the values of the same context variable in the two contexts are identical (i.e., 
                                       
                                          c
                                          
                                             x
                                             i
                                          
                                       
                                       =
                                       
                                          c
                                          
                                             y
                                             i
                                          
                                       
                                    ), then their similarity is 1. For example, in Table 2
                                     
                                    c
                                    
                                       x
                                       3
                                    
                                    =
                                    c
                                    
                                       y
                                       3
                                    , c
                                    
                                       x
                                       5
                                    
                                    =
                                    c
                                    
                                       y
                                       5
                                    , and c
                                    
                                       x
                                       7
                                    
                                    =
                                    c
                                    
                                       y
                                       7
                                    , for the context variables weekday, companion, and season, respectively.

If c
                                    
                                       xi
                                     and c
                                    
                                       yi
                                     are considered to be completely different, then their similarity is 0. According to the example in Table 2, the context variables transport way, mobility, mood, price and time of day are examples of this (e.g., c
                                    
                                       x
                                       1
                                    
                                    ≠
                                    c
                                    
                                       y
                                       1
                                    , c
                                    
                                       x
                                       2
                                    
                                    ≠
                                    c
                                    
                                       y
                                       2
                                    , c
                                    
                                       x
                                       4
                                    
                                    ≠
                                    c
                                    
                                       y
                                       4
                                    , c
                                    
                                       x
                                       6
                                    
                                    ≠
                                    c
                                    
                                       y
                                       6
                                    , and c
                                    
                                       x
                                       9
                                    
                                    ≠
                                    c
                                    
                                       y
                                       9
                                    ).

Finally, if the values of the context variable i are not exactly the same but have a close semantic relationship (areRelated() in Algorithm 2), then the similarity takes some value between 0 and 1 (e.g., 0.5). This value (softSimilarity() in Algorithm 2) has been defined and stored previously and it represents a way to explicitly encode soft distances between possible values of a variable. For example, for the context variable temperature the distance between “hot” and “warm” is smaller than the distance between “hot” and “cold”, and regarding the weather the distance between “cloudy” and “rain” is smaller than the distance between “rain” and “sunny”. Another example can be illustrated by the context variable weather in Table 2, where the values clear sky and sunny are considered to be semantically close.


                                 
                                    
                                       
                                    
                                 
                              

In many cases, it may happen that a complete description of a context is not available. In other words, we could have context variables that have an unknown or null value. Directly applying the method described above to compare sparse context vectors may lead to similarity scores that are not appropriate. To deal with missing information, we have included in Algorithm 2 the method compareVariablesWithMissingInfo(), which can consider several strategies:
                              
                                 •
                                 Regarding the comparison between an unknown value of a context variable with another value, we could assume minimum similarity (i.e., a value of 0, which corresponds to the pessimistic assumption that the real value missing would be different from the other one), maximum similarity (i.e., a value of 1, which corresponds to the optimistic assumption that if we knew the value missing this would be equal to the other one), or neutral/medium similarity (e.g., a value of 0.5).

For instance, in Table 3
                                     one of the values of the context variable mobility (c
                                    
                                       z
                                       2
                                    ) is unknown and the other one has the value moving (c
                                    
                                       w
                                       2
                                    ). An optimistic comparison implies considering that the other user was also moving (maximum similarity), whereas a pessimistic comparison leads to the assumption that the other user was probably in a static location. A more neutral approach leads to consider a similarity of 0.5 as an average of the similarity values computed for the two other cases (1 and 0, respectively). Similarly, in Table 3 one of the values for the context variable companion is unknown (c
                                    
                                       w
                                       5
                                    ) and the other one has the value alone (c
                                    
                                       z
                                       5
                                    ), so a similar reasoning can be applied.

If the two values of a context variable i are both unknown, two strategies are possible. On the one hand, we can decide to ignore the comparison between the two unknowns, which means that the context variable i is not taken into account. On the other hand, it is also possible to perform the comparison between the two unknowns anyway, by applying one of the strategies mentioned above (that is, assume minimum similarity, consider maximum similarity, or estimate neutral/medium similarity).

As an example, in Table 3, for the context variable transport way the values for both users are unknown. So, we can ignore that context variable. Alternatively, we can assume that they were actually using the same transportation means (maximum similarity), using a different one (minimum similarity), or using a similar one (medium similarity). Using a medium similarity can also be interpreted from a statistical perspective: in this case, it is equally likely that the values match or do not match, so an overall average similarity can be considered.

With the pre-filtering paradigm (see Algorithm 3), first a context update is performed (i.e., the information regarding the context of the user is updated, by using sensors or explicit cues provided by the user). Then, a context analysis takes place to provide contextualized data by determining the similarity between the current context of the user Ccu
                         and other user context profiles Cup
                         included in past ratings, based on the use of Algorithm 2. The contextualized data is then provided as an input to a traditional recommendation algorithm. So, we could say that with this process we remove irrelevant raw data (i.e., data that are not related to the current context of the user) and that the data selected as relevant (smart data) are used to build the recommendation model. Finally, a maximum of k items are recommended to the current user.
                           Algorithm 3
                           Prefiltering paradigm


                           
                              
                                 
                                    
                                 
                              
                           

The post-filtering paradigm (see Algorithm 4) is similar to the pre-filtering paradigm, but inverting the order of the steps. First, it applies a traditional recommendation model to obtain candidate items and later contextualized candidate items are provided to the current user. Moreover, the post-filtering algorithm considers hard constraints to filter out items that do not satisfy them. Notice that the pre-filtering algorithm proposed (presented in Section 4.3) does not check hard constraints to filter the items that will be used to learn the model; although hard constraints could also be considered in the pre-filtering, that would decrease considerably the amount of items used for training the model.
                           Algorithm 4
                           Postfiltering paradigm


                           
                              
                                 
                                    
                                 
                              
                           

To obtain these contextualized items, both hard constraints and soft constraints could be applied. The application of hard constraints represents a strict requirement regarding the fulfillment of certain conditions, and therefore only the items that match all the hard constraints of the current user will be recommended (see Algorithm 5); as an example, filtering the candidate items according to specific location-dependent constraints [30] could be considered (e.g., filtering the items based on their distance from the user). The application of soft constraints implies a traditional comparison between the context of the user and the context of each candidate item (see Algorithm 6).
                           Algorithm 5
                           Filtering with hard constraints


                           
                              
                                 
                                    
                                 
                              
                           

Finally, in the contextual modeling paradigm (see Algorithm 7) the contextual information is used directly in the recommendation model, as context variables are simply considered as features in the feature vectors compared. Specifically, in our prototype we use a Naïve Bayes classifier [31], which is a probabilistic classifier based on Bayes' theorem.

In the contextual modeling paradigm, the classifier learns a model for each user profile. The model is stored in a knowledge base, which contains several instances (one for each user). Each instance is composed by the following features or attributes: the context variables (of nominal type) and the item's rating for those contexts (numeric type). The decision class (nominal type) are the ratings (e.g., values in a scale between 1 and 5). For a new instance (context variables of the current user and the possible item to recommend) the classifier predicts a rating. The ratings predicted for the different candidate items are sorted (in descending order of rating) and the first k items with a predicted rating higher than a specific recommendation threshold (e.g., the items with a rating predicted of at least 4) are provided to the current user.
                           Algorithm 6
                           Filtering with soft constraints


                           
                              
                                 
                                    
                                 
                              
                           


                              
                                 
                                    
                                 
                              
                           

Another variant for this paradigm would be to consider as the decision class the labels like or dislike, by partitioning the possible rating values in these two categories (e.g., the ratings 1, 2 and 3 could belong to the dislike class – i.e., items that should not be recommended – and the ratings 4 and 5 to the like class – i.e., items that should be recommended –). In this case, the algorithm would recommend the k items with the highest probability to belong to the class like.

We have developed a prototype of our framework using the Java programming language (Java 1.7), focusing so far particularly on the design of the pull-based approach. We have used the Weka
                        1
                     
                     
                        1
                        
                           http://www.cs.waikato.ac.nz/ml/weka/.
                      data mining toolkit as well as the machine learning library Mahout.
                        2
                     
                     
                        2
                        
                           https://mahout.apache.org/.
                      Both Weka and Mahout offer implementations for various data mining algorithms; specifically, we have used the Naïve Bayes classification algorithm provided by Weka and the recommendation algorithms offered by Mahout (in particular, the SVD algorithm). In this section, we present the experimental evaluation that we have performed. All the experiments were conducted on a computer with an Intel Core i5-2320 processor with 3GHz and 16GB of RAM, running Windows 7.

In the following, we first describe the dataset that we have used, its adaptation for our experimental evaluation, the experiments performed, and the results obtained.

A very important problem to evaluate mobile CARS is the lack of available datasets that contain information about the context of the user when he/she provided a specific rating. It would be interesting to have some reliable high-dimensional dataset (e.g., like the well-known Movielens
                           3
                        
                        
                           3
                           
                              http://grouplens.org/datasets/movielens/.
                        ), but enriched with precise and complete contextual information. Unfortunately, the current situation is quite different:
                           
                              •
                              Most papers in the field of context-aware mobile recommendation systems have been evaluated with own data collected from real users (e.g., see [15,29,13,32–37]). For example, in [35], to evaluate a context-aware mobile music recommendation system, the authors firstly considered the publicly available CAL500 dataset, which incorporates ratings along with some usage annotations (such as whether the user was driving or sleeping). However, those annotations only partially covered the evaluation needs of the authors, and so they decided to build a new dataset with songs crawled from Grooveshark
                                    4
                                 
                                 
                                    4
                                    
                                       http://grooveshark.com.
                                  and YouTube
                                    5
                                 
                                 
                                    5
                                    
                                       http://www.youtube.com.
                                  and using humans to annotate them.

There are some context-aware datasets available in the Internet that contain contextual information (e.g., see http://students.depaul.edu/ yzheng8/DataSets.html), in domains such as foods and restaurants [12,38,39], movies [8], hotels and travel [40–43], and music [44]. There is also a Yelp's Academic Dataset,
                                    6
                                 
                                 
                                    6
                                    
                                       http://www.yelp.com/academic_dataset.
                                  which includes ratings provided by real users to score local businesses (e.g., in [45] the authors enhanced these data by simulating the context). Another interesting dataset is the ConcertTweets dataset
                                    7
                                 
                                 
                                    7
                                    
                                       http://people.stern.nyu.edu/padamopo/data/.
                                  
                                 [46], which contains concert ratings combined with spatio-temporal contextual dimensions and data of social networks.

So, an important current problem in this area is the lack of a good-quality large dataset with enough information on ratings and contexts for (quantitative and qualitative) evaluation purposes of the context-aware mobile recommendations-based paradigms and applications developed by the research community.

Of the few datasets available, the one most suited to our problem, and therefore the one that we decided to use, was the collected data from an Android Mobile Application called South Tyrol Suggests (STS).
                           8
                        
                        
                           8
                           
                              https://play.google.com/store/apps/details?id=it.unibz.sts.android.
                         The STS application provides context-aware suggestions for accommodations, attractions, events, and restaurants in South Tyrol. Specifically, the dataset available at http://students.depaul.edu/ yzheng8/datasets/Data_STS.zip contains 2534 ratings (on a scale of 1 to 5), provided by 325 users in different contexts, of approximately 249 POIs [42,43]. Contexts in the dataset are composed by 14 context dimensions:
                           
                              •
                              
                                 User context (8 variables): transport way (walking, bicycle, car, public), weekday (weekday, weekend), mood (happy, sad, active, lazy), companion (alone, friends, family, girlfriend, children), time available (half day, one day, more than one day), knowledge of the surroundings (new to area, returning visitor, citizen), travel goal (visiting friends, business, religion, health care, social event, education, landscape, fun, sport), and distance to the item (far away, nearby).


                                 POI context (2 variables): budget (budget traveler, price for quality, high spender, free) and crowdedness (crowded, not crowded, empty).


                                 Environment context (4 variables): season (spring, summer, autumn, winter), temperature (burning, hot, warm, cool, cold, freezing), time of the day (morning, noon, afternoon, evening, night), and weather (clear sky, sunny, cloudy, rainy, thunderstorm, snowing).

The values of context variables related to the environment were automatically collected, whereas the values about the context of the items and the user context were manually obtained (the application requested the user to explicitly fill appropriate values for those variables when submitting his/her rating), with the exception of the context variable weekday, which was automatically computed. From now on, we will consider 13 of the previous 14 context variables, as the distance between the user and the item will be translated into a geographic location for the item, as explained in Section 5.3.

Although the dataset chosen is the most appropriate one that we have been able to find, it is subject to important limitations. A notable problem is that it is pretty sparse in terms of the availability of ratings and contexts. Fig. 4
                         illustrates the low percentage of information available for each context variable in the full dataset, which emphasizes the interest of techniques that capture contextual information automatically without the intervention of the user (see Section 3.2). As shown in the figure, the context variable for which there is more information available is the “temperature” variable (a value of temperature is provided in about 15.6% of the ratings), whereas the variable with more missing values is the “transport way” (specified only for 3.2% of the ratings). The percentages shown in the figure are really low, which means that in most cases the real value of a specific context variable potentially affecting a rating is not available.

This sparseness of contextual information is further analyzed in Fig. 5
                        , which indicates, for each rating, the number of context variables that have a value. As the figure shows, only a maximum of 5 context variables are provided for some ratings and most ratings have only 1 context variable defined (or none). For 23.64% of the ratings in the dataset only one context variable has a defined value and 38.44% of the ratings have no context variable defined.

The ratings available are not uniformly distributed over the different users either: for some users there are very few ratings available and for others we have comparatively a high number of ratings. So, there is an average of 8 ratings per user, but some users have provided many ratings (a single user provided 175 ratings) and some users provided only 1 rating.

As a reasonable decision could be to consider only the users for which a significant number of ratings is available, we analyzed the contextual information for the three users with more ratings in the dataset: user 1, user 7, and user 24, who have 175, 96, and 123 ratings, respectively; to determine an appropriate number of users to select, we applied the clustering algorithm k-means for different values of k. Fig. 6
                         shows, for those three users, the number of ratings with no contextual information, the number of ratings with some contextual information, and the number of contexts guaranteed to be different.
                           9
                        
                        
                           9
                           Notice that two contexts that have the values of all the defined context variables equal are not guaranteed to be different from each other (neither equal) if they also contain some undefined values.
                         Just by coincidence, these three users voted exactly the same items (numbered from 1 to 8 in the figure). Each division/portion of each bar in the figure marks a value in the Y-axis. For example, the figure shows that for user 1 and item 1: the item was rated by the user 43 times; of those, 13 ratings completely lacked contextual information and 30 ratings had some contextual information (i.e., at least 1 context variable had a defined value); moreover, it also shows that, from the ratings with some contextual information, only 23 contexts are guaranteed to be different. It should be noted that in some cases the portion corresponding to the number of ratings with some contextual information is hardly appreciable (e.g., for item 5 of user 1, for item 6 of user 7, etc.) because that number matches the number of contexts guaranteed to be different. The figure shows that the sparseness of contextual information also holds in the case of the users for whom a higher amount of information is available. Notice that the number of ratings of each user is in general smaller than the number of items that he/she rated. This is because there are users that have rated the same POI several times even in potentially-identical contexts (i.e., identical contexts if we ignore context variables with undefined values).

As the location is an important context parameter, that is not available in the dataset, we decided to adapt the original dataset by including a new context variable to represent the location (location of the user in the case of a user context, location of an item in the case of an item context). For this purpose, we completed randomly the values of the context variables “distance to the item” and “transport way”. Firstly, we generated randomly the location values (latitude and longitude) of the 249 POIs, assuming that they are bounded by an area of 3km2 (i.e., the density of POIs is about 83 per km2). Then, we simulated the locations of the users in a certain context by taking into account several user profiles (see Table 4
                        ) – each user is assumed to belong to one of those profiles –, the values of the context variable “transport way” (as there are missing values for this context variable in the dataset, we generated the missing values randomly), and the locations of the POIs generated previously.

As an example, according to Table 4, if a user with a “lazy profile” is driving in his/her car, then he/she will consider as far those POIs that are at a distance exceeding 1km. Now, let us imagine that we have a rating provided by this user for a certain item and that the user indicated that the item was “near”. In order to simulate a plausible location of the user when he/she provided that rating, we proceed as follows: 1) we generate randomly a location within a scenario of 4km2 (slightly higher than the area of 3km2 where the items are positioned, in order to simulate the potential absence of items, but not of users, near the borders of the scenario); 2) we compute the distance between the location of the user and the POI; and 3) if the distance is smaller than 1km (the maximum radius for that user profile and transportation means), then that location is valid for the user at the time of voting and can be kept, and otherwise we get back to step 1.

As we are generating some data randomly to complete the dataset, it is important to ensure that this artificial addition does not modify any substantial aspect of the dataset. For that purpose, we computed the Pearson correlation coefficient to determine the relationship between the ratings provided by the users and the distance to the corresponding POIs. We obtained a Pearson coefficient of 0.18 (very slight positive correlation) for the original values in the dataset, which indicates that the user does not generally penalize ratings for items that are far. For the simulated data, we obtained a coefficient of −0.01 (near independency, which is consistent with the fact that the missing data were generated randomly). In both cases, there is a very weak correlation. Therefore, the modifications to the dataset do not affect the real correspondence between the ratings and the distances between the users and the items rated. In Fig. 7
                         we show the distribution of ratings for each real distance indication (item near the user or far from the user) and we can see that there is a high percentage of high ratings (rating values of 4 and 5) for both of those two distance indications, not only for nearby items.

In our experimental evaluation, we have used the classical metrics of Mean Absolute Error (MAE), precision, recall, and F-measure. We determined the MAE (see Eq. (2)), by computing the absolute differences between the predicted ratings 
                           
                              
                                 
                                    r
                                    ^
                                 
                                 i
                              
                           
                         and the real ratings (ri
                        ), averaged over the number of ratings available.
                           
                              (2)
                              
                                 M
                                 A
                                 E
                                 =
                                 
                                    1
                                    n
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          
                                             
                                                
                                                   r
                                                   ^
                                                
                                                i
                                             
                                             −
                                             
                                                r
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        whereas the MAE is a measure of the absolute numeric error in the estimation of the votes, the precision, recall and F-measure indicate the performance of the recommendation algorithm regarding the items recommended and not recommended. Thus, the precision (see Eq. (3)) reflects the capability to recommend only useful items (avoiding the irrelevant ones), while the recall (see Eq. (4)) represents the coverage of useful items that the recommendation model can obtain (avoiding missing relevant items). Finally, as a combined metric we use the F1-measure, which is defined as the harmonic mean of the precision and recall. The F1-measure is a particular case of F-measure (see Eq. (5)) for the particular case of a value of β
                        =1. Notice that the meaning of the values TP, FP, and FN, used in the formulas of precision and recall is explained below, in relation to the concept of confusion matrix.
                           
                              (3)
                              
                                 precision
                                 =
                                 
                                    
                                       T
                                       P
                                    
                                    
                                       T
                                       P
                                       +
                                       F
                                       P
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 recall
                                 =
                                 
                                    
                                       T
                                       P
                                    
                                    
                                       T
                                       P
                                       +
                                       F
                                       N
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    F
                                    β
                                 
                                 =
                                 
                                    
                                       1
                                       +
                                       
                                          β
                                          2
                                       
                                    
                                 
                                 ∗
                                 
                                    
                                       precision
                                       ∗
                                       recall
                                    
                                    
                                       
                                          
                                             β
                                             2
                                          
                                          ∗
                                          precision
                                          +
                                          recall
                                       
                                    
                                 
                              
                           
                        
                     

To illustrate the performance of the system in terms of precision and recall, it is useful to use a confusion matrix (or contingency table), as shown in Table 5
                        . This table represents the four possibilities that can arise regarding a recommendation decision. The diagonal numbers TP (True Positives) and TN (True Negatives) count the correct decisions: recommend an item when it should be recommended and do not recommend an item when it should not be recommended, respectively. On the other hand, FP (False Positives) and FN (False Negatives), represent incorrect decisions: recommend an item when it should not be recommended and do not recommend an item when it should be recommended, respectively.

In order to evaluate the performance of the context-aware recommendation paradigms included in the framework, we compared the pre-filtering, post-filtering, contextual modeling, and traditional recommendations. The experiments were realized with the dataset STS described in Section 5.1 and analyzed in Section 5.2, after performing the slight adaptations indicating in Section 5.3. Our experiments include a training phase and a testing phase. Hence, we decided to divide 70% of the data for training and 30% for testing. The training set represents information available about the user profiles (previous ratings already provided by the users) whereas with the testing set we simulate items that have not been rated yet (the system will try to predict the right recommendations for those items).

Firstly, we compare the traditional algorithm of collaborating filtering (non-contextual) with the context-aware paradigms of pre-filtering, post-filtering, and contextual modeling. Due to the limited information available in the dataset, we decided to use the recommendation algorithm based on SVD (provided by Mahout). The SVD recommendation model allows a better handling of the problem of cold start, by capturing indirect relationships between users and items (i.e., it is able to relate several users even when they have not rated items in common). For the contextual modeling, we use the Naïve Bayes Classifier (implemented in Weka).

In the pre-filtering and post-filtering paradigms, the similarity threshold was set at 0.5 and the similarity was calculated by using Eq. (1). In the pre-filtering paradigm, for the computation of context similarities by Algorithm 2, we apply for compareVariablesWithMissingInfo() the strategy that ignores context variables with unknown information and assumes a maximum similarity of 1 when a variable has a value and the other does not. We made this optimistic decision because the information of context vectors is very poor (there is a high sparseness in the representation of contexts, as explained in Section 5.2), and otherwise we would filter out too many contexts.

In the post-filtering paradigm, we implemented the filteringWithSoftConstraints() algorithm called in Algorithm 4 by penalizing the predicted rating for the case of items that are far from the user, by measuring by how much the distance of what is considered near is exceeded (according to the user profile and his/her transportation means, as shown in Table 4). For this purpose, we verified if the rating predicted is greater than or equal to the recommendation threshold (set to 3). If so, we penalize the predicted rating by using Algorithm 8.
                           Algorithm 8
                           Post-filtering: penalization of the rating predicted based on the distance


                           
                              
                                 
                                    
                                 
                              
                           

@&#EXPERIMENTAL RESULTS@&#

We distinguish the experimental results according to whether only soft constraints are applied (relevant context variables are marked, by assigning them an appropriate weight) or whether hard constraints (strict conditions on context variables that need to be satisfied) are also required.


                           Fig. 8
                            compares the different paradigms in the case of soft constraints. Regarding the MAE, we can see that the traditional method achieves very similar results to the pre-filtering paradigm, being these two the paradigms that provide the smaller MAE. Fig. 8 shows that the precision of the pre-filtering and the traditional paradigms perform similarly to the post-filtering, and that contextual modeling performs slightly better (see Table 6
                           , which shows the precise values of the precision, recall, and F1-measure). In terms of recall and F1-measure, the pre-filtering and traditional paradigms also perform similarly and outperform the post-filtering and contextual modeling paradigms. Specifically, we can observe that with the post-filtering and contextual modeling paradigms the recall decreases in about 45.8% and 18.2%, respectively. Similarly, the F1-measure decreases in about 26.7% with post-filtering and about 7.9% with contextual modeling. We think that an important reason for not observing very large differences with the traditional paradigm is the lack of dense contextual information in the dataset used (see Section 5.7 for more details).

As indicated in Section 5.2, the users with more ratings in the dataset are the users 1, 7, and 24, with 175, 96 and 123 ratings, respectively. For these users, we also determined the values of the MAE and F1-measure (see Figs. 9 and 10
                           
                           ). We can see that there is a significant variability regarding the performance of the different methods for different users, as the quality of the recommendation models is heavily influenced by the amount of data available for those users. In general, the more data available (i.e., the higher the number of ratings per user) the better the accuracy of the recommendations.

To facilitate the analysis of the existing relation between the number of ratings available and the recommendation performance, in Fig. 11
                            we show the MAE achieved for each of the recommendation methods when the number of ratings varies. This figure presents results based on experimental data for the users 1, 7, and 24, but a similar trend can be observed if we consider other users. For users with a very low number of ratings the training phase has a very limited amount of data available to build the recommendation model and, consequently, the recommendation performance decreases. In Section 5.7 we analyze the impact of the problem of sparseness of the dataset in detail.

Now we consider the case of hard constraints. As an example, we consider as a hard constraint the existence of a location-dependent constraint that requires that an item must be near the user in order to be recommended (the concept of nearness depends on the user profile and the transportation means used, as shown in Table 4).

We compare a traditional recommendation algorithm with the post-filtering paradigm. In the case of applying hard constraints, then the traditional paradigm is clearly worse in terms of precision and F1-measure (see Fig. 12
                           ). The reason is that the post-filtering paradigm is able to remove items that do not satisfy the hard constraints, which are not removed by the traditional recommendation algorithm, as it does not apply any kind of post-filtering. Removing irrelevant items increases the precision (by a factor of two, according to Fig. 12). As the postfiltering does not remove relevant items (only the items that do not satisfy the hard constraints are removed), it does not affect the recall. As a result, the overall F1-measure improves considerably. So, we see that checking hard constraints in a post-filtering step is essential.

The little information that we have in the dataset is considered as a reason for performance reduction in the learning of an appropriate recommendation model. As a result, the prediction of some ratings might be unsuitable, which in turn could lead to imprecise or incomplete recommendations.

We have carried out an experiment to prove the hypothesis that the more data available the better the learning model will perform. Firstly, we discarded the users for which a very low number of ratings was available; specifically, we required at least 11 ratings per user, which led us to the selection of 24 users (from a total of 325 users). Then, we divided the dataset randomly in two subsets: 70% of the ratings of each user were used for training and the remaining 30% were used for testing. Afterwards, we removed from the testing set those items and users that never appear in the training set (neither jointly nor as part of different ratings). From the above training set, we temporarily generated another training file (named “temporal training set”), where we initially added only one rating per user. The rest of the ratings were stored in a file named “pool set”. Next, we trained the recommendation model with the temporal training set and we evaluated it with the testing set focusing only on the users 1, 7, and 24. Later, we incrementally added to the temporal training set a maximum of 10 ratings per user by using certain addition strategies:
                           
                              •
                              
                                 Option 1: adding ratings from the pool set to the temporal training set one by one until a maximum of 10 ratings are added.


                                 Option 2: adding 5 ratings from the pool set to the temporal training set and then 5 ratings more.


                                 Option 3: directly adding 10 ratings from the pool set to the temporal training set.

We learned an SVD recommendation model using Mahout with the complete training set and performed the evaluation with the testing set; this evaluation was named baseline, as it represents the best model that can be obtained (using all the information available in the existing dataset, which means a total of 649 ratings in the training set). After that, we trained an alternative SVD model with the temporal training sets that were generated with the option 1, option 2, and option 3, and we evaluated the MAE, precision, and recall of each variant with the testing set. Notice that each option implies a different number of training-testing stages (11, 3, and 2, respectively), with an increasing number of ratings in the temporal training set used in each stage. Figs. 13, 14 and 15
                        
                        
                         display the results obtained. The figures clearly show that the quality of the model increases when more training data is available. Therefore, we could expect that better recommendations could be obtained if a richer dataset was available.

We can illustrate with some data the effect observed in the previous figures. For example, if we focus on the MAE, we can see in Fig. 13 that when there is initially one rating for each user the value of the MAE is of 0.99. From this initial training file, for the Option 1, when two ratings per user are added (i.e., there is a total of 76 ratings in the training set) the value of the MAE decreases slightly to 0.98, and so on until a value of 0.91 is obtained when there are 269 ratings in the training set. For the Option 2, when five ratings per user are added (which leads to a total of 149 ratings in the training set) the value of the MAE decreases from 0.99 (in the case of one rating per user) to 0.93, and when adding five ratings more per user the MAE decreases to 0.91. Finally, for the Option 3, when ten ratings are added per user (i.e., there is a total of 269 ratings in the training set) the MAE is reduced to 0.96. In the previous three options, by increasing the number of ratings per user in the training set, the values of the MAE tend to decrease to values around 0.89 (the value obtained for the baseline when the training set contains 649 ratings in total, that is, using the whole dataset). A similar behavior can be observed for the precision and recall measures (Figs. 14 and 15). The key aspect that should be noted is that there is a clear trend showing that the performance can increase when more training data (i.e., historical data about previous users' rating) increases.

The experimental evaluation showed a couple of results that were unexpected:
                           
                              •
                              We cannot observe a clear improvement of the other paradigms over the traditional recommendation paradigm. We believe that the reason for this is the low quality of the dataset: even if it is the best one that we have found, it has a significant amount of missing information and poor context descriptions (see Section 5.2). As a result, the models learned are not precise enough. As shown in Section 5.7, a better context-rich dataset is expected to significantly improve the results and highlight the differences.

The recall with the post-filtering paradigm decreases significantly. This is because the post-filtering penalizes data items that are far from the user (see Section 5.5); indeed, the difference between the post-filtering paradigm and the traditional paradigm is the application of this removal a posteriori (soft constraints and hard constraints, as shown in Algorithm 4). Whereas this seems reasonable, according to our analysis in Section 5.3 the distance between the user and the item does not seem to have a direct key impact on the final rating provided by the user. Nevertheless, in Section 5.6.2 we actually showed how the post-filtering can significantly increase the accuracy of the recommendations when there are hard constraints regarding the maximum distance allowed.

@&#RELATED WORK@&#

Generally the user preferences towards potentially relevant items are conditioned by his/her context. However, one of the fundamental problems that traditional 2D recommendation models exhibit is that the contextual information (e.g., the time, with whom the user is with, the weather conditions, what the user is doing, etc.) is excluded from consideration. The addition of context-awareness in recommendation systems has been receiving considerable attention in the last years, given rise to research on Context-Aware Recommendation Systems (CARS). The idea is to exploit contextual information to suggest relevant items to the user according to his/her current context.

In this section, we present the state of the art related to CARS and mobile CARS. As can be seen along this section, the field of context-aware recommendation systems has started to emerge quite recently. However, aspects related to mobile users and mobile computing are usually ignored in this field. The aim of our architecture is to combine ideas of the existing research, as well as to incorporate other relevant elements for context-aware mobile recommendations. So, our goal is to contribute to bridge the gap not only between recommendation systems [3] and context-aware computing [47,48], but also between context-aware recommendation systems [9] and mobile computing [49,50].

Several studies have proved that contextual information improves both the quality of the recommendations and the user satisfaction when a recommendation system is employed. For example, the authors of [8] proposed that the recommendation procedure should incorporate contextual information. In Section 2.2, we described the three paradigms proposed for CARS (pre-filtering, post-filtering, and contextual modeling), which we have incorporated in our framework.

A critical issue for the contextual modeling paradigm is obviously the development of context models, such as those proposed in [34,51,52]. The problem with these proposals is that they model information for a very specific application domain, and so their domain-specific models cannot be easily reused in other recommendation scenarios. For this reason, within the research community there is a need to solve this problem by defining a generic, abstract, contextual framework for modeling CARS. There are also some proposals that try to exploit available contextual information and be more generic, but they have some limitations. Thus, in [27] the authors emphasize that those approaches usually represent information that either concerns particular application domains (e.g., tourism, movies, etc.) or more abstract domains (e.g., products, web services, e-learning, etc.), but that a truly generic contextual model for CARS was missing, which motivated their work. As an example, [53] presents a generic model using an ontology, which can be used in different types of recommendation systems and model data, context, and the recommendation process itself. Recently, [27] carried out a study to try to determine whether a more generic modeling approach could be applied for CARS. As a result of the study, the authors proposed a novel generic contextual modeling framework for CARS, which was theoretically evaluated with positive results.

Some open research problems identified in [9] have been addressed to a certain extent in recent studies. For example, in [54] the authors performed an evaluation and comparison of the effectiveness (accuracy vs. diversity) of the existing paradigms, in order to identify strengths and weaknesses of each paradigm and to determine which one is better in different circumstances (a qualitative comparison among the paradigms had been presented before in [55]). Moreover, the inclusion of diversity as an important element in context-aware recommendation systems was considered for the first time in [56]: the idea is that the users should be provided with recommendations that are diverse enough rather than very similar to each other, which is an idea that had been exploited before in Information Retrieval (IR) contexts [57].

To finish this overview of CARS, it is interesting to mention a software framework called Hybreed 
                        [58], that has been proposed to build complex context-aware applications. The framework is based on a notion of context quite generic. An interesting feature is that the user of the framework (a developer of recommendation systems or a researcher working in this field) can use different recommendation algorithms (e.g., item/user-based collaborative filtering, item-average recommendation, random recommendation, slope-one, content-based algorithms, rule-based recommendations, as well as combinations of them). Besides, it provides recommendations for both individual users and groups of users. It also includes methods to generate context-aware recommendations. Finally, it incorporates data from external data sources (e.g., user's profile information, semantic networks, etc.) and is able to store and manage the information in databases (e.g., MySQL or HSQL). However, there are still elements pending for future work, as identified by the authors, such as developing and providing advanced learning algorithms as part of the framework or the development of a processing engine that supports distributed and asynchronous workflows. Moreover, privacy issues were not addressed.

With the continuous technological advances of mobile devices and communication technologies, the exploitation of contextual information in recommendation systems is being adapted to the domain of mobile computing, which implies considering context-aware mobile recommendations [59].

In recommendation systems in general, and in particular when mobile users are considered, it is important to balance the potential trade-off between not offering some relevant items in the recommendations and providing some irrelevant items (recall vs. precision). In the first situation, we would miss the opportunity to suggest the user items that he/she may find very interesting. In the second, we could end up overloading the user with irrelevant information, which in turn could lead to an eventual user's desensitization and distrust in the system. In mobile environments, where the user is moving and the context is highly dynamic, it is essential to provide precise recommendations and avoid overloading the user with the suggestion of many items. Generally, mobile devices such as smartphones have important limitations in comparison to traditional mobile or desktop computers; for example, they usually provide restricted input facilities (e.g., lack of a comfortable keyboard). Moreover, a recommendation system should try to relieve the user from having to type or introduce significant information as an input, favoring implicit recommendations (based on the context and user preferences) over explicit (query-based or user-initiated) recommendations. Along these lines, [15] proposes a proactive recommendation system that pushes recommendations to the user when the current situation (i.e., the context) is considered appropriate, without explicit user requests.

The term UbiCARS has been proposed in [60] to emphasize the combination of the characteristics of both ubiquitous systems and CARS. Systems in this category are ubiquitous in the sense that they capture information from the environment and react to it. At the same time, they are context-aware because they consider the context in the recommendation process by using multidimensional contextual datasets. As an example, we could consider the case of recommending nearby items to a user while he/she is shopping (as in the use case presented in Section 2.4); it could be based on the use of NFC or other similar technologies to read RFID tags and identify products in the vicinity of the user, as well as product information that can be useful in that context.

An important subset of CARS is represented by the so-called Mobile Location-Aware Recommendation Systems (LARS). These systems only consider the dimension location in the multidimensional context. In this direction, a number of researches have been carried out. An example is the Location-Aware Recommendation System LARS [61,62], which uses location-based ratings to provide recommendations.

In the rest of this section, we describe other examples of mobile context-aware recommendation systems proposed for different domains. These kinds of systems could be developed based on the architecture that we propose in this paper. As a summary, in Table 7
                        , we provide an overview of the context variables and application domains of existing work in the field of mobile CARS.

In [36], the goal is to recommend mobile applications (e.g., a mobile restaurant guide) to users that have a context similar to the one of other users when they installed the applications. The authors of that work proposed to hybridize traditional recommendation systems to manage contextual information (e.g., the current location of the user).

Another interesting work focused on the recommendation of mobile applications is [63], which suggests mobile applications to mobile device users based on the actual usage of the applications in different contexts. Its authors describe different dimensions and techniques to obtain information about the users, items, ratings, and contexts.

For the domain of restaurants, the proposal in [12] extended a Support Vector Machine (SVM) classifier by including contextual information in the feature space. The authors also combined a Context-Aware SVM (C-SVM) with Collaborative Filtering (CF), which led to a method called C-SVM-CF. Both methods were evaluated and used for recommending restaurants. Another work with a similar goal was [64], which proposed a map-based personalized recommendation system that predicts proper restaurants based on the use of Bayesian Networks and shows the results to the user on a map.

A proactive recommendation system that pushes recommendations to the user when the current situation (i.e., the context) is considered appropriate, without explicit user requests, was described in [15]. Along these lines, [65] evaluated the impact of proactivity in the user experience: whether users would accept proactive recommendations, how to present the recommended items, and how to properly notify the users. To answer these questions, they evaluated two mobile user interfaces for context-aware restaurant recommendation, based on the proactive recommendation model proposed in [15].

The work in [13] presented a CF-based framework, based on OLAP and multi-dimensional CF, that provides restaurant recommendations; the framework was implemented in an existing m-commerce platform of the food industry. Another novel multidimensional approach for context-aware recommendation in m-commerce was presented in [14] and evaluated in the context of a recommendation system for restaurant foods.

In [69] a context-aware system for mobile devices that incorporates implicit contextual information (the user's speed and trajectory) was proposed. The authors defined an area of interest (AOI) such that only the POIs within that area are recommended to the user. Another example of context-aware mobile application is COMPASS [66], which provides POI recommendations (e.g., restaurants, museums, etc.) based on the location of a tourist and his/her interests. In [37] the authors also included the context in a recommendation system to recommend POIs (e.g., gas stations, parking lots, or restaurants) in automotive scenarios (e.g., the driver of a car receives recommendations while driving).

The inclusion of Context-aware Collaborative Filtering (CaCF) into mobile guides was investigated in [67]. The authors started from the idea that similar users usually choose similar POIs in similar contexts. They included contextual information into the CF through contextual pre-filtering and contextual modeling. The methods proposed were evaluated with available GPS trajectories collected from the Vienna Zoo (Austria), with the purpose of offering relevant context-aware POI recommendations to the visitors.

In [68], the authors proposed a methodology that supports the development cycle for CARS. To put it in practice, they developed a context-aware mobile recommendation system prototype called ReRex, that suggests interesting POIs for tourists according to the value of several contextual conditions.

According to [42], a better user profile will lead to better recommendations. This can be obtained by applying active learning techniques to ask the user to rate specific selected items (e.g., popular and non-redundant items) for which the knowledge about the user ratings is expected to improve the quality of his/her profile. To evaluate the approach proposed, they also built a mobile CARS to recommend POIs for tourists in the Alto-Adige region in Italy.

In [43], the authors described a context-aware recommendation system for tourists, named STS (South Tyrol Suggests), that takes into account the impact of the weather conditions at a specific POI. As explained in Section 5.1, to evaluate our approach we analyzed and used a dataset collected through the use of this application. In a similar direction, [70] proposed a hybrid mobile recommendation system that exploits contextual information to support tourists in making decisions about the attractions to visit.

The work in [16] presents a model to generate context-aware mobile recommendation systems that recommend places (e.g., restaurants, stores, cinemas, supermarkets, etc.) where bank clients have paid with their credit cards. The authors used banking data to obtain information based on real person's actions and banking history.

As a final example, the classical collaborative filtering approach was modified in [24] to include several context dimensions (e.g., location, time, interest, and satisfaction level) by applying data mining techniques (e.g., decision tree-based classification rules to understand the needs of the users). The proposed algorithm was evaluated in the context of recommendation of places for shopping, eating, enjoying, drinking, and learning.

InCarMusic is a context-aware mobile recommendation system that offers music recommendations to the passengers of a car [44]. For the recommendation of songs for daily activities (e.g., studying, running, walking, sleeping, working, and shopping), a novel probabilistic model was proposed in [35], which integrates contextual information (collected through mobile devices) with music content analysis.

A general framework for the recommendation of social events (e.g., music events) was proposed in [71,72]. It supports the implementation of context-aware recommendation engines for mobile platforms. The main idea of the framework is based on the hybridization of traditional CF with contextual information. Moreover, it uses a MapReduce programming model [76] for the distributed data aggregation and blending of multiple context-dimensions.

Based on a dimensional recommendation model and a hybrid processing approach, the CoMeR platform [34] supports context-aware media recommendation for smart phones. To validate the approach, a context-aware movie recommendation system for smartphones (called ContAwareMovie) was developed by using CoMeR. Also for the recommendation of media, MMedia2U [29] is a prototype of a mobile photo recommendation system, which exploits the user's contextual information as well as the existing context when the photo was created.

A scalable architecture for context-aware activity-detecting mobile recommendation systems (called Magitti) was developed in [32,33]. It infers leisure time activities based on the context and patterns of user behavior.

Different recommendation systems have also been developed in the context of news and e-learning. For example, an approach to recommend news by using the current context of mobile users, as well as the format in which the news items should be represented, was proposed in [73]. The work in [77] presented a framework for the recommendation of learning resources for learners in a mobile social learning community.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper, we have described a framework that facilitates the development of context-aware recommendation systems for mobile users. Specifically, the main contributions of this work are:
                        
                           •
                           We have presented a recommendation architecture that is generic, extensible, and adaptable to the requirements of specific types of recommendations. As it has been shown in the extensive study of the state of the art, most related proposals are solutions to specified problems in certain domains. Despite those efforts, the emergence of flexible and generic frameworks to support an easy development of mobile CARS has been relatively unexplored.

We have described in detail the design of the pull-based recommendation module, which accommodates the pre-filtering, post-filtering, and contextual modeling paradigms.

We have performed an experimental evaluation that compares the different paradigms. A major difficulty for the experimental evaluation is the difficulty to find a suitable dataset that incorporates contextual information. Even with the limitations of the dataset chosen, which we have analyzed in detail, up to the authors' knowledge this is one of the first studies that performs an experimental evaluation of context-aware recommendation strategies for mobile environments which is not merely qualitative (i.e., simply based on user opinions about the expected or perceived benefits) but quantitative, based on data.

The possibility to bridge the gap between CARS and mobile computing is still emerging and the framework described in this paper represents a vision that has to be tackled gradually. As future work, we plan to continue the development of the proposed architecture, with a special emphasis on the design of the techniques needed to facilitate recommendations and data sharing in mobile peer-to-peer environments, as well as on the design of the push-based recommendation module. Regarding the evaluation, we would like also to explore other alternatives (e.g., gamification with real users, through the development of a videogame with recommendation testing purposes).

@&#ACKNOWLEDGMENTS@&#

This work has been supported by the CICYT project TIN2013-46238-C4-4-R, DGA-FSE, and a Banco Santander scholarship held by the first author. We sincerely thank the reviewers for their useful comments, that helped us to improve our work.

@&#REFERENCES@&#

