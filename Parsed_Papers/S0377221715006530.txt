@&#MAIN-TITLE@&#Thirty years of heterogeneous vehicle routing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The paper classifies heterogeneous vehicle routing problems (HVRPs).


                        
                        
                           
                           A comprehensive and up-to-date review of the existing work on HVRPs is presented.


                        
                        
                           
                           A comparative analysis of the metaheuristics proposed for HVRPs is provided.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing

Heterogeneous fleet

Fleet size and mix

Review

@&#ABSTRACT@&#


               
               
                  It has been around 30 years since the heterogeneous vehicle routing problem was introduced, and significant progress has since been made on this problem and its variants. The aim of this survey paper is to classify and review the literature on heterogeneous vehicle routing problems. The paper also presents a comparative analysis of the metaheuristic algorithms that have been proposed for these problems.
               
            

@&#INTRODUCTION@&#

In the classical Vehicle Routing Problem (VRP) introduced by Dantzig and Ramser (1959), the aim is to determine an optimal routing plan for a fleet of homogeneous vehicles to serve a set of customers, such that each vehicle route starts and ends at the depot, each customer is visited once by one vehicle, and some side constraints are satisfied. There exists a rich literature on the VRP and its variants, see, e.g., the surveys by Cordeau, Laporte, Savelsbergh, Vigo, Barnhart, and Laporte (2007) and Laporte (2009), and the books by Golden, Raghavan, and Wasil (2008) and Toth and Vigo (2014).

In most practical distribution problems, customer demands are served by means of a heterogeneous fleet of vehicles (see, e.g., Hoff, Andersson, Christiansen, Hasle, & Løkketangen, 2010; FedEx, 2015; TNT, 2015). Fleet dimensioning or composition is a common problem in industry and the trade-off between owning and keeping a fleet and subcontracting transportation is a challenging decision for companies. Fleet dimensioning decisions predominantly involve choosing the number and types of vehicles to be used, where the latter choice is often characterized by vehicle capacities. These decisions are affected by several market variables such as transportation rates, transportation costs and expected demand.

The extension of the VRP in which one must additionally decide on the fleet composition is known as the Heterogeneous Vehicle Routing Problem (HVRP). HVRPs are rooted in the seminal paper of Golden, Assad, Levy, and Gheysens (1984) published some 30 years ago and have recently evolved into a rich research area. There have also been several classifications of the associated literature from different perspectives. Baldacci, Battarra, and Vigo (2008) provided a general overview of papers with a particular focus on lower bounding techniques and heuristics. The authors also compared the performance of existing heuristics described until 2008 on benchmark instances. Baldacci, Toth, and Vigo (2010a) presented a review of exact algorithms and a comparison of their computational performance on the capacitated VRP and HVRPs, while Hoff et al. (2010) reviewed several industrial aspects of combined fleet composition and routing in maritime and road-based transportation. More recently, Irnich, Schneider, and Vigo (2014) briefly reviewed papers on HVRPs published from 2008 to 2014.

This paper makes three main contributions. The first is to classify heterogeneous vehicle routing problems. The second is to present a comprehensive and up-to-date review of the existing studies. The third is to comparatively analyze the performance of the state-of-the-art metaheuristic algorithms. Our review differs from the previous ones by including references that have appeared since 2008, by comparing heuristic algorithms, and by including industrial applications and case studies.

The remainder of this paper is structured as follows. The HVRPs and its variants are described and classified in Section 2. Extended reviews of the three main problem types, namely the Fleet Size and Mix Vehicle Routing Problem, the Heterogeneous Fixed Fleet Vehicle Routing Problem and the Fleet Size and Mix Vehicle Routing Problem with Time Windows are presented in Sections 3–5, respectively. Reviews of the other variants, extensions and case studies are presented in Sections 6 and 7. A tabulated summary of the literature and comparisons of the state-of-the-art heuristic algorithms are provided in Section 8. The paper closes with some concluding remarks and future research directions in Section 9.

We first define and classify the variants of HVRPs in Section 2.1, and then present three mathematical formulations in Section 2.2.

HVRPs generally consider a limited or an unlimited fleet of capacitated vehicles, where each vehicle has a fixed cost, in order to serve a set of customers with known demands. These problems consist of determining the fleet composition and vehicle routes, such that the classical VRP constraints are satisfied. Two major HVRPs are the Fleet Size and Mix Vehicle Routing Problem (FSM
                           1
                        
                        
                           1
                           Traditionally, the Fleet Size and Mix Vehicle Routing Problem has been abbreviated as FSMVRP, and its counterpart with time windows as FSMVRPTW. A similar convention has been adopted for the Heterogeneous Fixed Fleet Vehicle Routing Problem, by using HFFVRP and HFFVRPTW to denote its versions without and with time windows, respectively. In our view, some of these abbreviations are excessively long and defy the purpose of using shorthand notation. Hence we introduce shorter and simpler abbreviations in this paper.
                        ) introduced by Golden et al. (1984) which works with an unlimited heterogeneous fleet, and the Heterogeneous Fixed Fleet Vehicle Routing Problem (HF) introduced by Taillard (1999) in which the fleet is predetermined. Other variants of the FSM and the HF also exist. In what follows, we will classify the main variants with respect to two criteria: (i) objectives and (ii) presence or absence of time window constraints. We will also mention other HVRP variants and extensions.

The objective of both the FSM and the HF is to minimize a total cost function which includes fixed (F) and variable (V) vehicle costs. We now differentiate between five important variants: 1) the FSM with fixed and variable vehicle costs, denoted by FSM(F, V), introduced by Ferland and Michelon (1988); 2) the FSM with fixed vehicle costs only, denoted FSM(F), introduced by Golden et al. (1984); 3) the FSM with variable vehicle costs only, denoted by FSM(V), introduced by Taillard (1999); 4) the HF with fixed and variable vehicle costs, denoted by HF(F, V), introduced by Li, Golden, and Wasil (2007); 5) the HF with variable vehicle costs only, denoted by HF(V), introduced by Taillard (1999).

Two natural extensions of the FSM and HF arise when time window constraints are imposed on the start of service at each customer location. These problems are denoted by FSMTW and HFTW, respectively. In these extensions, two measures are used to compute the total cost to be minimized: 1) The first is based on the en-route time (T) which is the sum of the fixed vehicle cost and the trip duration but excludes the service time. In this case, service times are used only to check route feasibility and for performing adjustments to the departure time from the depot in order to minimize pre-service waiting times; 2) The second cost measure is based on distance (D) and consists of the fixed vehicle cost and the distance traveled by the vehicle, as is the case in the standard VRP with Time Windows (VRPTW) (Solomon, 1987).

The FSM and HF, combined with the two objectives above, give rise to four problem types: 1) the FSMTW with objective T, denoted by FSMTW(T), introduced by Liu and Shen (1999b); 2) the FSMTW with objective D, denoted by FSMTW(D), introduced by Bräysy, Dullaert, Hasle, Mester, and Gendreau (2008); 3) the HFTW with objective T, denoted by HFTW(T), introduced by Paraskevopoulos, Repoussis, Tarantilis, Ioannou, and Prastacos (2008); 4) the HFTW with objective D, denoted by HFTW(D), recently introduced by Koç, Bektaş, Jabali, and Laporte (2015).

More involved variants of the FSM or of the HF have been defined, including those with multiple depots (see Dondo & Cerdá, 2007; Bettinelli, Ceselli, & Righini, 2011, 2014). Other extensions include stochastic demand (Teodorović, Krčmar-Nozić, & Pavković, 1995), pickups and deliveries (Irnich, 2000; Qu & Bard, 2014), multi-trips (Prins, 2002; Seixas & Mendes, 2013), the use of external carriers (Chu, 2005; Potvin & Naud, 2011), backhauls (Belmecheri, Prins, Yalaoui, & Amodeo, 2013; Salhi, Wassan, & Hajarat, 2013), open routes (Li, Leung, & Tian, 2012), overloads (Kritikos & Ioannou, 2013), site-dependencies (Chao, Golden, & Wasil, 1999; Nag, Golden, & Assad, 1988), multi-vehicle task assignment (Franceschelli, Rosa, Seatzu, & Bullo, 2013), green routing (Juan, Goentzel, & Bektaş, 2014; Koç, Bektaş, Jabali, & Laporte, 2014), single and double container loads (Lai, Crainic, Di Francesco, & Zuddas, 2013), two-dimensional loading (Dominguez, Juan, Barrios, Faulin, & Agustin, 2014; Leung, Zhang, Zhang, Hua, & Lim, 2013), time-dependencies (Afshar-Nadjafi & Afshar-Nadjafi, 2014), multi-compartments (Wang, Ji, & Chiu, 2014), multiple stacks (Iori & Riera-Ledesma, 2015) and collection depot (Yao, Yu, Hu, Gao, & Zhang, 2015).

We now present three formulations for the HVRP, two based on commodity flows and one based on set partitioning. The common notations of all three formulations are as follows. Each customer i has a non-negative demand qi
                        . Let 
                           
                              H
                              =
                              {
                              1
                              ,
                              …
                              ,
                              k
                              }
                           
                         be the set of available vehicle types. Let th
                         and Qh
                         denote the fixed vehicle cost and the capacity of vehicle of type 
                           
                              h
                              ∈
                              H
                              ,
                           
                         respectively. Let mh
                         be the available number of vehicles of type h.

The HVRP is modeled on a complete graph 
                              
                                 G
                                 =
                                 (
                                 N
                                 ,
                                 A
                                 )
                                 ,
                              
                            where 
                              
                                 N
                                 =
                                 {
                                 0
                                 ,
                                 …
                                 ,
                                 n
                                 }
                              
                            is the set of nodes, node 0 corresponds to the depot, and 
                              
                                 A
                                 =
                                 {
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 :
                                 0
                                 ≤
                                 i
                                 ,
                                 j
                                 ≤
                                 n
                                 ,
                                 i
                                 ≠
                                 j
                                 }
                              
                            denote the set of arcs. The customer set is 
                              
                                 
                                    N
                                    0
                                 
                                 
                                    =
                                    N
                                    ∖
                                    
                                       {
                                       0
                                       }
                                    
                                 
                              
                           . Let 
                              
                                 c
                                 
                                    i
                                    j
                                 
                                 h
                              
                            be the travel cost on arc 
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 A
                              
                            by a vehicle of type h. Furthermore, let 
                              
                                 f
                                 
                                    i
                                    j
                                 
                                 h
                              
                            be the amount of commodity transported on arc 
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 A
                              
                            by a vehicle of type h and let the binary variable 
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 h
                              
                            be equal to 1 if and only if a vehicle of type 
                              
                                 h
                                 ∈
                                 H
                              
                            travels on arc 
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 A
                              
                           .

The single-commodity flow formulation of Baldacci et al. (2008) for the HVRP is as follows:

                              
                                 (2.1)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Minimize
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      
                                                         N
                                                         0
                                                      
                                                   
                                                
                                                
                                                   t
                                                   h
                                                
                                                
                                                   x
                                                   
                                                      0
                                                      j
                                                   
                                                   h
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ∈
                                                      A
                                                   
                                                
                                                
                                                   c
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.2)
                                 
                                    
                                       
                                          
                                             
                                                subject
                                                
                                                to
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      
                                                         N
                                                         0
                                                      
                                                   
                                                
                                                
                                                   x
                                                   
                                                      0
                                                      j
                                                   
                                                   h
                                                
                                                ≤
                                                
                                                   m
                                                   h
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                h
                                                ∈
                                                H
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.3)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                =
                                                1
                                             
                                          
                                          
                                          
                                             
                                                
                                                i
                                                ∈
                                                
                                                   N
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.4)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                =
                                                1
                                             
                                          
                                          
                                          
                                             
                                                
                                                j
                                                ∈
                                                
                                                   N
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.5)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   f
                                                   
                                                      j
                                                      i
                                                   
                                                   h
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   f
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                =
                                                
                                                   q
                                                   i
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                i
                                                ∈
                                                
                                                   N
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.6)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   q
                                                   j
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                ≤
                                                
                                                   f
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                ≤
                                                
                                                   (
                                                   
                                                      Q
                                                      h
                                                   
                                                   −
                                                   
                                                      q
                                                      i
                                                   
                                                   )
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                A
                                                ,
                                                h
                                                ∈
                                                H
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.7)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   1
                                                   }
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                A
                                                ,
                                                h
                                                ∈
                                                H
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.8)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   f
                                                   
                                                      i
                                                      j
                                                   
                                                   h
                                                
                                                ≥
                                                0
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                A
                                                ,
                                                h
                                                ∈
                                                H
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           In this formulation, the objective function (2.1) minimizes the sum of vehicle fixed costs and the total travel cost. The maximum number of available vehicles of each type is imposed by constraints (2.2). In the case of the FSM, an unlimited number of vehicles for each vehicle type h (
                              
                                 
                                    m
                                    h
                                 
                                 =
                                 
                                    |
                                    
                                       N
                                       0
                                    
                                    |
                                 
                              
                           ) are available, which effectively renders constraints (2.2) redundant. Constraints (2.3) and (2.4) ensure that each customer is visited exactly once. Constraints (2.5) and (2.6) define the commodity flows. Finally, constraints (2.7) and (2.8) enforce the integrality and non-negativity restrictions on the variables.

In the two-commodity flow formulation of Baldacci, Battarra, and Vigo (2009) for the FSM(F), the vehicle types are undominated and ordered so that 
                              
                                 
                                    Q
                                    1
                                 
                                 <
                                 
                                    Q
                                    2
                                 
                                 <
                                 …
                                 <
                                 
                                    Q
                                    k
                                 
                              
                            and 
                              
                                 
                                    t
                                    1
                                 
                                 <
                                 
                                    t
                                    2
                                 
                                 <
                                 …
                                 <
                                 
                                    t
                                    k
                                 
                              
                           . An undirected complete graph 
                              
                                 
                                    G
                                    ^
                                 
                                 =
                                 
                                    (
                                    
                                       V
                                       ^
                                    
                                    ,
                                    
                                       E
                                       ^
                                    
                                    )
                                 
                              
                            is given, where 
                              
                                 
                                    V
                                    ^
                                 
                                 =
                                 
                                    {
                                    0
                                    ,
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    }
                                 
                              
                            is the set of 
                              
                                 n
                                 +
                                 1
                              
                            nodes and 
                              
                                 E
                                 ^
                              
                            is the set of edges. The node set 
                              
                                 V
                                 =
                                 
                                    V
                                    ^
                                 
                                 
                                    ∖
                                    
                                       {
                                       0
                                       }
                                    
                                 
                              
                            includes the n customers and node 0 represents the depot. Each edge 
                              
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ∈
                                 
                                    E
                                    ^
                                 
                              
                            is associated with a non-negative symmetric routing cost, cij
                           . Let 
                              
                                 G
                                 =
                                 (
                                 
                                    V
                                    ′
                                 
                                 ,
                                 E
                                 )
                              
                            be an undirected complete graph constructed from 
                              
                                 G
                                 ^
                              
                            as follows. The node set V′ includes the set of customer nodes V and 
                              
                                 h
                                 +
                                 1
                              
                            copies of the depot node: h origin depots, one for each vehicle type, and a common destination depot. In particular, 
                              
                                 
                                    V
                                    ′
                                 
                                 =
                                 V
                                 ∪
                                 K
                                 ∪
                                 
                                    {
                                    n
                                    +
                                    k
                                    +
                                    1
                                    }
                                 
                                 ,
                              
                            where 
                              
                                 K
                                 =
                                 {
                                 n
                                 +
                                 1
                                 ,
                                 n
                                 +
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 +
                                 k
                                 }
                              
                            is the set of origin depots, and node 
                              
                                 
                                    n
                                    ′
                                 
                                 =
                                 n
                                 +
                                 k
                                 +
                                 1
                              
                            is the destination depot. Let 
                              
                                 π
                                 (
                                 i
                                 )
                                 =
                                 i
                                 −
                                 n
                                 ,
                                 (
                                 i
                                 ∈
                                 K
                                 )
                                 ,
                              
                            be the vehicle type associated with node i. It is assumed that the cost matrix dij
                            is symmetric and that 
                              
                                 
                                    q
                                    i
                                 
                                 =
                                 0
                              
                            (i ∈ K ∪ {n′}). The cost of edges dij
                            in E is defined as follows: 1) 
                              
                                 
                                    d
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    t
                                    
                                       π
                                       (
                                       j
                                       )
                                    
                                 
                                 +
                                 
                                    c
                                    
                                       0
                                       i
                                    
                                 
                                 ,
                              
                            for qi
                            ≤ Q
                           
                              π(j), j ∈ K, i ∈ V; 2) 
                              
                                 
                                    d
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    c
                                    
                                       i
                                       j
                                    
                                 
                                 ,
                              
                            for 
                              
                                 
                                    q
                                    i
                                 
                                 +
                                 
                                    q
                                    j
                                 
                                 ≤
                                 
                                    Q
                                    h
                                 
                                 ,
                                 i
                                 ,
                                 j
                                 ∈
                                 V
                                 ,
                                 i
                                 <
                                 j
                              
                           ; 3) 
                              
                                 
                                    d
                                    
                                       i
                                       
                                          n
                                          ′
                                       
                                    
                                 
                                 =
                                 
                                    c
                                    
                                       0
                                       i
                                    
                                 
                                 ,
                              
                            for i ∈ V; 4) 
                              
                                 
                                    d
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 ∞
                                 ,
                              
                            otherwise.

Two flow variables yij
                            and yji
                            are associated with each edge (i, j) ∈ E. The flow variables yij
                            represent the vehicle load. The flow 
                              
                                 
                                    y
                                    
                                       j
                                       i
                                    
                                 
                                 =
                                 
                                    Q
                                    k
                                 
                                 −
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                              
                            represents the empty space on a vehicle of the largest type. The empty space on the vehicle of type h is represented by 
                              
                                 
                                    y
                                    
                                       j
                                       i
                                    
                                 
                                 −
                                 
                                    (
                                    
                                       Q
                                       k
                                    
                                    −
                                    
                                       Q
                                       h
                                    
                                    )
                                 
                              
                           . Furthermore, for each edge (i, j) ∈ E, let xij
                            be a binary variable, equal to 1 if and only edge (i, j) is in the solution. In addition, let 
                              
                                 S
                                 =
                                 {
                                 S
                                 :
                                 S
                                 ⊆
                                 V
                                 ,
                                 |
                                 S
                                 |
                                 ≥
                                 2
                                 }
                              
                           . Given a set 
                              
                                 S
                                 ∈
                                 S
                                 ,
                              
                            let δ(S) be the cutset defined by S (i.e., 
                              
                                 δ
                                 (
                                 S
                                 )
                                 =
                                 {
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 E
                                 :
                                 i
                                 ∈
                                 S
                                 ,
                                 j
                                 ∉
                                 S
                              
                            or i ∉ S, j ∈ S). Also, let 
                              
                                 q
                                 
                                    (
                                    S
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       S
                                    
                                 
                                 
                                    q
                                    i
                                 
                              
                            be the total demand of customers in S.

We now formally present the two-commodity flow formulation for the FSM(F):

                              
                                 (2.9)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Minimize
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ∈
                                                      E
                                                   
                                                
                                                
                                                   d
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.10)
                                 
                                    
                                       
                                          
                                             
                                                subject
                                                
                                                to
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      
                                                         V
                                                         ′
                                                      
                                                   
                                                
                                                
                                                   (
                                                   
                                                      y
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   −
                                                   
                                                      y
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                =
                                                2
                                                
                                                   q
                                                   i
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                i
                                                ∈
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.11)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      V
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                =
                                                q
                                                
                                                   (
                                                   V
                                                   )
                                                
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.12)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      V
                                                   
                                                
                                                
                                                   y
                                                   
                                                      j
                                                      
                                                         n
                                                         ′
                                                      
                                                   
                                                
                                                =
                                                0
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.13)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      {
                                                      i
                                                      ,
                                                      j
                                                      }
                                                      ∈
                                                      δ
                                                      (
                                                      b
                                                      )
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                =
                                                2
                                             
                                          
                                          
                                          
                                             
                                                
                                                ∀
                                                b
                                                ∈
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.14)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      V
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                =
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      V
                                                   
                                                
                                                
                                                   x
                                                   
                                                      j
                                                      
                                                         n
                                                         ′
                                                      
                                                   
                                                
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.15)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                +
                                                
                                                   y
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                =
                                                
                                                   Q
                                                   k
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.16)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      {
                                                      i
                                                      ,
                                                      j
                                                      }
                                                      ∈
                                                      δ
                                                      (
                                                      S
                                                      )
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ≥
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      V
                                                   
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                K
                                                ⊂
                                                S
                                                ,
                                                S
                                                ⊆
                                                K
                                                ∪
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.17)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ≤
                                                
                                                   Q
                                                   
                                                      π
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                i
                                                ∈
                                                K
                                                ,
                                                j
                                                ∈
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.18)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ≥
                                                0
                                                ,
                                                
                                                   y
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                ≥
                                                0
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.19)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   1
                                                   }
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                E
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           Constraints (2.10)–(2.12) and (2.18) define a feasible flow pattern. Constraints (2.12) guarantee that the inflow at node n′ is equal to 0. Constraints (2.13) ensure that any feasible solution must contain two edges incident to each customer. Constraints (2.14) impose that if 
                              
                                 p
                                 =
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       K
                                    
                                 
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       V
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                              
                            vehicles leave node set K, then exactly p vehicles must enter node n′. Constraints (2.15) define the relation among variables in a feasible solution. Constraints (2.16) forbid the presence of simple paths starting and ending at nodes in K. The capacity requirements for each vehicle are imposed by constraints (2.17). Finally, constraints (2.18) and (2.19) enforce the integrality and non-negativity restrictions on the variables.

The set partitioning formulation of Baldacci and Mingozzi (2009) works with an undirected graph 
                              
                                 G
                                 =
                                 (
                                 
                                    V
                                    ′
                                 
                                 ,
                                 E
                                 )
                                 ,
                              
                            where 
                              
                                 
                                    V
                                    ′
                                 
                                 =
                                 
                                    {
                                    0
                                    ,
                                    …
                                    ,
                                    n
                                    }
                                 
                              
                            is the set of 
                              
                                 n
                                 +
                                 1
                              
                            nodes and E is the set of edges. Node 0 represents the depot and node set 
                              
                                 V
                                 =
                                 
                                    V
                                    ′
                                 
                                 
                                    ∖
                                    
                                       {
                                       0
                                       }
                                    
                                 
                              
                            corresponds to n customers. A route 
                              
                                 R
                                 =
                                 (
                                 0
                                 ,
                                 
                                    i
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    i
                                    r
                                 
                                 ,
                                 0
                                 )
                              
                            performed by a vehicle of type h, is a simple cycle in G passing through the depot and customers 
                              
                                 {
                                 
                                    i
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    i
                                    r
                                 
                                 }
                                 ⊆
                                 V
                                 ,
                              
                            with r ≥ 1. Let ℜ
                              h
                            be the index set of all feasible routes of vehicle type 
                              
                                 h
                                 ∈
                                 H
                              
                            and let 
                              
                                 ℜ
                                 =
                                 
                                    ⋃
                                    
                                       h
                                       ∈
                                       H
                                    
                                 
                                 
                                    ℜ
                                    h
                                 
                              
                           . For each route ℓ ∈ ℜ
                              h
                            is associated a routing cost 
                              
                                 c
                                 
                                    ℓ
                                 
                                 h
                              
                           . Let 
                              
                                 
                                    ℜ
                                    i
                                    h
                                 
                                 ⊂
                                 
                                    ℜ
                                    h
                                 
                              
                            be the index subset of the routes of a vehicle of type h covering customer i ∈ V. Let 
                              
                                 R
                                 
                                    ℓ
                                 
                                 h
                              
                            be the subset of customers visited by route ℓ ∈ ℜ
                              h
                           . Furthermore, let 
                              
                                 y
                                 
                                    ℓ
                                 
                                 h
                              
                            be a binary variable that is equal to 1 if and only if route ℓ ∈ ℜ
                              h
                            is chosen in the solution.

We now formally present the set partitioning formulation:

                              
                                 (2.20)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Minimize
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      ℓ
                                                      ∈
                                                      
                                                         ℜ
                                                         h
                                                      
                                                   
                                                
                                                
                                                   (
                                                   
                                                      t
                                                      h
                                                   
                                                   +
                                                   
                                                      c
                                                      
                                                         ℓ
                                                      
                                                      h
                                                   
                                                   )
                                                
                                                
                                                   y
                                                   
                                                      ℓ
                                                   
                                                   h
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.21)
                                 
                                    
                                       
                                          
                                             
                                                subject
                                                
                                                to
                                                
                                                
                                                   ∑
                                                   
                                                      h
                                                      ∈
                                                      H
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      ℓ
                                                      ∈
                                                      
                                                         ℜ
                                                         i
                                                         h
                                                      
                                                   
                                                
                                                
                                                   y
                                                   
                                                      ℓ
                                                   
                                                   h
                                                
                                                =
                                                1
                                             
                                          
                                          
                                          
                                             
                                                
                                                i
                                                ∈
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.22)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      ℓ
                                                      ∈
                                                      
                                                         ℜ
                                                         h
                                                      
                                                   
                                                
                                                
                                                   y
                                                   
                                                      ℓ
                                                   
                                                   h
                                                
                                                ≤
                                                
                                                   m
                                                   h
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                h
                                                ∈
                                                H
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2.23)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   y
                                                   
                                                      ℓ
                                                   
                                                   h
                                                
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   1
                                                   }
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                ℓ
                                                ∈
                                                
                                                   ℜ
                                                   h
                                                
                                                ,
                                                h
                                                ∈
                                                H
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           In this formulation, the objective function (2.20) minimizes the sum of all vehicle fixed costs and total routing cost. Constraints (2.21) specify that each customer 
                              
                                 i
                                 ∈
                                 
                                    N
                                    0
                                 
                              
                            must be covered once by one route. Constraints (2.22) impose the upper bound on the number of vehicles of each type that can be used (
                              
                                 
                                    m
                                    h
                                 
                                 =
                                 
                                    |
                                    V
                                    |
                                 
                              
                           ). Finally, constraints (2.23) enforce the integrality restrictions on the variables.

This section reviews the standard FSM and unifies the studies pertaining both the FSM and the HF. We first review lower bound and exact algorithms in Section 3.1, then continuous approximation models in Section 3.2, and finally heuristics in Section 3.3.

Several studies describe lower bounds and exact algorithms for the FSM. Yaman (2006) developed formulations and valid inequalities for this problem and proposed formulations, four of which are based on the Miller, Tucker, and Zemlin (1960) subtour elimination constraints for the Traveling Salesman Problem (TSP), and two are based on commodity flows. The author compared the linear programming bounds of these formulations, derived valid inequalities and lifted several constraints to improve the lower bounds. Her results revealed that the solutions obtained from the strongest formulations were of good quality, and yielded a maximum optimality gap of 3.28 percent. Baldacci et al. (2009) later described a mixed integer programming formulation based on two-commodity flows and developed two new classes of valid inequalities for the FSM. These inequalities, which were new covering-type and fleet-dependent capacity inequalities, aimed to increase the lower bounds. The authors showed that their model was quite compact when compared with previous formulations, and that its linear relaxation had a reasonable quality. Fleet-dependent capacity inequalities were able to improve the lower bound by about 5 percent on average, and the new covering inequalities improved it by about 2.5 percent. Pessoa, Uchoa, and Poggi de Aragão (2009) presented a robust branch-cut-and-price algorithm for the FSM. Q-routes were associated with the columns, which are relaxations of capacitated elementary routes that make the pricing problem solvable in pseudo-polynomial time. These authors also proposed new families of cuts which were expressed on a large set of variables and did not increase the complexity of the pricing subproblem. The results showed that instances up to 75 nodes can be solved to optimality, a significant improvement with respect to previous exact algorithms.

Three unified exact algorithms are available to solve both the FSM and the HF. Choi and Tcha (2007) developed a column generation algorithm and solved its linear programming relaxation by column generation. They modified several dynamic programming algorithms for the classical VRP to efficiently generate feasible columns and then applied a branch-and-bound procedure to obtain an integer solution. Their results confirmed the superiority of this method over existing algorithms, both in terms of solution quality and computation time. Baldacci and Mingozzi (2009) later introduced a unified exact algorithm based on the set partitioning formulation. Three types of bounding procedures were used, based on the LP-relaxation and on Lagrangean relaxation. The new lower bounds were tighter than all previously known lower bounds. The last exact algorithm for the FSM and the HF was, to our knowledge, presented by Baldacci, Bartolini, Mingozzi, and Roberti (2010a). It combines several dual ascent procedures to generate a near-optimal dual solution of the set partitioning model and it adds valid inequalities to the set partitioning formulation within a column-and-cut generation algorithm to close the integrality gap left by the dual ascent procedures. The final dual solution is then defined to generate a reduced problem containing all optimal integer solutions. This algorithm outperformed all other available exact algorithms.


                        Jabali, Gendreau, and Laporte (2012) developed a continuous approximation model for the FSM. Their model builds upon the work of Daganzo (1984a, 1984b) and of Newell and Daganzo (1986), where the latter introduced a continuous approximation model for the VRP. This model can be used at an aggregate level to analyze capacity scenarios and various cost scenarios. The authors incorporated mixed fleet considerations to the model of Newell and Daganzo (1986) in which the vehicle routes are based on a partition of a ring-radial region into zones, each of which is serviced by a single vehicle. They presented a mixed integer non-linear formulation and developed several upper and lower bounding procedures for it. The performance of the model was tested on several instances. Computational results showed that the two proposed upper bounding procedures were more reliable than solving the original model by an off-the-shelf software. They also demonstrated the sensitivity of the models with respect to several parameters such as the vehicle variable and fixed costs, the route duration limit and customer density.

This section presents a review of heuristic methods for the FSM. We first review population search heuristics in Section 3.3.1, then tabu search heuristics in Section 3.3.2, and finally other heuristics in Section 3.3.3.

In contrast to the VRP, only a few population search heuristics have been developed for the FSM. Ochi, Vianna, Drummond, and Victor (1998a) described a hybrid metaheuristic which integrates genetic algorithms and scatter search with a decomposition-into-petals procedure. Ochi, Vianna, Drummond, and Victor (1998b) later used the same idea within parallel genetic algorithms. Several results of Taillard (1999) were improved with this method. However, Ochi et al. (1998a, 1998b) did not report the exact solution values. Lima, Goldbarg, and Goldbarg (2004) proposed a memetic algorithm which is a hybrid of a genetic algorithm and of the simulated annealing heuristic of Osman (1993), and was able to find eight new best-known solutions for the Golden et al. (1984) instances. Another genetic algorithm was developed by Liu, Huang, and Ma (2009) who used several heuristics to generate the initial solution. Out of the 20 instances of Golden et al. (1984), 14 solutions were matched and one was improved when compared with existing algorithms such as those of Brandão (2009) and Choi and Tcha (2007).

Several population heuristics for the FSM and the HF are based on variants of the split procedure of Prins (2004). Prins (2009) developed two memetic algorithms hybridized with a local search, based on chromosomes encoded as giant tours and without trip delimiters. The methods optimally split giant tours into feasible routes and assigns a suitable vehicle type to them. The method creates new solutions from a single solution at each iteration by performing mutations and local search operations. The results revealed that the proposed method was able to efficiently handle the problems. The authors also generated a set of HF instances based on real distances from French counties and ranging from 50 to more than 250 customers. In a recent study, Vidal, Crainic, Gendreau, and Prins (2014) introduced a genetic algorithm using a unified component based solution framework for different variants of the VRPs, including the FSM, the FSMTW(T) and the FSMTW(D). The authors used problem-independent local search operators such as crossover, split and a number of diversification mechanisms. A unified route-evaluation methodology was developed to increase the effectiveness of the local search. This methodology is primarily based on two procedures: move evaluations as a concatenation of known subsequences and information preprocessing on subsequences, as well as other well-known procedures. Excellent results were obtained on the FSM, the FSMTW(T) and the FSMTW(D), which will be presented in more detail in Section 8.2.3.

The first tabu search heuristic for the FSM is probably that of Osman, Salhi, Rayward-Smith, Osman, Reeves, and Smith (1996) who modified the route perturbation procedure of Salhi and Rand (1993). The existing results for the benchmark instances were improved with the proposed method. Gendreau, Laporte, Musaraganyi, and Taillard (1999) later developed a tabu search heuristic which embedded the generalized insertion heuristic of Gendreau, Hertz, and Laporte (1992) and the adaptive memory procedure of Rochat and Taillard (1995). Their results were compared with those of Taillard (1999) and confirmed the superiority of their algorithm. Wassan and Osman (2002) presented a reactive tabu search heuristic in which several neighborhoods and special data structures were integrated and contained an intensification phase to trigger switches between simple moves. Several deterministic moves were introduced to diversify the search. The authors also proposed special data structures to explore various neighborhoods. The method was capable of generating a number of best-known solutions. Another tabu search heuristic was developed by Lee, Kim, Kang, and Kim (2008) which applied a modified sweeping method with set partitioning on a giant tour was used to create initial solutions. An optimal vehicle assignment was performed for the set of routes, whenever the algorithm identified a new solution. Competitive results were obtained on the Golden et al. (1984) instances and several new best-known solutions were found. Finally, Brandão (2009) proposed a tabu search algorithm in which three procedures are used to generate the initial solutions, and three moves are defined for the neighborhoods: single insertion, double insertion and swap. The algorithm also used intensification and diversification procedures during the search. The proposed method was able to obtain high quality solutions, including five new best-known solutions.

Several versions of constructive heuristics and many other heuristics have been proposed for the FSM over the last 30 years. Golden et al. (1984) formally described and formulated the FSM. They also developed some heuristics based on the Clarke and Wright (1964) savings algorithm and on the partitioning of a giant tour into routes suitable for various vehicle types, using the Or (1976) improvement mechanism for the TSP. They also described a procedure to calculate a lower bound. They applied the Fisher and Jaikumar (1981) heuristic to solve the generalized assignment problem for the assignment of customers to vehicles. Gheysens, Golden, and Assad (1984) used the Golden et al. (1984) lower bounding procedure to create a new heuristic. Their method first generated a fleet mix and then solved the resulting problem as a VRP. In a later study, Gheysens, Golden, and Assad (1986) showed that the proposed lower bound based heuristic of Gheysens et al. (1984), performed in general better than the heuristics of Golden et al. (1984). However, computation times were much larger and finding a feasible solution was not guaranteed. Desrochers and Verhoog (1991) developed an improved savings heuristic which is a matching based savings algorithm using successive route merging procedures. The method selects the best solution by solving a weighted matching problem at each iteration. Competitive results were obtained with respect to previous studies. Salhi, Sari, Saidi, and Touati (1992) presented a mathematical formulation and described a perturbation based heuristic which was tested on 20 benchmark instances and yielded several best-known solutions. Salhi and Rand (1993) described a more advanced constructive heuristic which starts from a solution obtained by solving a VRP with a single vehicle capacity, selected among the available ones. Several procedures are then iteratively applied to improve it which is achieved by changing the vehicle type assigned to each route, merging or removing routes and moving customers from one route to another. On average, the proposed method performed better than the earlier algorithms. Renaud and Boctor (2002) proposed a sweep-based heuristic which extended the work of Renaud, Boctor, and Laporte (1996). The algorithm first creates a large number of routes that can be served by one or two vehicles and a set partitioning problem is then solved optimally, in polynomial time, to select the routes and vehicles to use. The method outperformed the existing algorithms and yielded competitive results with respect to tabu search. Han and Cho (2002) presented another constructive heuristic algorithm which uses generic intensification and diversification procedures. The method incorporates several mechanisms from deterministic variants of simulated annealing like threshold accepting and the great deluge algorithm (Dueck, 1993). The method performed well on the Golden et al. (1984) small-size instances, but was dominated by the heuristics of Taillard (1999) and Gendreau et al. (1999) on the large-size instances.

The FSM and the HF are simultaneously considered in several papers. The earliest such work is by Taillard (1999) who developed a heuristic column generation algorithm. His method solved a homogeneous VRP by means of the Rochat and Taillard (1995) adaptive memory procedure for each of the vehicle type, where it was assumed that the number of available vehicles is unlimited. This heuristic outperformed that of Osman et al. (1996) on the eight largest FSM instances. The method was also tested for the HF on new benchmark instances. Imran, Salhi, and Wassan (2009) later adapted a variable neighborhood search algorithm for the FSM and the HF. Several additional features were added to the method: an adaptation of local search procedures including Dijkstra’s algorithm, a diversification procedure, and the use of a dummy empty route during the search. This heuristic yielded competitive results on benchmark instances and was able to find several new best-knowns solutions. A hybrid algorithm that considered both problems was later proposed by Subramanian, Penna, Uchoa, and Ochi (2012). It includes an iterated local search (ILS)-based heuristic to generate columns in a set partitioning formulation. Competitive results and new best-known solutions were obtained on benchmark instances which include large-size instances involving up to 360 customers. The same authors presented improved results by integrating the ILS with a variable neighborhood descent procedure and with a random neighborhood ordering scheme in the local search phase (Penna, Subramanian, & Ochi, 2013). The performance of the method was tested on 52 benchmark instances with up to 100 customers. Four new best-known solutions were obtained and 42 best-known results were matched.

To our knowledge, no exact algorithm has specifically been designed for the standard HF. However, several exact algorithms jointly consider the FSM and the HF. We therefore focus exclusively on heuristics described for the HF. We first review tabu search heuristics in Section 4.1, and then other heuristics in Section 4.2.


                        Euchi and Chabchoub (2010) designed a hybrid tabu search embedded within an adaptive memory heuristic for the HF. This algorithm generates three initial solutions, and at each iteration the current solution is improved by several constructive methods. The results obtained on benchmark instances were competitive in terms of solution quality and computation time. Another tabu search algorithm was proposed by Brandão (2011). The algorithm is initiated with a giant tour over all customers which is then partitioned into routes that are later improved using four types of moves. Four new best-known solutions were obtained on benchmark instances.


                        Tarantilis, Kiranoudis, and Vassiliadis (2003) proposed a list-based threshold accepting metaheuristic for the HF which explores the solution space to identify promising regions. The method was competitive on benchmark instances and could find several new best-known solutions. In a later study, the same authors developed a backtracking adaptive threshold accepting algorithm (Tarantilis, Kiranoudis, & Vassiliadis, 2004), which generalizes that of Tarantilis and Kiranoudis (2001). The main difference between this method and the standard threshold accepting heuristic is that the value of the threshold does not always decrease but can also increase. New best solutions and better results were obtained compared with Taillard (1999). The heuristic of Gencer, Top, and Aydogan (2006) is based on the principle of first clustering and then routing and considers the possibility of leasing vehicles when the size of the fleet is insufficient. On average, the algorithm provided lower quality solutions than that Tarantilis et al. (2004) but found better solutions in terms of vehicle capacity utilization. Li et al. (2007) adapted their previous record-to-record travel algorithm (Li, Golden, & Wasil, 2005) to solve the HF. The algorithm is a deterministic variant of a simulated annealing heuristic and produced new best-known solutions. Li, Tian, and Aneja (2010) later developed a multistart adaptive memory programming and path relinking heuristic. This algorithm constructs multiple provisional solutions which are then improved through a modified tabu search at each iteration. New best-known solutions were found on two benchmark instances, and for the others the method found solutions of a quality comparable to that of previous algorithms. Liu (2013) developed a hybrid population heuristic with embedded local search mechanisms to diversify the population. Competitive results were obtained within short computation times. Naji-Azimi and Salari (2013) solved the HF by developing a mathematical formulation based heuristic algorithm. The method applies a mechanism in which the initial solution is destroyed and repaired by solving a mathematical model to optimality. Three new best-known solutions were obtained on benchmark instances.

We now review the existing literature on the FSMTW. This variant of the FSM has received considerable attention, which is the reason why it is presented in a separate section. To the best of our knowledge, apart from a simple branch-and-bound scheme (Ferland & Michelon, 1988), no exact algorithm has yet been proposed for the standard FSMTW. We first review tabu search heuristics in Section 5.1, followed by other heuristics in Section 5.2.


                        Paraskevopoulos et al. (2008) developed a two-phase heuristic based on a hybridized tabu search algorithm for the FSMTW(T) and the HFTW(T). In the first phase, initial solutions are generated by a semi-parallel construction heuristic which is followed by a sophisticated ejection chain procedure in the second phase. The quality of the solutions is further improved using variable neighborhood tabu search. To diversify the solutions, the authors describe a specialized shaking mechanism. Computational experiments conducted on the FSMTW benchmark data sets allowed the identification of better solutions than those reported by Dell’Amico, Monaci, Pagani, and Vigo (2007), by about 3.4 percent on average. New benchmark results for the HFTW(T) were also presented for the first time.


                        Ferland and Michelon (1988) showed that the VRPTW can be extended to the heterogeneous VRPTW. They presented three heuristic algorithms: discrete approximation, assignment and matching, as well as two simple branch-and-bound procedures. Liu and Shen (1999b) described a heuristic for the FSMTW(T) which starts by determining an initial solution through an adaptation of the Clarke and Wright (1964) savings algorithm previously presented by Golden et al. (1984). The second stage improves the initial solution by moving customers by means of parallel insertions. The algorithm was tested on a set of 168 FSMTW benchmark instances derived from the set of Solomon (1987) for the VRPTW and was also tested on the standard FSM. Dullaert, Janssens, Sörensen, and Vernimmen (2002) described a sequential construction algorithm for the FSMTW(T). The algorithm includes three insertion-based heuristics which are extensions of the I1 heuristic of Solomon (1987) and of the Golden et al. (1984) vehicle insertion saving method. Another paper on the FSMTW(T) is that of Dell’Amico et al. (2007) who developed a multi-start parallel regret construction heuristic embedded within a ruin-and-recreate metaheuristic. The proposed heuristic allows for the combination of routes into longer routes requiring a larger vehicle, and the splitting of routes into smaller ones. It outperformed previously published heuristics. Repoussis and Tarantilis (2010) later developed an adaptive memory programming algorithm for the FSMTW(T) which includes a probabilistic construction heuristic, a diversification mechanism, a short-term memory tabu search heuristic with edge-exchange neighborhoods, speed-up procedures, and an iterated tabu search procedure working with a perturbation mechanism. Learning and several frequency-based long term mechanisms are also embedded into the algorithm. This method outperformed those presented in previous studies and improved upon 80 best-known solutions.


                        Bräysy et al. (2008) presented a three-phase multi-restart deterministic annealing metaheuristic for the FSMTW(T) and the FSMTW(D). In this algorithm, solutions are created by Clarke and Wright (1964) savings algorithm and by combining several diversification strategies. The second stage aims to reduce the number of routes in the initial solution by means of a greedy local search procedure. Four local search operators are embedded within a deterministic annealing framework to guide the improvement process in the final stage. The algorithm outperformed the earlier results on the FSMTW(T). New benchmark results on the FSMTW(D) were also presented. In a later study, Bräysy, Porkka, Dullaert, Repoussis, and Tarantilis (2009) described a hybrid metaheuristic algorithm for large-scale FSMTW(D) instances. They combined the well-known threshold acceptance heuristic with a guided local search metaheuristic having several search limitation strategies. Computational experiments yielded better results on the FSMTW(D) instances compared to those of Bräysy et al. (2008), and this algorithm was then used to solve a further 600 new FSMTW(D) benchmark instances with up to 1000 customers.


                        Prieto, Bellas, Caamaño, and Duro (2011) described an asynchronous situated coevolution algorithm for the FSMTW(D) which uses a situated coevolution process inspired from the artificial life simulations. The authors showed that their open-ended evolutionary simulation which includes an improvement procedure yields good results. The performance was only tested on one instance with 20 nodes and 50 ships, not part of the standard benchmark FSMTW(D) instances, and the solution consists of a self-organized fleet of heterogeneous ships which satisfies the problem constraints and the market requirements.

More recently, Koç et al. (2015) presented a unified heuristic called a hybrid evolutionary algorithm (HEA) for the FSMTW(T), the FSMTW(D), the HFTW(T) and the HFTW(D), and were the ones who introduced the last variant. The HEA combines several metaheuristics principles such as heterogeneous adaptive large scale neighborhood search and population search. The authors integrated within the HEA an innovative intensification strategy on elite solutions, a new diversification scheme based on the regeneration and the mutation procedures of solutions, and developed an advanced version of the split algorithm of Prins (2009) to determine the best fleet mix for a set of routes. Extensive computational experiments on benchmark instances showed that the HEA is highly effective on all four problems.

Both the FSM and the HF have given rise to a multitude of extensions which have received particular attention in the last 5 years. In this section, we review such variants and extensions, which are classified in Fig. 1
                     .

The Multi-Depot FSM was introduced by Salhi and Sari (1997) who proposed a three-level composite heuristic for it. An initial solution is first generated, a composite heuristic is executed to improve the quality of the solution, and an extension of the composite heuristic which considers all depots simultaneously is then applied. Several procedures of the algorithm are taken from Salhi and Rand (1993). Salhi, Imran, and Wassan (2014) later considered the same problem by proposing a mixed integer linear programming formulation with new valid inequalities and several variable settings. Furthermore, the authors developed a variable neighborhood search heuristic equipped with a scheme for determining borderline customers and combined with a local search method based on a multi-level heuristic. The heuristic uses Dijkstra’s algorithm to optimally partition the routes. It includes a diversification procedure and also contains a mechanism to aggregate the routes from different depots and then to disaggregate them and assign them to different depots. In total, 23 new best solutions out of the 26 benchmark instances were obtained, which makes this heuristic highly competitive.

Several metaheuristics were developed for the Multi-Depot FSMTW. Thus Dondo and Cerdá (2007) proposed a mathematical model and a three-phase heuristic. The first phase determines a set of cost effective clusters and the second phase assigns clusters to vehicles and sequences them on each tour by using a cluster-based mathematical model. In the final phase, customer orders and scheduling of vehicle arrival times are optimized by solving a mathematical model. Computational experiments were conducted on adapted classical Solomon (1987) VRPTW instances with up to 100 nodes. In another study, Xu, Wang, and Yang (2012) described a mathematical formulation and implemented a variable neighborhood search algorithm. The authors designed a hybrid insert and exchange operator for the shaking mechanism and implemented a best-improvement strategy to increase solution quality and decrease the running time. No computational experiments were conducted on the FSMTW since the authors only tested their algorithm on the classical Golden et al. (1984) FSM instances.


                        Bettinelli et al. (2011) developed a branch-and-cut-and-price algorithm for the Multi-Depot HFTW. They investigated several mixed strategies, such as initializing the restricted master problem and repairing the columns in the restricted master problem by removing cycles. Their results suggest that the number of different vehicle types, as opposed to the presence of multiple depots, makes the problem more difficult to solve. The tightness of the time windows was also found to influence the difficulty of the problem.


                        Irnich (2000) introduced the Multi-Depot Pickup and Delivery FSMTW with a single hub. In this problem, all routes have to visit the hub once, and are cycles that start from and end at the same depot. The author developed a network model which computes lower bounds and solves a set partitioning problem.


                        Afshar-Nadjafi and Afshar-Nadjafi (2014) studied a Time-Dependent Multi-Depot HFTW and proposed a mathematical formulation along with a constructive heuristic with three local search operators. Their results were compared on 180 test instances and indicate that the proposed heuristic was able to identify solutions within 0.3 percent of optimality for small size instances


                        Levy, Sundar, and Rathinam (2014) introduced the Multi-Depot Multi-Unmanned FSM with Fuel Constraints where the different types of vehicles, between two and nine, are expected to refuel at fuel stations or at depots as they run out of fuel. They used a variable neighborhood descent (VND) and a variable neighborhood search (VNS). The authors presented simulation results to test the efficiency of the method on a set of 23 instances on which VND produced better solutions than VNS.


                        Dayarian, Crainic, Gendreau, and Rei (2015) introduced the Multi-Depot FSMTW with deliveries to plants. The problem is inspired by collection-redistribution activities in the raw-milk industry of Quebec, where there is a need to satisfy the plant demands by delivering the supplies collected earlier. The authors defined a new set covering model, a specialized cutting-edge column generation procedure to solve its linear relaxation, and a new branching strategy based on the special structure of the problem. Promising results were obtained on instances with up to 50 producers.

In recent years, green issues have received increased attention in the context of the VRP. Thus, Kwon, Choi, and Lee (2013) studied a green extension of the HF in which the objective is to minimize carbon emissions. The authors presented a mathematical formulation and developed several tabu search algorithms. The authors performed a cost-benefit assessment of the value of selling or purchasing of carbon emission rights. Their results suggest that carbon emissions can be reduced without increasing costs due to the benefits of carbon trading.


                        Juan et al. (2014) introduced the FSM with Multiple Driving Ranges in which the total distance that each vehicle type can travel is limited. This problem arises in the routing of electric and hybrid-electric vehicles which can only travel limited distances due to the limited capacity of their batteries. The authors described a mathematical formulation and developed a multi-round heuristic. The method is based on a biased randomized algorithm which can be used alone to create alternative fleet choices whenever the feasibility of the prespecified fleet configuration is not guaranteed. A set of benchmark instances were created to analyze how distance-based costs increase when considering “greener” fleet configurations. The method performed well on all benchmark instances and many different alternative solutions offer competitive distance-based costs while using fewer long- or medium-range vehicles than normally required.


                        Kopfer and Kopfer (2013) studied the emission minimizing variant of the FSM. These authors described a mathematical formulation for the problem and computed the CO2 emissions based on the vehicle load and distance traveled. They presented computational experiments on small size instances with up to 10 customers. Kopfer, Schönberger, and Kopfer (2014) later studied an extension of the problem in which emission and fuel consumption are jointly minimized. They presented a mathematical model and solved it by CPLEX on instances with up to 14 nodes. The model was used to analyze the potential of reducing CO2 emissions by using a heterogeneous fleet. The tests confirmed that the quantity of fuel needed to serve a given customer demand can indeed be reduced.


                        Koç et al. (2014) studied the Fleet Size and Mix Pollution-Routing Problem where the objective is a linear combination of vehicle, fixed cost, fuel cost and CO2 emissions, and driver cost. The authors formally defined the problem, presented a mathematical model and developed a hybrid evolutionary metaheuristic. Several algorithmic features were introduced, namely a heterogeneous adaptive large neighborhood search procedure, a split algorithm with speed optimization algorithm and a new solution education procedure. Computational experiments were conducted to shed light on the potential trade-offs between various performance indicators, such as fuel and CO2 emissions, vehicle fixed cost, distance, driver cost and total cost. The authors quantified the benefit of using a heterogeneous fleet over a homogeneous one. An interesting finding was that a heterogeneous fleet with fixed speeds achieved greater benefits in cost as opposed to a homogeneous fleet using speed optimization.


                        Tütüncü (2010) introduced the HF with Backhauls and proposed a new greedy randomized adaptive memory programming search based on a visual interactive algorithm. The method was embedded within a visual decision support system where users are allowed to generate and assess alternative decisions by using their experience and knowledge of the problem. The proposed algorithm was initially tested on classical HF instances and competitive results were obtained within a reasonable computation time. Several new benchmark instances with up to 100 nodes were also generated for the HF with Backhauls.


                        Belmecheri et al. (2013) described the HFTW with Mixed Backhauls where linehaul customer demands are delivered from the depot, while backhaul customers have goods to be picked up and brought back to the same depot. The authors presented a mathematical model and proposed a particle swarm optimization heuristic which was applied to randomly generated instances with 25–100 nodes.

A new variant of the FSM with Backhauls was introduced by Salhi et al. (2013). In this problem, there are two types of customers: delivery (linehaul) customers and pick-up (backhaul) customers. All deliveries must be made to the linehaul customers before any of the backhaul customers are serviced. Routes containing only backhaul customers are not allowed. The authors formulated the problem, presented several valid inequalities and developed a heuristic algorithm based on a set partitioning formulation. A total of 36 instances were generated, ranging from 20 to 100 nodes. Optimal solutions were obtained on small size instances, and upper and lower bounds could be computed on larger ones. The method performed reasonably well on the FSM with Backhauls as well as on the standard FSM.

Several studies have considered the special case of the HF with the use of external carriers. In this problem, customer demands are delivered by means of a heterogeneous internal fleet or by an external carrier. The objective is minimizing a total cost function of external carriers, transportation and fixed cost of the internal fleet.

One of the first papers on this problem is by Chu (2005) who proposed a three-level heuristic. The customers served by the external carrier are first selected. Routes are then constructed to serve the remaining customers by applying a modified version of Clarke and Wright (1964) savings algorithm. Finally, a steepest descent heuristic is applied to improve the quality of the solution. The author applied the method to five generated instances with up to 29 customers. Another study on this problem was presented by Bolduc, Renaud, and Boctor (2007) who described a heuristic that first selects the customers to be served by external carriers, and then generates an initial solution subsequently improved by four-opt moves. This heuristic yielded better results than that of Chu (2005). In a later study, Bolduc, Renaud, Boctor, and Laporte (2008) proposed a perturbation metaheuristic for the same problem. The algorithm integrates a local descent on different neighborhood structures with a randomized construction procedure, a perturbation mechanism where pairs of customers are swapped, and an improvement procedure. It also makes use of a streamlined family of edge exchanges. The method provided better results than those of Chu (2005) and Bolduc et al. (2007). Finally, Potvin and Naud (2011) developed a tabu search heuristic for the same problem with a neighborhood structure based on ejection chains. This heuristic outperformed all previous ones and was particularly effective on large-size instances due to the use of the ejection chain mechanism which allows multiple displacements of customers served by heterogeneous vehicles.


                        Ceschia, Luca Di, and Andrea (2011) studied another extension of the FSMTW with Carrier-Dependent Costs. The problem works with a heterogeneous fleet, a multi-day planning horizon, complex carrier-dependent vehicle costs, and the possibility of not serving some orders. The authors developed a tabu search with a combination of three different neighborhood relations. The effects of these neighborhoods were investigated on a set of real-world instances. The method was also tested on the benchmarks instances of Bolduc et al. (2007). The proposed method was able to obtain one new best-known solution.

A few studies have considered the joint HVRP and container loading problem, where the latter feature adds a significant layer of complexity. One of the earlier papers by Lai et al. (2013) considered the HF with Single and Double Container Loads where container loads must be shipped from exporters to a port and from the port to importers by trucks carrying either one or two containers. The problem was formulated as a mixed integer linear program. The authors developed an algorithm in which an initial solution is obtained through a modified version of Clarke and Wright (1964) savings heuristic, and is then improved by a sequence of local search stages.


                        Leung et al. (2013) have studied the FSM with Two-Dimensional Loading. In this problem, vehicles have different capacities, fixed and variable operating costs, a length and a width, and two-dimensional loading constraints. Customers demand rectangular items with a given width, length and weight. The authors developed a simulated annealing algorithm combined with a local search heuristic to improve the solution. Furthermore, six packing algorithms, five of which were proposed by Zachariadis, Tarantilis, and Kiranousdis (2009) and one by Leung, Zheng, Zhang, and Zhou (2010) were also used to solve the loading subproblem. The method was tested on benchmark instances derived from the VRP with Two-Dimensional Loading (Gendreau, Iori, Laporte, & Martello, 2008; Iori, Salazar, & Vigo, 2007). Dominguez et al. (2014) later studied an undirected version of the FSM with Two-Dimensional Loading which differs from that of Leung et al. (2013) by allowing the items to be rotated by 90° during the truck-loading process. The work was motivated by a real-world case in which a company distributes industrial building construction equipment to customers. These items are assumed to be rectangular and must be packed so as to efficiently use the vehicle capacity. Thus, the equipments must be distributed considering not only their weight, but also their specific dimensions. The authors developed a multi-start heuristic based on biased randomization of routing and packing algorithm. Routing and packing costs are considered simultaneously to better support the decision making process. The authors used the benchmark instances of Leung et al. (2013) and were able to obtain some new best-known solutions.

Split deliveries in vehicle routing occur when the demand of a customer may be fulfilled by multiple vehicles. Tavakkoli-Moghaddam, Safaei, Kah, and Rabbani (2007) were among the first to allow split deliveries in the context of the HF. The cost of the fleet depends on the total unused capacity and on the number of vehicles used. The authors formulated the problem as mixed-integer linear program and then developed a hybrid simulated annealing algorithm. They generated new benchmark instances with 6–100 nodes. On the small size instances, the heuristic was compared with a branch-and-bound method which yields competitive results. On the larger size instances the comparison was made with respect to lower bounds obtained by solving a giant tour visiting all the customers.


                        Belfiore and Yoshizaki (2013) developed a scatter-search algorithm for the FSMTW with Split Deliveries. Initial solutions were created by two constructive heuristics. Scatter search was then used to diversify and intensify the solutions. The authors applied their algorithm on the standard FSMTW instances of Liu and Shen (1999a) and on generated instances from the VRP with Split Deliveries of Ho and Haugland (2004) with 100 nodes for which several best-known solutions obtained.


                        Qu and Bard (2013) introduced the Pickup and Delivery HF with Configurable Vehicle Capacity in which the vehicle capacity can be modified by reconfiguring its interior to satisfy different types of customer demands. The authors presented a mixed-integer formulation, and developed a two-phase heuristic based on greedy randomized adaptive search procedures with multiple starts. In the first phase, several randomized procedures are used to obtain a set of good feasible solutions and in the second phase an adaptive large neighborhood search heuristic is applied to improve the solutions. Eight real instances with up to 100 nodes and four vehicle types were solved. The solutions yielded cost savings from 30 percent to 40 percent. The same authors (Qu & Bard, 2014) later introduced the Pickup and Delivery FSMTW with Configurable Vehicle Capacity. They presented a mixed-integer programming model and a branch-and-price-and-cut algorithm. The authors proposed a labeling algorithm for the pricing subproblem, which is an elementary shortest path problem, developed efficient dominance conditions to speed up the method, and used subset-row inequalities to strengthen the lower bound obtained by column generation. Benchmark data sets with up to 50 nodes were generated to test the efficiency of the method. Optimal solutions were obtained in the majority of cases.


                        Li et al. (2012) seem to have been the first to study the Open HF, where a vehicle starts its route at the depot but is not required to return back to it after servicing the last customer. The authors proposed a multistart adaptive memory programming algorithm with a modified tabu search heuristic which was applied to randomly generated instances with between 50 and 200 nodes and with six vehicle types. The second paper on this problem is by Yousefikhoshbakht, Didehvar, and Rahmati (2014), in which an adaptive memory algorithm combined with tabu search is proposed. The algorithm generates initial diversified solutions which are later intensified. The tests revealed that the algorithm is effective and can find better solutions than those of Li et al. (2012).

A number of the HVRP extensions have been studied, ranging from cases in which customer demands are stochastic to cases containing realistic constraints relative to synchronization, multiple products, loading, etc. We now provide a brief overview of these studies.


                        Teodorović et al. (1995) considered a stochastic FSM where customer demands are drawn from a uniform distribution. The authors proposed a heuristic to construct a giant tour, which is then split into smaller routes, each of which is assigned to a suitable vehicle type. The probability of failure on a route is then computed as the probability that the total demand served on the route exceeds the vehicle capacity.


                        Vis, de Koster, and Savelsbergh (2005) considered a variant of the FSMTW with fleet dimensioning between buffer areas and storage areas at a container terminal. This problem arises in maritime transportation where products can be transported in containers between ports. The containers are transferred from one transportation mode to another, and cranes remove containers from a ship to put them in a capacitated buffer area. A vehicle lifts a container from the buffer area before it is full and transports it to another buffer area before it is eventually moved to a storage area. The problem minimizes the container fleet size between buffer and storage areas within a prespecified time window. The authors described a mathematical model for the problem and used simulation to validate the results on instances with 50, 80, or 100 containers. Additional experiments were also conducted to test the performance of the model under various conditions. The objective was to minimize the vehicle fleet size.


                        Bolduc, Renaud, and Montreuil (2006) consider the HF with Synchronized Production and Distribution for a large-scale supply chain network. The problem involves the determination of a production schedule, inventory levels and a schedule for delivering demand at the retailers. The authors presented a mathematical model, proposed four heuristics for direct deliveries and described several extensions to tackle with the multiple-retailer-routes.


                        Tavakkoli-Moghaddam, Safaei, and Gholipour (2006) introduced another variant of the FSMTW in which only the depot has a time window, and the cost is independent of the route length but dependent on the type and capacity of available vehicles. The authors developed a mathematical model and a hybrid simulated annealing algorithm based on the nearest neighborhood heuristic. Computational results show that 18 small scale instances of up to 10 customers were solved to optimality with the proposed mathematical model and the heuristic could find good solutions within reasonable computation time on 10 large instances with up to 300 customers.

The HF with soft Time Windows was studied by Yepes and Medina (2006) who proposed a three-step local search algorithm based on a probabilistic variable neighborhood search. The method includes a generation procedure that makes use of a greedy randomized adaptive search, a diversification procedure uses an extinctive selection evolution mechanism, and a postoptimization mechanism based on a threshold heuristic with restarts. The authors note that practical VRPs need an economic objective function to compute the solution cost under various economic scenarios whose specific conditions may change every day. Three instances with 100 nodes and three vehicle types were solved.


                        De la Cruz, Paternina-Arboleda, Cantillo, and Montoya-Torres (2013) studied the FSMTW with multiple products and limited transport capacity. The authors developed a hybrid ant colony heuristic with a two-pheromone trail strategy to accelerate the ants, combined with a simple tabu search heuristic. A colony of cooperative agents is used to obtain feasible solutions for the problem where the implementation is two-level iterative process (see Barbarosoglu & Ozgur, 1999; Homberger & Gehring, 1999). After the ant colony search, a tabu search algorithm is applied to obtain better solutions without significantly affecting the computation time. The heuristic uses recent event and frequent event memories, as well as diversification procedures. The authors generated benchmark instances with up to 200 nodes based on those of Solomon (1987) and Homberger and Gehring (1999) on which competitive results were obtained.


                        Franceschelli et al. (2013) developed two heuristic to solve several variants of the FSM with multi-vehicle task assignment. To improve the local task assignments, the first algorithm builds on local, asynchronous and pairwise optimizations, while the second one is linear with respect to the number of tasks. The authors proposed upper and lower bounds which consider vehicles with different movement and task execution speeds, and also tasks with several service costs. The algorithms were validated through simulations.

Another extension of the FSMTW, which considers overloads on vehicles, was investigated by Kritikos and Ioannou (2013). Overloads are allowed up to a prespecified bound, the penalty function of Gheysens et al. (1984) is embedded within the objective function to effectively control overloaded solutions. The authors developed a sequential insertion heuristic which extends the traditional insertion criteria of Solomon (1987), and adapts several algorithmic procedures introduced by Golden et al. (1984), Dullaert et al. (2002) and Liu and Shen (1999a). Competitive results were obtained on the adapted FSMTW instances of Liu and Shen (1999b).


                        Seixas and Mendes (2013) studied the Multi-Trip FSMTW with accessibility restrictions on customers, in which the work hours of the drivers are limited. They developed a column generation algorithm, a constructive heuristic and a tabu search heuristic. Valid inequalities were also introduced to strengthen the formulation. Instances with up to 50 customers and 25 vehicles were solved to optimality.


                        Jiang, Ng, Poh, and Teo (2014) considered the HFTW with a hierarchical objective function that minimizes the total number of vehicles and total traveled distance. Each component is multiplied by a hierarchical weight in the objective function. The authors developed a two-phase tabu-search algorithm. In the first phase the algorithm of Lau, Sim, and Teo (2003) is used to handle the heterogeneous fleet dimension and a post-processing procedure is applied in the second phase. The method was tested on randomly generated instances with up to 100 nodes.


                        Wang et al. (2014) studied the Multi-compartment HF. The problem arises in many practical application, such as the transportation of apparel products with different vehicle types. These products have different styles and packages, and are usually jointly delivered in one vehicle. Some products are hung on flexible swing rods while others are packed in boxes. In this case, the vehicle is reorganized to form multiple separated compartments, one for each product type. The authors proposed a reactive guided tabu search algorithm in which the search history is used to guide the process, and they solved instances with two different vehicle types and up to 100 nodes.


                        Iori and Riera-Ledesma (2015) introduced a variant of the FSM, called the Double VRP with Multiple Stacks, which is the one-to-one pickup-and-delivery VRP with backhaul deliveries. Heterogeneous vehicles carry containers divided into stacks of fixed height, the operation of the vehicles follows a last-in-first-out policy. The aim is to minimize the total routing cost by performing pickups and deliveries while ensuring feasible loading and unloading of the vehicles. The authors have developed three models: a three-index formulation, and two set partitioning formulations using different families of columns. These models were solved by branch-and-cut, branch-and-price and branch-and-price-and-cut, respectively. The branch-and-price and the branch-and-price-and-cut algorithms performed well when the number of vehicles increased. On the other hand, the branch-and-cut algorithm yielded better quality solutions on instances with a small number of vehicles. Instance with up to 50 nodes were solved to optimality by the branch-and-price-and-cut algorithm.

Because heterogeneous fleets are common in practice, several studies were conducted to investigate and solve real-life distribution problems, which we now review.


                     Tarantilis and Kiranoudis (2001) described a real-life application concerning the scheduling of distribution of fresh milk for a dairy company in the Athens area. The authors aimed to minimize the total cost of delivering fresh milk from a dairy company to supermarkets and small stores by means of a heterogeneous fleet of vehicles. There are 299 delivery points in that study, and three vehicle types are available. The authors proposed a heuristic that was able to yield considerable improvements in the operational performance of the company. In another paper, the same authors studied two real-life HF problems arising in the dairy sector and in the construction industry (Tarantilis & Kiranoudis, 2007). The first case study considers the central warehouse of a dairy company that hosts 27 vehicles of 12 different types and stores bottles of fresh milk that must be delivered daily to a set of customers, the number of which varies from 240 to 320. In the second case study, a construction company has a distribution center where ready-made concrete is loaded onto a heterogeneous fixed fleet of concrete-mixer trucks. The concrete is then delivered to 100 construction sites, and each load can be blended by a specific type of concrete-mixer truck of specific capacity which can carry different blends of concrete. In total, 13 trucks of six different types are available. The authors developed a flexible adaptive memory-based algorithm which is a two-phase construction heuristic, incorporating various operational constraints. The method outperformed that of Tarantilis et al. (2003) and significantly reduced the fleet size and distribution costs when compared with the current practice.


                     Prins (2002) studied a multi-trip variant of the HF in which each vehicle can perform several trips. Several heuristics, namely sequential heuristics, a new merge heuristic, steepest descent local search and tabu search. Both the single trip and multi-trip versions of the HF were solved with the proposed methods. Furthermore, the merge heuristic is applied to the case of a furniture manufacturer located near Nantes on the Atlantic coast of France, with 775 destination stores and 71 trucks. In the problem, the orders must be received at the latest on Friday for a delivery the week after. The author indicated that this situation creates sufficient time on Friday night to run the algorithm. The method achieved significant savings on the average route duration and on the total cost of the weekly scheduling.


                     Calvete, Gale, Oliveros, and Sanchez-Valverde (2007) described a two-phase goal programming model for the FSM with multiple objectives and hard or soft time windows to solve a real-life problem arising in the medium-size delivery company. In a first phase feasible routes are enumerated and the total penalty incurred by each route regarding to deviations from targets is computed. The second phase solves a set partitioning problem to select the best set of feasible routes. Medium-sized real-life problems containing 60 instances were grouped into six different configurations with 30, 50 and 70 nodes. Customers are clustered into four groups with respect to time windows: soft time windows reflecting town council regulations or customer requirements for delivery early in the morning, early in the afternoon or in the evening. Hard time windows allow a maximum deviation from the soft time windows of one hour on each side. Competitive results were obtained on medium-sized problems.


                     Belfiore and Yoshizaki (2009) proposed a scatter search algorithm for a real-life FSMTW with Split Deliveries arising in the retail industry in São Paulo. The sequential insertion heuristics of Dullaert et al. (2002) and of Ho and Haugland (2004) were adapted to generate initial solutions. Several intensification and diversification procedures were also combined. The algorithm was applied to a major Brazilian retail group which serves 519 delivery points in 11 states. Customers are served from one depot located in São Paulo with four different types of trucks. The results showed that proposed method is capable of finding better solutions than current practice and decreased the total distribution cost by 7.5 percent on average.


                     Bettinelli, Ceselli, and Righini (2014) considered the Pickup and Delivery Multi-Depot HF with Soft Time Windows to find efficient solutions for small transportation companies operating in the urban area of Milan. To this end, they proposed an exact branch-and-price algorithm based on advanced dynamic programming techniques. The method could optimally solve the instances with up to 75 customers. Furthermore, the authors analyzed the effect of managing customer preferences by soft time windows which increases routing costs from 5 to 15 percent.


                     Xu and Jiang (2014) studied the Multi-Depot FSM and proposed a variable neighborhood search algorithm based on hybrid operators to solve a problem arising in a large-scale water project in China. Simulated annealing was embedded within the algorithm to manage the acceptance process of the solutions. The project contained two distribution centers, 16 customers and two vehicle types. It aimed to achieve a material flow equilibrium including excavation sites, filling sites, transfer yards, excavation waste dump sites, material yards, a distribution center, and equipment parking. Overall, the algorithm was able to decrease the average traveled distance by 3.49 percent and to reduce the total costs by 7.35 percent.


                     Moutaoukil, Neubert, and Derrouiche (2014) performed a case study arising in a “green” context and aimed at minimizing CO2 emissions in the FSM. The authors defined a mathematical formulation to investigate the effect of homogeneous and heterogeneous fleets on CO2 emissions. They presented a small illustrative example, and solved a real-life problem. In this example, a collection center located in Saint-Étienne, France, serves 10 nodes with three vehicle types, compromising one light-duty and two heavy-duty vehicle, to collect parcels every day. The results show that the use of a heterogeneous fleet yields better results than a homogeneous fleet. However, the model was able to solve only small-scale instances.


                     Yao et al. (2015) studied a variant of the HF in which the vehicles start and end their tours at a third-party logistics company, pick up cartons from factories and then deliver them to customers. The authors proposed a particle swarm optimization heuristic integrated within a self-adaptive scheme and a local search improvement strategy. They applied the method to a case study in Dalian City where there are eight carton factories and 85 customers in the region. The total cost was reduced by 28 percent when compared with the current situation.

In this section, we first provide a tabulated summary of the existing literature on the HVRPs, and then present a comparative analysis of the computational results reported in the literature for the FSM, HF and FSMTW.

@&#SUMMARY@&#


                        Tables 1–3
                         contain a summary of all publications reviewed in this paper. These tables contain, for each reference, the side problem to the main problem (if any), whether a mathematical programming formulation was described (“•” for yes), the solution method and whether a case study was included. The abbreviations of side problems used in Tables 1–3 are as follows: backhauls (BC), carton with a collection depot (CCD), deliveries to plants (DTP), green (GR), multi-depot (MD), multi-compartment (MC), multi-vehicle task assignment (MV), multi-trip (MT), multiple stacks (MS), open (OP), overloads (OV), pickup and delivery (PD), single and double container loads (SDC), stochasticity (ST), time-dependencies (TD), two-dimensional loading (TDL), time windows (TW), use of external carriers (UEC). The abbreviations of solution methods are as follows: continuous approximation models (CA), branch-and-bound algorithm (BB), branch-and-cut algorithm (BCA), branch-cut-and-price algorithm (BCP), branch-and-price algorithm (BP), column generation (CG), decomposition (DE), heuristic column generation (HCG), integer programming (IP), mixed integer programming (MIP), lower bound formulations (LB), set partitioning (SP), valid inequalities (VI), adaptive memory programming (AMP), ant colony optimization (ACO), constructive heuristics (CH), iterated local search (ILS), particle swarm optimization (PSO), population search (PS), scatter search (SS), simulated annealing (SA), simulation (SIM), tabu search (TS), threshold accepting (TA), variable neighborhood search (VNS).
                        
                     

The following conclusions can be drawn from the tables: 1) For the HVRP, the most widely studied version is the FSM and its variants, with 60 references, comprising 58.25 percent of all references reviewed in this paper. This is followed by the HF and its variants studied in 32 references (31.07 percent of all references). In 11 references both the FSM and the HF (10.68 percent of all references) were studied. 2) For the FSM (Table 1), the most widely studied versions are the standard one and the FSMTW, each with 22 references and each comprising 36.67 percent of the list. 3) For the HF (Table 2), the most widely studied version is the standard one, with 14 references, comprising 43.75 percent of the list. This is followed by the HFTW, studied in five references (15.63 percent of the list), by the Multi-depot HF studied in three references (9 percent of the list), and the Pickup and Delivery HF studied in three references (9 percent of the list). 4) Two papers considered both the FSMTW and the HFTW, comprising 18 percent of the list given in Table 3.5) Of the FSM solution methods (Table 1), the most common are constructive heuristics with 26 references (43.34 percent of the list), followed by tabu search with seven references (11.67 percent of the list), and population search with six references (10 percent of the list). 6) Of the HF solution methods (Table 2), the most common occurrence was constructive heuristics with 14 references (43.75 percent of the list), followed by tabu search heuristics with nine references (28.13 percent of the list), and threshold accepting heuristics with four references (12.5 percent of the list). 7) Concerning both the FSM and the HF solution methods (Table 3), the most common are population search with three references (27 percent of the list), followed by iterated local search with two references (18 percent of the list).
                     


                        Baldacci et al. (2010a) provided a comparison of the exact algorithms produced until 2010. To the best of our knowledge, no exact algorithm has been developed for the standard FSM or the HF since 2010. For this reason, we provide a comparative analysis of the heuristic results for the HVRP in this section.

Most studies describing new algorithms for the HVRP were tested on the benchmark instances: 1) Golden et al. (1984) proposed a set of 20 instances for the FSM with 12–100 nodes. 2) Liu and Shen (1999b) described several data sets for the FSMTW, derived from the classical Solomon (1987) VRPTW instances with 100 nodes. These sets include 56 instances split into a random data set R, a clustered data set C and a semi-clustered data set RC. Sets denoted by R1, C1 and RC1 have a short scheduling horizon and small vehicle capacities, in contrast to the sets denoted R2, C2 and RC2 which have a long scheduling horizon and large vehicle capacities. Liu and Shen (1999b) also introduced three cost structures and several vehicle types with different capacities and fixed vehicle costs for each of the 56 instances. This results in a total of 168 benchmark instances for the FSMTW. 3) Taillard (1999) developed a benchmark data set for the HF by adapting eight of the Golden et al. (1984) benchmark instances. This set includes eight instances containing 50, 70 and 100 nodes. 4) The benchmark of Paraskevopoulos et al. (2008) for the HFTW is a subset of the FSMTW instances, in which the fleet size is set equal to that found in the best known solutions of Liu and Shen (1999a). In total, there are 24 benchmark instances derived from Liu and Shen (1999a) for the HFTW.

We now present a comparison of the recent results for the FSM, HF and FSMTW in Sections 8.2.1–8.2.3, respectively.


                           Table 4 presents a summary of the comparison results of recent metaheuristics for the FSM with three costs variants, i.e., FSM(F, V), FSM(F) and FSM(V). For detailed comparison results, the reader is referred to Tables A.1–A.3 in Appendix A. In these tables, the first column provides the references, and for each reference two performance indicators are shown: the average percentage deviation (Dev) from the value of the best-known solution (BKS) for each instance retrieved from the articles surveyed, and the average computation time in seconds (Time). The reported running times are the best solution running time over all runs. The computers and programming languages used are not comparable, hence scaled times for one reference computer would not be valid. We simply indicate the features of each computer such as processor and CPU speed in gigahertz in the last column of the table.


                           Table 4 indicates an effective progress since 2007. All metaheuristics for the three cost versions of the FSM achieve average deviations 0.2 percent or less. In terms solution quality, the top performers are Penna et al. (2013) and Vidal et al. (2014) for the FSM(F, V), Vidal et al. (2014) for the FSM(F), and Choi and Tcha (2007), Penna et al. (2013) and Vidal et al. (2014) for the FSM(V).


                           Table 5
                            provides a summary of the average results of recent metaheuristics applied to two costs variants of HF: HF(F, V) and HF(V). For detailed comparison results, the reader is referred to Tables A.4 and A.5 in Appendix A.


                           Table 5 shows a continuous progress since 1999. Recent metaheuristics for all two cost versions of the HF achieve average deviations 0.5 percent or less. In terms of solution quality, the top performers are Subramanian et al. (2012) for the HF(F, V), and Li et al. (2007), Subramanian et al. (2012), Liu (2013) and Penna et al. (2013) for the HF(V).


                           Tables 6
                            and 7
                            present summaries of the results of recent metaheuristics for the FSM on two costs variants: FSMTW(T) and FSMTW(D). The first column shows the instance sets containing several instances. The second column shows the average BKS. The remaining columns show, for each reference, the average percentage deviations of each set, and the average solution time. The computer specifications are provided in the last two rows.

In the case of the FSMTW(T), a continuous progress can be observed since 2007. Recent metaheuristics, Vidal et al. (2014) and Koç et al. (2015), achieve average deviations 0.2 percent or less. In the case of the FSMTW(D), there has also been a significant progress in terms of average deviations. Recent metaheuristics, Vidal et al. (2014) and Koç et al. (2015), achieve average deviations of at most 0.1 percent. These two papers developed powerful population search based metaheuristics, and obtained very effective results on both cost variants of the FSMTW.

The
                     
                      Heterogeneous Vehicle Routing Problem (HVRP) was introduced some 30 years ago by Golden et al. (1984) and has since evolved into a rich research area. Several versions of the problem have been studied, and applications are encountered in many settings. Our survey provides a classification of the HVRP literature under two main dimensions: unlimited fleet and limited fleet. We have identified the following conclusions and future research directions: 1) All five standard versions of the HVRP (FSM(F, V), FSM(F), FSM(V), HF(F, V), HF(V)) have now been solved to near optimality by heuristics, and it is our belief that this algorithmic research on the standard problems has now reached maturity. 2) Over the years, most of the research effort has shifted toward the study of rich extensions of the standard HVRP, such as time windows, multiple depots, external carriers, pickup and delivery operations, container loading and backhauls. There still exist numerous research opportunities on these rich extensions. 3) The “green” extension of the problem has also received increasing attention in recent years. It would seem interesting to study some extensions of the standard HVRP in a green context. 4) Almost all studies, except one, have so far focused on time-independent versions of the HVRP. A more realistic version of the standard HVRP and its variants would be to consider time-dependencies, particularly in urban settings and in city logistics. 5) To our knowledge, no exact algorithm has yet been proposed for the FSMTW (except for a simple branch-and-bound scheme) or the HFTW. Further studies should focus on developing effective exact methods for those different problems. 6) HVRPs tend to be very hard to solve, which explains why most algorithms are heuristics. These have gradually evolved from simple interchange schemes to more sophisticated metaheuristics, sometimes combining exact methods. In general, constructive heuristics complemented with local search heuristics are the main methods of these studies, but researchers should consider hybrid schemes combining population search and local search (like ALNS or iterated local search), such as those applied to the standard VRP (Laporte, Ropke, & Vidal, 2014). Such metaheuristics should also be effective on special cases of FSM/HF and on problems that contain FSM/HF as special cases. The recent tendency in the field of the VRP heuristics has been to develop algorithms that are highly accurate but often require large computing times and lack simplicity in the sense that they contain too many parameters and are difficult to reproduce. This observation applies to most of the metaheuristics we have just surveyed. While computing times have become more modest in some of the best recent implementations, the lack of simplicity of these methods remains problematic in many cases (Laporte et al., 2014). On a more positive note, we have witnessed in recent years the emergence of flexible metaheuristics capable of solving a host of problem variants with the same parameter settings (Koç et al., 2015; Vidal et al., 2014). 7) To our knowledge, only one study has developed a continuous approximation model which is highly effective on the standard FSM. This type of modeling should be applied to the HF and to rich extensions of the HVRP.

We believe this paper has helped unify the rapidly expanding body of knowledge on the HVRP and will encourage other researchers to pursue the study of this fascinating field of research.

@&#ACKNOWLEDGEMENTS@&#

The
                   authors gratefully acknowledge funding provided by the Southampton Business School of University of Southampton and by the Canadian Natural Sciences and Engineering Research Council under grants 39682–10 and 436014–2013. Thanks are due to three referees for their valuable comments.


                     Tables A.1–A.3 provide a computational results on three costs variants of the FSM: the FSM(F, V), the FSM(F) and the FSM(V), respectively. Tables A.4 and A.5 provide statistics relative to recent metaheuristics for two cost variants of the HF: the HF(F, V) and the HF(V). The first column of each table is the instance number. The second column shows the number of customers, and the third column shows the value of the best-known solution (BKS) for each instance, where a boldface entry indicates that the value is optimal. The remaining columns show, for each reference, two performance indicators: the percentage deviation (Dev) from BKS obtained from the articles surveyed, and the computation time in seconds (Time).

@&#REFERENCES@&#

