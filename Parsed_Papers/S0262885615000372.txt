@&#MAIN-TITLE@&#Optimized projection patterns for stereo systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The novel concept of non-recurring De Bruijn (NRDB) sequence


                        
                        
                           
                           The algorithms to generate NRDB sequences for given parameters


                        
                        
                           
                           The optimal subsequence search algorithm using branch-and-bound


                        
                        
                           
                           Discussion on similarities and differences of active stereo and structured light


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Active stereo

Stereo matching

Projection pattern

De Bruijn sequence

Structured light

@&#ABSTRACT@&#


               
               
                  This paper describes how to generate optimal projection patterns to supplement general stereo camera systems. In contrast to structured light, the active stereo systems utilize the projected patterns only as auxiliary information in correspondence search, whereas the structured light systems have to detect the patterns and decode them to compute depth. The concept of non-recurring De Bruijn sequences is introduced, and a few algorithms based on the non-recurring De Bruijn sequence are designed to build optimized projection patterns for several stereo parameters. When only the search window size of a stereo system is given, we show that a non-recurring De Bruijn sequence with corresponding parameters makes the longest functional pattern, and presents experimental results using real scenes to show the effectiveness of the proposed projection patterns. Additionally if the pattern length is given in the form of maximum disparity search range, the algorithm using branch-and-bound search scheme to find an optimal sub-sequence of a non-recurring De Bruijn sequence is proposed.
               
            

@&#INTRODUCTION@&#

In many real-world applications, stereo camera systems are widely used since they can be easily built using inexpensive off-the-shelf components. However their performance, especially the coverage which represents how much portion of the scene can be successfully reconstructed, is highly dependent on the texturedness of the scene. This is an inherent problem of stereo reconstruction algorithms since depth is computed from the disparity between corresponding pixels in left and right images (Fig. 1(a)), and without enough texture it is very hard to establish accurate and correct correspondences. In many indoor environments, large untextured walls and floors occupy most of scenes and these make the generic passive stereo system fail to correctly reconstruct and recognize such structures.

Many algorithms (e.g. global correspondence methods in [1]) have been proposed to reduce this problem by filling the gaps in the uncertain areas of reconstruction, but for most algorithms the required computation is too large for real-time applications, and the resulting depth maps are not guaranteed to be complete or accurate.

Compared to the stereo systems that use two rigidly-attached cameras, the structured light methods ([2–4]) use one camera and one pattern projector to capture depthmaps. Recently several sensors in this category represented by Kinect [5] became available to ordinary users. The principal theories are same in both approaches except the way how the correspondence is searched. In structured light, each ‘pixel’ in the projector is tagged with a unique pattern patch around it, and the pattern is sought along the epipolar line in the captured image. The projected patterns in the captured image need to be correctly detected and precisely decoded to compute the depthmap. If the pattern is not clearly visible, for example due to existing textures on the object surface, low albedo, large distance, or strong environmental illumination (direct sun-light), the correspondence cannot be made and the depth cannot be estimated.

Another relatively unexplored way is to augment the stereo system by actively projecting light patterns to the scene to create artificial textures in the scene (active stereo methods). The proposed approach is seemingly quite similar to the structured light methods, in a sense that both actively project certain patterns to the scene, however there exists a key difference between these two approaches. Whereas the structured light systems have to detect and decode the projected patterns, the active stereo method only uses the patterns as supplementary information in the standard stereo matching process. Even when the projected pattern is not visible at all, the active stereo methods still can generate depthmaps unlike structured light. Since the projected patterns are never explicitly detected or decoded, ideally it only improves the stereo reconstruction without any additional computational costs. When the pattern is not visible, the active stereo system will perform as well as the passive stereo system, and otherwise it will utilize the additional information from the projected pattern. Fig. 2
                      shows a typical example; Fig. 2(a) shows a passive stereo output when the scene lacks texture, and Fig. 2(b)–(d) is the output of the same stereo algorithm with a carefully designed pattern projected onto the scene.

The main theme of active stereo research is how to create the most effective texture pattern that results best stereo reconstruction. There exist only a few work which fits in this direction. Spacetime stereo [6,7] used purely random multiple bit patterns in space-time domain. The results show that if enough number of random bits is used, the ambiguity in pixel matching can be effectively resolved. Konolige [8] optimized the projection pattern using simulated annealing—the bit columns in the windows with the minimum hamming distance are randomly replaced with other bit patterns and the changes with higher hamming distance are accepted with decreasing probability (detailed discussion can be found in Section 4).

In this paper we seek the best projection patterns which ensure that generic stereo methods using window-based epipolar searching find the correct correspondences for all unoccluded pixels. The pattern greatly improves the depth estimate in textureless regions, and also it works with any stereo algorithms that use SAD (Sum-of-Absolute-Difference), SSD (Sum-of-Squared-Difference) or similar measures. Since the stereo rig has a fixed epipolar planes, it is best to align the epipolar planes of the projector and the cameras to the stereo's. If all epipolar planes are aligned and the projector is placed near the stereo, the projected patterns are observed in the captured images with minor distortion. Thus the minimum Hamming distance (MHD) between all pairs of search windows, used in [8], is indeed the metric to be optimized to this end. We present novel non-recurring De Bruijn sequences by modifying De Bruijn sequences [9] not to have any recurring symbols in the sequence. The projection patterns built based on a non-recurring De Bruijn (NRDB) sequence guarantee that the spatial or spatio-temporal neighborhood block at each pixel is unique along the epipolar line within the cycle size of the sequence. In a general stereo setup, the search window size is large enough to contain several pixel-wide projection window (e.g. 5×5 projection pattern can be observed in 11×11 search window in the image
                        1
                     
                     
                        1
                        In practice it is recommended to set the ratio between the projection pattern and the search window to be close to 2 (see Section III-A of [8]).
                     ). The complete NRDB sequence becomes very long in such setup, thus we can only use substring of the NRDB sequence. In such case, one needs to use the subsequence with the largest MHD, and the proposed branch-and-bound algorithm finds the optimal subsequence.

The main contributions of the paper can be summarized as follows:
                        
                           •
                           A novel concept of non-recurring De Bruijn sequences which adapts the property of De Bruijn sequences for this application. A generic algorithm and a few specialized algorithms to generate the sequences.

A branch-and-bound search algorithm that seeks an optimal fixed-length sub-sequence.

The earlier version of the work [10] addressed the first issue mainly, and here we extend it to output an optimal subsequence, and add more insights on the topic.

The paper is organized as follows: Section 2 reviews related prior works, and Section 3 introduces the non-recurring de Bruijn sequences with a few practical algorithms to generate them. Section 4 describes the branch-and-bound algorithm to find the optimal fixed-length pattern. Section 5 presents various experimental results and comparisons with prior arts, and Section 6 concludes the paper.

@&#RELATED WORKS@&#

Recently the need for accurate and dense depth measurement has grown and many innovative sensors have been introduced. Kinect [5] is the most popular and commercially successful example of such sensors. Some other sensors measure time-of-flight of modulated lights (e.g. SR-3000 [11]) or gating the reflected light (Z-cam [12]). Among many approaches in active depth sensing algorithms, we focus on triangulation-based methods, such as spacetime stereo [6,7], active stereo [10,8], or structured light [2,3]. The underlying idea of active triangulation-based methods is, if every location in the epipolar search range is marked with a unique signature, one can easily match pixels between two views by comparing their signatures.

Spacetime stereo algorithm [6,7] is a simple but very effective extension to the traditional passive stereo method, for it can estimate a dense depth map regardless of the amount of texture in the scene. With randomly generated projection patterns, it is possible to create intensity profiles in the observed spatio-temporal pixel blocks, that can be distinguished from other pixel blocks on the epipolar line. Its ability to capture clear and dense depthmaps in realtime opened new directions of applications [13,14].

Structured light has been studied for decades due to its simplicity and effectiveness in capturing 3D geometry. The structured light research focuses on encoding more information into a limited pattern size, and robustly detecting the patterns and decoding them. The existence of the explicit decoding stage, which determines the pixel location in the projection pattern, makes the main difference from the stereo methods. It enables 3D reconstruction using just one camera and one projector, but the reconstruction becomes impossible when the pattern is not visible due to the distance to the surface or the surface albedo.

There are a few ways to encode information in the projection pattern—spatial, temporal, and chromatic. Temporal encoding projects multiple patterns which contain specific bits of the codes. Ideally each code can be put in a single pixel, but in dynamic scenes where the camera/projector or the target moves, the reconstruction becomes very inaccurate. Spatial encoding uses neighboring pixel intensities to deliver the code. While the pattern can be encoded into a single projection pattern, thus there is no motion artifact, the large spatial window size required to contain the code tends to lead blockier reconstruction [2].

Chromatic coding uses different colors to encode the codes into the pattern. This is similar to the projection patterns using multiple colors which can be thought of as multiple binary patterns projected at the same time in different spectral channels. The loss in spatial and temporal resolution is minimized, but the result is highly affected by the color or reflectance of the target surface. Moreover, some methods use multi-level pattern intensity to encode more information (such as sinusoidal variations or by setting the intensity levels to off, low, or high) [15,4]. In natural environments, unlike controlled environments such as a dark room, it is often very hard to distinguish the multiple levels in the captured image, mainly due to target object's surface property, and environmental illumination condition, and camera's dynamic range and A/D conversion resolution. Due to these reasons, multi-level or multi-color projection patterns are not considered in this work.

Taguchi et al. 
                     [16] proposed a motion-aware decoding algorithm which intelligently selects most appropriate spatio-temporal window in temporally encoded structured light. Young et al. 's viewpoint coding algorithm [17] reconstructs the depthmap by placing the camera in coded places. Kawasaki et al. 
                     [18] proposed a single-shot structured light algorithm using vertical and horizontal lines. From the connectivity information acquired from the crossings of vertical and horizontal lines, the order or relative positions of the lines can be recovered and the triangulation becomes possible.

Note that the active stereo is a different problem from the structured light. In the active stereo system, the depth is computed by epipolar search which is completely independent of the projection pattern. The stereo system works without the projected pattern, capturing noisy and incomplete reconstruction on the textureless regions. The structured light methods, on the other hand, assume that the carefully designed known pattern is projected onto the scene surface. Therefore the objective function for each method can be quite different. More detailed discussion on active stereo methods is given in Section 4.

Recently Maurice et al. 
                     [19] presented an efficient search algorithm for 2D structured light patterns that considers minimum and mean Hamming distance between all pairs of subwindows. Except that [19] requires explicit pattern decoding process, two major differences with the proposed work are 1) the proposed algorithm fully utilizes the assumption of the pattern being aligned with the stereo epipolar lines, but in their projector-camera system this assumption is easily violated when the projector and camera are not rigidly attached, thus entire 2D pattern is optimized, and 2) the minimum Hamming distance is only used as the constraint, not the main objective of the optimization.

In most stereo algorithms, correspondence search is performed by comparing the window centered at each pixel with moving windows over the epipolar line in the other view (Fig. 1(a)). Unambiguous matches can be found if the search windows around the pixels contain very distinct and unique patterns. If the corresponding windows in the projection pattern are unique, their images in the captured frame are also likely to be distinct and unique. In this paper we focus on the projection pattern itself rather than its captured images.

The epipolar search process in stereo matching is, for the given window in the reference image, finding the best matching window on the epipolar line in the other image. This can be seen as matching the given string (the window in the reference image) with the same sized substrings in the other longer string (entire image strip in the other image), where the symbols in the strings represent the columns in search windows.

To have unique matches at all pixels, all substrings need to be unique in the entire string. Also the string needs to be cyclic if the length of string is smaller than the image width, to ensure that all searches starting at every pixel find unique matches. For a given alphabet, De Bruijn sequences [9] are the longest sequences that have these properties.
                           Definition
                           Given an alphabet with k symbols A
                              ={a
                              1,…,ak
                              } and a positive integer n, a De Bruijn sequence B(n, A) is a cyclic sequence of the symbols in which all possible length-n sequences of A appear exactly once.

For example, B(2, {0, 1}) is a cyclic sequence containing all length-2 sequence of {0, 1}, i.e. 00, 01, 11 and 10 only once. ‘0011’ is one example of such sequences.

Suppose the epipolar search uses an m
                        ×
                        n window (m-rows by n-columns in the projection pattern) and the search range (= maximum disparity) is N. Since we are considering only binary patterns, the number of all possible patterns in one column is 2
                           m
                        , thus without loss of generality we can define the alphabet A to be {0,1,...,2
                           m
                        
                        −1}. A string s
                        =
                        s
                        1
                        s
                        2
                        …
                        s
                        
                           N
                        , s
                        
                           k
                        
                        ∈
                        A represents the projection pattern, whose length-n substrings s
                        
                           i
                           :
                           i
                           +
                           n
                           −1 are the search window at location i, 1≤
                        i
                        ≤
                        N (note that the string s is cyclic). Sliding the search window to the next pixel is same as removing the first symbol of the substring and adding the new symbol at the end, i.e. 
                        s
                        
                           i
                           +1:
                           i
                           +
                           n
                        , as shown in Fig. 3
                        .

To understand how to generate De Bruijn sequences, the De Bruijn graph needs to be introduced first.
                           Definition
                           A De Bruijn graph G
                              
                                 B
                              (n,
                              A) is a directed graph {V,
                              E}, where V is a set of all possible length-n permutations of the symbols in A, {
                              v
                              :
                              v
                              =
                              v
                              1
                              v
                              2
                              …
                              v
                              
                                 n
                              
                              }, and E is the set of directed edges {(v,
                              w)} where v
                              
                                 i
                              
                              =
                              w
                              
                                 i
                                 −1, 2≤
                              i
                              ≤
                              n, i.e. the last n
                              −1 symbols of the source node match the first n
                              −1 symbols of the sink node (
                                 v
                                 =
                                 
                                    v
                                    1
                                 
                                 
                                    
                                       
                                          v
                                          2
                                       
                                       …
                                       
                                          v
                                          n
                                       
                                    
                                    ¯
                                 
                               and 
                                 w
                                 =
                                 
                                    
                                       
                                          w
                                          1
                                       
                                       …
                                       
                                          w
                                          
                                             n
                                             −
                                             1
                                          
                                       
                                    
                                    ¯
                                 
                                 
                                    w
                                    n
                                 
                              ). The label of each edge is the last symbol of its sink node (wn
                              ).

Briefly speaking, a De Bruijn graph has all length-n permutations of symbols as the nodes, and they are connected if one node is reachable from the other node by applying a ‘sliding’ operation to its string. Once the De Bruijn graph is built, finding De Bruijn sequences is conceptually very simple. A Hamiltonian cycle
                           2
                        
                        
                           2
                           A Hamiltonian cycle is a cyclic path that visits every vertix exactly once.
                         of G
                        
                           B
                        (n,
                        A) or an Euler cycle
                           3
                        
                        
                           3
                           An Euler cycle is a cyclic path that visits every edge exactly once.
                         of G
                        
                           B
                        (n
                        −1,
                        A) corresponds to a De Bruijn sequence B(n,
                        A). For example, the first example sequence in Fig. 4(a) ‘0011’ is a Hamiltonian cycle ‘00-01-11-10-(00)’ of Fig. 4(b), and the second sequence ‘00010111’ is an Eulerian cycle starting at the edge ‘0’ from the node ‘11’ of the same graph. The third sequence ‘001122021’is a Hamiltonian cycle of Fig. 4(c).

De Bruijn sequences have been used in many fields, including depth sensing using structured light approaches. The biggest problem in applying De Bruijn sequences for depth sensing is that each symbol is not directly sensible from the images. When a series of ‘0’s are in the original sequence, it is not easy to tell how many ‘0’s are observed in the video frame, since the width of observed symbols can change due to the orientation of the target surface (foreshortening effect) and pixellation in the imaging process (see Fig. 5(d)).

Most of the prior works in structured light use conventional De Bruijn sequences and try to separate symbols in the observed images, for example, by putting separators between symbols [2], or applying XOR operations [20]. These approaches cannot be the solution to our problem since we do not explicitly decode the symbols like the structured light methods and the duplicate substrings cause ambiguity in the correspondence matching.

Instead, our approach is to modify the sequence itself to eliminate the recurrences of symbols while maintaining the core property of De Bruijn sequences. The non-recurring De Bruijn sequence is defined as follows.
                           Definition
                           A non-recurring De Bruijn sequence NB(n,
                              A) is a cyclic sequence without any recurring symbols, in which all possible non-recurring length-n sequences of A appear exactly once.

To generate a non-recurring De Bruijn sequence, a modified De Bruijn graph is used. The modification is simply removing all nodes with recurring symbols in the graph and the edges attached to them. Denote this modified De Bruijn graph as G
                        
                           B
                        ′(n,
                        A), and now we show that Hamiltonian cycles of the modified De Bruijn graph are non-recurring De Bruijn sequences.
                           Proposition
                           Let the modified De Bruijn graph G
                              
                                 B
                              ′(n,
                              A) be a graph after removing all nodes with recurring symbols in their labels the edges attached to them in G
                              
                                 B
                              (n,
                              A), Then a Hamiltonian cycle of G
                              
                                 B
                              ′(n,
                              A) is a non-recurring De Bruijn sequence.

From the definition of a De Bruijn graph, each node represents a length-n subsequence, and a Hamiltonian cycle of the graph corresponds to a cyclic sequence that contains all the subsequences, enumerated by sliding the subsequence window by one character in the sequence.

Let G
                        
                           B
                        ′(n,
                        A) be a modified graph from G
                        
                           B
                        (n,
                        A) by removing all nodes containing recurring symbols and corresponding edges, e.g. 
                        Fig. 5(b), (c). From the definition 
                           
                              G
                              
                                 B
                                 ′
                              
                           
                           
                              n
                              A
                           
                         contains all non-recurring length-n subsequences as its nodes, and therefore a Hamiltonian cycle of 
                           
                              G
                              
                                 B
                                 ′
                              
                           
                           
                              n
                              A
                           
                        , if one exists, is a non-recurring De Bruijn sequence.

A non-recurring De Bruijn sequence is the longest sequence whose length-n subsequences are unique, and we can use the sequence to build a projection pattern without any additional separators or encodings. It is not clear whether a non-recurring De Bruijn sequence always exists for any n and A in general. However, we can show that there always exists a non-recurring De Bruijn sequence when n
                        =2, and describe an algorithm to generate an NB(2,
                        A).
                           Proof of existence
                           In a De Bruijn graph G(2,
                              A), the parents and children of a node with recurring symbols always have direct links between them, since if a path xa
                              →
                              aa
                              →
                              ay exists, then an edge xa
                              →
                              ay always exists. Therefore when the nodes with recurring symbols are removed, Hamiltonian cycles passing through the nodes can “detour” along the alternate edges connecting their parent and child, thus they can be modified to generate a non-recurring De Bruijn sequence.


                        
                           
                              
                           
                        
                     

The above algorithm simply removes one of every recurring symbols in the De Bruijn sequence, which corresponds to modifying the Hamiltonian cycle in the proof. For example, B(2,{0,1,2})= 001122021⟹012021 =
                        NB(2,{0,1,2}). One can easily see that the length of an NB(2,
                        A) is k(k
                        −1) where k
                        =|A|.

If the pattern is projected by an optical projector, any pattern can be used. However the pattern is in focus only at a specific depth, and the size of projector may be too big for certain applications with tight restrictions in space or weight. A fixed projection pattern can be generated using a diffractive optical element (DOE) with a laser. A DOE is a piece of glass with very fine graving on the surface, which creates the pattern by diffraction when a laser beam passes through it. There are two types of DOEs: binary DOEs if the graving is only on–off, and multi-level DOEs if multiple depths of graving are needed. Multi-level DOEs can generate arbitrary patterns, whereas binary DOEs can only generate mirror symmetric patterns. Binary DOEs are much easier to design and fabricate than multi-level DOEs. From this practical reason, we pursue mirror symmetry in non-recurring De Bruijn sequences.
                           4
                        
                        
                           4
                           Any conventional De Bruijn sequence is not symmetric, since it has many different recurring substrings such as ‘00’ and ‘11’.
                        
                        
                           Definition
                           A symmetric non-recurring De Bruijn sequence SNB(n,
                              A) is a non-recurring De Bruijn sequence s
                              1
                              …
                              s
                              
                                 N
                               with an additional constraint s
                              
                                 i
                              
                              =
                              s
                              
                                 N
                                 −
                                 i
                                 +1 for all i
                              ∈{1,...,
                              N} where N is the length of the sequence.

In general it is not easy to find a Hamiltonian cycle which corresponds to a symmetric sequence directly from the modified De Bruijn graph. To generate a symmetric non-recurring De Bruijn sequence for n and A, one should generate a non-recurring De Bruijn graph G
                        
                           B
                        ′(n,
                        A), pick a node and start constructing a Hamiltonian cycle in both directions by following edges with the same symbol. If a Hamiltonian cycle is found in this way, it is a symmetric non-recurring Debruijn sequence.

Additionally we present an algorithm that can generate a symmetric non-recurring De Bruijn sequence when n is 2 and k is a prime number larger than 2. The following algorithm generates a symmetric non-recurring De Bruijn sequence SNB(2,
                        A) with A
                        ={0,...,
                        k
                        −1}.


                        
                           
                              
                           
                        
                     

The proof of the correctness of this algorithm is given in the Appendix A, but here we briefly sketch the process. For a given a, the inner-loop adds k symbols that are a-apart from the previous one starting from 0 (which corresponds to the column in the left matrix in Fig. 6
                        ). After concatenating the columns into a string, one can see that the string satisfies all properties of symmetry and a non-recurring De Bruijn sequence.


                        Fig. 7(a) shows a SNB(2,{0,...,6}) sequence generated with the above algorithm. Note that a sequence can be encoded in different ways depending on the actual system setups. If the space-time stereo algorithm is used, the bits in each symbol can be spread into multiple sprites (Fig. 7(b)), or stacked along y-axis if a typical stereo system is used (Fig. 7(c)). It is also possible to use different color channels to encode symbols if color cameras are used.

Recently Konolige [8] proposed a method to find the active projection patterns that improves the performance of stereo systems. The main focus of the work is to find an optimal pattern that each sub-window is maximally distinct, and the minimum Hamming distance ( mhd ) between sub-sequences is used as the optimality measure:
                        
                           
                              M
                              H
                              D
                              
                                 s
                              
                              =
                              
                                 
                                    min
                                    
                                       
                                          |
                                          
                                             s
                                             i
                                          
                                          |
                                          =
                                          |
                                          
                                             s
                                             j
                                          
                                          |
                                          =
                                          n
                                       
                                       
                                          
                                             s
                                             i
                                          
                                          ,
                                          
                                             s
                                             j
                                          
                                          ⊏
                                          s
                                       
                                    
                                 
                              
                              
                                 
                                    ∑
                                    k
                                 
                                 
                                    h
                                    d
                                    
                                       
                                          
                                             s
                                             i
                                          
                                          
                                             k
                                          
                                          ,
                                          
                                             s
                                             j
                                          
                                          
                                             k
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        
                     where hd(a), (b) is the Hamming distance of two symbols a and b, and 
                        s
                        i
                      and 
                        s
                        j
                      are length-n subsequences of a cyclic string s (t ⊏ s denotes t is a subsequence of a cyclic string s).

The difference of NRDB from the approach in [8] is that NRDB algorithm generates the maximum-length sequence for the given alphabet and window size, whereas [8] tries to find the maximum-mhd sequence for the given alphabet and sequence length. In other words, [8] tries to find the best sequence when the maximum disparity is fixed (thus the length of the sequence is given). Note that the maximum mhd of a non-recurring De Bruijn sequence is always 1, since it contains all possible non-recurring subsequences and there exist subsequences that only differ at one location whose Hamming distance is 1.

In this section we describe the algorithm to find the optimal ideal pattern for a given sequence length. The algorithm needs to find a sequence which has the maximum mhd among all possible length-N sequences. This problem can be seen as finding the best length-N cycle in the non-recurring De Bruijn graph. Unfortunately this problem is NP-hard, since finding the best Hamiltonian cycle in the graph with N nodes (traveling salesman problem), which is the sub-problem of the original problem, is already NP-hard. [8] tries to find the sequence using the randomized search with simulated annealing.

We present an algorithm that uses branch-and-bound approach that finds the global optimum. The target of the algorithm is to find an optimal length-N cyclic sequence s
                        ⁎ which maximizes the mhd,
                           5
                        
                        
                           5
                           Note that there may exist multiple optimal sequences, and the algorithm finds one of them.
                        
                        
                           
                              
                                 
                                    s
                                    *
                                 
                                 =
                                 arg
                                 
                                    max
                                    s
                                 
                                 
                                 M
                                 H
                                 D
                                 
                                    s
                                 
                                 ,
                                 
                                 where
                                 
                                 |
                                 s
                                 |
                                 =
                                 N
                                 .
                              
                           
                        
                     

Suppose we start with an L-partial sequence 
                           s
                           L
                         of s (L
                        ≤
                        N, |s
                        
                           L
                        |=
                        N), which has L normal symbols in front and the rest N
                        −
                        L symbols are a special wildcard symbol (denoted as ‘∗’). For example, ‘0121∗∗∗’ is a 4-partial sequence of a length-7 cyclic sequence ‘0121312’. We define the Hamming distance between the wildcard and any symbol to be the maximal value, which is the number of bits used in representing all symbols in the alphabet.

It is important to note that mhd monotonically decreases as the wildcards are replaced with the symbols, which is the process of traversing nodes in the graph. For any length-N cyclic sequence s,
                           
                              
                                 M
                                 H
                                 D
                                 
                                    
                                       s
                                       
                                          L
                                          ′
                                       
                                    
                                 
                                 ≥
                                 M
                                 H
                                 D
                                 
                                    
                                       s
                                       L
                                    
                                 
                                 ≥
                                 M
                                 H
                                 D
                                 
                                    s
                                 
                                 ,
                                 
                                 where
                                 
                                 
                                    L
                                    ′
                                 
                                 ≤
                                 L
                                 .
                              
                           
                        
                     

Therefore, it can be shown that if MHD(s
                        
                           L
                        )≤MHD(s*), then MHD(s)≤MHD(s*). Using this property, we can prune our search space based on the current-best sequence ŝ* and if a better sequence is found it becomes the new current-best sequence. If we finish traversing the whole search space, we can guarantee that the current-best sequence is one of the optimal sequences.

Instead of looking for the optimal sequence of length N in one shot, we can optionally search the final sequence progressively by increasing the sub-sequence length L from lower value to N. If the mhd value of a length-L subsequence reaches the upper bound, we can safely conclude that the found (sub-)sequence is the optimal one, since the maximum mhd of longer sub-sequences should be equal to or less than that of shorter sub-sequences. The algorithm starts with an initial sub-sequence length L
                        0, finds the maximum mhd value for that length, and iteratively searches the maximum mhd values for the longer (sub-)sequences by setting the maximum mhd value of the previous round to be the upper bound of the current round.

For any L-partial sequence 
                           s
                           L
                        , L
                        <
                        L′, the following inequality holds;
                           
                              
                                 M
                                 H
                                 D
                                 
                                    
                                       s
                                       L
                                    
                                 
                                 ≤
                                 M
                                 H
                                 D
                                 
                                    
                                       s
                                       
                                          L
                                          ′
                                       
                                       *
                                    
                                 
                                 ,
                              
                           
                        where 
                           
                              s
                              
                                 L
                                 ′
                              
                              *
                           
                         is the optimal L′-partial sequence. If the search for L′-partial sequence is completed and the optimal L′-partial sequence is 
                           
                              s
                              
                                 L
                                 ′
                              
                              *
                           
                        , then we can stop the search if we find a L-partial sequence ŝ
                        
                           L
                         whose mhd is MHD(s
                        
                           L′), and assign ŝ
                        
                           L
                         to be s
                        
                           L
                        
                        ⁎.

By utilizing a few characteristics of the non-recurring De Bruijn sequence, we can further save computations. Any row permutation and row-wise bit-negation of a projection pattern does not change the Hamming distances between its sub-sequences. This can be easily verified that the pixel correspondences in Hamming distance comparison do not change by permuting rows, and the Hamming distance itself is not affected by bitwise negation. If we represent a cyclic sequence s as an array of bit patterns r
                        
                           i
                         stacked vertically together, i.e. 
                           s
                           =
                           
                              
                                 r
                                 1
                              
                              
                                 r
                                 2
                              
                              …
                              
                                 r
                                 
                                    
                                       
                                          log
                                          2
                                       
                                       
                                          A
                                       
                                    
                                 
                              
                           
                        , where 
                           
                              s
                              k
                           
                           =
                           (
                           
                              r
                              1
                           
                           
                              k
                           
                           ,
                           …
                           ,
                           
                              r
                              
                                 
                                    
                                       log
                                       2
                                    
                                    
                                       A
                                    
                                 
                              
                           
                           (
                           k
                           
                              
                                 )
                                 )
                              
                              Τ
                           
                         and r
                        
                           i
                        (k)∈{0,1}, k
                        ∈1..
                        N. Then
                           
                              
                                 
                                    
                                       
                                          H
                                          D
                                          
                                             
                                                …
                                                
                                                   r
                                                   i
                                                
                                                …
                                                
                                                   r
                                                   j
                                                
                                                …
                                             
                                          
                                          =
                                          H
                                          D
                                          
                                             
                                                …
                                                
                                                   r
                                                   j
                                                
                                                …
                                                
                                                   r
                                                   i
                                                
                                                …
                                             
                                          
                                          ,
                                          
                                          and
                                       
                                    
                                    
                                       
                                          H
                                          D
                                          
                                             
                                                …
                                                
                                                   r
                                                   i
                                                
                                                …
                                             
                                          
                                          =
                                          H
                                          D
                                          
                                             
                                                
                                                   …
                                                   ;
                                                   ¬
                                                   
                                                      r
                                                      i
                                                   
                                                   ;
                                                   …
                                                
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

Therefore we can fix the search to start with a specific symbol (0) at the beginning and the next symbol to be only the ones with distinct number of 1-bits. This is possible because all other cases can be made from this result by row-permutation and row-negation. For example, for 3×3 window case (n
                        =3, k
                        =23), it is sufficient to check the sequences starting with ‘01’, ‘03’, and ‘07’.

With all properties described in the previous section, we can write a recursive algorithm (Fig. 8
                        ) that searches an optimal length-N sequence. In real implementation, the first recursion (‘if i<2’ in Fig. 8) is split into multiple threads to fully exploit the multi-core CPU architecture. On each expansion (‘α
                        ← symbol(j)’) the symbols are randomly re-ordered to avoid searching sequences in a fixed order. The global variables MHD
                           L
                         and MHD
                           U
                         hold the lower and upper bound for the current round (with a given L). The lower bound is updated during the search, and the upper bound is updated after each round is finished.


                        Fig. 9
                         visualizes the relationship between the search algorithm and the non-recurring De Bruijn graph. The algorithm tries to find one of the best length-N cycles in the graph, and each addition of symbols in recursion corresponds to the expansion of the partial cycle in the graph. Only valid nodes with no recurring symbol are expanded, and it does not visit the same node more than once (otherwise this will result mhd to become zero). When a cycle is about to be closed (the last step in Fig. 9), only feasible nodes with links to the starting node will be considered, as shown in the figure.

It is straightforward to modify the algorithm in Fig. 8 to generate a symmetric length-N sequence. It can be done by starting in the middle of the sequence, and adding the same symbol to both ends (Fig. 10
                        ). Note that if N is an odd number, the sequence will end up with recurring symbols at the end. The search for the symmetric sequences runs much faster than the normal sequences since two symbols are added at each step.

In this section, we report a few search results for common stereo configurations using the proposed algorithms. Fig. 11(a) shows the maximum mhd values at each round on different sets of symbols and window sizes. It can be observed that as L gets larger the maximum mhd gets smaller. The upper bound for each round is set in MHD
                           U
                         and the subroutine (subNR_r) returns as soon as the current best mhd reaches MHD
                           U
                        . Otherwise, it needs to check all possible partial-L sequences to confirm that there is no partial-L sequence with MHD
                           U
                        . This exhaustive search takes very long time when L is large, but without branch-and-bound scheme, it is intractable due to the enormous size of the search space. Table 1
                         briefly summarizes the characteristics of the problem and the actual performance of the proposed algorithms. The numbers of all possible combinations when brute-force search for normal and symmetric sequences are given as (k
                        −1)
                           N
                           −2
                        ⋅
                        log
                        2
                        k and (k
                        −1)
                           N/2−1
                        ⋅
                        log
                        2
                        k respectively.

In Fig. 11(b–e), we present the sequences discovered by the search algorithm. Note that the optimal sequence with the maximum mhd is not unique. All equivalent sequences which are generated by row-wise bit-negation and/or row permutation have the same mhd value, and there may exist different sequences that have the same maximum mhd value.

In real implementation, it gives the best performance when the projection-to-imaging pixel ratio is approximately two (also see [8]).
                           6
                        
                        
                           6
                           When the projector and stereo system are mounted closely (compared to the distance to scene), this ratio is mostly determined by the intrinsics of optics, thus it is a realistic assumption.
                         In such case, the above sequences can be used for stereo algorithms with search window size of 5×5 to 11×11 and maximum disparity of 128, which are very commonly used stereo parameters. For other stereo configurations, the best ideal pattern can be generated with the proposed algorithm.

@&#EXPERIMENTS@&#

In this section we present a few experimental results of the NRDB sequence and the effect of mhd in stereo reconstruction. Note that the proposed algorithm is guaranteed to find the optimal sequence in the given setup, and it is not easy to verify this experimentally. Here we show that the proposed NRDB sequence gives better results compared to the gray code and the random patterns, and that the higher mhd indeed leeds to better reconstruction results.

We test the projection patterns using both regular single-frame stereo and space-time stereo implementations using SAD measure. The search window centered at each pixel is compared with the windows on the epipolar line with disparity from 0 to dmax
                        , and the disparity with minimum SAD error is set as the disparity for the pixel. Both left and right disparity maps are built independently and only consistent pixels in the left disparity map are reported as the final disparity map (L/R check). As shown in Fig. 12(a), we used an off-the-shelf optical projector for the experiments and a custom-built stereo rig. Our implementation uses NVidia's CUDA framework, and runs at 30 fps for 320×240 with 200 (subpixel) disparity levels and 5×3×3 spatio-temporal window.

Depending on the algorithms to be used and the configuration of the stereo system, different types of projection patterns are to be used. For space-time stereo, each bit-plane becomes a separate projection pattern, and each bit is stretched out along y-axis (Fig. 7(b)). The pattern presented in Fig. 7(c) is one for generic SAD or SSD grayscale stereo algorithms. The spatial y-axis is used to encode the bits of symbols, thus entire sequence is built into one binary image. For this pattern to work well, the stereo parameters must be chosen appropriately. The search window must be large enough to contain the projected substring in the image, and the maximum disparity must be smaller than the observed length of the sequence. These requirements are not particularly hard to satisfy in reality though.


                        Fig. 12 shows the experimental setup (a), a rectified image frame (d), and results using space-time stereo (b), (c), (e), and (f). The algorithm successfully recovers fine structures such as cables on the table (Fig. 12e,f) or fingers (Fig. 12(b), (c)), since only two stripes are enough to establish a unique signature.

We also tested the single projection pattern (Fig. 7(c)) with our stereo implementation (5×5 window to cover the 2×3 pattern). Fig. 2(a) shows a typical disparity map of untextured scene after applying our stereo implementation. After L/R check stereo fails to give any depth estimate for most of regions and it also gives several incorrect depth estimates. Fig. 2(b), (c), and (d) are the result after the pattern is projected to the scene, which clearly shows the effectiveness of the proposed pattern. In this case there are no motion artifacts since only one pair of frames acquired at the same time are used.

Since both symbols and the sequence are encoded in one pattern, the physical arrangement of the projector and cameras are more important than space-time stereo. There are two requirements for best performance; 1) the pattern's horizontal axis must be parallel to the stereo baseline, and 2) it is desirable to have the projector's optical center on the baseline. When these are met, the observed pattern is well aligned on the epipolar lines regardless of the position and orientation of the target surface. For the experiments in Fig. 2, the second requirement is not satisfied and the wall facing sideways is not correctly reconstructed.

In [10] we presented experimental comparisons with the gray code and random patterns used in space-time stereo literature [6,7]. Since the main application of the work is augmenting conventional stereo, we conducted the comparison with prior arts. In this section and the following section, we used a commercially available Bumblebee 2 stereo camera by Point Grey. It runs its own version of stereo matching algorithm (Triclops) with 7×7 window and L/R check. All projection patterns are fit into 3×64 bit patterns, and they are repeated horizontally and vertically to fill the field of view of the projector (320×240). For comparison we created the projection patterns using 3-bit gray code (3×8 bits), the symmetric NRDB sequence in Section 3.3 (3×41 bits), the optimal 3×3 symmetric pattern in Fig. 11(c), and three random patterns. In all experiments, five images are captured and the average is reported to reduce the effect of noise in capturing process and stereo matching.


                        Fig. 13(e), (f), and (g) shows the reconstructed disparity maps using the stereo algorithm with the patterns. In this experiment, only 3 bits (the number of rows in the pattern in Fig. 13(b)) are used to show the difference between the coding schemes, therefore the projection patterns are built by arranging the 8 unique columns (from 000 to 111). The 3-bit gray code pattern is constructed by simply concatenating the 8 columns, and due to its short length the same pattern is repeated within the stereo's maximum disparity search range, thus it leads to very poor results in reconstruction. Similar situation happens in the symmetric NRDB sequence, where several pixel correspondences are not correctly found. The optimal subsequence pattern gives the best reconstruction results, whereas the performance of random patterns varies depending on the specific bits set in the sequences.

In addition to the qualitative evaluation, the quantitative comparison results are shown in Table 2
                        . First we compare the ratio of pixels with valid disparity (Coverage column). The non-black pixels in the mask (Fig. 15(b)) are visible in both views and shined by the pattern, thus we count the number of valid pixels in the region. The coverage of the optimal subsequence reaches close to 99%, and the random sequences perform comparably well.

To evaluate the accuracy of reconstruction, the distance of the reconstructed points to the planes in the scene, whose plane parameters are estimated from several (5 to 9) manually-selected scene point matches. The reported accuracy is the average distance to the plane (in meters) and the standard deviation from the mean. In the test scene there are two planes, and the accuracy for each plane as well as the overall statistics are reported in the Accuracy column. The depthmaps built using the optimal sequence give the most accurate and stable result compared to other methods.

We also experimentally tested the accuracy and coverage of the reconstruction according to the mhd of the patterns. In this experiment we used the stereo parameters of 9×9 window and L/R check, and the projection patterns of length 64 and 5×5 window with different mhd are projected to the scene. We used the mhd of 4, 7, and 10 for comparison, since the simplest 5×64 subsequences such as [0,1,…,31,0,2,…,30,1,3,…,31] or [31,30,…,1,0,1,2,…,31,0] have mhd =4. For the mhd=10 case, the sequence in Fig. 11(e) is used.


                        Fig. 14
                         shows the effect of the active projection on a textured scene (b–c). The holes and noisy areas in textureless regions in (b) disappear when the pattern is projected in (c). Unlike the structured light, texturedness of the scene does not degrade the performance of active stereo, and this verifies that the projection pattern acts as supplementary information for stereo matching.


                        Fig. 15
                         demonstrates the effect of larger mhd on the reconstruction quality. The difference between with and without projection is large even when the mhd of the projection pattern is small (c vs. d). As mhd increases, the reconstructed disparity map becomes fully filled and less noisy.

The quantitative results, computed in the same way as in the previous section, are shown in Table 3
                        . When the mhd=4 pattern is used, the coverage becomes more than 99%, and as the mhd increases the coverage slowly increases as well. To estimate the three planes in the scene, we used all 15 (3×5) depthmaps estimated with the projection patterns. As expected, the accuracy is enhanced when a higher mhd sequence is used.

Finally we report the statistics of ‘inlier’ points by filtering the outlier points that are further than 30cm from the planes (last column). The ratio of inlier pixels and the average distance of inlier pixels are reported. As mhd increases, more pixels are estimated accurately (becoming inliers), but the distance to the plane tends to saturate. The reason may be the limitation of the stereo matching algorithm (no fine subpixel matching) and the pixel size in the rectified image. From the experiments, we can verify that the performance of stereo matching increases as larger mhd sequences are used.

@&#CONCLUSION@&#

In this work, we propose a novel concept of non-recurring De Bruijn sequences and projection patterns for the stereo systems from the sequences. The proposed patterns are designed to work with the existing stereo systems without any change, and they greatly improve the coverage and quality of depth estimation especially in untextured areas. Since the active pattern projection only adds the texture in the scene, the stereo system can still be functional when the projected pattern is not visible or the projection module is turned off. We experimentally show that the proposed pattern works well in the real environment and have benefits over the existing algorithms.

We also presented a novel global search algorithm for the optimal pattern for the given stereo search window size and maximum disparity parameters. The proposed branch-and-bound algorithm utilizes the lower and upper bounds of partial sequences, and it guarantees the result sequence to be a globally optimal one.

@&#ACKNOWLEDGEMENT@&#

We thank the reviewers for valuable comments and suggestions. The work is supported by the MSIP, Korea, under the ICT R\&D programs (No. 10047078 and No. 14-824-09-006) and the C-ITRC (IITP-2015-H8601-15-1005), supervised by the IITP.

We show the proof that the SNB2(k) algorithm in Section 3.3 generates symmetric non-recurring De Bruijn sequences.

If all indices from 0 to k
                        −1 are placed on a circle, mod(⋅,
                        k) operator maps any integer to one of these indices (see Fig. 6).

The subsequence generated by each inner loop execution always starts with 0, followed by the index whose distance on the circle to the previous output is a. The next of the last index is 0 (i.e. mod(a
                        ×
                        k,
                        k)=0). Since k is a prime number, each inner loop execution outputs all possible indices only once, and each index ia,b
                         is mod(i
                        
                           a,b
                           −1
                        +
                        a,
                        k) for b
                        >0. As a is increased from 1 to k
                        −1, every length-2 subsequences xy in the entire output sequence has a unique pair of starting index x and counter-clockwise distance on circle a
                        
                           xy
                        
                        =
                        mod(y
                        −
                        x,
                        k), which means there is no other occurrence of xy in the sequence.

Also the length of output sequence is k(k
                        −1) which is the number of all possible length-2 combination of symbols. Therefore the output sequence generated by this algorithm is a non-recurring De Bruijn sequence.□

We need to show seq(i
                        0
                        +
                        c)=
                        seq(i
                        0
                        −
                        c) for any 
                           0
                           ≤
                           c
                           <
                           
                              
                                 k
                                 
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                              2
                           
                        , where 
                           
                              i
                              0
                           
                           =
                           
                              
                                 k
                                 
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                              2
                           
                        . For any location i in the output sequence, 0≤
                        i
                        <
                        k(k
                        −1), the corresponding a and b can be computed as a
                        =⌊i/k⌋+1 and b
                        =
                        i
                        −
                        k⌊i/k⌋. Also we can decompose c into c
                        =
                        pk
                        +
                        q, where p,q are non-negative integers and 0≤
                        q
                        <
                        k.

For i
                        0
                        +
                        c, 
                           
                              a
                              +
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             k
                                             
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          2
                                       
                                       +
                                       p
                                       k
                                       +
                                       q
                                    
                                 
                                 /
                                 k
                              
                           
                           +
                           1
                           =
                           
                              
                                 k
                                 −
                                 1
                              
                              2
                           
                           +
                           p
                           +
                           1
                        , and 
                           
                              b
                              +
                           
                           =
                           
                              
                                 k
                                 
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                              2
                           
                           +
                           p
                           k
                           +
                           q
                           −
                           k
                           
                              
                                 
                                    
                                       k
                                       
                                          
                                             k
                                             −
                                             1
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 p
                              
                           
                           =
                           q
                        . (since k is a prime number larger than 2, 
                           
                              
                                 k
                                 −
                                 1
                              
                              2
                           
                         is an integer).

For i
                        0
                        −
                        c, 
                           
                              a
                              −
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             k
                                             
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          2
                                       
                                       −
                                       p
                                       k
                                       −
                                       q
                                    
                                 
                                 /
                                 k
                              
                           
                           +
                           1
                           =
                           
                              
                                 k
                                 −
                                 1
                              
                              2
                           
                           −
                           p
                        , and 
                           
                              b
                              −
                           
                           =
                           
                              
                                 k
                                 
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                              2
                           
                           −
                           p
                           k
                           −
                           q
                           −
                           k
                           
                              
                                 
                                    
                                       k
                                       
                                          
                                             k
                                             −
                                             1
                                          
                                       
                                    
                                    2
                                 
                                 −
                                 p
                                 −
                                 1
                              
                           
                           =
                           k
                           −
                           q
                        .

Therefore, 
                           s
                           e
                           q
                           
                              
                                 
                                    i
                                    0
                                 
                                 +
                                 c
                              
                           
                           =
                           mod
                           
                              
                                 
                                    
                                       
                                          
                                             k
                                             −
                                             1
                                          
                                          2
                                       
                                       +
                                       p
                                       +
                                       1
                                    
                                 
                                 q
                                 ,
                                 k
                              
                           
                           =
                           mod
                           
                              
                                 
                                    
                                       k
                                       +
                                       1
                                    
                                    2
                                 
                                 q
                                 +
                                 p
                                 q
                                 ,
                                 k
                              
                           
                           =
                           mod
                           
                              
                                 
                                    
                                       k
                                       q
                                    
                                 
                                 −
                                 
                                    
                                       k
                                       −
                                       1
                                    
                                    2
                                 
                                 q
                                 +
                                 p
                                 q
                                 ,
                                 k
                              
                           
                           =
                           mod
                           
                              
                                 
                                    
                                       
                                          
                                             k
                                             −
                                             1
                                          
                                          2
                                       
                                       −
                                       p
                                    
                                 
                                 
                                    
                                       k
                                       −
                                       q
                                    
                                 
                                 ,
                                 k
                              
                           
                           =
                           s
                           e
                           q
                           
                              
                                 
                                    i
                                    0
                                 
                                 −
                                 c
                              
                           
                        .□


                     
                        
                           
                              Supplementary Video 1
                           
                           
                        
                     
                     
                        
                           
                              Supplementary Video 2
                           
                           
                        
                     
                     
                        
                           
                              Supplementary Video 3
                           
                           
                        
                     
                     
                        
                           
                              Supplementary Video 4
                           
                           
                        
                     
                     
                        
                           
                              Supplementary material 1
                           
                           
                        
                     
                     
                        
                           
                              Supplementary Video 5
                           
                           
                        
                     
                     
                        
                           
                              Supplementary Video 6
                           
                           
                        
                     
                     
                        
                           
                              Supplementary material 2
                           
                           
                        
                     
                  

Supplementary data to this article can be found online at http://dx.doi.org/10.1016/j.imavis.2015.04.004.

@&#REFERENCES@&#

