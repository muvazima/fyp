@&#MAIN-TITLE@&#Biharmonic fields and mesh completion

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A volumetric mesh repair algorithm, based on bi-harmonic fields.


                        
                        
                           
                           The pre-computation of a volume mask to over-constrain the boundary conditions.


                        
                        
                           
                           A discrete solution of the bi-harmonic equation based on a quadratic optimization.


                        
                        
                           
                           A fully automatic algorithm for massive hole repair in very large triangle meshes.


                        
                        
                           
                           The ability to handle complex hole topologies having islands and general shapes.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Model repair

Thin-plate energy

Volumetric methods

@&#ABSTRACT@&#


               
               
                  We discuss bi-harmonic fields which approximate signed distance fields. We conclude that the bi-harmonic field approximation can be a powerful tool for mesh completion in general and complex cases. We present an adaptive, multigrid algorithm to extrapolate signed distance fields. By defining a volume mask in a closed region bounding the area that must be repaired, the algorithm computes a signed distance field in well-defined regions and uses it as an over-determined boundary condition constraint for the biharmonic field computation in the remaining regions. The algorithm operates locally, within an expanded bounding box of each hole, and therefore scales well with the number of holes in a single, complex model. We discuss this approximation in practical examples in the case of triangular meshes resulting from laser scan acquisitions which require massive hole repair. We conclude that the proposed algorithm is robust and general, and is able to deal with complex topological cases.
               
            

@&#INTRODUCTION@&#

Repairing mesh holes in very large geometric models is nowadays still a challenge. Mesh completion algorithms should be automatic, stable and robust, to cope with a huge number of unrepaired regions having unpredictable topologies.

The motivation of this paper came from a cultural heritage project aiming at the acquisition and 3D reconstruction of the entrance of the Ripoll Monastery in Spain. The monument is also known as the “Portalada”, and is the main Romanic sculpture in Catalonia, dating back to the 12th century. The total size of the mesh after registration was in the vicinity of 173 M triangles, presenting 14,622 holes of different sizes. More details on the project can be found in [1]. Holes and cracks were automatically detected through a search for cycles of border edges, and simple holes could be repaired by projecting their boundary onto a suitable plane and triangulating the projection without adding Steiner points. Classical mesh repair algorithms, however, were not able to handle some large holes or holes with complex boundaries, as discussed later in the paper.

In this paper, we present a novel algorithm that solves and repairs complex hole configurations without user intervention. Our approach is based on several ideas. We compute a suitable approximation of the signed distance field to the mesh in a volumetric data structure, in the vicinity of a hole. Other authors (see [2]) have used diffusion equations or other variational formulations to obtain smooth signed distance fields. We choose to find a 3D thin-plate solution of the bi-harmonic equation to guarantee C
                     1 continuity with the mesh around the repaired area. The repairing surface is then obtained as the zero-isosurface of the scalar bi-harmonic field. The algorithm starts by computing a volume mask which defines a region where the signed distance to the mesh around the hole can be computed robustly, and uses this distance field in that region to over-constrain the boundary conditions of the bi-harmonic equation. A discrete approximation of the bi-harmonic field is obtained by solving a quadratic optimization problem with a multigrid adaptive solver. One of the remarkable features of our approach is that it is able to successfully address complex topologies with disconnected mesh regions in a robust way. Our algorithm provides a means to automatically repair holes in very large triangle meshes with a smooth blending at the boundaries. Obviously, it is possible to construct intricate examples for which the proposed algorithm would fail – or at least fail to match our intuition – but our extensive tests using real data from laser scans show that the algorithm does consistently handle them in a very satisfactory way without supervision.

Our approach was also inspired by [2]. However, as discussed in the next Section, they used the heat diffusion equation which results in a C
                     0 field. To reach C
                     1 continuity with the hole border regions, they included a heuristic step in each iteration by adding a heat source term after each diffusion step. We claim that in order to obtain general volume-based solutions for the mesh repair problem, the heat equation is not sufficient. Instead, we show that bi-harmonic fields do provide acceptable results.

The main contributions of the presented algorithm are:

                        
                           •
                           A volumetric mesh repair algorithm, based on the local computation of a bi-harmonic field approximation of the signed distance field. A key ingredient in the solution is the pre-computation of a volume mask to delimit a region where the signed distance is well-defined, and can be used to over-constrain the boundary conditions of the bi-harmonic equation over the whole domain.

A discrete solution of the bi-harmonic equation based on a quadratic optimization, with a multi-grid adaptive repair algorithm. As a direct consequence of using the biharmonic equation, we obtain tangent continuity and we don’t have to include extra empirical steps like in previous approaches.

A fully automatic algorithm for massive hole repair in very large triangle meshes, including the detection of mesh areas with holes, their repair and post-processing.

The ability to handle complex hole topologies having islands and general shapes.

The next two Sections present an overview of the prior art and of our proposed algorithm. Section 4 details the generation of the initial distance field and our bi-harmonic field approximation, while Section 6 discusses the acceleration of the computation and adaptive solutions that have been implemented. The last two sections present and discuss the results and detail the conclusions of the paper.

The need to repair surface models has always been present regardless of their source. Since the general repair problem is inherently ill-posed (due to ambiguities), production in this subfield has been ongoing. The first algorithms developed to address this challenge attempted to characterize all possible defects (gaps, holes, self-intersections, degeneracies, loss of sharp features, noise, topology problems, …). Various surveys detail these problems and many of the contributions that have been proposed to solve them until now [3,4]. It would also be possible to apply solutions designed for the reconstruction of point cloud models to these problems, even though that would imply discarding the connectivity information available in the model. Point-cloud solutions also place less emphasis than our algorithm on preserving the geometric information of the original mesh. A good overview can be found in Berger et al. [5], which contains an extensive analysis of these techniques.

The first solutions focused on directly repairing meshes. Liepa [6] proposed a step-based algorithm in which the holes were identified, triangulated, the resulting mesh patch refined, and finally, smoothed. More recently Bac et al. [7] introduced a similar method where refining the mesh and minimizing bending energy were alternated. Both methods share their inability to deal with holes with “islands” (see Fig. 7(p) for an example of holes with islands and how it is handled by our algorithm).

Another group of approaches to the problem used a different strategy. Solutions known as volumetric methods start from a model to be repaired (a mesh or point cloud) and transform it into a volume where multiple defects can be treated uniformly. Volumetric methods also guarantee surfaces free of self-intersections. The main differences within this group of methods come from the process used to transform the input model into a volume and the algorithm applied to complete the repair if the first step is insufficient.

Some of these volumetric techniques build an octree to represent the surface and use it to help in the repair of the entry model. For example, in [8], Ju computes signs for the vertices of the octree nodes consistently with the intersections between the triangles of the mesh and the edges of the octree. These signs serve later to extract an isosurface without defects, but that only approximates the original mesh. Instead, in [9] the user provides a maximum tolerance error for the corresponding octree construction ensuring that the final mesh does not deviate beyond this distance. This approach excels at repairing CAD models, but is not applicable to models resulting from a scan, since the holes can be hundreds of times greater than the average edge size.

Other techniques compute a signed distance field. Davis et al. [2] calculate an initial signed distance field near the surface, over which they alternate the application of a low-pass filter with a composition operator. This solution is based on a perturbed heat diffusion simulation. The authors use a 3 × 3 × 3 heat kernel to diffuse high confidence signed distance values to the area missing data. However, and after each diffusion step, the authors add an empirical source term into each node, representing the addition of heat to the system. These diffusion and addition steps correspond to their convolution and compositing steps. The final patches interpolate the edges of the hole adequately but empirical steps must be tuned in order to achieve normal continuity. Nooruddin and Turk [10] throw rays in multiple directions counting the number of intersections with the model. Using the parity rule on the resulting data they compose a distance field that represents the repaired model, but they require that all defects are treated simultaneously which may be inefficient for larger objects. Other authors attempt to calculate an initial field, extending the distance values obtained using some interpolation technique, and the help of an expert user in the case of complex shapes. In particular, Masuda [11] used quadratic functions to perform this extension of the distance field. Brunet et al. [12] also use an iterative algorithm that alternates smoothing steps – based on B-splines – and fitting steps, but their method requires an initial triangulation of the detected holes, which could adversely affect the outcome.
                  

These previous works often focus on closed meshes with some imperfections, and therefore try to complete all boundaries. Thus, a direct comparison with our framework is not possible. In order to compare them, we have completed one of our sample holes with a portion of its bounding box, and run those algorithms on the resulting closed – but defective – mesh. The results are shown in Fig. 1. In this example, Nooruddin and Turk [10] delete a portion of the original mesh (Fig. 1(d)), Liepa [6] does not blend smoothly at the boundary (Fig. 1(e)), and Ju [8] produces triangles that are too large (Fig. 1(f)), and all three solutions join the boundary with only C
                     0 continuity. Fig. 1(g) shows the result of Kazhdan and Hoppe [13] which maintains the continuity, but still presents anomalous protuberances and cavities. Since Kazhdan and Hoppe [13] compute the surface adding the input point cloud data to the optimization as restrictions, noise at the hole boundary strongly influences the result.

There are also algorithms that get rid of the requirement of using signed distances in order to handle point clouds directly. Hornung and Kobbelt [14] propose immersing the point data in a voxelization so an unsigned distance field can be computed. The resulting distance values can be interpreted as inverse-likelihoods of the voxel being visited by the surface. Feeding this information into a min-cut algorithm yields a classification of the voxels’ faces. This algorithm has the potential of producing a manifold boundary from the vertices alone, but does not respect the initial data points. Instead, it resamples the data at the frequency of the highest resolution used.

Other authors have used bi-harmonic solutions to extend geoemtry, like Jacobson et. al. [15], although their focus was on developing modeling techniques.

The methods above have a tendency to use smooth patches to fill holes surrounded by complex patterns, another set of proposals attempt to reproduce the original shape of the model – in a plausible way. One possibility is to apply principles similar to those used in texture synthesis and fill the holes with pieces of geometry that fit in from the model itself. Sharf et al. [16] use local implicit approximations in order to measure the similarity between two patches. These patches are put in place using first a rigid transformation followed by an iterative closest point procedure with non-rigid transformations. The underlying assumption in all of these methods is that an appropriate shape continuation can be inferred from the acquired sample points only, using generic smoothness or self-similarity priors for missing parts of the model. Kraevoy and Sheer [17] use instead template-based completion techniques. Their method computes a mapping between the incomplete input mesh and the template to correctly close gaps and holes.

An advantage of our algorithm is the fact that we can minimize the distance from the computed to the original mesh. This allows us to use pieces of the resulting isosurface to close the holes (as done in [12]), while preserving the original geometry elsewhere.

@&#OVERVIEW@&#

Our approach is aimed at repairing and completing very complex meshes in a robust and automatic way. As mentioned, our work was initially motivated by the case presented in [1], where a mesh of 173 million triangles with more than 14,000 holes had to be repaired. Cases from real applications like [1] with very large acquired meshes require fully automatic and reliable algorithms. In our opinion, volumetric schemes are well suited to fulfill these requirements.

The input of the algorithm is an unrepaired triangle mesh. Fig. 2
                      shows the steps of our algorithm on a sample hole in the mesh reported in [1]. The operation of the algorithm is fully automatic and requires no special parameters to be set by the user to achieve these results.

Our algorithm starts by detecting all border edges (triangle edges which do not belong to any other triangle). Holes are identified as closed loops of border edges. Every hole is then associated with its extended bounding box BH
                     , which is obtained by extending its bounding box by 20% in each coordinate direction. By computing these extended bounding boxes, we ensure that a sufficient part of the mesh around the hole is included in BH
                     .

Our algorithm is based on several key ingredients. We identify individual holes and work to repair each one using a volumetric technique in its extended bounding box. We define a volume mask to introduce extra constraints to a bi-harmonic equation, and compute a discrete bi-harmonic field by solving a constrained optimization problem. We generate the repairing surface as the zero isosurface of this bi-harmonic field, ensuring an elegant and robust solution that blends smoothly, with tangent continuity, with the original mesh. The consequence is that we obtain a much more stable solution, fairly insensitive to noise at hole border edges. This is specially important in meshes coming from laser scan acquisitions, in which hole borders are limit regions, next to regions the sensors fail to digitize, and therefore noisy. Defining the distance field in a broader band is essential to ensure the stability of the solution. From our experiments with a large number of complex holes we have concluded that increasing the constrained volume during the solution of the biharmonic equation always increases the stability and robustness of the final solution, see Section 7 for a summary of results.
                  

The next steps of the algorithm, detailed below, are then repeated for each detected hole. It may occur that the extended bounding box BH
                      of a certain hole H contains other small holes. These secondary holes are also repaired as a byproduct of the repair process of H.

                        
                           •
                           A uniform grid is defined in the volume BH
                              , with a resolution similar to the size of the triangles in this extended bounding box. More specifically, we compute the grid resolution to ensure that no triangle edge in BH
                               will be greater than the grid edge size. Observe that, due to the locality of the BH
                               volumes, the grid resolution is automatically adapted to the size of the mesh triangles in the vicinity of the hole. This is important in huge meshes having different triangle resolutions in different regions. We have experimentally observed that a resolution of 1283 is usually acceptable, although in some cases the optimal resolution may be 643 (for small holes) or 2563 may be needed, in the case of very big holes.

For all BH
                               grid vertices, two distances are computed: the unsigned distance to the mesh triangles in BH
                               and the unsigned distance to the border edges of the hole H. This is detailed in Section 4.1.

A mask defining a partition in the discrete volume BH
                               is computed. This splits the discrete volume BH
                               into two disjoint regions RD
                               (distance-field region) and RB
                               (biharmonic field region). As shown in Section 4.1, RD
                               is a closed region where a signed distance to the mesh around the hole can be robustly computed, while RB
                               is the region closer to the hole, where we want to smoothly extend the distance computed inside RD
                              . In what follows, we define the mask as the characteristic function of RD
                              , Fig. 2(b).

A signed distance field is computed for every mesh vertex in RD
                               as the distance to the mesh, as detailed in Section 4.1.

A discrete bi-harmonic field is computed by solving a constrained optimization problem, see Section 4.2. The field is defined in BH
                               and the algorithm works by optimizing its smoothness. A key ingredient of the scheme is the use of over-constrained bi-harmonic boundary conditions. A plausible and C
                              1 continuous solution is obtained by requiring all grid vertices in RD
                               to be as close as possible to the pre-computed signed distance field values. By over-constraining the boundary conditions of the bi-harmonic function, we obtain a stable and robust solution, as discussed in Section 7, (see also Fig. 2(d)).

The computation of the bi-harmonic field is accelerated by using a multigrid solver with adaptive refinement, as detailed in Section 6.

Once the bi-harmonic field is computed, the hole is closed by stitching the zero-isosurface of the field with the triangles in the vicinity of the border edges (see Section 5).

Observe that, unlike some previous approaches, our algorithm does not require an initial triangulation of the holes. The computation of the bi-harmonic field is driven by the mask M and the signed distance field in the region RD
                     .

In [2], alternating steps of blurring and compositing are used to diffuse the sign distance value iteratively. Our approach is simpler and does not require any compositing step to conveniently increase the heat value at each step. The compositing step in [2] is required to smoothen diffusion solutions which by definition are not tangent-smooth. In our case, by increasing the order of the PDE, we directly obtain the desired continuity as a by-product of the mathematical model that we use. We also over-constrain the boundary bi-harmonic conditions to ensure that the zero iso-surface will adequately approximate the initial mesh around the holes. Compare Figs. 8 and 10 for a laboratory example of how the over-constraining affects the quality of the result.

We start by defining a uniform grid in the volume BH
                         of each mesh hole. The grid resolution is chosen to guarantee that cell sizes are of the order of the size of the triangles in BH
                        .

Next, we compute a region RD
                         of BH
                         such that it contains all the grid-cells that contain triangles, and the cells containing triangle split RD
                         in two disjoint regions 
                           
                              R
                              D
                              +
                           
                         and 
                           
                              R
                              D
                              −
                           
                        . By this we mean that any continuous path joining a point in 
                           
                              R
                              D
                              +
                           
                         with a point in 
                           
                              R
                              D
                              −
                           
                         must go through a cell that contains mesh traingles. On top of these necessary conditions, we have found that it is desirable for RD
                         to be as large as possible – to have a large number of cells in it – as this increases the stability of solutions. We define a mask as the characteristic function of RD
                        , so in an abuse of notation occasionally refer to it as the mask RD
                        . In this region RD
                         we can compute a signed distance to the mesh robustly, and these values are used as boundary conditions for the bi-harmonic field we intend to compute, thus smoothly extending this field to RB
                        , the complement 
                           
                              
                                 B
                                 H
                              
                              −
                              
                                 R
                                 D
                              
                           
                         of RD
                        . As discussed in Section 4.2, the signed distance field to the mesh in the mask region RD
                         works like an over-determined set of boundary conditions for the computation of the bi-harmonic field in the domain BH
                        . The computation of optimal masks for general mesh topologies in BH
                         is however beyond the scope of this paper and will be investigated as part of our future work.

In our present implementation, we use distance fields to compute the mask. We start by computing two unsigned distances for every grid vertex in BH
                        : the unsigned distance to the mesh triangles in BH
                         and the unsigned distance to the border edges of the hole H. Then, the region RD
                         is defined as the set of BH
                         grid vertices such that their distance to the mesh triangles in BH
                         is less than the distance to the border edges of the hole H. The complement of RD
                         in BH
                         is defined as the region RB
                        , the set of grid vertices such that their distance to the mesh triangles equals the distance to the border edges of the hole. Fig. 3 shows the mask and the regions RD
                         and RB
                         in a simple 2D example. Both unsigned distance fields are computed by using a priority queue while iteratively propagating distances from cells containing mesh triangles to neighbor cells.

A signed distance field to the mesh around the hole can now be computed for every mesh vertex in RD
                         by simply using the sub-regions 
                           
                              R
                              D
                              +
                           
                         and 
                           
                              R
                              D
                              −
                           
                         to assign coherent signs to the already computed distance field to the mesh.

Our approach solves the mesh completion problem in each BH
                         by computing a discrete bi-harmonic approximation to the signed distance field to the mesh.

Let OH
                         be the set of grid vertices in the two outer layers of the BH
                         grid. We use a discrete approximation of the bilaplacian for each grid vertex V in 
                           
                              
                                 B
                                 H
                              
                              −
                              
                                 O
                                 H
                              
                              ,
                           
                         involving a 5 × 5 × 5 kernel. This kernel is a straightforward 3D extension of the well-known 2D discrete bilaplacian on uniform grids expressed as a symmetric convolution. Its first three slices are:

                           
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                [
                                                
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                                ]
                                             
                                             ,
                                             
                                                [
                                                
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         
                                                            −
                                                            12
                                                         
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                                ]
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                                [
                                                
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         
                                                            −
                                                            12
                                                         
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            −
                                                            12
                                                         
                                                      
                                                      
                                                         42
                                                      
                                                      
                                                         
                                                            −
                                                            12
                                                         
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         
                                                            −
                                                            12
                                                         
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                                ]
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To ensure a smooth behavior of the field on the boundaries of BH
                        , we also include a laplacian optimization term for every grid vertex in OH
                        . In short, we have laplacian terms for grid vertices in the two outer layers of the BH
                         grid and bilaplacian terms for the rest of grid vertices.

The second part of the optimization function includes the constraints or boundary conditions. For every grid vertex V in RD
                        , we impose that its final value F(V) should be equal to the value of the already computed signed distance field D(V) at this point.

In other words, instead of trying to find the field F(V) by solving the bilaplacian equation 
                           
                              
                                 Δ
                                 2
                              
                              
                                 (
                                 F
                                 
                                    (
                                    V
                                    )
                                 
                                 )
                              
                              =
                              0
                           
                         for all grid vertices in BH
                        , we solve a constrained optimization problem by computing:

                           
                              
                                 
                                    
                                       
                                          a
                                          r
                                          g
                                          m
                                          i
                                          n
                                       
                                       F
                                    
                                    ∑
                                    
                                       
                                          (
                                          
                                             Δ
                                             2
                                          
                                          F
                                          
                                             (
                                             V
                                             )
                                          
                                          )
                                       
                                       2
                                    
                                 
                              
                           
                        for all V in BH
                        , with the constraint 
                           
                              F
                              (
                              V
                              )
                              =
                              D
                              (
                              V
                              )
                           
                         for all V in RD
                        .

To avoid potential instabilities produced by mesh noise in the vicinity of the holes which can be visible in the D(V) field, we convert the constrained optimization into an unconstrained optimization problem:

                           
                              (1)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                
                                                   a
                                                   r
                                                   g
                                                   m
                                                   i
                                                   n
                                                
                                                F
                                             
                                             
                                                (
                                                λ
                                                
                                                   ∑
                                                   
                                                      V
                                                      ∈
                                                      
                                                         B
                                                         H
                                                      
                                                      −
                                                      
                                                         O
                                                         H
                                                      
                                                   
                                                
                                                
                                                   
                                                      (
                                                      
                                                         Δ
                                                         2
                                                      
                                                      F
                                                      
                                                         (
                                                         V
                                                         )
                                                      
                                                      )
                                                   
                                                   2
                                                
                                                )
                                             
                                             +
                                             λ
                                             
                                                ∑
                                                
                                                   V
                                                   ∈
                                                   
                                                      O
                                                      H
                                                   
                                                
                                             
                                             
                                                
                                                   Δ
                                                   (
                                                   F
                                                   (
                                                   V
                                                   )
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                (
                                                1
                                                −
                                                λ
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                                ∑
                                                
                                                   
                                                      V
                                                      ′
                                                   
                                                   ∈
                                                   
                                                      R
                                                      D
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   F
                                                   
                                                      (
                                                      
                                                         V
                                                         ′
                                                      
                                                      )
                                                   
                                                   −
                                                   D
                                                   
                                                      (
                                                      
                                                         V
                                                         ′
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This optimization problem is quadratic, with a well-defined solution involving a linear system of equations. We have observed that the solution of this unconstrained problem is more robust and stable.

As discussed also in Section 7, this bi-harmonic solution is well behaved even for complex topological configurations like holes containing islands of groups of mesh triangles and unrepaired areas with complex geometries.

To obtain a repaired mesh, we have to blend the isosurface mesh MF
                      of volume F(V) (extracted using Marching Cubes) with the original mesh MO
                     . Before stitching the two meshes together, we discard the 1-ring of each hole, because in practice we find it is usually very noisy and decreases the quality of the result (other applications that require it, may choose, however, to preserve them). After that we move the isosurface vertices closer to the hole using the gradient of F(V) and taking into account the distance from each affected vertex to the hole. We do this applying the following translation:

                        
                           
                              
                                 −
                                 
                                    λ
                                    
                                       h
                                       o
                                       l
                                       e
                                    
                                 
                                 
                                    (
                                    V
                                    )
                                 
                                 ·
                                 F
                                 
                                    (
                                    V
                                    )
                                 
                                 ·
                                 ∇
                                 F
                                 
                                    (
                                    V
                                    )
                                 
                              
                           
                        
                     where λhole
                     (V) is a monotonic function that returns a value in [0, 1] depending on the distance from V to the hole. In our implementation λhole
                      returns one if V is on the hole and zero when V is at a distance over three times the length of the average edge in MO
                     .

Now we need to connect the mesh resulting from the previous step with the original mesh MO
                     . To do this we obtain the set of all voxels Chole
                      of F(V) that are intersected by the chain of edges of the hole. We can then join the two meshes by applying a vertex clustering operation to the vertices in each of the voxels in Chole
                     . However, this causes the merge result of the two meshes to no longer be a 2-manifold. To fix this, we must remove the part of the mesh MF
                      that is outside of the hole to be repaired.

To perform this last step we compute the set of voxels Cmesh
                      that contain triangles of the original mesh. We then execute a voxel flood filling algorithm that starts from the voxels in Chole
                      and avoids traversing voxels from Cmesh
                     . The set of visited voxels Cpatch
                      contains the triangles of the mesh that we need to keep. All those that belonged to MF
                      but do not intersect Cpatch
                      are eliminated.

In some cases the algorithm may leave a few small holes at the connection area between the isosurface and the original mesh. These are simple, sub-voxel holes that we simply fill by triangulating their boundary.

We are not aware of any mesh-stitching algorithm that is robust and correct under all circumstances; our algorithm provides an heuristic that seems to yield good results in practice, but may be replaced by the stitching algorithm of preference. For example, one could adapt the algorithm proposed in [18] to act as a stitching algorithm here, leaning on the distance field computed by our algorithm. Finding a robust and general stitching algorithm is an interesting avenue of work.

The system set forth in the previous sections is sufficient to successfully solve the formulated problem, but solving it directly using an iterative approach risks getting stuck in suboptimal solutions (local minima, as illustrated in Fig. 4
                     ). Applying a direct solver instead is too expensive, even for small resolutions (323, 643). Since we may find large holes or complex shapes that require higher resolutions, we need to improve its efficiency. In this section we present how to extend the basic implementation using an adaptive multiresolution scheme.
                  

To address the high cost of solving the complete system at higher resolution, we first obtain a good estimate of field distances at a lower resolution (163 or 323, depending on the complexity and size of the hole) through a direct solver and then use the resulting solution to construct an initial guess of an iterative solver at higher resolutions.

If the size of the voxelization that we want to apply to the solution of the problem is N
                        3, we choose a resolution M
                        3 where M < N, and down-sample by discarding values. No interpolation mechanism is used during this step which helps to facilitate the construction of the corresponding mask of size M
                        3 because, as described in the previous section, the mask can only take one of two values (in/out RD
                        ). It is also important to note that the result of this decreased resolution system will be used as the initial value of the iterative algorithm, not as the final solution.

After solving the system of size M
                        3 using a direct solver (Cholesky in our implementation), we need to apply a process of up-sampling to obtain a distance field of size N
                        3. For this step we could apply many interpolation schemes. In our current implementation we have tested both trilinear interpolation and more sophisticated Bspline-based interpolations. Using splines gives a smoother estimate and, in many cases, closer to the desired solution, but the cost is substantial when compared with other steps (for an example, see Section 7, Table 1
                        ). We have therefore desisted from using any more precise interpolation scheme, as the increase in precision is vastly outweighed by the time needed to reach the result.

Moreover, the main advantage of applying more powerful methods of interpolation (such as B-splines) is in the fact that the initial guess provided to the iterative solver will be closer to the final solution. However, we can apply the above process into smaller steps so that the up-sampling has to calculate fewer values and deviates less from the global minimum. In our implementation, we start with the system of size M
                        3, solve it using a direct solver, apply up-sampling to a size of (2M)3, and apply an iterative solver (conjugate gradient in our case). Repeating the last two steps we eventually reach the desired resolution N
                        3. This reduces the number of iterations required at each multiresolution level for the chosen iterative solver to do its job. Furthermore, as each step of up-sampling is much smaller, a trilinear interpolation is good enough as shown in Section 7. In all the cases we have tested time gained by using trilinear interpolation exceeded what was obtained by the reduction of the number of iterations, while the accuracy of the resulting solutions was largely unaffected.

To further improve efficiency we have made the process adaptive. That is, we only compute new values for nodes in each step when they are sufficiently close to the surface. In particular, for each step of the multi-resolution process we extract the discrete band DB of the current voxelization (set of voxels containing the zero isosurface), and we enlarge it a distance δ (measured in voxels) by a dilation operator, obtaining EDB. When assembling the linear system described in Section 4, only nodes inside EDB are considered to be unknowns. The rest are considered constant, eliminating from the system all equations that end with no unknowns. Finally, before performing the upsampling needed to continue with the next multiresolution step, we replace the values of the unknowns into the distance field, preserving the values outside EDB. This process is outlined in Fig. 5.

The distance δ we use to dilate DB determines how much we gain in terms of efficiency with the adaptive method, but too small a number will cause the surface to be unable to move to voxels outside of EDB. In all our tests we have found a distance of 
                           
                              δ
                              =
                              1
                           
                         suffices to produce satisfactory results. Using a factor of 2 between the sizes of each multiresolution level ensures that the final surface will not be found more than one voxel away from the solution of the previous step.
                     

@&#RESULTS@&#

A comparison between the results of our approach and those of several previous algorithms is presented in Fig. 1. This figure shows an original hole to be repaired, the solution that we obtain with the our algorithm, and the corresponding results with the algorithms from Nooruddin and Turk [10], Kazhdan and Hoppe [13], Liepa [6] and Tao Ju [8]. Our result is smooth and presents tangent continuity. Notice that portions of the walls of BH
                         have been added to the original hole for this test, because some of the algorithms compared need a closed model since they operate on the whole. Ours, being local, does not have that requirement, and will fix all the holes interior to BH
                         and ignore the outer boundary. All other results reported in this paper operate on the portion of the mesh that is inside the bounding volume, and require no pre-process.

We have tested our algorithm with different interpolation schemes to compute the up-sampling in EDB (see Fig. 5), in order to determine the best compromise between efficiency and quality of the results, as mentioned in the previous section. All times reported in this section have been measured on a PC with a Core i7 CPU at 3.20 GHz, with 12 GB of memory, and at 64 bits. The GPU is a GeForce GTX 570, but it was only used for rendering and does not impact the times reported.

As a typical example, Table 1 shows the time spent and the approximation error achieved when interpolating the higher resolution grid with simple trilinear interpolation, and when using an interpolating uniform b-spline. The columns list the root mean square error in the solution of the bi-laplacian equations, the root mean square distance from the resulting mesh to the ring-three around the hole, and the time in seconds of the whole computation. As expected, the better interpolation yields smaller errors, but in all cases we have tested, this improvement seems too little for the huge increase in computation time. We think the results achieved through trilinear interpolation are of high quality already, and therefore it is not sensible to spend the time needed to use a more precise interpolation scheme when raising the resolution of the grid.


                        Figs. 6 and 7 show six examples of holes from the scanning of the “Portalada”, and the results of our hole-filling algorithm. Notice how holes with intricate shapes and inner islands (Fig. 7(p)) are handled properly, and all holes within the bounding box that are away from its boundary are fixed in the same step. Notice also that the portion of the surface filling the hole can be perturbed using standard techniques as in [1] so that it exhibits the same roughness of the rest of the model. Since this is not the focus of this paper, and in order to stress the smoothness of the solution, we have chosen not to do so in the figures of this paper.

A comment is in order regarding the measure of geometric precision in the data above. In dealing with meshes produced by 3D scanners, we’ve found that —because holes originate in regions the scanner cannot reach— points on the boundary of the holes are usually more noisy than those slightly further away. Consequently, we measure the fitting of the new surface not right on the edge of the hole, but on vertices that lie at an edge-distance of 3 from the hole. The difference is witnessed by the data in Table 2
                        , that lists – for the holes in Figs. 6 and 7 – the error on the edge of each hole (RMS E0) and on the vertices of its 3-ring (RMS E3), both before smoothing the distance field and after completing the algorithm. The table shows that both errors are similar in magnitude, so using RMS E3 does not influence the quality of the result, while it does provide a more stable measure.


                        Table 3
                         shows the time it takes to complete our algorithm for the test holes in Figs. 6 and 7.

We list the time it took to smooth the distance field, along with the total time of initializing the distance field, up-sampling and smoothing, using the multigrid approach. The last three columns of this table indicate the proportion of relevant unknowns using the multigrid approach with respect to the total number of unknowns in the full system.

In order to facilitate the verification of our results, and hoping that it will promote adoption of the technique, we have made our code available at https://github.com/achicac/BiharmonicRepair.
                     


                        Fig. 8 shows the result of the smoothed distance field when only a thin layer of distances to the mesh is used to constrain the bi-harmonic filtering. Here we’ve used a mask of width two around the mesh. Compare the resulting field with that obtained in Fig. 10 for the same model, but using the full mask as proposed here. By over constraining the bi-harmonic system, we achieve a far more stable, robust and noise-resilient solution. This is of even more importance when applied to a scanned model, instead of a synthetic example as the one shown here, where noise at the boundary is fairly small.

Regarding the solution of the unconstrained optimization problem proposed in (1) in the bi-harmonic field approximation subsection, we have performed several experiments on the effect of the value of λ on the result. Fig. 9
                         shows some of these results. From our experiments, we have concluded that a value 
                           
                              λ
                              =
                              
                                 1
                                 6
                              
                           
                         is a reasonable choice, offering an adequate balance between smoothness of the result and approximation of the original mesh. This choice is of course subjective, and the algorithm will still perform for different values of lambda. Greater values of λ produce smoother surfaces at the cost of a lower approximation to the hole boundaries, whereas smaller λ values generate less smooth surfaces which better approximate the mesh around the hole, so the choice has an impact on how nicely we can sew the surfaces.

It should be observed that the presented algorithm accepts any kind of open or closed mesh. By working locally in extended bounding box volumes, it can reach the solution in an efficient way and without considering the rest of the unrepaired mesh.

@&#LIMITATIONS@&#

Our algorithm assumes that the mesh is sufficiently smooth and that it can be approximated by the zero isosurface of a local solution of the biharmonic equation. It is therefore not appropriate in the case of sharp features.
                     

Folded meshes having close-by sheets could be handled by an accurate mask choice, but this cases will usually require some degree of user intervention. Developing smarter mask construction strategies is an interesting avenue for future research, that would extend the domain of the algorithm. However, these configurations do not appear naturally among the imperfections in professionally scanned models, so we have not experienced any cases in which the current mask construction strategy did not succeed.


                        Fig. 10 presents an experiment on failure cases for our algorithm. We run our algorithm on regular meshes representing three different clipped spheres, by cutting out 25%, 50% and 75% of the sphere diameter. The figure shows that our algorithm generates reasonable results in the first two cases, where it succeeds in appropriately closing the hole. In the third case, however, the final isosurface moves outside of the extended bounding box. This is an extreme case that we have never found in our practical applications, and is in fact similar to the problem of closing a finite surface with borders. Such cases could be better addressed by a Poisson reconstruction algorithm.

Having too narrow a band to constraint the bi-harmonic equation can result in unstable solutions as already discussed, see Fig. 8. Instead, in our experimental results with a great number of complex holes, we have observed that constraining larger volumes as prescribed by our volume masks adequately stabilizes the bi-harmonic solution in noisy, scan-based cases (compare Fig. 8(b) and Fig. 10(b)).

@&#CONCLUSIONS@&#

We have presented an algorithm to automatically repair complex hole configurations without any user intervention. Our approach is based on several ingredients. We solve a volumetric problem in the vicinity of each mesh hole to compute a suitable approximation of the signed distance field. The algorithm is based on computing a 3D thin-plate solution of the bi-harmonic equation that guarantees C
                     1 continuity with the previous mesh around the repaired area, and obtains the repairing surface by computing the zero-isosurface of the scalar bi-harmonic field.

A key ingredient of the algorithm is a volume mask such that the signed distance field to the mesh around the hole can be reliably computed in the mask domain. The rest of the algorithm uses this distance field to over-constrain the boundary conditions of the bi-harmonic equation over all of BH
                     . A discrete approximation of the bi-harmonic field is obtained by solving a quadratic optimization problem, with a multigrid adaptive solver.

Unlike some previous approaches, our algorithm does not require an initial triangulation of the holes. The computation of the bi-harmonic field is driven by the mask and the signed distance field in its domain.

Our approach is able to successfully address complex topologies with disconnected mesh regions in a robust way. Thus, our proposed algorithm affords an automatic solution for hole repair in very large triangle meshes that provides a smooth blending at the boundaries and is able to act on holes locally, so that it scales well to very large meshes with multitude of holes, as are typically given by large 3D scanning projects.

The resulting meshes can be post-processed to propagate into the new patch a roughness similar to the mesh surrounding it, statistically synthesizing similar details. This would be helpful in practical cases where we want to conceal the repaired portion and make it pass as original.

In the future, it would be interesting to explore ways to find more general, optimal masks, that would extend the applicability of the technique to other domains with even more involved configurations.

@&#ACKNOWLEDGMENTS@&#

Argudo, Brunet, Chica and Vinacua’s research on this project has been supported by the Spanish Ministerio de Economia y Competitividad (MINECO) under Grants TIN2013-47137-C2-1-P and TIN2014-52211-C2-1-R. Argudo’s Research has also been supported by a Graduate Research Fellowship from the Spanish Government.

Supplementary material associated with this article can be found, in the online version, at 10.1016/j.gmod.2015.06.010.
                  


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

